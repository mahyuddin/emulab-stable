#!/usr/local/bin/perl -w
#########################################################################
# SnmpIt! - An SNMP Tool for the Intel 510T Switch                      #
#                                                                       #
# Run with -h option to see command line syntax/options.                #
#                                                                       #
#      Author: Mac Newbold, Flux Research Group, University of Utah     #
# Last Change: April 1999                                               #
#     Version: 0.5b                                                     #
#                                                                       #
#########################################################################

#
# INIT SECTION =========================================================
#

my $S = "";  #Switch IP addr.
my @p = ();  #Port numbers
my $D = 0;   #Disable (bool)
my $E = 0;   #Enable (bool)
my $a = "";  #Auto Negotiation (enable/disable) (two-way switch)
my $d = "";  #Duplex (half/full)
my $s = 0;   #Speed (10/100)
my $A = "";  #AutoVLAN filename
my $l = 0;   #List all VLANs on switch
my $C = "";  #Create VLAN - name
my @v = ();  #VLAN Members - list of MAC Addresses
my $B = 0;   #Block (bool) (two-way switch)
my $V = 1;   #Verify Only (bool) (two-way switch)
my $L = 0;   #Loud/Verbose (bool) !Must default quiet; switch only turns on!

&ParseArgs(*ARGV,*S,*p,*D,*E,*a,*d,*s,*A,*l,*C,*v,*B,*V,*L);
#print "Returned: S=$S p=@p D=$D E=$E a=$a d=$d s=$s C=$C v=@v B=$B\n";

use lib '/n/moab/x/newbold/ucd-snmp-4.1.1/perl/SNMP/blib/lib';
use lib '/n/moab/x/newbold/ucd-snmp-4.1.1/perl/SNMP/blib/arch/auto/SNMP';
use SNMP;
#$SNMP::debugging = 1;

&SNMP::addMibDirs('/usr/local/share/snmp/mibs');
&SNMP::addMibFiles('/usr/local/share/snmp/mibs/RFC1155-SMI.txt',
		   '/usr/local/share/snmp/mibs/RFC1213-MIB.txt',
		   '/usr/local/share/snmp/mibs/BRIDGE-MIB.txt', 
		   '/usr/local/share/snmp/mibs/EtherLike-MIB.txt',
#		   '/usr/local/share/snmp/mibs/RMON-MIB.txt',
		   '/usr/local/share/snmp/mibs/INTEL-GEN-MIB.txt', 
		   '/usr/local/share/snmp/mibs/INTEL-S500-MIB.txt',
		   '/usr/local/share/snmp/mibs/INTEL-VLAN-MIB.txt',
#		   '/usr/local/share/snmp/mibs/DVMRP-MIB.txt', 
#		   '/usr/local/share/snmp/mibs/INTEL-L3LINK-MIB.txt',
#		   '/usr/local/share/snmp/mibs/IGMP-MIB.txt',
#		   '/usr/local/share/snmp/mibs/INTEL-IPF-MIB.txt', 
#		   '/usr/local/share/snmp/mibs/INTEL-IPROUTER-MIB.txt',
#		   '/usr/local/share/snmp/mibs/INTEL-IGMP-PRUNING-MIB.txt', 
#		   '/usr/local/share/snmp/mibs/INTEL-IPX-MIB.txt'
		   );
$SNMP::save_descriptions = 1; # must be set prior to mib initialization
 SNMP::initMib(); # parses default list of Mib modules from default dirs

#
# MAIN SECTION =========================================================
#

$SNMP::use_enums = 1; #use enum values instead of only ints
my $sess = new SNMP::Session(DestHost => $S);

if ($D || $E) {
    my $Admin = ".1.3.6.1.2.1.2.2.1.7";
    my $Status = "";
    $Status = "down" if ($D);
    $Status = "up" if ($E);
    if (! &Update(*sess,$Admin,*p,$Status,*B,*V,*L)) {
	print STDERR "Port ",($D?"disable":"enable")," failed.\n";
    }    
}

if ($s) {
    my $Spd = ".1.3.6.1.4.1.343.6.10.2.4.1.10.1.1";
    if (! &Update(*sess,$Spd,*p,$s,*B,*V,*L)) {
	print STDERR "Port Speed change failed.\n";
    }    
}

if ($d) {
    my $Dup = ".1.3.6.1.4.1.343.6.10.2.4.1.11.1.1";
    if (! &Update(*sess,$Dup,*p,$d,*B,*V,*L)) {
	print STDERR "Port Duplex change failed.\n";
    }    
}

if ($a) {
    my $Auto = ".1.3.6.1.4.1.343.6.10.2.4.1.12.1.1";
    my $aOp = ( $a=~/en/ ? "auto" : "manual");
    if (! &Update(*sess,$Auto,*p,$a,*B,*V,*L)) {
	print STDERR "Port Auto-Configuration change failed.\n";
    }    
}

if (@v) {
    #This is to make ONE vlan - for multiple, use -A AutoVLAN
    &GetToken(*sess,*L);
    &OneVLAN(*sess,*C,*v,*L);
    &ReleaseToken(*sess,*l);
}

if ($A) {
    &AutoVLANConfig(*sess,*A,*L);
}

#List VLANs is always last, so that changes made are reflected...
if ($l) {
    &ListVLANs(*sess,*L);
}

#
# END OF MAIN  =================================================
#



#
# SUBROUTINE SECTION =================================================
#

#
# SUB PARSEARGS----------------------
#
sub ParseArgs {
    local(*CMDS,*S,*p,*D,*E,*a,*d,*s,*A,*l,*C,*v,*B,*V,*L) = @_;
    my $help=0; 
    if (@CMDS < 3) {$help = 2; }
    while (@CMDS != 0 && $CMDS[0] =~ /^(-|\+)/) {
	$_ = shift(@CMDS);
	#print "Item=$_\n";
	#print "S=$S p=@p D=$D E=$E a=$a d=$d s=$s C=$C v=@v B=$B V=$V\n";
	if (/^-S(.*)/) {$S = ($1 ? $1 : shift(@CMDS));}
	elsif (/^-p(.*)/) {
	    push(@p, ($1 ? $1 : shift(@CMDS)));
	    while ( @CMDS>0 && ! ($CMDS[0] =~ /^(-|\+)(.*)/ ) ) { 
		push(@p, shift(@CMDS));
	    }
	}
	elsif (/^-R(.*)/) {
	    my $Range ="";
	    $Range .= ($1 ? $1 : shift(@CMDS));
	    if ( $Range =~ /^(\d*)\.\.(\d*)$/ ) {
		push(@p, $1..$2);
	    } else {
		die("Invalid Range: $Range\n");
	    }	   
	}
	elsif (/^-h(.*)/) {$help = 1;}
	elsif (/^-L(.*)/) {$L = 1;}
	elsif (/^-D(.*)/) {$D = 1;}
	elsif (/^-E(.*)/) {$E = 1;}
	elsif (/^-a(.*)/) {$a="disable";}
	elsif (/^\+a(.*)/) {$a="enable";}
	elsif (/^-d(.*)/) {$d = ($1 ? $1 : shift(@CMDS));}
	elsif (/^-s(.*)/) {$s = ($1 ? $1 : shift(@CMDS));}
	elsif (/^-A(.*)/) {$A = ($1 ? $1 : shift(@CMDS));}
	elsif (/^-C(.*)/) {$C = ( !(@CMDS==0 || $CMDS[0] =~ /^(-|\+)(.*)/) ? 
				  ($1 ? $1 : shift(@CMDS)) : "");}
	elsif (/^-v(.*)/) {
	    push(@v, ($1 ? $1 : shift(@CMDS)));
	    while ( @CMDS>0 && ! ($CMDS[0] =~ /^(-|\+)(.*)/ ) ) { 
		push(@v, shift(@CMDS));
	    }
	}
	elsif (/^-B(.*)/) {$B = 0;}
	elsif (/^\+B(.*)/) {$B = 1;}
	elsif (/^-V(.*)/) {$V = 0;}
	elsif (/^\+V(.*)/) {$V = 1;}
	else {die("Unknown Option: $_\n");}
    }
    #print "\nDone:\nS=$S p=@p D=$D E=$E a=$a d=$d s=$s C=$C v=@v B=$B V=$V\n";
    if ($help) {
	print
	    "SnmpIt! - An SNMP Tool for the Intel 510T Switch\n",
	    "Syntax:\n",
	    "$0 [-help] [-L] -S<switch> [(+|-)B] [(+|-)V]\n",
	    "\t[-p<port> <port> <port>...] [-R <x>..<y>]\n",
	    "\t[-D|-E] [[+|-]a] [-s<speed>] [-d<duplex>]\n", 
	    "\t[-C[<vlan name>] -v<vlan memeber MAC>]\n",
	    "\t[-A<vlan data filename>] -l\n";
    }
    if ($help == 1) {
	print
	    "\n",
	    "  -h    Display this help message\n",
	    "  -L    Loud/Verbose mode (now ",($L?"on":"off"),")\n",
	    "  -S    Switch name or IP address\n",
	    "  +B/-B Blocking mode (now ",($B?"on":"off"),")\n",
	    "  +V/-V Verify (when done with list; now ",($V?"on":"off"),")\n",
	    "  -p    List of port numbers on which to perform operations\n",
	    "  -R    Range of port numbers\n",
	    "  -D    Disable port(s)\n",
	    "  -E    Enable port(s)\n",
	    "  +a/-a Enable/Disable Port Auto-Negotiation of speed/duplex\n",
	    "  -s    Port Speed (10 or 100 Mbits)\n",
	    "  -d    Port Duplex (half or full)\n",
	    "  -A    AutoVLAN - Automatically set up set of VLANs\n",
	    "  -l    List all VLANs on switch (ell, not #1)\n",
	    "  -C    Create VLAN\n",
	    "  -v    Add member to VLAN\n";
    }
    #If help only, end here...
    die("\b\n") if ($help);
    #Now die on any combinations that don't make sense...
    die("What shall I do?\n")
	if (! ($D || $E || $a || $s || $d || @v) );
    if ($S =~ /Alpha/i) { $S = "155.99.214.170"; }
    if ($S =~ /Beta/i)  { $S = "155.99.214.171"; }
    die("Unknown Switch $S: Possible completions are\n",
	"Alpha/155.99.214.170\n Beta/155.99.214.171\n") 
	if (!(($S=~/155\.99\.214\.(.*)/) && ($1=~ /^170$|^171$/)));
    die("Can't enable and disable at the same time.\n") if ($D && $E);
    die("Can't use auto with duplex or speed.\n") if (($a=~/en/)&&($d || $s));
    my $n=0;
    while(@p != 0 && $n < @p) {
	die("Invalid port ",$p[$n],": Must be 1-24\n") 
	    if ($p[$n] =~ /\D/ || $p[$n]>24 || $p[$n]<1);
	$n++;
    }
    die("Which port should I reconfigure?\n") if (!@p &&($D||$E||$d||$s||$a));
    die("Invalid duplex $d: Must be full or half\n") 
	if(!($d=~/^full$|^half$|^$/));
    die("Invalid speed $s: Must be 10 or 100\n") if (!($s=~/^10$|^100$|^0$/));
    if ($s eq "10" ) { $s="speed10Mbit" ;}
    if ($s eq "100") { $s="speed100Mbit";}
    $n=0;
    while(@v != 0 && $n < @v) {
	die("Invalid MAC Address ",$v[$n],". Must be 6 byte Hex value.\n")
	    if (! ( ($v[$n]=~ /^([a-f]|\d)*$/i) && (length ($v[$n]) == 12)));
	$n++;
    }
}

#
# SUB UPDATE----------------------
#

sub Update {    
    local(*sess,$OID,*p,$val,*B,*V,*L)= @_;
    #print "$sess\nOID:$OID\np=@p\nval=$val\n$B $V $L\n";
    my $Status = 0;
    foreach $port (@p) {
	$Status = $sess->get([[$OID,$port]]);
	print "Got value for $port: $Status\n" if ($L);
	if ($Status ne $val) {
	    print "Setting value for port $port to $val\n" if ($L);
	    #The empty sub {} is there to force it into async mode
	    $sess->set([[$OID,$port,$val,"INTEGER"]],sub {});
	    if ($B) {
		while ($Status ne $val) { 
		    $Status=$sess->get([[$OID,$port]]);
		    print "Got value for:$port ",$Status,"\n" if ($L);
		}
	    }
	}
    }
    if ( (!$B) && $V ) {
	my $loops=0;
	my $max_loops=10;
	my %notdone=();
	my @done=();
	foreach $port (@p) {
	    $Status=$sess->get([[$OID,$port]]);
	    print "Got value for:$port ",$Status,"\n" if ($L);
	    if ($Status ne $val) {
		$notdone{$port}=1;
	    }
	}
	while ( %notdone && $loops < $max_loops ) {
	    foreach $port (sort keys(%notdone)) {
		$Status=$sess->get([[$OID,$port]]);
		print "Got value for:$port ",$Status,"\n" if ($L);
		if ($Status eq $val) {
		    push(@done,$port);
		}
	    }
	    foreach $i (@done) { delete $notdone{$i}};
	    $loops++;
	}
	if ($loops==$max_loops) {
	    foreach $port (sort keys(%notdone)) {
		print STDERR "Port $port Change not verified!\n";
	    }
	    return(0); #Return False!
	}
    }
    1;
}

#
# SUB ReleaseToken----------------------
#

sub ReleaseToken {
    local(*sess,*L) = @_;
    my $TokenRelease = '.1.3.6.1.4.1.343.6.11.4.8';
    my $TokenReleaseResult = '.1.3.6.1.4.1.343.6.11.4.9';
    $sess->set([[$TokenRelease,0,"save","INTEGER"]]);
    $RetVal = $sess->get([[$TokenReleaseResult,0]]);
    print "VLAN Configuration Save Result is $RetVal\n" if ($L);
    if ($RetVal ne 'success') {
	die("VLAN Reconfiguration Failed. No changes saved.\n");
    }
}

#
# SUB GetToken----------------------
#

sub GetToken {
    local(*sess,*L) = @_;
    my $TokenOwner = '.1.3.6.1.4.1.343.6.11.4.5';
    my $TokenReq = '.1.3.6.1.4.1.343.6.11.4.6';
    my $TokenReqResult = '.1.3.6.1.4.1.343.6.11.4.7';
    my $TokenRelease = '.1.3.6.1.4.1.343.6.11.4.8';
    my $TokenReleaseResult = '.1.3.6.1.4.1.343.6.11.4.9';
    my $Num = pack("C*",0,0,0,0,1,1);
    #The zeros and ones are a magic number it needs...
    my $RetVal = $sess->set([[$TokenReq,0,$Num,"OCTETSTR"]]);
    print "VLAN Token Claim Result is $RetVal\n" if ($L);
    $RetVal = $sess->get([[$TokenReqResult,0]]);
    while ($RetVal eq "notReady") {
	$RetVal = $sess->get([[$TokenReqResult,0]]);
	print "VLAN Token Claim Result is $RetVal\n" if ($L);
    }
    print "VLAN Token Claim Result is $RetVal\n" if ($L);
    if ($RetVal ne 'success') {
	my $Owner = $sess->get([[$TokenOwner,0]]);
	die("Can't edit VLANs: Token taken by $Owner\n");
    }
}

#
# SUB OneVLAN----------------------
#

sub OneVLAN {
    #This is to be called ONLY after the edit token has already been taken!
    local(*sess,*C,*v,*L) = @_;
    my $NextVLANId = '.1.3.6.1.4.1.343.6.11.1.6';
    my $Vlan = $sess->get([[$NextVLANId,0]]);
    my $CreateOID = ".1.3.6.1.4.1.343.6.11.1.9.1.3";
    my $RetVal = "Undef.";
    if ( ! $C ) { $C = $v[0]; }
    print "  Creating VLAN $C as VLAN #$Vlan, containing: @v ... " if ($L) ;
    $RetVal = $sess->set([[$CreateOID,$Vlan,$C,"OCTETSTR"]]);
    print "",($RetVal? "Succeeded":"Failed"),".\n" if ($L);
    if (! defined ($RetVal) ) {
	&ReleaseToken(*sess,*L);
	die("VLAN name \"$C\" not unique.\n");
    }
    my @x;
    my $n=0;
    while(@v != 0 && $n < @v) {
	my $i=0;
	while ($i < 6 ) {
	    $x[$i] = hex ("0x".substr($v[$n],2*$i,2) );
	    $i++;
	}
	my $MacObjOID = ".1.3.6.1.4.1.343.6.11.1.10.1.3.$Vlan." . 
	    "$x[0].$x[1].$x[2].$x[3].$x[4].$x[5]";
	print "    Adding MAC Address $v[$n] ".
	    "($Vlan.$x[0].$x[1].$x[2].$x[3].$x[4].$x[5])... " if ($L);
	$RetVal = $sess->set([[$MacObjOID,0,$v[$n],"OCTETSTR"]]);
	print "",($RetVal? "Succeeded":"Failed"), ".\n" if ($L);
	$n++;
    }
}

#
# SUB AutoVLANConfig ----------------------
#

sub AutoVLANConfig {
    local(*sess,*A,*L) = @_;
    my @VLANS= ();
    &ReadIRFile(*A,*VLANS);
    &GetToken(*sess,*L);
    my $C="";
    while (@VLANS) {
	@v = shift(@VLANS);
	&OneVLAN(*sess,*C,*v,*L);
    }
    &ReleaseToken(*sess,*L);
}

#
# SUB ReadIRFile ----------------------
#

sub ReadIRFile {
   local(*A,*VLANS) = @_;
   if ( !open(IR,$A) ) { die("Could not open $A for VLAN Setup.\n"); }
   <IR>
   

}

#
# SUB ListVLANs ----------------------
#

sub ListVLANs {
    local(*sess,*L) = @_;
    
}

#
# SUB ----------------------
#

#
# END OF SUBROUTINE SECTION =========================================
#
#
# END OF PROGRAM  ===================================================
#
