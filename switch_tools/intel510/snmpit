#!/usr/local/bin/perl -w
#########################################################################
# snmpit - A General Purpose SNMP Tool                                  #
# (specialized for the Intel 510T Switch and APC power controllers)     #
#                                                                       #
# Run with -h option to see command line syntax/options.                #
#                                                                       #
#      Author: Mac Newbold, Flux Research Group, University of Utah     #
# Last Change: May 23, 2000                                             #
#     Version: 1.11                                                     #
#                                                                       #
#########################################################################

&myMain;

sub myMain {

#
# INIT SECTION =========================================================
#

    my $i = "";  #IP addr.
    my @p = ();  #Port numbers
    my $d = 0;   #Disable (bool)
    my $e = 0;   #Enable (bool)
    my $a = "";  #Auto Negotiation (enable/disable) (two-way switch)
    my $dup = "";#Duplex (half/full)
    my $spd = 0; #Speed (10/100)
    my $s = 0;   #Show port configs
    my $g = 0;   #Get Statistics
    my $f = "";  #AutoVLAN filename
    my $l = 0;   #List all VLANs on switch
    my $m = "";  #Create VLAN - name
    my @vlan =();#VLAN Members - list of MAC Addresses
    my @r = ();  #VLAN(s) to be removed
    my $u = 0;   #Wait for Update of VLAN tables
    my $b = 0;   #Block (bool) (two-way switch)
    my $c = 1;   #Confirm Changes (bool) (two-way switch)
    my $v = 0;   #Verbose (bool) !Must default quiet; switch only turns on!
    
#power control
    my $on=0;
    my $off=0;
    my $cyc=0;
    my $all=0;
    my @outlets=();
    my %Interfaces=();
    my %Ports=();

    &ParseArgs(\@ARGV,\$i,\@p,\$d,\$e,\$a,\$dup,\$spd,\$s,\$f,\$l,\$m,\@vlan,
	       \@r,\$u,\$b,\$c,\$v,\$g,
	       \$on,\$off,\$cyc,\$all,\@outlets,\%Interfaces,\%Ports);
    
    use lib '/n/moab/x/newbold/ucd-snmp-4.1.1/perl/SNMP/blib/lib';
    use lib '/n/moab/x/newbold/ucd-snmp-4.1.1/perl/SNMP/blib/arch/auto/SNMP';
    use SNMP;
#$SNMP::debugging = 1;
    
    &SNMP::addMibDirs('/usr/local/share/snmp/mibs');
    if (($i=~/155\.99\.214\.17(.*)/) && ($1=~ /^0$|^1$|^2$|^3$/)) {
	&SNMP::addMibFiles('/usr/local/share/snmp/mibs/INTEL-GEN-MIB.txt', 
			   '/usr/local/share/snmp/mibs/INTEL-S500-MIB.txt',
			   '/usr/local/share/snmp/mibs/INTEL-VLAN-MIB.txt');
    } else {
	&SNMP::addMibFiles('/n/moab/x/newbold/mibs/PowerNet-MIB.txt');
    }
    
    $SNMP::save_descriptions = 1; # must be set prior to mib initialization
  SNMP::initMib(); # parses default list of Mib modules from default dirs
    
#
# MAIN SECTION =========================================================
#
    
    $SNMP::use_enums = 1; #use enum values instead of only ints
    my $sess = new SNMP::Session(DestHost => $i);
    my $sess2 =new SNMP::Session(DestHost => $i, Community => 'private');
    
#
# Port Level Control
#
    if ($d || $e) {
	my $Admin = ".1.3.6.1.2.1.2.2.1.7";
	my $Status = "";
	$Status = "down" if ($d);
	$Status = "up" if ($e);
	if (! &UpdateField(\$sess,\$Admin,\@p,\$Status,\$b,\$c,\$v)) {
	    print STDERR "Port ",($d?"disable":"enable")," failed.\n";
	}    
    }
    
    if ($spd) {
	my $Speed = ".1.3.6.1.4.1.343.6.10.2.4.1.10.1.1";
	if (! &UpdateField(\$sess,\$Speed,\@p,\$spd,\$b,\$c,\$v)) {
	    print STDERR "Port Speed change failed.\n";
	}    
    }
    
    if ($dup) {
	my $duplex = ".1.3.6.1.4.1.343.6.10.2.4.1.11.1.1";
	if (! &UpdateField(\$sess,\$duplex,\@p,\$dup,\$b,\$c,\$v)) {
	    print STDERR "Port Duplex change failed.\n";
	}    
    }
    
    if ($a) {
	my $Auto = ".1.3.6.1.4.1.343.6.10.2.4.1.12.1.1";
	my $aOp = ( $a=~/en/ ? "auto" : "manual");
	if (! &UpdateField(\$sess,\$Auto,\@p,\$a,\$b,\$c,\$v)) {
	    print STDERR "Port Auto-Configuration change failed.\n";
	}    
    }

    #Show always goes after changes, so that they are reflected.
    if ($s) {
	&ShowPorts(\$sess,\%Ports,\%Interfaces,\$i,\$v);
    }
    
    if ($g) {
	&GetStats(\$sess,\%Ports,\$i,\$v);
    }
    
#
# VLANs
#
    if (@vlan) {
	#This is to make ONE vlan - for multiple, use -f AutoVLAN from file
	&GetToken(\$sess,\$v);
	&OneVLAN(\$sess,\$m,\@vlan,\$v);
	&ReleaseToken(\$sess,\$v,\$u);
    }
    
    if ($f) {
	&AutoVLANConfig(\$sess,\$f,\$v,\$u,\%Interfaces);
    }
    
    if (@r) {
	&GetToken(\$sess,\$v);	
	foreach my $x (sort num @r)
	{
	    &RemoveVLAN(\$sess,\$x,\$v);
	}
	&ReleaseToken(\$sess,\$v,\$u);
    }
    
#List VLANs is always after $f and @vlan, so that changes made are reflected...
    if ($l) {
	&ListVLANs(\$sess,\%Interfaces,\$v);
    }
    
#
# Power Control
#
    if ($off || $on || $cyc) {
	my $CtlOID = ".1.3.6.1.4.1.318.1.1.4.4.2.1.3";
	my $op = "";
	#disable confirmation, and go to blocking mode...
	$c = 0;
	$b = 0;
	if ($all) {
	    my $AllOID = ".1.3.6.1.4.1.318.1.1.4.2.1";
	    @outlets = ( 0 );
	    if ($on)     { $op = "turnAllOnSequence";}
	    elsif ($off) { $op = "turnAllOffNow";    }
	    else         { $op = "rebootAllSequence";}
	    if (! &UpdateField(\$sess2,$AllOID,\@outlets,$op,\$b,\$c,\$v)) {
		print STDERR "Outlet control failed.\n";
	    }
	} else {
	    if ($on)     { $op = "outletOn";    }
	    elsif ($off) { $op = "outletOff";   }
	    else         { $op = "outletReboot";}
	    if (! &UpdateField(\$sess2,$CtlOID,\@outlets,$op,\$b,\$c,\$v)) {
		print STDERR "Outlet #@outlets control failed.\n";
		}
	}
    }
    
#
# END OF MAIN  =================================================
#
}


#
# SUBROUTINE SECTION =================================================
#

#
# SUB PARSEARGS----------------------
#
sub ParseArgs {
    local(*CMDS,*i,*p,*d,*e,*a,*dup,*spd,*s,*f,*l,*m,*vlan,*r,*u,*b,*c,*v,*g,
	  *on,*off,*cyc,*all,*outlets,*Interfaces,*Ports) = @_;
    my $help=0; 
    if (@main::CMDS < 1) {$help = 1; }
    while (@CMDS != 0 && $CMDS[0] =~ /^(-|\+)/) {
	$_ = shift(@CMDS);
	#print "Item=$_*\n";
	#print "i=$i p=",@p," D=$d E=$e a=$a d=$dup s=$s m=$m vlan=",
	#@vlan," b=$b c=$c on=$on off=$off cyc=$cyc\n";
	if (/^-i(.*)/) {$i = ($1 ? $1 : shift(@CMDS));}
	elsif (/^-p(.*)/) {
	    my $Range ="";
	    do {
		$Range = ($1 ? $1 : shift(@CMDS));
		#print "Range=$Range\n";
		if ( $Range =~ /^(\d*)\.\.(\d*)$/ ) {
		    #print "1Pushing ",$1..$2,"*\n";
		    push(@p, $1..$2);
		} else {
		    #print "2Pushing ",$Range,"*\n";
		    push(@p, $Range);
		}
	    }
	    while (@CMDS>0 && ! ($CMDS[0] =~ /^(-|\+)(.*)/ ) );
	}
	elsif (/^-h(.*)/) {$help = 2;}
	elsif (/^-off(.*)/) {$off = 1;}
	elsif (/^-on(.*)/) {$on = 1;}
	elsif (/^-cyc(.*)/) {$cyc = 1;}
	elsif (/^-all(.*)/) {$all = 1;}
	elsif (/^-a(.*)/) {$a="disable";}
	elsif (/^\+a(.*)/) {$a="enable";}
	elsif (/^-dup(.*)/) {$dup = ($1 ? $1 : shift(@CMDS));}
	elsif (/^-spd(.*)/) {$spd = ($1 ? $1 : shift(@CMDS));}
	elsif (/^-d(.*)/) {$d = 1;}
	elsif (/^-e(.*)/) {$e = 1;}
	elsif (/^-s(.*)/) {$s = 1;}
	elsif (/^-g(.*)/) {$g = 1;}
	elsif (/^-l(.*)/) {$l = 1;}
	elsif (/^-u(.*)/) {$u = 1;}
	elsif (/^-f(.*)/) {$f = ($1 ? $1 : shift(@CMDS));}
	elsif (/^-m(.*)/) {$m = ( !(@CMDS==0 || $CMDS[0] =~ /^(-|\+)(.*)/) ? 
				  ($1 ? $1 : shift(@CMDS)) : "");}
	elsif (/^-vlan(.*)/) {
	    push(@vlan, ($1 ? $1 : shift(@CMDS)));
	    while ( @CMDS>0 && ! ($CMDS[0] =~ /^(-|\+)(.*)/ ) ) { 
		push(@vlan, shift(@CMDS));
	    }
	}
	elsif (/^-r(.*)/) {
	    push(@r, ($1 ? $1 : shift(@CMDS)));
	    while ( @CMDS>0 && ! ($CMDS[0] =~ /^(-|\+)(.*)/ ) ) { 
		push(@r, shift(@CMDS));
	    }
	}
	elsif (/^-v(.*)/) {$v = 1;}
	elsif (/^-b(.*)/) {$b = 0;}
	elsif (/^\+b(.*)/) {$b = 1;}
	elsif (/^-c(.*)/) {$c = 0;}
	elsif (/^\+c(.*)/) {$c = 1;}
	elsif (/^-([1-8])$/) { push(@outlets, $1);}
	else {die("Unknown Option: $_\n");}
    }
    #print "Done:\nS=$i p=@p D=$d E=$e a=$a d=$dup s=$s C=$m vlan=@vlan B=$b V=$c on=$on off=$off cyc=$cyc\n";
    if ($help) {
	print
	    "snmpit - A general purpose SNMP Tool - Version 1.1\n",
	    "Syntax:\n",
	    " snmpit [-h] [-v] -i<ip>\n",
	    "\t[-u] [-l] [-m<vlan name>] [-vlan<MAC Addr.>]\n",
	    "\t[-f<filename>] [-r<vlan #> <vlan #> ... ]\n",
	    "\t[+b|-b] [+c|-c] [-g] [-s] [-p<port> <port> <x>..<y> ... ]\n",
	    "\t[-d|-e] [+a|-a] [-spd<speed>] [-dup<duplex>]\n";

# Hidden Power control functionality
#,
#	    "\t[ [-on|-off|-cyc] [-all] | [-<n>] ]\n";
	
    }
    if ($help > 1) {
	print
	    "\nGeneral:\n",
	    "  -h    Display this help message\n",
	    "  -v    Verbose mode (now ",($v?"on":"off"),")\n",
	    "  -i    IP address or switch name\n",
	    "\nVLAN Control:\n",
	    "  -u    Wait for Update of VLAN tables (takes ~10 seconds)\n",
	    "  -l    List all VLANs on switch (ell, not #1)\n",
	    "  -m    Make a VLAN\n",
	    "  -vlan Add MAC Address to VLAN\n",
	    "  -f    File mode - Automatically set up set of VLANs\n",
	    "  -r    Remove VLAN(s)\n",
	    "\nPort Control:\n",
	    "  +b/-b Blocking mode (now ",($b?"on":"off"),")\n",
	    "  +c/-c Confirm Changes (now ",($c?"on":"off"),")\n",
	    "  -g    Get Statistics\n",
	    "  -s    Show Port Configurations\n",
	    "  -p    List of port numbers and ranges\n",
	    "  -d    Disable port(s)\n",
	    "  -e    Enable port(s)\n",
	    "  +a/-a Enable/Disable Port Auto-Negotiation of speed/duplex\n",
	    "  -spd  Port Speed (10 or 100 Mbits)\n",
	    "  -dup  Port Duplex (half or full)\n";

# Hidden Power control functionality
#,
#	    "  -on   Turn on outlets\n",
#	    "  -off  Turn off outlets\n",
#	    "  -cyc  Power Cycle outlets\n",
#	    "  -all  All outlets\n",
#	    "  -(n)  Outlet #(n) (n=1-8)\n";
    }
    
    #Unused letters of the alphabet:
    #
    # j, k, n, q, t, w, x, y, z
    #
    #If help only, end here...
    die("\b\n") if ($help);
    #Now die on any combinations that don't make sense...
    die("What shall I do?\n")
	if (!($d||$e||$a||$spd||$dup||$s||$g||@vlan||$f||@r||$l
	      ||$on||$off||$cyc));
    if (@vlan||$f||@r||$l) { $i = "Gamma"; }
    if ($i =~ /Alpha/i) { $i = "155.99.214.170"; }
    if ($i =~ /Beta/i)  { $i = "155.99.214.171"; }
    if ($i =~ /Gamma/i)  { $i = "155.99.214.172"; }
    if ($i =~ /Delta/i)  { $i = "155.99.214.173"; }
    die("\"$i\" is not an Intel 510 Switch:\nPossible completions are:\n",
	"Alpha/155.99.214.170\n Beta/155.99.214.171\n",
	"Gamma/155.99.214.172\n Delta/155.99.214.173\n") 
	if ( (!(($i=~/155\.99\.214\.17(.*)/) && ($1=~ /^0$|^1$|^2$|^3$/))) && 
	     ($d||$e||$a||$spd||$dup||$s||$g||@vlan||$f||@r||$l));
    die("$i is not a power controller.\n") 
	if ( (($i=~/155\.99\.214\.(.*)/) && ($1=~ /^0$|^1$|^2$|^3$/)) && 
	     ($on||$off||$cyc) );
    die("Can't enable and disable at the same time.\n") if ($d && $e);
    die("Can't use auto with duplex or speed.\n") if(($a=~/en/)&&($dup||$spd));
    my $n=0;
    while(@p != 0 && $n < @p) {
	die("Invalid port ",$p[$n],": Must be 1-24\n") 
	    if ($p[$n] =~ /\D/ || $p[$n]>24 || $p[$n]<1);
	$n++;
    }
    die("Which ports do I reconfigure?\n") if (!@p &&($d||$e||$dup||$spd||$a));
    $dup = "\L$dup\E"; #lowercase it all...
    die("Invalid duplex $dup: Must be full or half\n") 
	if(!($dup=~/^full$|^half$|^$/));
    die("Invalid speed $spd: Must be 10 or 100\n") 
	if (!($spd=~/^10$|^100$|^0$/));
    if ($spd eq "10" ) { $spd="speed10Mbit" ;}
    if ($spd eq "100") { $spd="speed100Mbit";}
    if ($s || $g || @vlan || $f || @r || $l) {
	&ReadTranslationTable(\%Interfaces,\%Ports);
    }
    $n=0;
    while(@vlan != 0 && $n < @vlan) {
	#Lowercase it all, but leave in : for tbpcx:y syntax
	$vlan[$n] = "\L$vlan[$n]\E";
	if ((!(($vlan[$n]=~/^([a-f]|\d)*$/i)&&(length ($vlan[$n])== 12)))
	    && (defined $Interfaces{$vlan[$n]})) {
	    $vlan[$n] = $Interfaces{$vlan[$n]};
	}
	# Allow people to specify addresses with colons or dots
	$vlan[$n] =~ s/[:\.]//g;
	die("Invalid MAC Address ",$vlan[$n],". Must be 6 byte Hex value.\n")
	    if (!(($vlan[$n]=~/^([a-f]|\d)*$/i)&&(length ($vlan[$n])== 12)));
	$n++;
    }
    die("Can't use file mode with manual vlan creation.\n") if ($f && @vlan);
    if ($on || $off || $cyc) {
	$n=0;
	while(@outlets != 0 && $n < @outlets) {
	    die("Invalid Outlet \"",$outlets[$n],"\": Must be 1 to 8.\n")
		if (! ($outlets[$n]=~ /^[1-8]$/ ));
	    $n++;
	}
    }
}

#
# SUB ShowPorts ----------------------
#

sub ShowPorts {
    local(*sess,*Ports,*Interfaces,*i,*v) = @_;
    my $portConf = ["portConfSpeed",0];
    my $ifTable = ["ifAdminStatus",0];
    my %Able = ();
    my %Link = ();
    my %auto = ();
    my %speed = ();
    my %duplex = ();
    my @data=();
    #do one to get the first field...
    $sess->getnext($ifTable);
    do {
	@data = @{$ifTable};
	#print "$data[0]\t$data[1]\t$data[2]\n";
	if ($data[1] < 25) {
	    if ($data[0] =~ /AdminStatus/) { 
		$Able{$data[1]} = ($data[2]=~/up/ ? "yes" : "no"); 
	    }
	    if ($data[0] =~ /OperStatus/) { $Link{$data[1]} = $data[2]; } 
	}
	#do the getnext at the end, because if we're on the last, the next
	#one is junk to all the processing instructions...
	$sess->getnext($ifTable);
    } while ( $data[0] =~ /^i(f)(.*)Status$/) ;
    #do one to get the first field...
    $sess->getnext($portConf);
    do {
	@data = @{$portConf};
	$data[1] =~ s/\./:/g;
	$data[1] = (split(":",$data[1]))[2];
	#print "$data[0]\t$data[1]\t$data[2]\n";
	if ($data[1] < 25) {
	    if ($data[0] =~ /Speed/) {
		$data[2] =~ s/speed//;
		$data[2] =~ s/autodetect/\(auto\)/i;
		$speed{$data[1]} = $data[2]; 
	    }
	    if ($data[0] =~ /Duplex/) { 
		$data[2] =~ s/autodetect/\(auto\)/i;
		$duplex{$data[1]} = $data[2]; 
	    } 
	    if ($data[0] =~ /AutoNeg/) { $auto{$data[1]} = $data[2]; } 
	}
	#do the getnext at the end, because if we're on the last, the next
	#one is junk to all the processing instructions...
	$sess->getnext($portConf);
    } while ( $data[0] =~ /^portConf(Speed|Duplex|AutoNeg)$/);
    my $field = ["vlanPolicyVlanTable",0];
    my %vlanNames = ();
    my %portNames = ();
    my $mac="";
    my $id=0;
    #do one to get the first field...
    $sess->getnext($field);
    do {
	@data = @{$field};
	#print "$data[0]\t$data[1]\t$data[2]\n";
	if ($data[0] =~ /policyVlanName/) { $vlanNames{$data[1]} = $data[2]; }
	if ($data[0] =~ /MacRuleVlanId/) 
	{ 
	    my @vlan=();
	    if (defined ( @{$MACs{$data[2]}} ) ) { @vlan =@{$MACs{$data[2]}}; }
	    $_= sprintf("%d:%02x%02x%02x%02x%02x%02x", split(/\./,$data[1]));
	    @_= split(/:/,$_);
	    $id=$_[0];
	    $mac = $_[1];
	    $portNames{$mac}=$vlanNames{$id};
	}
	#do the getnext at the end, because if we're on the last, the next
	#one is junk to all the processing instructions...
        $sess->getnext($field);
    } while ( $data[0] =~ /^(policyVlan)|(policyMacRuleVlanId)/);
    my $switch = "";
    if ($i =~ /155\.99\.214\.170/) { $switch = "Alpha"; }
    if ($i =~ /155\.99\.214\.171/) { $switch = "Beta"; }
    if ($i =~ /155\.99\.214\.172/) { $switch = "Gamma"; }
    if ($i =~ /155\.99\.214\.173/) { $switch = "Delta"; }
    print "Port Configuration, Switch $switch ($i)\n";
    print "Port Interface\tVLAN\tEnabled\tLink\tAutoNeg\tSpeed\t\tDuplex\n";
    print "----------------------------------------------------------------";
    print "------------\n";
    foreach my $id ( sort num keys (%Able) ) {
	my $vlan;
	my $switchport = join(":",$i,$id);
	my $ifname = $Ports{$switchport};
	if (! defined ($ifname) ) { $ifname = "\t"; }
	if ($id < 10) { print " "; }
	print " ",$id,"  ";
	print $ifname,"\t";
	if (defined ($Interfaces{$ifname})) {
	    $vlan = $portNames{$Interfaces{$ifname}};
	}
	if ( defined $vlan) {
	    print $vlan;
	}
	print "\t";
	print $Able{$id},"\t",$Link{$id},"\t";
	print $auto{$id},"\t",$speed{$id},"\t";
	if (length ($speed{$id}) < 8 ) { print "\t"; }
	print $duplex{$id},"\n";
    }
}

#
# SUB GetStats ----------------------
#

sub GetStats {
    local(*sess,*Ports,*i,*v) = @_;
    my $ifTable = ["ifInOctets",0];
    my %inOctets=();
    my %inUcast=();
    my %inNUcast=();
    my %inDiscard=();
    my %inErr=();
    my %inUnkProt=();
    my %outOctets=();
    my %outUcast=();
    my %outNUcast=();
    my %outDiscard=();
    my %outErr=();
    my %outQLen=();
    my @data=();
    #do one to get the first field...
    $sess->getnext($ifTable);
    do {
	@data = @{$ifTable};
	#print "$data[0]\t$data[1]\t$data[2]\n";
	if ($data[1] < 25) {
	    if    ($data[0]=~/InOctets/)  {$inOctets{$data[1]}  = $data[2];} 
	    elsif ($data[0]=~/InUcast/)   {$inUcast{$data[1]}   = $data[2];}
	    elsif ($data[0]=~/InNUcast/)  {$inNUcast{$data[1]}  = $data[2];}
	    elsif ($data[0]=~/InDiscard/) {$inDiscard{$data[1]} = $data[2];}
	    elsif ($data[0]=~/InErrors/)  {$inErr{$data[1]}     = $data[2];}
	    elsif ($data[0]=~/InUnknownP/){$inUnkProt{$data[1]} = $data[2];}
	    elsif ($data[0]=~/OutOctets/) {$outOctets{$data[1]} = $data[2];}
	    elsif ($data[0]=~/OutUcast/)  {$outUcast{$data[1]}  = $data[2];}
	    elsif ($data[0]=~/OutNUcast/) {$outNUcast{$data[1]} = $data[2];}
	    elsif ($data[0]=~/OutDiscard/){$outDiscard{$data[1]}= $data[2];}
	    elsif ($data[0]=~/OutErrors/) {$outErr{$data[1]}    = $data[2];}
	    elsif ($data[0]=~/OutQLen/)   {$outQLen{$data[1]}   = $data[2];}
	}
	$sess->getnext($ifTable);
    } while ( $data[0] =~ /^i[f](In|Out)/) ;
    my $switch = "";
    if ($i =~ /155\.99\.214\.170/) { $switch = "Alpha"; }
    if ($i =~ /155\.99\.214\.171/) { $switch = "Beta"; }
    if ($i =~ /155\.99\.214\.172/) { $switch = "Gamma"; }
    if ($i =~ /155\.99\.214\.173/) { $switch = "Delta"; }
    print "Port Statistics, Testbed Switch $switch ($i)\n";
    print "\t\tIN: Octets\tUcast\tM/Bcast\tDiscard\tErrors\tUnknown Proto.\n";
    print "Port Interface\tOUT: Octets\tUcast\tM/Bcast\tDiscard\tErrors\tQueue Length\n";
    print "----------------------------------------------------------------";
    print "--------------\n";
    foreach my $port ( sort num keys (%inOctets) ) {
	my $vlan;
	my $switchport = join(":",$i,$port);
	my $ifname = $Ports{$switchport};
	if (! defined ($ifname) ) { $ifname = "\t"; }
	if ($port < 10) { print " "; }
	print " ",$port,"  ";
	print $ifname,"\t";
	my $n=0;
	my $str="";
	print $str=$inOctets{$port},"\t";
	if (length($str) < 8) { print "\t"; }
	print $str=$inUcast{$port},"\t";
	print $str=$inNUcast{$port},"\t"; 
	print $str=$inDiscard{$port},"\t";
	print $str=$inErr{$port},"\t"; 
	print $str=$inUnkProt{$port},"\t";
	print "\n\t\t";
	print $str=$outOctets{$port},"\t"; 
	if (length($str) < 8) { print "\t"; }
	print $str=$outUcast{$port},"\t";
	print $str=$outNUcast{$port},"\t"; 
	print $str=$outDiscard{$port},"\t";
	print $str=$outErr{$port},"\t"; 
	print $str=$outQLen{$port},"\n";
    }
}

#
# SUB UpdateField----------------------
#

sub UpdateField {
    local(*session,*OID,*ports,*val,*b,*c,*v)= @_;
    my $Status = 0;
    foreach my $port (@ports) {
	#print "Processing port $port, $OID, to $val. Last was $Status.\n";
	$Status = $session->get([[$OID,$port]]);
	print "Value for $port was $Status\n" if ($v);
	if ($Status ne $val) {
	    print "Setting value for $port to $val\n" if ($v);
	    #The empty sub {} is there to force it into async mode
	    $session->set([[$OID,$port,$val,"INTEGER"]],sub {});
	    if ($b) {
		while ($Status ne $val) { 
		    $Status=$session->get([[$OID,$port]]);
		    print "Value for $port was ",$Status,"\n" if ($v);
		}
	    }
	}
    }
    if ( (!$b) && $c ) {
	my $loops=0;
	my $max_loops=20;
	my %notdone=();
	my @done=();
	foreach my $port (@ports) {
	    $Status=$session->get([[$OID,$port]]);
	    print "Value for $port was ",$Status,"\n" if ($v);
	    if ($Status ne $val) {
		$notdone{$port}=1;
	    }
	}
	while ( %notdone && $loops < $max_loops ) {
	    foreach my $port (sort num keys(%notdone)) {
		$Status=$session->get([[$OID,$port]]);
		print "Value for $port was ",$Status,"\n" if ($v);
		if ($Status eq $val) {
		    push(@done,$port);
		}
	    }
	    foreach my $i (@done) { delete $notdone{$i}};
	    $loops++;
	}
	if ($loops==$max_loops) {
	    foreach my $port (sort num keys(%notdone)) {
		print STDERR "Port $port Change not verified!\n";
	    }
	    return(0); #Return False!
	}
    }
    1;
}

#
# SUB ReleaseToken----------------------
#

sub ReleaseToken {
    local(*sess,*v,*u) = @_;
    my $TokenRelease = '.1.3.6.1.4.1.343.6.11.4.8';
    my $TokenReleaseResult = '.1.3.6.1.4.1.343.6.11.4.9';
    my $TokenConfirmState = '.1.3.6.1.4.1.343.6.11.1.18';
    my $save = ($u ? "saveWithConfirmOption" : "save");
    print "Releasing Token with $save command\n" if ($v);
    $sess->set([[$TokenRelease,0,$save,"INTEGER"]]);
    my $RetVal = $sess->get([[$TokenReleaseResult,0]]);
    print "VLAN Configuration Save Result is $RetVal\n" if ($v);
    while ($RetVal eq "notReady") {
	$RetVal = $sess->get([[$TokenReleaseResult,0]]);
	print "VLAN Configuration Save Result is $RetVal\n" if ($v);
	select (undef, undef, undef, .25); #wait 1/4 second
    }
    if ($u) {
	$RetVal = $sess->get([[$TokenConfirmState,0]]);
	print "VLAN Configuration Confirm Result is $RetVal\n" if ($v);
	while ($RetVal eq "notReady") {
	    sleep(2);
	    $RetVal = $sess->get([[$TokenConfirmState,0]]);
	    print "VLAN Configuration Confirm Result is $RetVal\n" if ($v);
	}
	if ($RetVal eq "ready")
	{
	    $RetVal = $sess->set([[$TokenConfirmState,0,"confirm","INTEGER"]]);
	    print "VLAN Configuration Confirm Result is $RetVal\n" if ($v);
	}
	while (!($RetVal =~ /Conf/i)) {
	    $RetVal = $sess->get([[$TokenConfirmState,0]]);
	    print "VLAN Configuration Confirm Result is $RetVal\n" if ($v);
	}	
	if ($RetVal ne "confirmedNewConf") {
	    die("VLAN Reconfiguration Failed. No changes saved.\n");
	}
    } else {
	if ($RetVal ne 'success') {
	    print "VLAN Configuration Save Result is $RetVal\n" if ($v);
	    die("$RetVal VLAN Reconfiguration Failed. No changes saved.\n");
	}
    }   
}

#
# SUB GetToken----------------------
#

sub GetToken {
    local(*sess,*v) = @_;
    my $TokenOwner = '.1.3.6.1.4.1.343.6.11.4.5';
    my $TokenReq = '.1.3.6.1.4.1.343.6.11.4.6';
    my $TokenReqResult = '.1.3.6.1.4.1.343.6.11.4.7';
    my $TokenRelease = '.1.3.6.1.4.1.343.6.11.4.8';
    my $TokenReleaseResult = '.1.3.6.1.4.1.343.6.11.4.9';
    my $Num = pack("C*",0,0,0,0,1,1);
    #The zeros and ones are a magic number it needs...
    $sess->set([[$TokenReq,0,$Num,"OCTETSTR"]]);
    my $RetVal = $sess->get([[$TokenReqResult,0]]);
    while ($RetVal eq "notReady") {
	$RetVal = $sess->get([[$TokenReqResult,0]]);
	print "VLAN Token Claim Result is $RetVal\n" if ($v);
	select (undef, undef, undef, .25); #wait 1/4 second
    }
    print "VLAN Token Claim Result is $RetVal\n" if ($v);
    if ($RetVal ne 'success') {
	my $Owner = $sess->get([[$TokenOwner,0]]);
	print "VLAN Token Claim Result is $RetVal\n";
	die("Can't edit VLANs: Token taken by $Owner\n");
    }
}

#
# SUB OneVLAN----------------------
#

sub OneVLAN {
    #This is to be called ONLY after the edit token has already been taken!
    local(*sess,*m,*vlan,*v) = @_;
    my $NextVLANId = '.1.3.6.1.4.1.343.6.11.1.6';
    my $Vlan = $sess->get([[$NextVLANId,0]]);
    my $CreateOID = ".1.3.6.1.4.1.343.6.11.1.9.1.3";
    my $RetVal = "Undef.";
    print "ONE VLAN NAME = $m";
    if ( !$m ) { $m = $Vlan; }
    print "  Creating VLAN $m as VLAN #$Vlan: @vlan ... ";
    $RetVal = $sess->set([[$CreateOID,$Vlan,$m,"OCTETSTR"]]);
    print "",($RetVal? "Succeeded":"Failed"),".\n";
    if (! defined ($RetVal) ) {
	&ReleaseToken(*sess,*v,1);
	die("VLAN name \"$m\" not unique.\n");
    }
    my @x;
    my $n=0;
    while(@vlan != 0 && $n < @vlan) {
	my $i=0;
	while ($i < 6 ) {
	    $x[$i] = hex ("0x".substr($vlan[$n],2*$i,2) );
	    $i++;
	}
	my $MacObjOID = ".1.3.6.1.4.1.343.6.11.1.10.1.3.$Vlan." . 
	    "$x[0].$x[1].$x[2].$x[3].$x[4].$x[5]";
	print "    Adding MAC Address $vlan[$n] ".
	    "($Vlan.$x[0].$x[1].$x[2].$x[3].$x[4].$x[5])... ";
	$RetVal = $sess->set([[$MacObjOID,0,$vlan[$n],"OCTETSTR"]]);
	print "",($RetVal? "Succeeded":"Failed"), ".\n";
	$n++;
    }
}

#
# SUB AutoVLANConfig ----------------------
#

sub AutoVLANConfig {
    local(*sess,*f,*v,*u,*Interfaces) = @_;
    my @VLANS= ();
    my @names= ();
    &ReadIRFile(*f,\@names,\@VLANS,\%Interfaces);
    &GetToken(*sess,*v);
    my $m="";
    my @vlan=();
    while (@VLANS) {
	@vlan = @{shift(@VLANS)};
	$m = shift @names;
	print "VLAN NAME = $m\n";
	&OneVLAN(*sess,$m,*vlan,*v);
    }
    &ReleaseToken(*sess,*v,\$u);
}

#
# SUB ReadIRFile ----------------------
#

sub ReadIRFile {
    local(*f,*names,*VLANS,*Interfaces) = @_;
    my %exists = ();
    my $skip = 1;
    my $name = "";
    my $section = "";
    if ( -e "/usr/testbed/etc/$f") {
	open(IR,"/usr/testbed/etc/$f") 
	    || die("Couldn't open /usr/testbed/etc/$f\n");
    } elsif ( -e "$f" ) {
	open(IR,"$f") 
	    || die("Couldn't open $f\n");
    } elsif ( -e "/home/newbold/switch/$f" ) {
	open(IR,"/home/newbold/switch/$f") 
	    || die("Couldn't open /home/newbold/switch/$f\n");
    } else {
	die("Couldn't locate $f for VLAN setup.\n");
    }
    while (<IR>) {
	chop;
	if ( /^\#/ ) {  next; } #skip comments
	if ( /^start vlan/i ) { $skip = 0 ; next; }
	if ($skip) { next; }
	if ( /^end vlan/i ) { $skip = 1 ; next; }
	# If I'm in the right section, turn the line into a VLAN
	my @v= split;
	$name = shift @v;
	my $n=0;
	while(@v != 0 && $n < @v) {
	    #Lowercase it all, but leave in : for tbpcx:y syntax
	    $v[$n] = "\L$v[$n]\E";
	    #print "Took $v[$n]\t";
	    if ((!(($v[$n]=~/^([a-f]|\d)*$/i)&&(length ($v[$n])== 12)))
		&& (defined $Interfaces{$v[$n]})) {
		$v[$n] = $Interfaces{$v[$n]};
	    }
	    # Allow people to specify addresses with colons or dots
	    $v[$n] =~ s/[:\.]//g;
	    #print "Got $v[$n]\t";
	    die("Invalid MAC Address ",$v[$n],". Must be 6 byte Hex value.\n")
	       if (!(($v[$n]=~/^([a-f]|\d)*$/i)&&(length ($v[$n])== 12)));
	    $n++;
	}
	@v = sort @v;
	if (!defined $exists{ join(' ',@v) }) {
	    #print "Read VLAN $name with: ",join (" ",@v),"\n";
	   push( @VLANS, \@v);
	   push(@names, $name);
	   $exists{join(' ',@v)} = 1;
       }
    }   
    close (IR);
}


#
# SUB ReadTranslationTable ----------------------
#

sub ReadTranslationTable {
    local(*Table,*Ports) = @_;
    my $name="";
    my $mac="";
    my $switchport="";
    if ( -e "/usr/testbed/etc/macslist") {
	open(FILE,"/usr/testbed/etc/macslist") 
	    || die("Couldn't open /usr/testbed/etc/macslist\n");
    } elsif ( -e "macslist" ) {
	open(FILE,"macslist") 
	    || die("Couldn't open macslist\n");
    } elsif ( -e "/home/newbold/switch/macslist" ) {
	open(FILE,"/home/newbold/switch/macslist") 
	    || die("Couldn't open /home/newbold/switch/macslist\n");
    } else {
	print "Couldn't locate macslist configuration file.\n",
	   "Translation of MAC addresses will be disabled.\n";
	return 0;
    }
    while ( <FILE> ) {
	chop;
	s/(( )+|\t)/ /g;
	s/(( )+|\t)/ /g;
	@_ = split(/ /,$_);
	$name = $_[0];
	$mac = $_[1];
	if ( defined $_[3] ) {
	    $switchport = join(":",($_[2],$_[3]));
	    $Ports{$name} = $switchport;
	    $Ports{$switchport} = $name;
	} else {
	    $switchport = "";
	}
       #print "$name <==> $mac <==> $switchport\n";
	$Table{$name} = $mac;
	$Table{$mac} = $name;
    }
    close(FILE);
}

#
# SUB ListVLANs ----------------------
#

#used for numerical sort...
sub num { $a <=> $b; }

sub ListVLANs {
    local(*sess,*Interfaces,*v) = @_;
    my %Names = ();
    my %MACs = ();
    my @data = ();
    my @bytes = ();
    my $mac = "";
    my @vlan = ();
    my $field = ["vlanPolicyVlanTable",0];
    #do one to get the first field...
    $sess->getnext($field);
    do {
	@data = @{$field};
	#print "$data[0]\t$data[1]\t$data[2]\n";
	if ($data[0] =~ /policyVlanName/) { $Names{$data[1]} = $data[2]; }
	if ($data[0] =~ /MacRuleVlanId/) 
	{ 
	    my @vlan=();
	    if (defined ( @{$MACs{$data[2]}} ) ) { @vlan =@{$MACs{$data[2]}}; }
	    $_= sprintf("%d:%02x%02x%02x%02x%02x%02x", split(/\./,$data[1]));
	    @_= split(/:/,$_);
	    $mac = $_[1];
	    push(@vlan, $mac);
	    $MACs{$data[2]} = \@vlan;
	}
	#do the getnext at the end, because if we're on the last, the next
	#one is junk to all the processing instructions...
        $sess->getnext($field);
    } while ( $data[0] =~ /^(policyVlan)|(policyMacRuleVlanId)/) ;
    print "ID\tName\t\tMembers of VLAN\n";
    print "------------------------------------------\n";  
    foreach my $id ( sort num keys (%Names) ) {
	print $id,"\t",$Names{$id},"\t";
	if ( length ($Names{$id}) < 8 ) { print "\t"; }
	if (defined ( @{$MACs{$id}}) ) {
	    foreach my $m ( @{$MACs{$id}} ) {
		if ( defined ($Interfaces{$m})) {
		    print $Interfaces{$m}," \t";
		} else {
		    print $m,"\t";
		}
	    }
	}
	print "\n";
    }
}

#
# SUB RemoveVLAN ----------------------
#

sub RemoveVLAN {
    local(*sess,*r,*v) = @_;
    my $DeleteOID = ".1.3.6.1.4.1.343.6.11.1.9.1.4";
    my $RetVal = "Undef.";
    print "  Removing VLAN #$r ... ";
    if ($r == 25) {
	print "VLAN #$r is the Control VLAN, and cannot be removed.\n";
    } else {
	$RetVal = $sess->set([[$DeleteOID,$r,"delete","INTEGER"]]);
	print "",($RetVal? "Succeeded":"Failed"),".\n";
	if (! defined ($RetVal) ) {
	    print "VLAN #$r does not exist on this switch.\n";
	}
    }
}

#
# SUB ----------------------
#

#
# END OF SUBROUTINE SECTION =========================================
#
#
# END OF PROGRAM  ===================================================
#
