#!/usr/local/bin/perl -w
#########################################################################
# SnmpIt! - An SNMP Tool                                                #
# (specialized for the Intel 510T Switch and APC power controllers)     #
#                                                                       #
# Run with -h option to see command line syntax/options.                #
#                                                                       #
#      Author: Mac Newbold, Flux Research Group, University of Utah     #
# Last Change: April 29, 2000                                           #
#     Version: 1.0                                                      #
#                                                                       #
#########################################################################

#
# INIT SECTION =========================================================
#

my $i = "";  #IP addr.
my @p = ();  #Port numbers
my $d = 0;   #Disable (bool)
my $e = 0;   #Enable (bool)
my $a = "";  #Auto Negotiation (enable/disable) (two-way switch)
my $dup = "";  #Duplex (half/full)
my $s = 0;   #Speed (10/100)
my $f = "";  #AutoVLAN filename
my $l = 0;   #List all VLANs on switch
my $m = "";  #Create VLAN - name
my @vlan = ();  #VLAN Members - list of MAC Addresses
my @r = ();  #VLAN(s) to be removed
my $u = 0;   #Wait for Update of VLAN tables
my $b = 0;   #Block (bool) (two-way switch)
my $c = 1;   #Confirm Changes (bool) (two-way switch)
my $v = 0;   #Verbose (bool) !Must default quiet; switch only turns on!

#power control
my $on=0;
my $off=0;
my $cyc=0;
my $all=0;
my @outlets=();
my %Interfaces=();

&ParseArgs(*ARGV,*i,*p,*d,*e,*a,*dup,*s,*f,*l,*m,*vlan,*r,*u,*b,*c,*v,
	   *on,*off,*cyc,*all,*outlets,*Interfaces);

use lib '/n/moab/x/newbold/ucd-snmp-4.1.1/perl/SNMP/blib/lib';
use lib '/n/moab/x/newbold/ucd-snmp-4.1.1/perl/SNMP/blib/arch/auto/SNMP';
use SNMP;
#$SNMP::debugging = 1;

&SNMP::addMibDirs('/usr/local/share/snmp/mibs');
if (($i=~/155\.99\.214\.17(.*)/) && ($1=~ /^0$|^1$|^2$|^3$/)) {
    &SNMP::addMibFiles(
#		       '/usr/local/share/snmp/mibs/RFC1155-SMI.txt',
#		       '/usr/local/share/snmp/mibs/RFC1213-MIB.txt',
#		       '/usr/local/share/snmp/mibs/BRIDGE-MIB.txt', 
#		       '/usr/local/share/snmp/mibs/EtherLike-MIB.txt',
#		   '/usr/local/share/snmp/mibs/RMON-MIB.txt',
		       '/usr/local/share/snmp/mibs/INTEL-GEN-MIB.txt', 
		       '/usr/local/share/snmp/mibs/INTEL-S500-MIB.txt',
		       '/usr/local/share/snmp/mibs/INTEL-VLAN-MIB.txt',
#		   '/usr/local/share/snmp/mibs/DVMRP-MIB.txt', 
#		   '/usr/local/share/snmp/mibs/INTEL-L3LINK-MIB.txt',
#		   '/usr/local/share/snmp/mibs/IGMP-MIB.txt',
#		   '/usr/local/share/snmp/mibs/INTEL-IPF-MIB.txt', 
#		   '/usr/local/share/snmp/mibs/INTEL-IPROUTER-MIB.txt',
#		   '/usr/local/share/snmp/mibs/INTEL-IGMP-PRUNING-MIB.txt', 
#		   '/usr/local/share/snmp/mibs/INTEL-IPX-MIB.txt'
		       );
} else {
    &SNMP::addMibFiles('/n/moab/x/newbold/mibs/PowerNet-MIB.txt');
}

$SNMP::save_descriptions = 1; # must be set prior to mib initialization
 SNMP::initMib(); # parses default list of Mib modules from default dirs

#
# MAIN SECTION =========================================================
#

$SNMP::use_enums = 1; #use enum values instead of only ints
my $sess = new SNMP::Session(DestHost => $i);
my $sess2 =new SNMP::Session(DestHost => $i, Community => 'private');

#
# Port Level Control
#
if ($d || $e) {
    my $Admin = ".1.3.6.1.2.1.2.2.1.7";
    my $Status = "";
    $Status = "down" if ($d);
    $Status = "up" if ($e);
    if (! &UpdateField(\$sess,$Admin,\@p,$Status,\$b,\$c,\$v)) {
	print STDERR "Port ",($d?"disable":"enable")," failed.\n";
    }    
}

if ($s) {
    my $Spd = ".1.3.6.1.4.1.343.6.10.2.4.1.10.1.1";
    if (! &UpdateField(\$sess,$Spd,\@p,$s,\$b,\$c,\$v)) {
	print STDERR "Port Speed change failed.\n";
    }    
}

if ($dup) {
    my $duplex = ".1.3.6.1.4.1.343.6.10.2.4.1.11.1.1";
    if (! &UpdateField(\$sess,$duplex,\@p,$dup,\$b,\$c,\$v)) {
	print STDERR "Port Duplex change failed.\n";
    }    
}

if ($a) {
    my $Auto = ".1.3.6.1.4.1.343.6.10.2.4.1.12.1.1";
    my $aOp = ( $a=~/en/ ? "auto" : "manual");
    if (! &UpdateField(\$sess,$Auto,\@p,$a,\$b,\$c,\$v)) {
	print STDERR "Port Auto-Configuration change failed.\n";
    }    
}

#
# VLANs
#
if (@vlan) {
    #This is to make ONE vlan - for multiple, use -f AutoVLAN from file
    &GetToken(\$sess,\$v);
    &OneVLAN(\$sess,\$m,\@vlan,\$v);
    &ReleaseToken(\$sess,\$v,\$u);
}

if ($f) {
    &AutoVLANConfig(\$sess,\$f,\$v,\$u);
}

if (@r) {
    &GetToken(\$sess,\$v);
    foreach $x (sort @r)
    {
	&RemoveVLAN(\$sess,\$x,\$v);
    }
    &ReleaseToken(\$sess,\$v,\$u);
}

#List VLANs is always after $f and @vlan, so that changes made are reflected...
if ($l) {
    &ListVLANs(\$sess,\%Interfaces,\$v);
}

#
# Power Control
#
if ($off || $on || $cyc) {
    my $CtlOID = ".1.3.6.1.4.1.318.1.1.4.4.2.1.3";
    my $op = "";
    #disable confirmation, and go to blocking mode...
    $c = 0;
    $b = 0;
    if ($all) {
	my $AllOID = ".1.3.6.1.4.1.318.1.1.4.2.1";
	@outlets = ( 0 );
	if ($on)     { $op = "turnAllOnSequence";}
	elsif ($off) { $op = "turnAllOffNow";    }
	else         { $op = "rebootAllSequence";}
	if (! &UpdateField(\$sess2,$AllOID,\@outlets,$op,\$b,\$c,\$v)) {
	    print STDERR "Outlet control failed.\n";
	}
    } else {
	if ($on)     { $op = "outletOn";    }
	elsif ($off) { $op = "outletOff";   }
	else         { $op = "outletReboot";}
	if (! &UpdateField(\$sess2,$CtlOID,\@outlets,$op,\$b,\$c,\$v)) {
	    print STDERR "Outlet #@outlets control failed.\n";
	    }
    }
}

#
# END OF MAIN  =================================================
#



#
# SUBROUTINE SECTION =================================================
#

#
# SUB PARSEARGS----------------------
#
sub ParseArgs {
    local(*CMDS,*i,*p,*d,*e,*a,*dup,*s,*f,*l,*m,*vlan,*r,*u,*b,*c,*v,
	  *on,*off,*cyc,*all,*outlets,*Interfaces) = @_;
    my $help=0; 
    if (@CMDS < 1) {$help = 2; }
    while (@CMDS != 0 && $CMDS[0] =~ /^(-|\+)/) {
	$_ = shift(@CMDS);
	#print "Item=$_*\n";
	#print "i=$i p=@p D=$d E=$e a=$a d=$dup s=$s m=$m vlan=@vlan b=$b c=$c on=$on off=$off cyc=$cyc\n";
	if (/^-i(.*)/) {$i = ($1 ? $1 : shift(@CMDS));}
	elsif (/^-p(.*)/) {
	    my $Range ="";
	    do {
		$Range = ($1 ? $1 : shift(@CMDS));
		#print "Range=$Range\n";
		if ( $Range =~ /^(\d*)\.\.(\d*)$/ ) {
		    #print "1Pushing ",$1..$2,"*\n";
		    push(@p, $1..$2);
		} else {
		    #print "2Pushing ",$Range,"*\n";
		    push(@p, $Range);
		}
	    }
	    while (@CMDS>0 && ! ($CMDS[0] =~ /^(-|\+)(.*)/ ) );
	}
	elsif (/^-h(.*)/) {$help = 1;}
	elsif (/^-off(.*)/) {$off = 1;}
	elsif (/^-on(.*)/) {$on = 1;}
	elsif (/^-cyc(.*)/) {$cyc = 1;}
	elsif (/^-all(.*)/) {$all = 1;}
	elsif (/^-a(.*)/) {$a="disable";}
	elsif (/^\+a(.*)/) {$a="enable";}
	elsif (/^-dup(.*)/) {$dup = ($1 ? $1 : shift(@CMDS));}
	elsif (/^-s(.*)/) {$s = ($1 ? $1 : shift(@CMDS));}
	elsif (/^-d(.*)/) {$d = 1;}
	elsif (/^-e(.*)/) {$e = 1;}
	elsif (/^-l(.*)/) {$l = 1;}
	elsif (/^-u(.*)/) {$u = 1;}
	elsif (/^-f(.*)/) {$f = ($1 ? $1 : shift(@CMDS));}
	elsif (/^-m(.*)/) {$m = ( !(@CMDS==0 || $CMDS[0] =~ /^(-|\+)(.*)/) ? 
				  ($1 ? $1 : shift(@CMDS)) : "");}
	elsif (/^-vlan(.*)/) {
	    push(@vlan, ($1 ? $1 : shift(@CMDS)));
	    while ( @CMDS>0 && ! ($CMDS[0] =~ /^(-|\+)(.*)/ ) ) { 
		push(@vlan, shift(@CMDS));
	    }
	}
	elsif (/^-r(.*)/) {
	    push(@r, ($1 ? $1 : shift(@CMDS)));
	    while ( @CMDS>0 && ! ($CMDS[0] =~ /^(-|\+)(.*)/ ) ) { 
		push(@r, shift(@CMDS));
	    }
	}
	elsif (/^-v(.*)/) {$v = 1;}
	elsif (/^-b(.*)/) {$b = 0;}
	elsif (/^\+b(.*)/) {$b = 1;}
	elsif (/^-c(.*)/) {$c = 0;}
	elsif (/^\+c(.*)/) {$c = 1;}
	elsif (/^-(\d*)/) { push(@outlets, $1);}
	else {die("Unknown Option: $_\n");}
    }
    #print "Done:\nS=$i p=@p D=$d E=$e a=$a d=$dup s=$s C=$m vlan=@vlan B=$b V=$c on=$on off=$off cyc=$cyc\n";
    if ($help) {
	print
	    "SnmpIt! - A general purpose SNMP Tool\n",
	    "Syntax:\n",
	    "$0 [-h] [-v] [+b|-b] [+c|-c] -i<ip>\n",
	    "\t[-p<port> <port> <x>..<y> ... ]\n",
	    "\t[-d[isable]|-e[nable]] [+a|-a] [-s<speed>] [-dup<duplex>]\n", 
	    "\t[-m<vlan name>] [[-vlan<MAC Addr.>] | [-f<filename>]]\n",
	    "\t[-r<vlan #> <vlan #> ... ] [-l]\n",
	    "\t[ [-on|-off|-cyc] [-all] | [-<n>] ]\n";
	
    }
    if ($help == 1) {
	print
	    "\n",
	    "  -h    Display this help message\n",
	    "  -v    Verbose mode (now ",($v?"on":"off"),")\n",
	    "  -i    IP address or switch name\n",
	    "  +b/-b Blocking mode (now ",($b?"on":"off"),")\n",
	    "  +c/-c Confirm Changes (now ",($c?"on":"off"),")\n",
	    "  -p    List of port numbers and ranges\n",
	    "  -d    Disable port(s)\n",
	    "  -e    Enable port(s)\n",
	    "  +a/-a Enable/Disable Port Auto-Negotiation of speed/duplex\n",
	    "  -s    Port Speed (10 or 100 Mbits)\n",
	    "  -dup  Port Duplex (half or full)\n",
	    "  -f    File mode - Automatically set up set of VLANs\n",
	    "  -l    List all VLANs on switch (ell, not #1)\n",
	    "  -m    Make a VLAN\n",
	    "  -vlan Add MAC Address to VLAN\n",
	    "  -r    Remove VLAN(s)",
	    "  -u    Wait for Update of VLAN tables (takes about 20 seconds)\n",
	    "  -on   Turn on outlets\n",
	    "  -off  Turn off outlets\n",
	    "  -cyc  Power Cycle outlets\n",
	    "  -all  All outlets\n",
	    "  -(n)  Outlet #(n) (n=1-8)\n";
    }
    #If help only, end here...
    die("\b\n") if ($help);
    #Now die on any combinations that don't make sense...
    die("What shall I do?\n")
	if (! ($d||$e||$a||$s||$dup||@vlan||$f||@r||$l||$on||$off||$cyc) );
    if (@vlan||$f||@r||$l) { $i = "Gamma"; }
    if ($i =~ /Alpha/i) { $i = "155.99.214.170"; }
    if ($i =~ /Beta/i)  { $i = "155.99.214.171"; }
    if ($i =~ /Gamma/i)  { $i = "155.99.214.172"; }
    if ($i =~ /Delta/i)  { $i = "155.99.214.173"; }
    die("$i is not an Intel 510 Switch: Possible completions are\n",
	"Alpha/155.99.214.170\n Beta/155.99.214.171\n",
	"Gamma/155.99.214.172\n Delta/155.99.214.173\n") 
	if ( (!(($i=~/155\.99\.214\.17(.*)/) && ($1=~ /^0$|^1$|^2$|^3$/))) && 
	     ($d || $e || $a || $s || $dup || @vlan || $f || @r || $l ));
    die("$i is not a power controller.\n") 
	if ( (($i=~/155\.99\.214\.(.*)/) && ($1=~ /^0$|^1$|^2$|^3$/)) && 
	     ($on||$off||$cyc) );
    die("Can't enable and disable at the same time.\n") if ($d && $e);
    die("Can't use auto with duplex or speed.\n") if (($a=~/en/)&&($dup||$s));
    my $n=0;
    while(@p != 0 && $n < @p) {
	die("Invalid port ",$p[$n],": Must be 1-24\n") 
	    if ($p[$n] =~ /\D/ || $p[$n]>24 || $p[$n]<1);
	$n++;
    }
    die("Which ports do I reconfigure?\n") if (!@p &&($d||$e||$dup||$s||$a));
    die("Invalid duplex $dup: Must be full or half\n") 
	if(!($dup=~/^full$|^half$|^$/));
    die("Invalid speed $s: Must be 10 or 100\n") if (!($s=~/^10$|^100$|^0$/));
    if ($s eq "10" ) { $s="speed10Mbit" ;}
    if ($s eq "100") { $s="speed100Mbit";}
    if (@vlan || $f || $r || $l) {
	&ReadTranslationTable(\%Interfaces);
    }
    $n=0;
    while(@vlan != 0 && $n < @vlan) {
	#Lowercase it all, but leave in : for testx:y syntax
	$vlan[$n] = "\L$vlan[$n]\E";
	if (($vlan[$n]=~/([g-z])/ )&&(defined $Interfaces{$vlan[$n]})) {
	    $vlan[$n] = $Interfaces{$vlan[$n]};
	}
	# Allow people to specify addresses with colons or dots
	$vlan[$n] =~ s/[:\.]//g;
	die("Invalid MAC Address ",$vlan[$n],". Must be 6 byte Hex value.\n")
	    if (!(($vlan[$n]=~/^([a-f]|\d)*$/i)&&(length ($vlan[$n])== 12)));
	$n++;
    }
    die("Can't use file mode with manual vlan creation.\n") if ($f && @vlan);
    $n=0;
    while(@outlets != 0 && $n < @outlets) {
	die("Invalid Outlet \"",$outlets[$n],"\": Must be 1 to 8.\n")
	    if (! ($outlets[$n]=~ /^[1-8]$/ ));
	$n++;
    }
}

#
# SUB UpdateField----------------------
#

sub UpdateField {
    local(*session,$OID,*ports,$val,*b,*c,*v)= @_;
    my $Status = 0;
    foreach $port (@ports) {
	$Status = $session->get([[$OID,$port]]);
	print "Value for $port was $Status\n" if ($v);
	if ($Status ne $val) {
	    print "Setting value for $port to $val\n" if ($v);
	    #The empty sub {} is there to force it into async mode
	    $session->set([[$OID,$port,$val,"INTEGER"]],sub {});
	    if ($b) {
		while ($Status ne $val) { 
		    $Status=$session->get([[$OID,$port]]);
		    print "Value for $port was ",$Status,"\n" if ($v);
		}
	    }
	}
    }
    if ( (!$b) && $c ) {
	my $loops=0;
	my $max_loops=10;
	my %notdone=();
	my @done=();
	foreach $port (@ports) {
	    $Status=$session->get([[$OID,$port]]);
	    print "Value for $port was ",$Status,"\n" if ($v);
	    if ($Status ne $val) {
		$notdone{$port}=1;
	    }
	}
	while ( %notdone && $loops < $max_loops ) {
	    foreach $port (sort keys(%notdone)) {
		$Status=$session->get([[$OID,$port]]);
		print "Value for $port was ",$Status,"\n" if ($v);
		if ($Status eq $val) {
		    push(@done,$port);
		}
	    }
	    foreach $i (@done) { delete $notdone{$i}};
	    $loops++;
	}
	if ($loops==$max_loops) {
	    foreach $port (sort keys(%notdone)) {
		print STDERR "Port $port Change not verified!\n";
	    }
	    return(0); #Return False!
	}
    }
    1;
}

#
# SUB ReleaseToken----------------------
#

sub ReleaseToken {
    local(*sess,*v,*u) = @_;
    my $TokenRelease = '.1.3.6.1.4.1.343.6.11.4.8';
    my $TokenReleaseResult = '.1.3.6.1.4.1.343.6.11.4.9';
    my $TokenConfirmState = '.1.3.6.1.4.1.343.6.11.1.18';
    my $save = ($u ? "saveWithConfirmOption" : "save");
    print "Releasing Token with $save command\n" if ($v);
    $sess->set([[$TokenRelease,0,$save,"INTEGER"]]);
    $RetVal = $sess->get([[$TokenReleaseResult,0]]);
    print "VLAN Configuration Save Result is $RetVal\n" if ($v);
    while ($RetVal eq "notReady") {
	$RetVal = $sess->get([[$TokenReleaseResult,0]]);
	print "VLAN Configuration Save Result is $RetVal\n" if ($v);
	select (undef, undef, undef, .25); #wait 1/4 second
    }
    if ($u) {
	$RetVal = $sess->get([[$TokenConfirmState,0]]);
	print "VLAN Configuration Confirm Result is $RetVal\n" if ($v);
	while ($RetVal eq "notReady") {
	    sleep(2);
	    $RetVal = $sess->get([[$TokenConfirmState,0]]);
	    print "VLAN Configuration Confirm Result is $RetVal\n" if ($v);
	}
	if ($RetVal eq "ready")
	{
	    $RetVal = $sess->set([[$TokenConfirmState,0,"confirm","INTEGER"]]);
	    print "VLAN Configuration Confirm Result is $RetVal\n" if ($v);
	}
	while (!($RetVal =~ /Conf/i)) {
	    $RetVal = $sess->get([[$TokenConfirmState,0]]);
	    print "VLAN Configuration Confirm Result is $RetVal\n" if ($v);
	}	
	if ($RetVal ne "confirmedNewConf") {
	    die("VLAN Reconfiguration Failed. No changes saved.\n");
	}
    } else {
	if ($RetVal ne 'success') {
	    print "VLAN Configuration Save Result is $RetVal\n" if ($v);
	    die("$RetVal VLAN Reconfiguration Failed. No changes saved.\n");
	}
    }   
}

#
# SUB GetToken----------------------
#

sub GetToken {
    local(*sess,*v) = @_;
    my $TokenOwner = '.1.3.6.1.4.1.343.6.11.4.5';
    my $TokenReq = '.1.3.6.1.4.1.343.6.11.4.6';
    my $TokenReqResult = '.1.3.6.1.4.1.343.6.11.4.7';
    my $TokenRelease = '.1.3.6.1.4.1.343.6.11.4.8';
    my $TokenReleaseResult = '.1.3.6.1.4.1.343.6.11.4.9';
    my $Num = pack("C*",0,0,0,0,1,1);
    #The zeros and ones are a magic number it needs...
    $sess->set([[$TokenReq,0,$Num,"OCTETSTR"]]);
    my $RetVal = $sess->get([[$TokenReqResult,0]]);
    while ($RetVal eq "notReady") {
	$RetVal = $sess->get([[$TokenReqResult,0]]);
	print "VLAN Token Claim Result is $RetVal\n" if ($v);
	select (undef, undef, undef, .25); #wait 1/4 second
    }
    print "VLAN Token Claim Result is $RetVal\n" if ($v);
    if ($RetVal ne 'success') {
	my $Owner = $sess->get([[$TokenOwner,0]]);
	print "VLAN Token Claim Result is $RetVal\n";
	die("Can't edit VLANs: Token taken by $Owner\n");
    }
}

#
# SUB OneVLAN----------------------
#

sub OneVLAN {
    #This is to be called ONLY after the edit token has already been taken!
    local(*sess,*m,*vlan,*v) = @_;
    my $NextVLANId = '.1.3.6.1.4.1.343.6.11.1.6';
    my $Vlan = $sess->get([[$NextVLANId,0]]);
    my $CreateOID = ".1.3.6.1.4.1.343.6.11.1.9.1.3";
    my $RetVal = "Undef.";
    if ( !$m || $f ) { $m = $Vlan; }
    print "  Creating VLAN $m as VLAN #$Vlan: @vlan ... ";
    $RetVal = $sess->set([[$CreateOID,$Vlan,$m,"OCTETSTR"]]);
    print "",($RetVal? "Succeeded":"Failed"),".\n";
    if (! defined ($RetVal) ) {
	&ReleaseToken(*sess,*v,1);
	die("VLAN name \"$m\" not unique.\n");
    }
    my @x;
    my $n=0;
    while(@vlan != 0 && $n < @vlan) {
	my $i=0;
	while ($i < 6 ) {
	    $x[$i] = hex ("0x".substr($vlan[$n],2*$i,2) );
	    $i++;
	}
	my $MacObjOID = ".1.3.6.1.4.1.343.6.11.1.10.1.3.$Vlan." . 
	    "$x[0].$x[1].$x[2].$x[3].$x[4].$x[5]";
	print "    Adding MAC Address $vlan[$n] ".
	    "($Vlan.$x[0].$x[1].$x[2].$x[3].$x[4].$x[5])... ";
	$RetVal = $sess->set([[$MacObjOID,0,$vlan[$n],"OCTETSTR"]]);
	print "",($RetVal? "Succeeded":"Failed"), ".\n";
	$n++;
    }
}

#
# SUB AutoVLANConfig ----------------------
#

sub AutoVLANConfig {
    local(*sess,*f,*v,*u) = @_;
    my @VLANS= ();
    &ReadIRFile(*f,\@VLANS);
    &GetToken(*sess,*v);
    my $m="";
    while (@VLANS) {
	@vlan = @{shift(@VLANS)};
	&OneVLAN(*sess,*m,*vlan,*v);
    }
    &ReleaseToken(*sess,*v,\$u);
}

#
# SUB ReadIRFile ----------------------
#

sub ReadIRFile {
   local(*f,*VLANS) = @_;
   my %exists = ();
   my $skip = 1;
   my $switch = $i;
   my $section = "";
   if ( !open(IR,$f) ) { die("Couldn't open $f for VLAN Setup.\n"); }
   while (<IR>) {
       chop;
       if ( /^\#/ ) {  next; } #skip comments
       if ( /^start vlan/i ) { $skip = 0 ; next; }
       if ($skip) { next; }
       if ( /^end vlan/i ) { $skip = 1 ; next; }
       if ( /^switch/i ) { next; }
       if ( /^end/i ) { next; }
       # If I'm in the right section, turn the line into a VLAN
       my @v= split;
       my $n=0;
       while(@v != 0 && $n < @v) {
	   #Lowercase it all, but leave in : for testx:y syntax
	   $v[$n] = "\L$v[$n]\E";
	   if (($v[$n]=~/([g-z])/ )&&(defined $Interfaces{$v[$n]})) {
	       $v[$n] = $Interfaces{$v[$n]};
	   }
	   # Allow people to specify addresses with colons or dots
	   $v[$n] =~ s/[:\.]//g;
	   die("Invalid MAC Address ",$v[$n],". Must be 6 byte Hex value.\n")
	       if (!(($v[$n]=~/^([a-f]|\d)*$/i)&&(length ($v[$n])== 12)));
	   $n++;
       }
       @v = sort @v;
       if (!defined $exists{ join(' ',@v) }) {
	   push(@VLANS, \@v);
	   $exists{join(' ',@v)} = 1;
       }
   }   
   close (IR);
}


#
# SUB ReadTranslationTable ----------------------
#

sub ReadTranslationTable {
   local(*Table) = @_;
   my $name="";
   my $mac="";
   if ( -e "/usr/testbed/etc/macslist") {
       open(FILE,"/usr/testbed/etc/macslist") 
	   || die("Couldn't open /usr/testbed/macslist\n");
   } elsif ( -e "macslist" ) {
       open(FILE,"macslist") 
	   || die("Couldn't open macslist\n");
   } else {
       print "Couldn't locate macslist configuration file.\n",
	   "Translation of MAC addresses will be disabled.\n";
       return 0;
   }
   while ( <FILE> ) {
       chop;
       s/  / /g;
       @_ = split(/ /,$_);
       $name = $_[0];
       $mac = $_[2];
       $Table{$_[0]} = $_[2];
       $Table{$_[2]} = $_[0];
   }
   close(FILE);
}

#
# SUB ListVLANs ----------------------
#

sub ListVLANs {
    local(*sess,*Interfaces,*v) = @_;
    my %Names = ();
    my %MACs = ();
    my @data = ();
    my @bytes = ();
    my $mac = "";
    my @vlan = ();
    my $field = ["vlanPolicyVlanTable",0];
    #do one to get the first field...
    $sess->getnext($field);
    do {
	@data = @{$field};
	#print "$data[0]\t$data[1]\t$data[2]\n";
	if ($data[0] =~ /policyVlanName/) { $Names{$data[1]} = $data[2]; }
	if ($data[0] =~ /MacRuleVlanId/) 
	{ 
	    my @vlan=();
	    if (defined ( @{$MACs{$data[2]}} ) ) { @vlan =@{$MACs{$data[2]}}; }
	    $_= sprintf("%d:%02x%02x%02x%02x%02x%02x", split(/\./,$data[1]));
	    @_= split(/:/,$_);
	    $mac = $_[1];
	    push(@vlan, $mac);
	    $MACs{$data[2]} = \@vlan;
	}
	#do the getnext at the end, because if we're on the last, the next
	#one is junk to all the processing instructions...
        $sess->getnext($field);
    } while ( $data[0] =~ /^(policyVlan)|(policyMacRuleVlanId)/) ;
    print "ID\tName\t\tMembers of VLAN\n";
    print "------------------------------------------\n";
    foreach $id ( sort keys ( %Names)) {
	print $id,"\t",$Names{$id},"\t";
	if ( length ($Names{$id}) < 8 ) { print "\t"; }
	if (defined ( @{$MACs{$id}}) ) {
	    foreach $m ( @{$MACs{$id}} ) {
		if ( defined ($Interfaces{$m})) {
		    print $Interfaces{$m},"  \t";
		} else {
		    print $m,"\t";
		}
	    }
	}
	print "\n";
    }
}

#
# SUB RemoveVLAN ----------------------
#

sub RemoveVLAN(*sess,*r,*v) {
    local(*sess,*r,*v) = @_;
    my $DeleteOID = ".1.3.6.1.4.1.343.6.11.1.9.1.4";
    my $RetVal = "Undef.";
    print "  Removing VLAN #$r ... ";
    if ($r == 25) {
	print "VLAN #$r is the Control VLAN, and cannot be removed.\n";
    } else {
	$RetVal = $sess->set([[$DeleteOID,$r,"delete","INTEGER"]]);
	print "",($RetVal? "Succeeded":"Failed"),".\n";
	if (! defined ($RetVal) ) {
	    print "VLAN #$r does not exist on this switch.\n";
	}
    }
}

#
# SUB ----------------------
#

#
# END OF SUBROUTINE SECTION =========================================
#
#
# END OF PROGRAM  ===================================================
#
