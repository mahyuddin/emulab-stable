#! /usr/bin/env python

import re
import sys
import time
import socket
import getopt

import MySQLdb

DBNAME = "nfsdb"
DBUSER = "nfstrace"

try:
    DBPASS = open("/var/nfstrace/dbpass").read().strip()
    pass
except IOError:
    sys.stderr.write("error: permission denied\n")
    sys.exit(1)
    pass

VERBOSITY = 1

GC_TABLES = [
    "node_ids",
    "mounts",
    "mount_replies",
    "lookups",
    "lookup_replies",
    "reads",
    "writes",
    "creates",
    "create_replies",
    "mkdirs",
    "mknods",
    "removes",
    "rmdirs",
    "renames",
    "file_access",
    "file_dropped", ]

def usage():
    return

##
# Print the usage statement for the "gc" action.
#
def gc_usage():
    print "Usage: nfstrace gc <host0> [<host1> ...]"
    print
    print "Garbage collect old NFS trace data."
    print
    print "Examples:"
    print "  $ nfstrace gc pc10 pc11"
    return

##
# Print the usage statement for the "get" action.
#
def get_usage():
    print "Usage: nfstrace get <host0> [<host1> ...]"
    print
    print "Get a file listing for the given hosts."
    print
    print "Examples:"
    print "  $ nfstrace get pc10 pc11"
    return

##
# Print the usage statement for the "get" action.
#
def stats_usage():
    print "Usage: nfstrace stats"
    print
    print "Print out statistics."
    print
    print "Examples:"
    print "  $ nfstrace stats"
    return

def resolve_hosts(hosts):
    retval = []
    for lpc in range(0, len(hosts)):
        try:
            retval.append(socket.gethostbyname(hosts[lpc]))
            pass
        except socket.gaierror, e:
            raise getopt.error(hosts[lpc] + ":" + e.args[1])
        pass

    return retval

##
# Performs the "gc" action, which garbage collects old data for a set of nodes.
#
# @param args Action-specific command line arguments.
#
def do_gc(args):
    retval = 0

    try:
        opts, args = getopt.getopt(args, "", [])
        for opt, val in opts:
            if opt in ("-n", "--dry-run"):
                pass
            pass

        if len(args) == 0:
            raise getopt.error("Not enough arguments")
        
        ips = resolve_hosts(args)
        pass
    except getopt.error, e:
        print e.args[0]
        gc_usage()
        return 2

    for tab in GC_TABLES:
        cur.execute("DELETE FROM " + tab + " where node_ip in "
                    "(" + ",".join(("%s",) * len(ips)) + ")", ips)
        pass

    for lpc in range(0, len(ips)):
        if args[lpc] != ips[lpc]:
            cur.execute("REPLACE INTO node_ids (node_id, node_ip) VALUES "
                        "(%s,%s)",
                        (args[lpc], ips[lpc]))
            pass
        pass

    con.commit();
    
    return retval

##
# Performs the "get" action, which prints out the files accessed by a set of
# nodes.
#
# @param args Action-specific command line arguments.
#
def do_get(args):
    retval = 0

    try:
        opts, args = getopt.getopt(args, "", [])
        for opt, val in opts:
            if opt in ("-n", "--dry-run"):
                pass
            pass
        
        if len(args) == 0:
            raise getopt.error("Not enough arguments")
        
        args = resolve_hosts(args)
        pass
    except getopt.error, e:
        print e.args[0]
        get_usage()
        return 2

    missing = 0
    
    cur.execute("select hm.fn,"
                "  IFNULL(MAX(fa.last_access)>MAX(fd.last_remove),1) "
                "  from file_access as fa "
                "left join file_dropped as fd on fa.fh=fd.fh "
                "left join handle_map as hm on hm.fh=fa.fh "
                "where fa.node_ip in (" + ",".join(("%s",) * len(args))
                + ") group by hm.fn", args)
    for (fn, alive) in cur:
        if alive and fn:
            print fn
            pass
        elif not fn:
            missing += 1
            pass
        pass

    if missing > 0:
        print `missing` + " unknown file(s) accessed."
        pass

    return retval

def do_stats(args):
    retval = 0

    row_count = 10
    over_last = 5
    
    try:
        opts, args = getopt.getopt(args, "c:l:", [
            "count=", "last="
            ])
        for opt, val in opts:
            if opt in ("-c", "--count"):
                row_count = int(val)
                pass
            elif opt in ("-l", "--last"):
                over_last = int(val)
                pass
            pass
        pass
    except getopt.error, e:
        print e.args[0]
        get_usage()
        return 2

    print "Top readers:"
    cur.execute("select r.node_ip,count(1) as wc from reads as r "
                "where timestamp > (UNIX_TIMESTAMP() - (60 * %s)) "
                "group by r.node_ip order by wc desc limit %s",
                (over_last, row_count))
    readers = cur.fetchall()
    for (node_ip,count) in readers:
        cur.execute("select node_id from node_ids where node_ip=%s",
                    (node_ip,))
        node_id = cur.fetchone()
        if node_id:
            node_id = node_id[0];
            pass
        else:
            he = socket.gethostbyaddr(node_ip)
            node_id = he[0].split('.')[0]
            pass
        print "  %8d\t%s" % (count, node_id)
        pass

    print "Top read files:"
    cur.execute("select hm.fn,count(1) as rc from reads as r "
                "left join handle_map as hm on hm.fh=r.fh "
                "where timestamp > (UNIX_TIMESTAMP() - (60 * %s)) "
                "group by r.fh order by rc desc limit %s",
                (over_last, row_count))
    for (fn,count) in cur:
        print "  %8d\t%s" % (count, fn or "<unknown>")
        pass
    
    print "Top writers:"
    cur.execute("select w.node_ip,ni.node_id,count(1) as wc,sum(amount) "
                "from writes as w "
                "left join node_ids as ni on ni.node_ip=w.node_ip "
                "where timestamp > (UNIX_TIMESTAMP() - (60 * %s)) "
                "group by w.node_ip order by wc desc limit %s",
                (over_last, row_count))
    for (node_ip,node_id,count,amount) in cur:
        if not node_id:
            he = socket.gethostbyaddr(node_ip)
            node_id = he[0].split('.')[0]
            pass
        print "  %8d\t%16d\t%s" % (count, amount, node_id)
        pass
    
    print "Top written files:"
    cur.execute("select hm.fn,count(1) as wc from writes as w "
                "left join handle_map as hm on hm.fh=w.fh "
                "where timestamp > (UNIX_TIMESTAMP() - (60 * %s)) "
                "group by w.fh order by wc desc limit %s",
                (over_last, row_count))
    for (fn,count) in cur:
        print "  %8d\t%s" % (count, fn or "<unknown>")
        pass
    
    return retval


ACTIONS = {
    "gc" : (do_gc, gc_usage),
    "get" : (do_get, get_usage),
    "stats" : (do_stats, stats_usage),
    }

try:
    opts, req_args = getopt.getopt(sys.argv[1:],
                                   "h",
                                   [ "help", ])
    
    for opt, val in opts:
        if opt in ("-h", "--help"):
            usage()
            sys.exit()
            pass
        pass
    
    if len(req_args) < 1:
        raise getopt.error('error: too few arguments')

    action = req_args[0].lower()
    if action not in ACTIONS:
        raise getopt.error('error: unknown action - ' + req_args[0] + '\n'
                           'error: action must be one of: '
                           + str(ACTIONS.keys()))

    pass
except getopt.error, e:
    print e.args[0]
    usage()
    sys.exit(2)
    pass

con = MySQLdb.connect(db = DBNAME, user = DBUSER, passwd = DBPASS)

cur = con.cursor()

sys.exit(ACTIONS[action][0](req_args[1:]))
