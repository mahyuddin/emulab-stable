#!/usr/bin/perl -w
#
# EMULAB-COPYRIGHT
# Copyright (c) 2007 University of Utah and the Flux Group.
# All rights reserved.
#
use English;
use Getopt::Std;
use strict;

#
# Load in descriptors for images and osids. The input to this script is
# a file created with the dump-descriptors script in this directory,
#
sub usage()
{
    print STDOUT "Usage: load-descriptors filename\n";
    exit(-1);
}

#
# These are the OSIDs that are used to populate the osidtoimageid table
# using their nextosid entries.
#
my @standard_osnames  = ('RHL-STD', 'FBSD-STD');

#
# Configure variables
#
my $TB		= "@prefix@";
my $TBOPS       = "@TBOPSEMAIL@";
my $TBLOGS      = "@TBLOGSEMAIL@";
my $BOSSNODE	= "@BOSSNODE@";
my $TFTPDIR     = "/tftpboot";

#
# Testbed Support libraries
#
use lib "@prefix@/lib";
use libdb;
use libtestbed;
use User;
use Project;

#$libdb::DBQUERY_DEBUG = 1;

# Local
my %osidtoimageid  = ();
my %local_osids    = ();
my %local_imageids = ();

#
# Turn off line buffering on output
#
$| = 1;

#
# Untaint the path
# 
$ENV{'PATH'} = "/bin:/sbin:/usr/bin:";
delete @ENV{'IFS', 'CDPATH', 'ENV', 'BASH_ENV'};

# Protos
sub fatal($);

usage()
    if (@ARGV != 1);
my $filename = $ARGV[0];

#
# We need to know various indicies, for the protouser (elabman) and the
# TBOPSPID (emulab-ops) project.
#
my $protouser = User->Lookup("elabman");
if (!defined($protouser)) {
    fatal("Could not look up object for protouser (elabman)");
}
my $user_uid = $protouser->uid();
my $user_idx = $protouser->uid_idx();

my $protoproj = Project->Lookup(TBOPSPID());
if (!defined($protoproj)) {
    fatal("Could not look up object for protoproj");
}
my $pid     = $protoproj->pid();
my $pid_idx = $protoproj->pid_idx();
my $gid     = $protoproj->gid();
my $gid_idx = $protoproj->gid_idx();
my $douuids = 0;

# Temp tables to hold new rows.
DBQueryFatal("create table temp_images like images");
DBQueryFatal("create table temp_os_info like os_info");
DBQueryFatal("create table temp_o2i like osidtoimageid");

#
# Open tempfile.
#
open(OUTPUT, "$filename") or
    die("Could not open $filename for reading!\n");

while (<OUTPUT>) {
    DBQueryFatal($_);
}
close(OUTPUT);

#
# See if the local images table has the new indicies. 
#
my $describe_result = DBQueryFatal("describe images");

while (my $rowref = $describe_result->fetchrow_hashref()) {
    my $slot  = $rowref->{"Field"};

    if ($slot eq "pid_idx") {
	DBQueryFatal("update temp_images set pid_idx='$pid_idx'");
    }
    elsif ($slot eq "gid_idx") {
	DBQueryFatal("update temp_images set gid_idx='$gid_idx'");
    }
    elsif ($slot eq "creator_idx") {
	DBQueryFatal("update temp_images set creator_idx='$user_idx'");
    }
    elsif ($slot eq "uuid") {
	$douuids++;
    }
}

#
# Ditto for os_info table
#
$describe_result = DBQueryFatal("describe os_info");

while (my $rowref = $describe_result->fetchrow_hashref()) {
    my $slot  = $rowref->{"Field"};

    if ($slot eq "pid_idx") {
	DBQueryFatal("update temp_os_info set pid_idx='$pid_idx'");
    }
    elsif ($slot eq "creator_idx") {
	DBQueryFatal("update temp_os_info set creator_idx='$user_idx'");
    }
}

#
# Go through the new set of os_info entries and assign local IDs to them.
# Remember them since we need to change the new images table too.
#
my $query_result = DBQueryFatal("select osid from temp_os_info");

while (my ($osid) = $query_result->fetchrow_array()) {
    $local_osids{$osid} = TBGetUniqueIndex("next_osid", 1000);
}

#
# Update temp_os_info with locally derived osids. nextosid as well.
#
foreach my $osid (keys(%local_osids)) {
    my $newosid = $local_osids{$osid};

    DBQueryFatal("update temp_os_info set osid='$newosid' ".
		 "where osid='$osid'");
    DBQueryFatal("update temp_os_info set nextosid='$newosid' ".
		 "where nextosid='$osid'");
    if ($douuids) {
	my $uuid = NewUUID();
	
	DBQueryFatal("update temp_os_info set uuid='$uuid' ".
		     "where nextosid='$osid'");
    }
}

#
# Go through new set of images entries, but watch for ezid images since they
# have the same ID as its corresponding os_info entry.
#
$query_result = DBQueryFatal("select imageid,ezid from temp_images");

while (my ($imageid,$ezid) = $query_result->fetchrow_array()) {
    if ($ezid) {
	$local_imageids{$imageid} = $local_osids{$imageid};
    }
    else {
	$local_imageids{$imageid} = TBGetUniqueIndex("next_osid", 1000);
    }
}

#
# Update temp_images with locally derived imageids.
#
$query_result->dataseek(0);

while (my ($imageid) = $query_result->fetchrow_array()) {
    my $newimageid = $local_imageids{$imageid};

    DBQueryFatal("update temp_images set imageid='$newimageid' ".
		 "where imageid='$imageid'");

    if ($douuids) {
	my $uuid = NewUUID();
	
	DBQueryFatal("update temp_images set uuid='$uuid' ".
		     "where imageid='$imageid'");
    }
}

#
# And then update osids inside temp_images with locally derived imageids.
#
foreach my $osid (keys(%local_osids)) {
    my $newosid = $local_osids{$osid};

    DBQueryFatal("update temp_images set part1_osid='$newosid' ".
		 "where part1_osid='$osid'");
    DBQueryFatal("update temp_images set part2_osid='$newosid' ".
		 "where part2_osid='$osid'");
    DBQueryFatal("update temp_images set part3_osid='$newosid' ".
		 "where part3_osid='$osid'");
    DBQueryFatal("update temp_images set part4_osid='$newosid' ".
		 "where part4_osid='$osid'");
    DBQueryFatal("update temp_images set default_osid='$newosid' ".
		 "where default_osid='$osid'");
}

#
# Use the nextosid slot of the -STD osids to figure out what the default
# images are.
#
$query_result =
    DBQueryFatal("select nextosid from temp_os_info ".
		 "where nextosid is not null and (".
		 join(" or ", map("osname='$_'", @standard_osnames)) . ")");

while (my ($nextosid) = $query_result->fetchrow_array()) {
    my $subquery_result =
	DBQueryFatal("select imageid from temp_images ".
		     "where loadlength=1 and (".
		     join(" or ", map("$_='$nextosid'",
				      ("part1_osid", "part2_osid",
				       "part3_osid", "part4_osid"))) . ")");

    if (!$subquery_result->numrows) {
	print "*** WARNING: No osidtoimageid mapping for $nextosid\n";
	next;
    }
    my ($imageid) = $subquery_result->fetchrow_array();
    
    $osidtoimageid{$nextosid} = $imageid;
}

#
# Make up osidtoimageid entries for all local PCs. This is a shotgun
# approach, but for a new testbed is probably the right thing.
#
$query_result =
    DBQueryFatal("select type from node_types where class='pc'");

while (my ($type) = $query_result->fetchrow_array()) {
    foreach my $osid (keys(%osidtoimageid)) {
	my $imageid = $osidtoimageid{$osid};

	DBQueryFatal("replace into temp_o2i values ".
		     "('$osid', '$type', '$imageid')");
    }
}

#
# Ready to populate the tables. Move the entries from temp_images and
# temp_os_info across to the real tables.
#
DBQueryFatal("replace into images select * from temp_images");
DBQueryFatal("replace into os_info select * from temp_os_info");
DBQueryFatal("replace into osidtoimageid select * from temp_o2i");

exit(0);

sub fatal($)
{
    my ($mesg) = $_[0];

    die("*** $0:\n".
	"    $mesg\n");
}


