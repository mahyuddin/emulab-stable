#!/usr/bin/perl -w
#
# EMULAB-COPYRIGHT
# Copyright (c) 2000-2002 University of Utah and the Flux Group.
# All rights reserved.
#

#
# stated - A daemon to monitor the states of nodes in the testbed. Recives
# state change notification through the event system, and writes the new
# state into the database.
#
# In the future, will watch for invalid state transitions, and watch for nodes
# that time out.
#
# Send it a HUP signal to get it to reload the timeout and transition
# information. Periodically reloads this information regardless, though.
#

#
# Configure variables
#
use lib '@prefix@/lib';
my $BOSSNODE = "@BOSSNODE@";
my $TBOPS = "@TBOPSEMAIL@";
my $TBDBNAME = "@TBDBNAME@";

$| = 1;

use event;
use libdb;
use libtestbed;
use Getopt::Std;
use strict;
use English;

#
# Number of iterations (roughly, seconds) after which we'll reload 
# information from the database. This is so we don't end up with information
# that's _too_ out of sync.
#
my $reload_time = 3600;

#
# Process command-line arguments
#

sub usage {
	print << "END";
Usage: $0 [-d] [-s server] [-p port] [-f] [-h]
-s server       Use specified server, instead of this site's bossnode
-p port	        Use specified port
-d              Turn on debugging output, and don't go into the background
-f              Stay in the foreground, rather than forking
-h              This message
END
}

my %opt = ();
getopts("ds:p:hf",\%opt);

if ($opt{h}) { exit &usage; }
if (@ARGV) { exit &usage; }

my ($server,$port,$debug,$nofork);
if ($opt{s}) { $server = $opt{s}; } else { $server = $BOSSNODE; }
if ($opt{p}) { $port = $opt{p}; }
if ($opt{d}) { $debug = 1; } else { $debug = 0; }
if ($opt{f}) { $nofork = 1; } else { $nofork = 0; }

#
# Background
#
my $logname = "@prefix@/log/stated.log";
if (!$debug && !$nofork) {
	if (TBBackGround($logname)) {
		exit(0);
	}
} else {
    if ($nofork) {
	#
	# Open our log file manually
	#
	open(STDERR, ">> $logname") or die("opening $logname for STDERR: $!");
	open(STDOUT, ">> $logname") or die("opening $logname for STDOUT: $!");
    }
}

my $URL = "elvin://$server";
if ($port) { $URL .= ":$port"; }

#
# Connect to the event system, and subscribe the the events we want 
#
my $handle = event_register($URL,0);
if (!$handle) { die "Unable to register with event system\n"; }

my $tuple = address_tuple_alloc();
if (!$tuple) { die "Could not allocate an address tuple\n"; }

#
# Unfortunately, we can't subscribe to multiple objtypes - so, we subscribe
# to all events to $BOSSNODE, and throw away notificattions whose objtypes
# do not match the ones we care about.
#
%$tuple = ( host => $BOSSNODE );

if (!event_subscribe($handle,\&handleEvent,$tuple)) {
	die "Could not subscribe to events\n";
}

#
# Read in the pre-existing node states, and timeout and valid transition
# information from the database
#
my %nodes    = readStates();
my %timeouts = getTimeouts();
my %valid    = getValid();

#
# Gets set if a reload of state from the database should happen.
#
my $do_reload = 0;

#
# Make the daemon reload database state on a sighup - but I'm worried
# about what would happen if we tried to do this mid-loop. So, we'll
# just set a flag and do it when we're done with our current pass.
#
$SIG{HUP} = sub { print "Recieved a SIGHUP\n"; $do_reload = 1; };

print "stated starting up\n";

#
# Now, we just poll for events, and watch for 
#
my $iterations = 0;
while (1) {
	event_poll($handle);
	my $now = time();
	#
	# Look for nodes that have passed their timeout
	#
	while (my ($node, $value) = each %nodes) {
		my $state    = $value->{state};
		my $mode     = $value->{mode};
		my $time     = $value->{timestamp};
		my $notified = $value->{notified};
		my ($timeout,$action);
		if ($mode && $state && $timeouts{$mode} &&
				$timeouts{$mode}{$state}) {
			($timeout, $action) = @{$timeouts{$mode}{$state}};
		}
		if ((!$notified) && $time && $timeout &&
				(($time + $timeout) < $now)) {
			   #
			   # TODO: Need to actually do something!
			   #
			   notify("Node $node has timed out in state $state" .
			   	  ", mode $mode\n");
			   $value->{notified} = 1;
		}
	}

	if ($do_reload || ($iterations > $reload_time)) {
		reload();
		$do_reload = 0;
		$iterations = 0;
	}

	$iterations++;
	sleep(1);
}

#
# Read the current states of nodes from the database
#
sub readStates(;@) {
    	my %oldnodes = @_;

	#
	# Guard against undefined variable warnings
	#
	if (! defined(%oldnodes)) {
		%oldnodes = ();
	}

	debug("readStates called\n");
	my $result = DBQueryFatal("SELECT node_id, eventstate, " .
				  "state_timestamp, op_mode, " .
				  "op_mode_timestamp FROM nodes");

	my %nodes;
	while (my ($node_id, $state, $timestamp, $mode, $mode_timestamp)
			= $result->fetchrow()) {
	    	#
		# If there's an entry in oldnodes for this node, and it
		# hasn't changed state or time, use the old entry (so that
		# we don't lose information about which nodes we've already
		# notified the ops about, etc.)
		#
		if ($oldnodes{$node_id} && $state && $timestamp &&
		   ($oldnodes{$node_id}{state} eq $state) &&
		   ($oldnodes{$node_id}{timestamp} == $timestamp)) {
		       $nodes{$node_id} = $oldnodes{$node_id};
		} else { 
		    $nodes{$node_id}{state}          = $state;
		    $nodes{$node_id}{timestamp}      = $timestamp;
		    $nodes{$node_id}{mode}           = $mode;
		    $nodes{$node_id}{mode_timestamp} = $mode_timestamp;
		}
	}
	return %nodes;
}

#
# Read timeouts for various states from the database
#
sub getTimeouts() {
	debug("getTimeouts called\n");
	my $result = DBQueryFatal("SELECT op_mode, state, timeout, action " .
				  "FROM state_timeouts");

	my %timeouts;
	while (my ($op_mode, $state, $timeout, $action) = $result->fetchrow()) {
		$timeouts{$op_mode}{$state} = [ $timeout, $action ];
	}
	return %timeouts;
}

#
# Read the list of valid state transitions from the database
#
sub getValid() {
	debug("getValid called\n");
	my $result = DBQueryFatal("SELECT op_mode, state1, state2 " .
				  "FROM state_transitions");

	my %valid;
	while (my ($mode,$state1, $state2) = $result->fetchrow()) {
		$valid{$mode}{$state1}{$state2} = 1;
	}
	return %valid;
}

#
# Gets called for every event that we recieve
#
sub handleEvent($$$) {
	my ($handle,$notification,$data) = @_;
	my $objtype = event_notification_get_objtype($handle,$notification);
	my $objname = event_notification_get_objname($handle,$notification);
	my $eventtype = event_notification_get_eventtype($handle,$notification);

	print "Got an event: ($objtype,$objname,$eventtype)\n";

	#
	# Check to see if another instance is supposed to be handling this node
	#
	if (!checkDBRedirect($objname)) {
	    print "Got an event for node $objname, which isn't mine\n";
	    return;
	}

	SWITCH: for ($objtype) {

	    #
	    # Handle both the new TBNODEOPMODE and the old TBCONTROL events, 
	    # for backward compatibility.
	    #
	    (/TBNODESTATE/ || /TBCONTROL/) && do {
		stateTransition($objname,$eventtype);
		last;
	    };
	    (/TBNODEOPMODE/) && do {
		opModeTransition($objname,$eventtype);
		last;
	    };

	}

}

sub stateTransition($$) {

	my ($node,$newstate) = @_;

	# Check for invalid transitions
	my ($oldstate, $mode);
	if ($nodes{$node}) {
		$oldstate = $nodes{$node}{state};
		$mode = $nodes{$node}{mode};
	} else {
		#
		# Try reloading the cache once before we give up on this node
		#
		reload();
		if ($nodes{$node}) {
				$oldstate = $nodes{$node}{state};
				$mode = $nodes{$node}{mode};
		} else {
			notify("Got an event for a node ($node) I don't know ".
					"about\n");
		}
	}
	if ($oldstate && $mode && $valid{$mode} && $valid{$mode}{$oldstate} &&
			!$valid{$mode}{$oldstate}{$newstate}) {
		notify("Invalid transition for node $node from $oldstate " .
		       " to $newstate\n");
	}

	my $now = time();
	$nodes{$node}{state}     = $newstate;
	$nodes{$node}{timestamp} = $now;
	$nodes{$node}{notified}  = 0;

	DBQueryFatal("UPDATE nodes SET eventstate='$newstate', " .
		     "state_timestamp='$now' WHERE node_id='$node'");

}

sub opModeTransition($$) {

	my ($node,$newmode) = @_;

	print "opModeTransition: $node, $newmode\n";

	my $now = time();
	$nodes{$node}{mode}           = $newmode;
	$nodes{$node}{mode_timestamp} = $now;
	$nodes{$node}{notified}       = 0;

	DBQueryFatal("UPDATE nodes SET op_mode='$newmode', " .
		     "op_mode_timestamp='$now' WHERE node_id='$node'");

}

#
# Figure out if this node belongs to us (ie. if it's using our database.)
# Returns 1 if it does, 0 if not
#
sub checkDBRedirect($) {

	my ($node) = @_;

	#
	# XXX: I don't want to do this every time, for performance reaons,
	# but we need to make sure that we don't get into an inconsistent 
	# state
	#
	my $result = DBQueryFatal("SELECT testdb FROM nodes as n " .
		"LEFT JOIN reserved as r ON n.node_id = r.node_id " .
		"LEFT JOIN experiments as e ON r.pid = e.pid " .
			"AND r.eid = e.eid " .
		"WHERE n.node_id = '$node'");

	if (!$result->num_rows()) {
		notify("Got an event for a node ($node) I don't know about\n");
		return 0;
	}

	my ($testdb) = $result->fetchrow();

	#
	# XXX: It's hokey to hardcode tbdb here, but....
	#
	if ((!$testdb && ($TBDBNAME eq "tbdb")) ||
	    ($testdb && ($testdb eq $TBDBNAME))) {
		return 1;
	} else {
		return 0;
	}
}

#
# Reload state from the database
#
sub reload() {
    	print "Reloading state from database\n";
	%nodes    = readStates(%nodes);
	%timeouts = getTimeouts();
	%valid     = getValid();
}

sub debug(@) {
	if ($debug) { print @_; }
}

sub notify($) {
    	my $message = shift;
	if (!$debug) {
	    	SENDMAIL($TBOPS,"Node State Daemon Messsage",$message,$TBOPS);
	}
	print $message;
}

#
# This gets called if we die of 'natural causes' (exit, die, etc.)
#
END {
    	if ($handle) {
		print "Exiting, cleaning up\n";
		if (event_unregister($handle) == 0) {
			die "Unable to unregister with event system\n";
		}
	}

}
