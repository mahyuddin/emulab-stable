OVERVIEW
********

The testbed event system is composed of four parts: (1) the event
library, which implements a simple, transport-independent API that
clients may use to trigger and respond to events; (2) the event
scheduler, an event system client that triggers events at specified
future times; (3) frontends that take events specified by the user as
input and pass them to the event scheduler; and (4) backends that
respond to various system events on behalf of the testbed.  Each
of these four parts are described in more detail in the following
sections.

Event library
=============

Clients in the system trigger and respond to events using the event
library.  The event library is currently implemented as a layer above
the Elvin publish/subscribe system (see "ELVIN OVERVIEW" below for a
brief overview of how Elvin works).  A library and API separate from
Elvin exists for several reasons:

    - The event library provides a much simpler interface than Elvin,
      providing only the functionality that should be needed in
      the testbed.  This should make it significantly easier to write
      clients that use the event system.

    - The event library API is independent of Elvin, so if we change
      to a system other than Elvin in the future (or write our own),
      only the event library will need to be ported.  In particular,
      no event system clients should need to be changed.

    - The event library API is significantly simpler than the Elvin
      API, so it should be much easier to implement in environments
      such as the Linux kernel, the OSKit, or Scout.

The event library is currently available as a C library on Unix.
The C API is described in the API file.

Event representation
--------------------

Events are represented by Elvin notifications that contain two system
defined fields: (1) "host", which specifies the hostname of the
testbed node that should receive the event notification, or "*" if the
event notification should be sent to all nodes; and (2) "type", which
specifies the event type.  In addition to the system defined fields,
event notifications may contain additional attributes (in
the form of name/value pairs) that may be used to provide additional
information about the event that has occurred.

Event scheduler
===============

The event scheduler is an event system client responsible for
triggering future events.  To schedule an event for firing at a
future time, event system clients may call the event library API
function event_schedule.  event_schedule accepts a notification
and a firing time, alters the notification to change the type
attribute to EVENT_SCHEDULE and add a firing time attribute, and
then sends the altered notification using event_notify.  The event
scheduler subscribes to EVENT_SCHEDULE notifications.  As they
arrive, it restores the type in the notification to that of the
original event and enqueues the notification in a priority queue
for firing at the indicated time.  When the time arrives, the
scheduler removes the notification from the queue and resends it
using event_notify.

Frontend support
================

[ Note that the event system currently has no frontend support. Such
  support needs to be added for each system event type that needs to
  be supported, e.g. traffic generation control. ]

The frontend for static events is the NS script. Frontend support
for static events consists of a set of modifications to the NS
parser that extracts events from the NS script and passes them to
the event scheduler. For example, the NS command

    $ns at 0.5 "$cbr0 start"

might cause a event with type=TRAFGEN_START and host=<hostname of the
node $cbr0 is attached to> to be scheduled by the event scheduler for
execution in 0.5 seconds.

The frontend for dynamic events could be a GUI that either triggers
events directly (using the event library) or schedules events to be
triggered in the future (using the event scheduler).

Backend support
===============

[ As with frontend support, the event system currently has no backend
  support. Such support needs to be added for each system event
  type that needs to be supported, e.g. traffic generation control. ]

The backends are event system clients responsible for responding to
certain events on behalf of the testbed.  For example, traffic
generation nodes might be event system backends that start generating
traffic when they receive the TRAFGEN_START event notification
and stop generating traffic when they receive the TRAFGEN_STOP
event notification.

ELVIN OVERVIEW
**************

The testbed event system currently uses the Elvin publish/subscribe
system for communicating between event producers and event consumers.
Elvin uses a client/server architecture for delivering notifications.
The server accepts subscriptions from clients and routes notifications
from producers to the consumers that wish to receive them.
Notifications are arbitrary-length lists of name/value pairs (e.g.,
"type: NODE_FAILED, time: 23"), and subscriptions are expressed using
a simple syntax (e.g., "type == NODE_FAILED && time > 20").  Clients
can be both producers and consumers in the same session.  Clients may
be written in C, C++, Java, Python, and Emacs Lisp.  For more
information about how Elvin works, please see http://elvin.dstc.com/.

Elvin supports wide-area federations of Elvin servers; we can use this
feature to enable a global event namespace across multiple testbeds in
different geographic locations when the time comes.
