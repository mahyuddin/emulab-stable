#
# CODE PAST THIS POINT WAS NOT AUTOMATICALLY GENERATED BY SWIG
#
# For now, this has to get cat'ed onto the end of event.pm, since it
# doesn't seem possible to get SWIG to just pass it through into the
# output file
#

#
# Stash away the given callback and data, and call the C event_subscribe
# function that uses a stub callback
#
sub event_subscribe($$$;$) {
	my ($handle,$function,$tuple,$data) = @_;
	$event::callback = $function;
	$event::callback_data = $data;
	return stub_event_subscribe($handle,$tuple);
}

#
# Clear $callback_ready, call the C event_poll function, and see if the
# C callback got called (as evidenced by $callback_ready getting set) If it
# did, call the perl callback function.
#
sub event_poll($) {
	my $handle = shift;

	my $rv = c_event_poll($handle);
	if ($rv) {
		die "Trouble in event_poll - returned $rv\h";
	}

	while (my $data = dequeue_callback_data() ) {
		&$event::callback($handle,$data->{callback_notification},
				$event::callback_data);
		event_notification_free($handle,$data->{callback_notification});
		free_callback_data($data);
	}

	return 0;
}

#
# NOTE: The following line will only work if this module is included by
# a file that has already done a 'use lib' to get the path to testbed
# libraries in the INC path. But, since they had to do that to get this
# library anyway, shouldn't be a problem. (Didn't want to have to make
# this a .in file.)
#
use libtestbed;

#
# Conveniece functions - Intended to work like DBQuery* from libdb .
# Much of this code shamlessly ripped off from libdb.pm
#

#
# Warn and send email after a failed event send. First argument is the error
# message to display. The contents of $EventErrorString is also printed.
# 
# usage: EventWarn(char *message)
#
sub EventWarn($) {
	my($message) = $_[0];
	my($text, $progname);

	#
	# Must taint check $PROGRAM_NAME cause it comes from outside. Silly!
	#
	if ($PROGRAM_NAME =~ /^([-\w.\/]+)$/) {
		$progname = $1;
	} else {
		$progname = "Tainted";
	}

	$text = "$message - In $progname\n" .
		"$EventErrorString\n";

	print STDERR "*** $text";

	libtestbed::SENDMAIL($TBOPS, "EventError - $message", $text);
}

#
# Same as above, but die after the warning.
# 
# usage: EventFatal(char *message);
#
sub EventFatal($) {
	my($message) = $_[0];

	EventWarn($message);

	die("\n");
}


#
# Conveniece function - Intended to work like DBQueryFatal from libdb
#
sub EventSendFatal(@) {
	my @tuple = @_;
    
	my $result = EventSend(@tuple);

	if (!$result) {
		EventFatal("Event Send failed");
	}

	return $result;
}

#
# Conveniece function - Intended to work like DBQueryWarn from libdb
#
sub EventSendWarn(@) {
	my @tuple = @_;
    
	my $result = EventSend(@tuple);

	if (!$result) {
		EventFatal("Event Send failed");
	}

	return $result;
}

sub EventSend(@) {
	my %tuple_values = @_;

	my $URL = "elvin://" . TB_BOSSNODE;

	my $handle = event_register($URL,0);
	if (!$handle) {
		$EventErrorString = "Unable to register with the event system";
		return undef;
	}

	my $tuple = address_tuple_alloc();
	if (!$tuple) {
		$EventErrorString = "Unable to allocate an address tuple";
		return undef;
	}

	#
	# Set the values the user requested
	#
	%$tuple = %tuple_values;

	my $notification = event_notification_alloc($handle,$tuple);
	if (!$notification) {
		$EventErrorString = "Could not allocate notification";
		return undef;
	}

	if (!event_notify($handle, $notification)) {
		$EventErrorString = "Could not send event notification";
		return undef;
	}

	event_notification_free($handle, $notification);
	address_tuple_free($tuple);

	if (event_unregister($handle) == 0) {
		$EventErrorString = "Could not unregister with event system";
		return undef;
	}

	return 1;
}


push @EXPORT, qw(event_subscribe event_poll EventSend EventSendFatal
	EventSendWarn);
1;

