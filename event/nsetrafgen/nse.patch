Index: ns-2/install
diff -u ns-2/install:1.2 ns-2/install:1.3
--- ns-2/install:1.2	Tue Mar 12 01:05:34 2002
+++ ns-2/install	Thu Mar 21 11:51:21 2002
@@ -16,7 +16,7 @@
 # WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
 # MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
 #
-# $Header: /foo/x/flux/CVS/ns-2/install,v 1.2 2002/03/12 08:05:34 shash Exp $
+# $Header: /foo/x/flux/CVS/ns-2/install,v 1.3 2002/03/21 18:51:21 shash Exp $
 
 die() {
 	echo "$@"  1>&2
@@ -53,7 +53,7 @@
 
 blame='Tcl is not part of the ns project.  Please see www.Scriptics.com
 to see if they have a fix for your platform.'
-./configure --enable-gcc --disable-shared --prefix=$CUR_PATH || die "tcl8.3.2 configuration failed! Exiting ..."
+./configure --enable-gcc --disable-shared --disable-load --prefix=$CUR_PATH || die "tcl8.3.2 configuration failed! Exiting ..."
 if make 
 then 
 	echo "tcl$TCLVER make succeeded."
Index: ns-2/ns-2.1b8a/scheduler.cc
diff -u ns-2/ns-2.1b8a/scheduler.cc:1.2 ns-2/ns-2.1b8a/scheduler.cc:1.3
--- ns-2/ns-2.1b8a/scheduler.cc:1.2	Tue Mar 12 01:03:06 2002
+++ ns-2/ns-2.1b8a/scheduler.cc	Thu Mar 14 16:46:45 2002
@@ -304,11 +304,7 @@
 		return;
 	for (p = &queue_; *p != e; p = &(*p)->next_)
 		if (*p == 0) {
-			fprintf( stderr, 
-                                 "Scheduler Cancel fails. Should have aborted\n"); // XXX: hack -> abort();
-                        e->uid_ = - e->uid_;
-                        return;
-                        //abort();
+                      abort();
                 }
 
 	*p = (*p)->next_;
Index: ns-2/ns-2.1b8a/tcp-full.cc
diff -u ns-2/ns-2.1b8a/tcp-full.cc:1.3 ns-2/ns-2.1b8a/tcp-full.cc:1.4
--- ns-2/ns-2.1b8a/tcp-full.cc:1.3	Wed Mar 20 17:30:12 2002
+++ ns-2/ns-2.1b8a/tcp-full.cc	Tue Apr  9 14:49:20 2002
@@ -89,6 +89,7 @@
 #include "flags.h"
 #include "random.h"
 #include "template.h"
+#include <stdlib.h>
 
 #define	TRUE 	1
 #define	FALSE 	0
@@ -96,6 +97,20 @@
 #define	MIN(x,y)	(((x)<(y))?(x):(y))
 #define	MAX(x,y)	(((x)>(y))?(x):(y))
 
+#define SEQ_LT(a,b)  (((a)<(b) && (b)-(a) < TCP_MAXSEQ/2) || ((a)>(b) && (a)-(b) >= TCP_MAXSEQ/2))
+#define SEQ_LE(a,b)  (((a)<=(b) && (b)-(a) < TCP_MAXSEQ/2) || ((a)>(b) && (a)-(b) >= TCP_MAXSEQ/2))
+#define SEQ_GT(a,b)  (((a)>(b) && (a)-(b) < TCP_MAXSEQ/2) || ((a)<(b) && (b)-(a) >= TCP_MAXSEQ/2))
+#define SEQ_GE(a,b)  (((a)>=(b) && (a)-(b) < TCP_MAXSEQ/2) || ((a)<(b) && (b)-(a) >= TCP_MAXSEQ/2))
+#define INCR_SEQ(num, val) (num) = ((num) + (val)) % TCP_MAXSEQ
+#define SEQ_ADD(num, val) (((num) + (val)) % TCP_MAXSEQ)
+inline int SEQ_SUB(int num, int val) {
+  int ret = num - val;
+  return( abs(ret) < TCP_MAXSEQ/2 ? ret : ((int)(((long long)(num) - (val) + TCP_MAXSEQ) % TCP_MAXSEQ)) );
+}
+#define DECR_SEQ(num, val) (num) = SEQ_SUB((num), (val))
+#define SEQ_MIN(x,y) (SEQ_LT((x),(y))?(x):(y))
+#define SEQ_MAX(x,y) (SEQ_GT((x),(y))?(x):(y))
+
 static class FullTcpClass : public TclClass { 
 public:
 	FullTcpClass() : TclClass("Agent/TCP/FullTcp") {}
@@ -229,8 +244,8 @@
 FullTcpAgent::pack(Packet *pkt)
 {
 	hdr_tcp *tcph = hdr_tcp::access(pkt);
-	return (tcph->ackno() >= highest_ack_ &&
-		tcph->ackno() < recover_);
+	return (SEQ_GE(tcph->ackno(), highest_ack_) &&
+		SEQ_LT(tcph->ackno(), recover_) );
 }
 
 /*
@@ -335,13 +350,13 @@
   	    return;
 	} else if (state_ == TCPS_CLOSED) {
 		reset();
-		curseq_ = iss_ + nb;
+		INCR_SEQ( curseq_, SEQ_ADD(iss_, nb));
 		connect();		// initiate new connection
 	} else if (state_ == TCPS_ESTABLISHED) {
 		closed_ = 0;
-		if (curseq_ < iss_)
+		if ( SEQ_LT(curseq_, iss_) )
 			curseq_ = iss_;
-		curseq_ += nb;
+		INCR_SEQ(curseq_, nb);
 		send_much(0, REASON_NORMAL, maxburst_);
 	}
 	return;
@@ -390,7 +405,7 @@
 
 int FullTcpAgent::rcvseqinit(int seq, int dlen)
 {
-	return (seq + dlen + 1);
+	return (SEQ_ADD(seq, dlen + 1));
 }
 
 int
@@ -468,6 +483,7 @@
 
 	last_ack_sent_ = ackno;
 	send(p, 0);
+	
 }
 
 void FullTcpAgent::cancel_timers()
@@ -498,23 +514,23 @@
 	   	maxseg_ = size_ - headersize();
 	else
 		size_ =  maxseg_ + headersize();
-	int is_retransmit = (seqno < maxseq_);
+	int is_retransmit = SEQ_LT(seqno, maxseq_) ;
 	int quiet = (highest_ack_ == maxseq_);
 	int pflags = outflags();
 	int syn = (seqno == iss_);
 	int emptying_buffer = FALSE;
 	int buffered_bytes = (infinite_send_) ? TCP_MAXSEQ :
-				curseq_ - highest_ack_ + 1;
+				SEQ_ADD( SEQ_SUB(curseq_, highest_ack_), 1);
 
 	int win = window() * maxseg_;	// window (in bytes)
-	int off = seqno - highest_ack_;	// offset of seg in window
+	int off = SEQ_SUB(seqno, highest_ack_);	// offset of seg in window
 	int datalen;
 
 	// be careful if we have not received any ACK yet
 	if (highest_ack_ < 0) {
 		if (!infinite_send_)
-			buffered_bytes = curseq_ - iss_;;
-		off = seqno - iss_;
+		  	buffered_bytes = SEQ_SUB(curseq_, iss_);
+		off = SEQ_SUB(seqno, iss_);
 	}
 
 	if (syn && !data_on_syn_)
@@ -535,7 +551,6 @@
 		datalen = maxseg_;
 	}
 
-
 	//
 	// this is an option that causes us to slow-start if we've
 	// been idle for a "long" time, where long means a rto or longer
@@ -552,8 +567,8 @@
 	// see if sending this packet will empty the send buffer
 	// a dataless SYN packet counts also
 	//
-	if (!infinite_send_ && ((seqno + datalen) > curseq_ || 
-	    (syn && datalen == 0))) {
+	if (!infinite_send_ && SEQ_GT(SEQ_ADD(seqno, datalen), curseq_) || 
+	    (syn && datalen == 0)) {
 		emptying_buffer = TRUE;
 		//
 		// if not a retransmission, notify application that 
@@ -638,7 +653,7 @@
 	 * around until we actually send a segment
 	 */
 
-	int reliable = datalen + syn + fin; // seq #'s reliably sent
+	int reliable = SEQ_ADD(datalen, syn + fin); // seq #'s reliably sent
 	if (cong_action_ && reliable > 0)
 		cong_action_ = FALSE;
 
@@ -648,15 +663,15 @@
 	 */
 
 	if (!fin && seqno == t_seqno_) {
-		t_seqno_ += reliable;
+	        INCR_SEQ(t_seqno_, reliable);
 	}
 
 
 	// highest: greatest sequence number sent + 1
 	//	and adjusted for SYNs and FINs which use up one number
 
-	int highest = seqno + reliable;
-	if (highest > maxseq_) {
+	int highest = SEQ_ADD(seqno, reliable);
+	if (SEQ_GT(highest, maxseq_)) {
 		maxseq_ = highest;
 		//
 		// if we are using conventional RTT estimation,
@@ -708,8 +723,9 @@
 	int win = window() * maxseg_;	// window() in pkts
 	int npackets = 0;
 	int topwin = curseq_; // 1 seq number past the last byte we can send
-	if ((topwin > highest_ack_ + win) || infinite_send_)
-		topwin = highest_ack_ + win;
+	int hiack_plus_win = SEQ_ADD(highest_ack_, win);
+        if (SEQ_GT(topwin, hiack_plus_win) || infinite_send_)
+		INCR_SEQ( topwin, hiack_plus_win);
 
 	if (!force && (delsnd_timer_.status() == TIMER_PENDING))
 		return;
@@ -720,7 +736,7 @@
 	 */
 
 	while (force ||
-	      (pipectrl_ ? (pipe_ < window()) : (t_seqno_ < topwin))) {
+	      (pipectrl_ ? (pipe_ < window()) : SEQ_LT(t_seqno_, topwin) )) {
 
 		if (!force && overhead_ != 0 &&
 		    (delsnd_timer_.status() != TIMER_PENDING)) {
@@ -782,7 +798,7 @@
 	hdr_tcp *tcph = hdr_tcp::access(pkt);
 
 	register int ackno = tcph->ackno();
-	int progress = (ackno > highest_ack_);
+	int progress = SEQ_GT(ackno, highest_ack_);
 
 //if (state_ > TCPS_ESTABLISHED)
 //printf("%f %s: newack: %d, state %d, maxseq:%d\n", now(), name(),
@@ -806,7 +822,7 @@
 	// update t_seqno_ here, otherwise we would be doing
 	// go-back-n.
 
-	if (t_seqno_ < highest_ack_)
+	if (SEQ_LT(t_seqno_, highest_ack_))
 		t_seqno_ = highest_ack_; // seq# to send next
 
         /*
@@ -821,7 +837,7 @@
 			recent_age_ = now();
 			recent_ = tcph->ts();
                         rtt_update(now() - tcph->ts_echo());
-		} else if (rtt_active_ && ackno > rtt_seq_) {
+		} else if (rtt_active_ && SEQ_GT(ackno, rtt_seq_)) {
 			// got an RTT sample, record it
                         t_backoff_ = 1;
                         rtt_active_ = FALSE;
@@ -905,7 +921,7 @@
 {
 	if (flags_ & TF_ACKNOW)
 		return TRUE;
-	return ((rcv_nxt_ - last_ack_sent_) >= (segs_per_ack_ * maxseg_));
+	return (SEQ_SUB(rcv_nxt_, last_ack_sent_) >= (segs_per_ack_ * maxseg_));
 }
 
 /*
@@ -1011,7 +1027,7 @@
 		 * See RFC1323 (now RFC1323 bis)
                  */
                 if (ts_option_ && !fh->no_ts_ &&
-		    tcph->seqno() <= last_ack_sent_) {
+		    SEQ_LE(tcph->seqno(), last_ack_sent_)) {
 			/*
 			 * this is the case where the ts value is newer than
 			 * the last one we've seen, and the seq # is the one
@@ -1040,11 +1056,11 @@
 			// If we are in fast
 			// recovery, go below so we can remember to deflate
 			// the window if we need to
-			if (ackno > highest_ack_ && ackno < maxseq_ &&
+			if (SEQ_GT(ackno, highest_ack_) && SEQ_LT(ackno, maxseq_) &&
 			    cwnd_ >= wnd_ && !fastrecov_) {
 				newack(pkt);	// update timers,  highest_ack_
 				/* no adjustment of cwnd here */
-				if (curseq_ >= highest_ack_ || infinite_send_)
+				if (SEQ_GE(curseq_, highest_ack_) || infinite_send_)
 					send_much(0, REASON_NORMAL, maxburst_);
 				Packet::free(pkt);
 				return;
@@ -1060,7 +1076,7 @@
 			//	this routine scans all tcpcb's looking for
 			//	DELACK segments and when it finds them
 			//	changes DELACK to ACKNOW and calls tcp_output()
-			rcv_nxt_ += datalen;
+			INCR_SEQ(rcv_nxt_, datalen);
 			flags_ |= TF_DELACK;
 			recvBytes(datalen); // notify application of "delivery"
 			//
@@ -1130,7 +1146,7 @@
 
 		/* drop if it's a SYN+ACK and the ack field is bad */
 		if ((tiflags & TH_ACK) &&
-			((ackno <= iss_) || (ackno > maxseq_))) {
+			(SEQ_LE(ackno, iss_) || SEQ_GT(ackno, maxseq_) )) {
 			// not an ACK for our SYN, discard
 			fprintf(stderr,
 			    "%f: FullTcpAgent::recv(%s): bad ACK (%d) for our SYN(%d)\n",
@@ -1224,14 +1240,14 @@
 			 * SYN+ACK, so t_seqno_ will have been
 			 * advanced to 2... reduce this
 			 */
-			t_seqno_--;	// CHECKME
+			DECR_SEQ(t_seqno_, 1);	// CHECKME
 		}
 
 trimthenstep6:
 		/*
 		 * advance the seq# to correspond to first data byte
 		 */
-		tcph->seqno()++;
+		INCR_SEQ(tcph->seqno(), 1);
 
 		if (tiflags & TH_ACK)
 			goto process_ACK;
@@ -1295,12 +1311,12 @@
 	//	to have seq #s below rcv_nxt can trigger an ACK war by
 	//	forcing us to ACK the pure ACKs
 	//
-	todrop = rcv_nxt_ - tcph->seqno();  // how much overlap?
+	todrop = SEQ_SUB(rcv_nxt_, tcph->seqno());  // how much overlap?
 
 	if (todrop > 0 && ((tiflags & (TH_SYN|TH_FIN)) || datalen > 0)) {
 		if (tiflags & TH_SYN) {
 			tiflags &= ~TH_SYN;
-			tcph->seqno()++;
+			INCR_SEQ(tcph->seqno(), 1);
 			th->size()--;	// XXX Must decrease packet size too!!
 			todrop--;
 		}
@@ -1329,7 +1345,7 @@
 			todrop = datalen;
 			dupseg = TRUE;
 		}
-		tcph->seqno() += todrop;
+		INCR_SEQ(tcph->seqno(), todrop);
 		th->size() -= todrop;	// XXX Must decrease size too!!
 		datalen -= todrop;
 	}
@@ -1339,7 +1355,7 @@
 	 * record the timestamp.
 	 * See RFC1323 (now RFC1323 bis)
 	 */
-	if (ts_option_ && !fh->no_ts_ && tcph->seqno() <= last_ack_sent_) {
+	if (ts_option_ && !fh->no_ts_ && SEQ_LE(tcph->seqno(), last_ack_sent_) ) {
 		/*
 		 * this is the case where the ts value is newer than
 		 * the last one we've seen, and the seq # is the one we expect
@@ -1369,7 +1385,7 @@
 
 	switch (state_) {
 	case TCPS_SYN_RECEIVED:	/* want ACK for our SYN+ACK */
-		if (ackno < highest_ack_ || ackno > maxseq_) {
+		if (SEQ_LT(ackno, highest_ack_) || SEQ_GT(ackno, maxseq_) ) {
 			// not in useful range
 			goto dropwithreset;
 		}
@@ -1429,7 +1445,7 @@
 		// look for dup ACKs (dup ack numbers, no data)
 		//
 		// do fast retransmit/recovery if at/past thresh
-		if (ackno <= highest_ack_) {
+		if (SEQ_LE(ackno, highest_ack_)) {
 			// an ACK which doesn't advance highest_ack_
 			if (datalen == 0 && (!dupseg_fix_ || !dupseg)) {
 				--pipe_; // ACK indicates pkt cached @ receiver
@@ -1462,7 +1478,7 @@
 					fastrecov_ = TRUE;
 
 					/* re-sync the pipe_ estimate */
-					pipe_ = maxseq_ - highest_ack_;
+					pipe_ = SEQ_SUB(maxseq_, highest_ack_);
 					pipe_ /= maxseg_;
 					pipe_ -= (dupacks_ + 1);
 
@@ -1502,7 +1518,7 @@
 
 process_ACK:
 
-		if (ackno > maxseq_) {
+		if (SEQ_GT(ackno, maxseq_)) {
 			// ack more than we sent(!?)
 			fprintf(stderr,
 			    "%f: FullTcpAgent::recv(%s) too-big ACK (ack: %d, maxseq:%d)\n",
@@ -1553,7 +1569,7 @@
 		 * If no data (only SYN) was ACK'd,
 		 *    skip rest of ACK processing.
 		 */
-		if (ackno == (highest_ack_ + 1))
+		if (ackno == SEQ_ADD(highest_ack_, 1) )
 			goto step6;
 
 		// if we are delaying initial cwnd growth (probably due to
@@ -1660,7 +1676,7 @@
 			// accept the data here as-is (i.e. don't
 			// require being in ESTABLISHED state)
 			flags_ |= TF_DELACK;
-			rcv_nxt_ += datalen;
+			INCR_SEQ(rcv_nxt_, datalen);
 			if (datalen)
 				recvBytes(datalen); // notify app. of "delivery"
 			tiflags = tcph->flags() & TH_FIN;
@@ -1676,8 +1692,8 @@
 			// K: some changes here, figure out
 			int rcv_nxt_old_ = rcv_nxt_; // notify app. if changes
 			tiflags = rq_.add(pkt);
-			if (rcv_nxt_ > rcv_nxt_old_)
-				recvBytes(rcv_nxt_ - rcv_nxt_old_);
+			if (SEQ_GT(rcv_nxt_, rcv_nxt_old_))
+				recvBytes(SEQ_SUB(rcv_nxt_, rcv_nxt_old_));
 			if (tiflags & TH_PUSH) {
 				// K: APPLICATION recv
 				needoutput = need_send();
@@ -1703,7 +1719,7 @@
 	if (tiflags & TH_FIN) {
 		if (TCPS_HAVERCVDFIN(state_) == 0) {
 			flags_ |= TF_ACKNOW;
-			rcv_nxt_++;
+			INCR_SEQ(rcv_nxt_,1);
 		}
 		switch (state_) {
                 /*
@@ -1740,7 +1756,7 @@
 
 	if (needoutput || (flags_ & TF_ACKNOW))
 		send_much(1, REASON_NORMAL, maxburst_);
-	else if (curseq_ >= highest_ack_ || infinite_send_)
+	else if (SEQ_GE(curseq_, highest_ack_) || infinite_send_)
 		send_much(0, REASON_NORMAL, maxburst_);
 	// K: which state to return to when nothing left?
 
@@ -1767,9 +1783,9 @@
 	if (tiflags & TH_ACK) {
 		sendpacket(ackno, 0, 0x0, 0, REASON_NORMAL);
 	} else {
-		int ack = tcph->seqno() + datalen;
+		int ack = SEQ_ADD(tcph->seqno(), datalen);
 		if (tiflags & TH_SYN)
-			ack--;
+			DECR_SEQ(ack, 1);
 		sendpacket(0, ack, TH_ACK, 0, REASON_NORMAL);
 	}
 drop:
@@ -1796,7 +1812,7 @@
 void
 FullTcpAgent::dupack_action()
 {   
-        int recovered = (highest_ack_ > recover_);
+        int recovered = SEQ_GT(highest_ack_, recover_);
 	//int recovered = !fastrecov_;
         if (recovered || (!bug_fix_ && !ecn_) ||
 	    last_cwnd_action_ == CWND_ACTION_DUPACK) {
@@ -1890,8 +1906,7 @@
 
 void FullTcpAgent::usrclosed()
 {
-//curseq_ = t_seqno_ - 1;	// truncate buffer
-	curseq_ = maxseq_ - 1;
+	curseq_ = SEQ_SUB(maxseq_, 1);  // truncate buffer
 	infinite_send_ = 0;
 	switch (state_) {
 	case TCPS_CLOSED:
@@ -2250,7 +2265,7 @@
 	hdr_cmn *th = hdr_cmn::access(pkt);
 
 	int start = tcph->seqno();
-	int end = start + th->size() - tcph->hlen();
+	int end = SEQ_ADD(start, th->size() - tcph->hlen());
 	int tiflags = tcph->flags();
 
 	return (add(start, end, tiflags));
@@ -2276,14 +2291,14 @@
 		head_->flags_ = tiflags;
 		head_->time_ = now;
 	} else {
-		if (tail_->endseq_ <= start) {
+		if (SEQ_LE(tail_->endseq_, start)) {
 			// common case of end of reass queue
 			p = tail_;
 			goto endfast;
 		}
 
 		// Look for the first segment AFTER this one
-		for (q = head_; q && (end > q->startseq_); q = q->next_)
+		for (q = head_; q && SEQ_GT(end, q->startseq_); q = q->next_)
 			;
 		// set p to the segment before this one
 		if (q == NULL)
@@ -2293,7 +2308,7 @@
 
 		// Put this one after p, regardless whether any segments 
 		// should be deleted
-		if (p == NULL || (start > p->endseq_)) {
+		if (p == NULL || SEQ_GT(start, p->endseq_)) {
 			// no overlap
 endfast:
 			n = new seginfo;
@@ -2324,17 +2339,17 @@
 		} else {
 			// start or end overlaps p, so patch
 			// up p; will catch other overlaps below
-			p->startseq_ = MIN(p->startseq_, start);
-			p->endseq_ = MAX(p->endseq_, end);
+			p->startseq_ = SEQ_MIN(p->startseq_, start); 
+			p->endseq_ = SEQ_MAX(p->endseq_, end);
 			p->flags_ |= tiflags;
 			n = p;
 		}
 
 		// Look for the first segment BEFORE p
-		for (q = head_; q && (n->startseq_ > q->endseq_); q = q->next_)
+		for (q = head_; q && SEQ_GT(n->startseq_, q->endseq_); q = q->next_)
 			;
-		while (q != n) {
-			if (n->startseq_ > q->startseq_)
+		while (q && q != n) {
+ 		        if (SEQ_GT(n->startseq_, q->startseq_))
 				// q is partially included in n, merge it
 				n->startseq_ = q->startseq_;
 			// Delete q, which is already covered by n.
@@ -2359,7 +2374,7 @@
 	// look for a sequence of in-order segments and
 	// set rcv_nxt if we can
 	//
-	if (head_->startseq_ > rcv_nxt_) {
+	if (SEQ_GT(head_->startseq_, rcv_nxt_)) {
 		return 0;	// still awaiting a hole-fill
 	}
 
@@ -2383,7 +2398,7 @@
 
 		if (q == ptr_)
 			ptr_ = NULL;
-		if (q->next_ && (q->endseq_ < q->next_->startseq_)) {
+		if (q->next_ && SEQ_LT(q->endseq_, q->next_->startseq_)) {
 			delete q;
 			break;		// only the in-seq stuff
 		}
@@ -2507,7 +2522,7 @@
 void
 TahoeFullTcpAgent::dupack_action()
 {  
-        int recovered = (highest_ack_ > recover_);
+        int recovered = SEQ_GT(highest_ack_, recover_);
         if (recovered || (!bug_fix_ && !ecn_) ||
             last_cwnd_action_ == CWND_ACTION_DUPACK) {
                 goto full_tahoe_action;
@@ -2619,7 +2634,7 @@
 	int ackno = tcph->ackno();
 
 	if (state_ == TCPS_ESTABLISHED &&
-	    (ackno > iss_ && ackno <= maxseq_)) {
+	    SEQ_GT(ackno, iss_) && SEQ_LE(ackno, maxseq_)) {
 
 		int slen = tcph->sa_length();
 		int i;  
@@ -2650,11 +2665,11 @@
 {
 	FullTcpAgent::ack_action(p);
 
-	if (!sq_.empty() && sack_max_ <= highest_ack_) {
+	if (!sq_.empty() && SEQ_LE(sack_max_, highest_ack_)) {
 		sq_.clear();
 	}
 
-	if (sack_nxt_ < highest_ack_)
+	if (SEQ_LT(sack_nxt_, highest_ack_))
 		sack_nxt_ = highest_ack_;
 	pipectrl_ = FALSE;
 }
@@ -2663,7 +2678,7 @@
 SackFullTcpAgent::dupack_action()
 {
 
-        int recovered = (highest_ack_ > recover_);
+        int recovered = SEQ_GT(highest_ack_,recover_);
 
         if (recovered || (!bug_fix_ && !ecn_) ||
             last_cwnd_action_ == CWND_ACTION_DUPACK) {
@@ -2703,7 +2718,7 @@
 SackFullTcpAgent::pack_action(Packet*)
 {
 	--pipe_;
-	if (sack_nxt_ < highest_ack_)
+	if (SEQ_LT(sack_nxt_, highest_ack_))
 		sack_nxt_ = highest_ack_;
 }
 
@@ -2748,18 +2763,18 @@
 
 	// skip over old blocks
 	while (sq_.nextblk(nxtblk)) {
-		if (t_seqno_ <= nxtblk[1])
+		if (SEQ_LE(t_seqno_, nxtblk[1]))
 			break;
 	}
 
 	while (force || (pipe_ < window())) {
 		force = 0;
 		// don't sent off the top
-		if (t_seqno_ > recover_ || t_seqno_ >= sack_max_)
+		if (SEQ_GT(t_seqno_,recover_) || SEQ_GE(t_seqno_, sack_max_))
 			break;
 
 		// skip this one if the receiver has it already
-		if (t_seqno_ >= nxtblk[0] && t_seqno_ <= nxtblk[1]) {
+		if (SEQ_GE(t_seqno_, nxtblk[0]) && SEQ_LE(t_seqno_, nxtblk[1])) {
 			t_seqno_ = nxtblk[1];
 			if (sq_.nextblk(nxtblk))
 				continue;
Index: ns-2/ns-2.1b8a/tcp.h
diff -u ns-2/ns-2.1b8a/tcp.h:1.1 ns-2/ns-2.1b8a/tcp.h:1.2
--- ns-2/ns-2.1b8a/tcp.h:1.1	Wed Feb 20 15:48:05 2002
+++ ns-2/ns-2.1b8a/tcp.h	Tue Mar 12 01:03:06 2002
@@ -54,6 +54,8 @@
 	int ackno_;             /* ACK number for FullTcp */
 	int hlen_;              /* header len (bytes) for FullTcp */
 	int tcp_flags_;         /* TCP flags for FullTcp */
+        int maxseg_;            /* MSS for TCPTap to negotiate in the SYN segment
+				   needed in NSE */
 
 	static int offset_;	// offset for this header
 	inline static int& offset() { return offset_; }
@@ -72,6 +74,7 @@
 	int& hlen() { return (hlen_); }
 	int& ackno() { return (ackno_); }  
 	int& flags() { return (tcp_flags_); }
+	int& maxseg() { return (maxseg_); }
 };
 
 /* these are used to mark packets as to why we xmitted them */
Index: ns-2/ns-2.1b8a/emulate/iptap.cc
diff -u ns-2/ns-2.1b8a/emulate/iptap.cc:1.1 ns-2/ns-2.1b8a/emulate/iptap.cc:1.2
--- ns-2/ns-2.1b8a/emulate/iptap.cc:1.1	Wed Feb 20 15:48:06 2002
+++ ns-2/ns-2.1b8a/emulate/iptap.cc	Tue Mar 12 01:03:06 2002
@@ -144,7 +144,7 @@
   /* TCP header info from the grabbed packet. */
   unsigned char tcphlen;
   
-  if (net_->mode() != O_RDWR && net_->mode() != O_RDONLY) {
+  if (net_incoming_->mode() != O_RDWR && net_incoming_->mode() != O_RDONLY) {
     fprintf(stderr,
 	    "IPTapAgent(%s): recvpkt called while in write-only mode!\n",
 	    name());
@@ -165,7 +165,7 @@
   // fill up payload
   sockaddr addr;	// not really used (yet)
   double tstamp;
-  int cc = net_->recv(p->accessdata(), maxpkt_, addr, tstamp);
+  int cc = net_incoming_->recv(p->accessdata(), maxpkt_, addr, tstamp);
   if (cc <= 0) {
     if (cc < 0) {
       perror("recv");
@@ -231,23 +231,24 @@
   unsigned short dglen;
   struct ip *ipheader;
 
-  if (net_->mode() != O_RDWR && net_->mode() != O_WRONLY) {
+  if (net_outgoing_ == NULL) {
     fprintf(stderr,
-	    "IPTapAgent(%s): sendpkt called while in read-only mode!\n",
+	    "IPTapAgent(%s): sendpkt attempted with NULL net\n",
 	    name());
+    drop(p);
     return (-1);
   }
-  
-  // send packet into the live network
-  hdr_cmn* hc = HDR_CMN(p);
-  if (net_ == NULL) {
+
+  if (net_outgoing_->mode() != O_RDWR && net_outgoing_->mode() != O_WRONLY) {
     fprintf(stderr,
-	    "IPTapAgent(%s): sendpkt attempted with NULL net\n",
+	    "IPTapAgent(%s): sendpkt called while in read-only mode!\n",
 	    name());
-    drop(p);
     return (-1);
   }
   
+  // send packet into the live network
+  hdr_cmn* hc = HDR_CMN(p);
+  
   /*
     At this point, we should grab the ttl field from the ns
     packet, put it in the IP header of the actual packet,
@@ -277,13 +278,15 @@
   ipheader->ip_sum = (unsigned short) in_cksum((unsigned short *) ipheader,
 						sizeof(struct ip));
 
-  if (net_->send(p->accessdata(), hc->size()) < 0) {
+  if (net_outgoing_->send(p->accessdata(), hc->size()) < 0) {
     fprintf(stderr,
 	    "IPTapAgent(%s): sendpkt (%p, %d): %s\n",
 	    name(), p->accessdata(), hc->size(), strerror(errno));
+    Packet::free(p); // memory leak fix from 2.1b8a 
     return (-1);
     
   }
+  Packet::free(p); // memory leak fix from 2.1b8a 
   TDEBUG3("IPTapAgent(%s): sent packet (sz: %d)\n",
 	  name(), hc->size());
   return 0;
Index: ns-2/ns-2.1b8a/emulate/iptap.h
diff -u ns-2/ns-2.1b8a/emulate/iptap.h:1.1 ns-2/ns-2.1b8a/emulate/iptap.h:1.2
--- ns-2/ns-2.1b8a/emulate/iptap.h:1.1	Wed Feb 20 15:48:06 2002
+++ ns-2/ns-2.1b8a/emulate/iptap.h	Tue Mar 12 01:03:06 2002
@@ -38,6 +38,7 @@
 
 #include "tap.h"
 #include <netinet/in.h>
+#include <netinet/in_systm.h>
 #include <netinet/ip.h>
 #include <netinet/tcp.h>
 #include <sys/socket.h>
Index: ns-2/ns-2.1b8a/emulate/tap.cc
diff -u ns-2/ns-2.1b8a/emulate/tap.cc:1.1 ns-2/ns-2.1b8a/emulate/tap.cc:1.2
--- ns-2/ns-2.1b8a/emulate/tap.cc:1.1	Wed Feb 20 15:48:06 2002
+++ ns-2/ns-2.1b8a/emulate/tap.cc	Tue Mar 12 01:03:06 2002
@@ -46,7 +46,7 @@
 	}
 } class_tap_agent;
 
-TapAgent::TapAgent() : Agent(PT_LIVE), net_(NULL)
+TapAgent::TapAgent() : Agent(PT_LIVE), net_outgoing_(NULL), net_incoming_(NULL)
 {
 	bind("maxpkt_", &maxpkt_);
 }
@@ -55,11 +55,11 @@
 // link in a network to the agent.  Assumes net_ is non-zero
 //
 int
-TapAgent::linknet()
+TapAgent::linknet(Network *net)
 {
-	int mode = net_->mode();
-	int rchan = net_->rchannel();
-	int wchan = net_->schannel();
+	int mode = net->mode();
+	int rchan = net->rchannel();
+	int wchan = net->schannel();
 
 	unlink();
 	if (mode == O_RDONLY || mode == O_RDWR) {
@@ -67,7 +67,7 @@
 		if (rchan < 0) {
 			fprintf(stderr,
 		"TapAgent(%s): network %s not open for reading (mode:%d)\n",
-			    name(), net_->name(), mode);
+			    name(), net->name(), mode);
 			return (TCL_ERROR);
 		}
 		link(rchan, TCL_READABLE);
@@ -77,13 +77,13 @@
 		if (mode == -1) {
 			fprintf(stderr,
 			   "TapAgent(%s): Network(%s) not opened properly.\n",
-				name(), net_->name());
+				name(), net->name());
 			fprintf(stderr,
 			   "(choose: readonly, readwrite, or writeonly)\n");
 		} else {
 			fprintf(stderr,
 			    "TapAgent(%s): unknown mode %d in Network(%s)\n",
-				name(), mode, net_->name());
+				name(), mode, net->name());
 		}
 		return (TCL_ERROR);
 	}
@@ -93,7 +93,7 @@
 		if (wchan < 0) {
 			fprintf(stderr,
 			"TapAgent(%s): network %s not open for writing\n",
-			    name(), net_->name());
+			    name(), net->name());
 			return (TCL_ERROR);
 		}
 	}
@@ -112,10 +112,25 @@
 		} 
 	}
 	if (argc == 3) {
-		if (strcmp(argv[1], "network") == 0) {
-			net_ = (Network *)TclObject::lookup(argv[2]);
-			if (net_ != 0) {
-				return(linknet());
+		if (strcmp(argv[1], "network-outgoing") == 0) {
+			net_outgoing_ = (Network *)TclObject::lookup(argv[2]);
+			/* We don't need to monitor outgoing network (by calling linknet()) coz
+			   we just send packets to it. In case a particular
+			   network object does both, the user has to explicitly
+			   use the command network-incoming to monitor this fd */
+			if (net_outgoing_ == 0) {
+				fprintf(stderr,
+				"TapAgent(%s): unknown network %s\n",
+				    name(), argv[2]);
+				return (TCL_ERROR);
+			}
+			return(TCL_OK);
+		}	
+
+		if (strcmp(argv[1], "network-incoming") == 0) {
+			net_incoming_ = (Network *)TclObject::lookup(argv[2]);
+			if (net_incoming_ != 0) {
+				return(linknet(net_incoming_));
 			} else {
 				fprintf(stderr,
 				"TapAgent(%s): unknown network %s\n",
@@ -135,7 +150,7 @@
 TapAgent::recvpkt()
 {
 
-	if (net_->mode() != O_RDWR && net_->mode() != O_RDONLY) {
+	if (net_incoming_->mode() != O_RDWR && net_incoming_->mode() != O_RDONLY) {
 		fprintf(stderr,
 		  "TapAgent(%s): recvpkt called while in write-only mode!\n",
 		  name());
@@ -155,7 +170,7 @@
 	// fill up payload
 	sockaddr addr;	// not really used (yet)
 	double tstamp;
-	int cc = net_->recv(p->accessdata(), maxpkt_, addr, tstamp);
+	int cc = net_incoming_->recv(p->accessdata(), maxpkt_, addr, tstamp);
 	if (cc <= 0) {
 		if (cc < 0) {
 			perror("recv");
@@ -230,7 +245,7 @@
 int
 TapAgent::sendpkt(Packet* p)
 {
-	if (net_->mode() != O_RDWR && net_->mode() != O_WRONLY) {
+	if (net_outgoing_->mode() != O_RDWR && net_outgoing_->mode() != O_WRONLY) {
 		fprintf(stderr,
 		    "TapAgent(%s): sendpkt called while in read-only mode!\n",
 		    name());
@@ -239,14 +254,14 @@
 
 	// send packet into the live network
 	hdr_cmn* hc = HDR_CMN(p);
-	if (net_ == NULL) {
+	if (net_outgoing_ == NULL) {
 		fprintf(stderr,
 	         "TapAgent(%s): sendpkt attempted with NULL net\n",
 		 name());
 		drop(p);
 		return (-1);
 	}
-	if (net_->send(p->accessdata(), hc->size()) < 0) {
+	if (net_outgoing_->send(p->accessdata(), hc->size()) < 0) {
 		fprintf(stderr,
 		    "TapAgent(%s): sendpkt (%p, %d): %s\n",
 		    name(), p->accessdata(), hc->size(), strerror(errno));
Index: ns-2/ns-2.1b8a/emulate/tap.h
diff -u ns-2/ns-2.1b8a/emulate/tap.h:1.1 ns-2/ns-2.1b8a/emulate/tap.h:1.2
--- ns-2/ns-2.1b8a/emulate/tap.h:1.1	Wed Feb 20 15:48:06 2002
+++ ns-2/ns-2.1b8a/emulate/tap.h	Tue Mar 12 01:03:07 2002
@@ -71,8 +71,9 @@
 protected:
 	int maxpkt_;		/* max size allocated to recv a pkt */
 	void dispatch(int);	/* invoked via scheduler on I/O event */
-	int linknet();		/* establish I/O handler */
-	Network* net_;		/* live network object */
+	int linknet(Network *);		/* establish I/O handler */
+	Network* net_outgoing_;	/* live network object for outgoing packets */
+	Network* net_incoming_;		/* live network object for incoming packets */
 	double now() { return Scheduler::instance().clock(); }
 };
 
Index: ns-2/ns-2.1b8a/emulate/tcptap.cc
diff -u ns-2/ns-2.1b8a/emulate/tcptap.cc:1.1 ns-2/ns-2.1b8a/emulate/tcptap.cc:1.2
--- ns-2/ns-2.1b8a/emulate/tcptap.cc:1.1	Wed Feb 20 15:48:06 2002
+++ ns-2/ns-2.1b8a/emulate/tcptap.cc	Tue Mar 12 01:03:07 2002
@@ -62,7 +62,7 @@
     nsnode.sin_addr.s_addr = inet_addr(DEFAULT_NS_ADDR);
     nsnode.sin_family = AF_INET;
     
-    dropp = 0; 
+    dropp = 0;
 }
 
 
@@ -92,6 +92,12 @@
       }
       return (TCL_OK);
     }
+
+    if (strcmp(argv[1], "nsport") == 0) {
+      nsnode.sin_port = atoi(argv[2]);
+      return (TCL_OK);
+    }
+
     
     if (strcmp(argv[1], "extport") == 0) {
       extnode.sin_port = atoi(argv[2]);
@@ -199,6 +205,8 @@
   ipheader->ip_v = IPVERSION;
 
   ipheader->ip_len = length;
+  ipheader->ip_off = IP_DF; /* most common now. fragmentation is quite bad on
+			       performance */
   ipheader->ip_id = 0;
   ipheader->ip_ttl = ttl;
   ipheader->ip_p = protocol;
@@ -284,7 +292,7 @@
   /* Ip header information from the grabbed packet. */
   unsigned char ttl;
   
-  if (net_->mode() != O_RDWR && net_->mode() != O_RDONLY) {
+  if (net_incoming_->mode() != O_RDWR && net_incoming_->mode() != O_RDONLY) {
     fprintf(stderr,
 	    "TCPTapAgent(%s): recvpkt called while in write-only mode!\n",
 	    name());
@@ -304,7 +312,7 @@
   // fill up payload
   sockaddr addr;	// not really used (yet)
   double tstamp;
-  int cc = net_->recv(p->accessdata(), maxpkt_, addr, tstamp);
+  int cc = net_incoming_->recv(p->accessdata(), maxpkt_, addr, tstamp);
   if (cc <= 0) {
     if (cc < 0) {
       perror("recv");
@@ -370,8 +378,21 @@
   ns_tcphdr->flags() = 0;
   if (tcpheader->th_flags & TH_FIN)
     ns_tcphdr->flags() |= TH_FIN;
-  if (tcpheader->th_flags & TH_SYN) 
+  if (tcpheader->th_flags & TH_SYN) {
         ns_tcphdr->flags() |= TH_SYN;
+
+
+	/* For server side TCP in NSE, we need to store
+	   the source addr and port for the next packet
+	   we send => we ignore the command settings.
+	   We gotta check if this is a SYN+ACK in which case
+	   we are not server side */
+	if( (tcpheader->th_flags & TH_ACK) == 0 ) {
+	  extnode.sin_port =  ntohs(tcpheader->th_sport);
+	  extnode.sin_addr = ipheader->ip_src;
+	}
+  }
+
   if (tcpheader->th_flags & TH_RST) 
         ns_tcphdr->flags() |= TH_RST;
   if (tcpheader->th_flags & TH_PUSH) 
@@ -386,6 +407,9 @@
   ns_cmnhdr->size() = ntohs(ipheader->ip_len);
 
 
+  // We no longer need Packet p. memory leak fix from 2.1b8a 
+  Packet::free(p);
+  
   // inject into simulator
   target_->recv(nspacket);
   return;
@@ -398,7 +422,7 @@
  * simulator schedules TapAgent::recv which calls sendpkt
  *
  * Grabs a ns Full TCP packet, converts it into real TCP packet 
- * and injects onto the network using net_->send
+ * and injects onto the network using net_outgoing_->send
  *
  */
 int
@@ -410,7 +434,7 @@
   int hlength = IP_HEADER_LEN + TCP_HEADER_LEN;
   struct tcphdr *tcpheader;
 
-  if (net_->mode() != O_RDWR && net_->mode() != O_WRONLY) {
+  if (net_outgoing_->mode() != O_RDWR && net_outgoing_->mode() != O_WRONLY) {
     fprintf(stderr,
 	    "TCPTapAgent(%s): sendpkt called while in read-only mode!\n",
 	    name());
@@ -419,7 +443,7 @@
   
   // send packet into the live network
   hdr_cmn* ns_cmnhdr = HDR_CMN(p);
-  if (net_ == NULL) {
+  if (net_outgoing_ == NULL) {
     fprintf(stderr,
 	    "TCPTapAgent(%s): sendpkt attempted with NULL net\n",
 	    name());
@@ -432,6 +456,10 @@
   hdr_ip * ns_iphdr = HDR_IP(p);
   received_ttl = ns_iphdr->ttl_;
 
+  if (ns_tcphdr->tcp_flags_ & TH_SYN) {
+      hlength += 4; // adding 4 bytes for MSS option
+  }
+
   // Here we check if ns has sent any data in the packet.
   datalen = ns_cmnhdr->size() - ns_tcphdr->hlen();
   packet = (unsigned char *) calloc (1, sizeof(unsigned char) * 
@@ -452,23 +480,43 @@
 
   tcp_gen((char *)tcpheader, nsnode.sin_port, extnode.sin_port, p);
 
-  tcpheader->th_sum = trans_check(IPPROTO_TCP, (char *) tcpheader,
-				  sizeof(struct tcphdr) + datalen,
-				  nsnode.sin_addr, extnode.sin_addr);
+  // In the case of SYN packet, we negotiate MSS
+   if (ns_tcphdr->tcp_flags_ & TH_SYN) {
+       unsigned char *mss_opt = (unsigned char *) (packet + IP_HEADER_LEN + TCP_HEADER_LEN);
+       *mss_opt++ = 0x02;
+       *mss_opt++ = 0x04;
+
+       unsigned short *mss_val = (unsigned short *)mss_opt;
+       *mss_val = htons(ns_tcphdr->maxseg());
+       
+       tcpheader->th_off += 1;
+
+       tcpheader->th_sum = trans_check(IPPROTO_TCP, (char *) tcpheader,
+				       sizeof(struct tcphdr) + 4 + datalen, 
+				       nsnode.sin_addr, extnode.sin_addr);
+
+   } else {
+     tcpheader->th_sum = trans_check(IPPROTO_TCP, (char *) tcpheader,
+				     sizeof(struct tcphdr) + datalen,
+				     nsnode.sin_addr, extnode.sin_addr);
+   }
 
   /* 
      Limits the packets going out to only IP + TCP header. 
      ns will act as an ACK machine.
    */
-  byteswritten = net_->send(packet, hlength + datalen);
+  byteswritten = net_outgoing_->send(packet, hlength + datalen);
   if (byteswritten < 0) {
     fprintf(stderr,"TCPTapAgent(%s): sendpkt (%p, %d): %s\n",
 	    name(), p->accessdata(), ns_cmnhdr->size(), strerror(errno));
     Packet::free(p);
+    free(packet); // freeing the calloc'ed packet. memory leak fix from 2.1b8a  
     return (-1);
     
   }
   
+  free(packet); // freeing the calloc'ed packet. memory leak fix from 2.1b8a 
+
   TDEBUG3("TCPTapAgent(%s): sent packet (sz: %d)\n", name(), hc->size());
   return 0;
 }
Index: ns-2/ns-2.1b8a/emulate/tcptap.h
diff -u ns-2/ns-2.1b8a/emulate/tcptap.h:1.1 ns-2/ns-2.1b8a/emulate/tcptap.h:1.2
--- ns-2/ns-2.1b8a/emulate/tcptap.h:1.1	Wed Feb 20 15:48:06 2002
+++ ns-2/ns-2.1b8a/emulate/tcptap.h	Tue Mar 12 01:03:07 2002
@@ -38,6 +38,7 @@
 
 #include "tap.h"
 #include <netinet/in.h>
+#include <netinet/in_systm.h>
 #include <netinet/ip.h>
 #include <netinet/tcp.h>
 #include <sys/socket.h>
