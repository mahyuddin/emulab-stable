diff -ru dist-ns-allinone-2.1b9/install ns-allinone-2.1b9/install
--- dist-ns-allinone-2.1b9/install	Mon Apr 22 18:42:09 2002
+++ ns-allinone-2.1b9/install	Sun Oct  6 21:54:17 2002
@@ -39,224 +39,82 @@
 
 # Get current path
 CUR_PATH=`pwd`
+  
+if [ -x /usr/local/tcl8.3.2/bin/tclsh8.3 ] ; then
+  V_TCLSH=/usr/local/tcl8.3.2/bin/tclsh8.3 
+  export V_TCLSH
+  WITHTCL_PATH=/usr/local/tcl8.3.2
+  export WITHTCL_PATH
+
+else
+
+  # Build Tcl8.3.2
+  
+  echo "============================================================"
+  echo "* Build tcl$TCLVER"
+  echo "============================================================"
+  
+  cd ./tcl$TCLVER/unix
+  if [ -f Makefile ] ; then 
+	  make distclean
+  fi
+  
+  blame='Tcl is not part of the ns project.  Please see www.Scriptics.com
+  to see if they have a fix for your platform.'
+  ./configure --enable-gcc --disable-shared --prefix=$CUR_PATH || die "tcl8.3.2 configuration failed! Exiting ..."
+  if make 
+  then 
+	  echo "tcl$TCLVER make succeeded."
+	  make install || die "tcl$TCLVER installation failed."
+	  echo "tcl$TCLVER installation succeeded."
+	  cp ../generic/*.h ../../include
+  else
+	  echo "tcl$TCLVER make failed! Exiting ..."
+	  echo "For problems with Tcl/Tk see http://www.scriptics.com"
+	  exit
+  fi
+
+  cd ../../
+
+  WITHTCL_PATH=$CUR_PATH/tcl$TCLVER
+
+fi
+
+if [ -d /usr/local/otcl-1.0a8 ] ; then
+
+  WITHOTCL_PATH=/usr/local/otcl-1.0a8
+  export WITHOTCL_PATH
+
+else
+
+  # Build otcl
+
+  echo "============================================================"
+  echo "* Build OTcl-$OTCLVER"
+  echo "============================================================"
+  
+  cd ./otcl-$OTCLVER
+  
+  blame='Please check http://www.isi.edu/nsnam/ns/ns-problems.html
+  for common problems and bug fixes.'
+  ./configure --with-tcl=$WITHTCL_PATH || die "otcl-$OTCLVER configuration failed! Exiting ..."
+  
+  if make 
+  then
+	  echo "otcl-$OTCLVER has been installed successfully."
+  else
+	  echo "otcl-$OTCLVER make failed! Exiting ..."
+	  echo "See http://www.isi.edu/nsnam/ns/ns-problems.html for problems"
+	  exit
+  fi
+  
+  cd ..
 
-# Compile and install xgraph
+  WITHOTCL_PATH=`pwd`/otcl-$OTCLVER
+  export WITHOTCL_PATH
 
-echo "============================================================"
-echo "* Build XGraph-$XGRAPHVER"
-echo "============================================================"
-
-cd ./xgraph-$XGRAPHVER
-./configure
-if make
-then
-	echo "xgraph has been installed successfully. "
-else 
-	echo "Can not create xgraph; But xgraph is an optional package, continuing..."
-fi
-
-cd ../
-
-# Compile and install cweb and sgblib
-
-echo "============================================================"
-echo "* Build CWeb"
-echo "============================================================"
-
-cd ./cweb
-
-if [ ! -f ./Makefile ]
-then
-	echo "ns-allinone unable to install cweb for you. Please install it manually. cweb is used by sgb to create sgblibrary needed by scenario-generator. But this will not affect the use of ns as such, so continue.."
-else
-	echo "Making cweb"
-	touch *.c
-	make all || warn "cweb failed to make, but it's optional"
-	# xxx: other stuff will fail...
-	chmod 755 cweave
-	chmod 755 ctangle
-	cd ..
-	#echo "cd .."
-	if [ ! -d bin ]
-	then
-		mkdir bin
-	fi
-	cd bin
-	ln -s $CUR_PATH/cweb/cweave cweave
-	ln -s $CUR_PATH/cweb/ctangle ctangle
-fi
-
-cd ..
-PATH=$CUR_PATH/bin:$PATH
-export PATH
-
-echo "============================================================"
-echo "* Build Stanford GraphBase"
-echo "============================================================"
-
-cd ./sgb
-if [ ! -f ./Makefile ]
-	then
-	echo "Unable to create sgb library. This library is used by gt-itm and so for scenario generators. If you already have sgblib (possible if you are on solaris,sunos or freebsd platforms) you may still be able to run gt-itm. so continuing.."
-else
-	echo "Making sgb"
-	if make tests
-	then
-                if [ -f libgb.a ] ; then
-                        rm -f ../gt-itm/lib/libgb.a
-                        cp libgb.a ../gt-itm/lib/libgb.a
-                else 
-                        echo "* Wierd: sgb said it has been built but we can't find libgb.a!
-"
-                        exit -1
-                fi
-	else
-		echo "Unable to create sgb library, but it's optional, so continuing..."
-	fi
-fi
-
-cd ..
-
-# Compile and install gt-itm & sgb2ns
-
-echo "============================================================"
-echo "* Build GT-ITM"
-echo "============================================================"
-
-if [ -f ./gt-itm/lib/libgb.a ]
-then
- if [ ! -f ./gt-itm/src/Makefile ] 
-    then
-    echo "ns-alline is unable to install gt-itm sgb2ns for you, please install"
-    echo "them manually. You can't run scenario generator without gt-itm"
-    echo "and sgb2ns. But it will not affect you use ns, so continue ..."
- else
-    cd ./gt-itm/src
-    if make
-    then
-      echo "gt-itm has been installed successfully."
-    fi
-    
-    cd ../sgb2ns
-    if make
-    then
-      echo "sgb2ns has been installed successfully."
-    fi
-   cd ../../
- fi
-else
-    echo "sgb lib not found. gt-itm & sgb2ns could not be installed. Continuing.."
-fi
-
-# Build zlib
-
-echo "============================================================"
-echo "* Build zlib"
-echo "============================================================"
-
-cd ./zlib-1.1.3
-
-if ./configure --exec-prefix=../ --prefix=../
-then
-	if make
-	then
-		echo "Zlib has been installed successfully."
-	else
-		warn "Zlib make failed, but it's optional Continue ..."
-	fi
-else
-	warn "Zlib-1.1.3 configuration failed, but it's optional, so continuing ..."
-fi
-
-cd ../
-
-# Build Tcl8.3.2
-
-echo "============================================================"
-echo "* Build tcl$TCLVER"
-echo "============================================================"
-
-cd ./tcl$TCLVER/unix
-if [ -f Makefile ] ; then 
-	make distclean
-fi
-
-blame='Tcl is not part of the ns project.  Please see www.Scriptics.com
-to see if they have a fix for your platform.'
-./configure --enable-gcc --disable-shared --prefix=$CUR_PATH || die "tcl8.3.2 configuration failed! Exiting ..."
-if make 
-then 
-	echo "tcl$TCLVER make succeeded."
-	make install || die "tcl$TCLVER installation failed."
-	echo "tcl$TCLVER installation succeeded."
-	cp ../generic/*.h ../../include
-else
-	echo "tcl$TCLVER make failed! Exiting ..."
-	echo "For problems with Tcl/Tk see http://www.scriptics.com"
-	exit
-fi
-
-cd ../../
-
-# compile and install tk
-
-echo "============================================================"
-echo "* Build Tk$TKVER"
-echo "============================================================"
-
-cd ./tk$TKVER/unix
-if [ -f Makefile ] ; then
-	make distclean
-fi
-
-blame='Tk is not part of the ns project.  Please see www.Scriptics.com
-to see if they have a fix for your platform.'
-./configure --enable-gcc --disable-shared --prefix=$CUR_PATH || die "tk8.3.2 configuration failed! Exiting ..."
-if make 
-then
-	echo "tk$TKVER build succeeded."
-	make install || die "tk$TKVER installation failed."
-	echo "tk$TKVER installation succeeded."
-else
-	echo "tk$TKVER make failed! Exiting ..."
-	echo "For problems with Tcl/Tk see http://www.scriptics.com"
-	exit
 fi
 
-cd ../../
-
-#
-# Since our configures search for tclsh in $PATH, the following 
-# is needed. This is necessary for otcl/tclcl/ns/nam
-#
-PATH=$CUR_PATH/tcl$TCLVER/unix:$CUR_PATH/tk$TKVER/unix:$PATH
-export PATH
-LD_LIBRARY_PATH=$CUR_PATH/tcl$TCLVER/unix:$CUR_PATH/tk$TKVER/unix:$LD_LIBRARY_PATH
-export LD_LIBRARY_PATH
-
-# Build otcl
-
-echo "============================================================"
-echo "* Build OTcl-$OTCLVER"
-echo "============================================================"
-
-cd ./otcl-$OTCLVER
-
-blame='Please check http://www.isi.edu/nsnam/ns/ns-problems.html
-for common problems and bug fixes.'
-./configure || die "otcl-$OTCLVER configuration failed! Exiting ..."
-
-if make 
-then
-	echo "otcl-$OTCLVER has been installed successfully."
-else
-	echo "otcl-$OTCLVER make failed! Exiting ..."
-	echo "See http://www.isi.edu/nsnam/ns/ns-problems.html for problems"
-	exit
-fi
-
-cd ..
-
 # Build tclcl
 
 echo "============================================================"
@@ -265,7 +123,7 @@
 
 cd ./tclcl-$TCLCLVER
 
-./configure || die "tclcl-$TCLCLVER configuration failed! Exiting ..."
+./configure --enable-static --with-tcl=$WITHTCL_PATH --with-otcl=$WITHOTCL_PATH || die "tclcl-$TCLCLVER configuration failed! Exiting ..."
 
 if make
 then
@@ -286,40 +144,22 @@
 echo "============================================================"
 
 cd ./ns-$NSVER
-./configure || die "Ns configuration failed! Exiting ..."
 
-if make
+./configure --enable-static --with-tcl=$WITHTCL_PATH --with-otcl=$WITHOTCL_PATH || die "Ns configuration failed! Exiting ..."
+
+
+if make nse
 then
-	echo " Ns has been installed successfully." 
+	echo " Nse has been installed successfully." 
 else
-	echo "Ns make failed!"
+	echo "Nse make failed!"
 	echo "See http://www.isi.edu/nsnam/ns/ns-problems.html for problems"
 	exit
 fi
 
 cd ../
 
-# Build nam
-
-echo "============================================================"
-echo "* Build nam-$NAMVER"
-echo "============================================================"
-
-cd ./nam-$NAMVER
-
-./configure || die "Nam configuration failed! Exiting ..."
-
-if make
-then 
-    echo "Nam has been installed successfully."
-else
-    echo "Nam make failed! Continue ..."
-    echo "See http://www.isi.edu/nsnam/ns-problems.html for problems"
-fi
-
-cd ../
-
-# Install nam, ns, xgraph into bin
+# Install nse
 
 if [ ! -d bin ] ; then
     mkdir bin
@@ -327,55 +167,14 @@
 
 cd bin
 
-ln -s $CUR_PATH/ns-$NSVER/ns ns
-
-if test -x $CUR_PATH/nam-$NAMVER/nam
-then
-    ln -s $CUR_PATH/nam-$NAMVER/nam nam
-else
-    echo "Please compile your nam separately."
-fi
-
-if test -x $CUR_PATH/xgraph-$XGRAPHVER/xgraph
-then
-    ln -s $CUR_PATH/xgraph-$XGRAPHVER/xgraph xgraph
-else
-    echo "Please compile your xgraph separately."
-fi
-
-if test -x $CUR_PATH/gt-itm/bin/sgb2ns
-then 
-    ln -s $CUR_PATH/gt-itm/bin/sgb2ns sgb2ns
-    ln -s $CUR_PATH/gt-itm/bin/sgb2hierns sgb2hierns
-    ln -s $CUR_PATH/gt-itm/bin/sgb2comns sgb2comns
-    ln -s $CUR_PATH/gt-itm/bin/itm itm
-    ln -s $CUR_PATH/gt-itm/bin/sgb2alt sgb2alt
-    ln -s $CUR_PATH/gt-itm/bin/edriver edriver
-else
-    echo "Please compile your gt-itm & sgb2ns separately."
-fi
+ln -s $CUR_PATH/ns-$NSVER/nse nse
 
 echo "Ns-allinone package has been installed successfully."
 echo "Here are the installation places:"
 echo "tcl$TCLVER:	$CUR_PATH/{bin,include,lib}"
-echo "tk$TKVER:		$CUR_PATH/{bin,include,lib}"
 echo "otcl:		$CUR_PATH/otcl-$OTCLVER"
 echo "tclcl:		$CUR_PATH/tclcl-$TCLCLVER"
-echo "ns:		$CUR_PATH/ns-$NSVER/ns"
-
-if [ -x $CUR_PATH/nam-$NAMVER/nam ]
-then
-echo "nam:	$CUR_PATH/nam-$NAMVER/nam"
-fi
-
-if [ -x $CUR_PATH/xgraph-$XGRAPHVER/xgraph ]
-then
-echo "xgraph:	$CUR_PATH/xgraph-$XGRAPHVER"
-fi
-if [ -x $CUR_PATH/gt-itm/bin/sgb2ns ] 
-then
-echo "gt-itm:   $CUR_PATH/itm, edriver, sgb2alt, sgb2ns, sgb2comns, sgb2hierns"
-fi
+echo "nse:		$CUR_PATH/ns-$NSVER/nse"
 
 echo ""
 echo "----------------------------------------------------------------------------------"
diff -ru dist-ns-allinone-2.1b9/ns-2.1b9/Makefile.in ns-allinone-2.1b9/ns-2.1b9/Makefile.in
--- dist-ns-allinone-2.1b9/ns-2.1b9/Makefile.in	Mon Mar 18 15:39:26 2002
+++ ns-allinone-2.1b9/ns-2.1b9/Makefile.in	Sun Oct  6 23:17:08 2002
@@ -78,6 +78,14 @@
 
 CFLAGS	= $(CCOPT) $(DEFINE)
 
+#### with event system
+INCLUDES += -I../.. -I../../../lib -I../../../../lib/libtb `elvin-config --cflags vin4c`
+CFLAGS += -DUSEEVENTS -DUSEROUTES -DADD_ETHER_OVERHEAD -DGETTIME_TSC
+LIB += -L../../../lib -L../../../../lib/libtb -levent -ltb
+LIB += `elvin-config --libs vin4c`
+STATIC += -static
+####
+
 # Explicitly define compilation rules since SunOS 4's make doesn't like gcc.
 # Also, gcc does not remove the .o before forking 'as', which can be a
 # problem if you don't own the file but can write to the directory.
@@ -266,6 +274,8 @@
 #	sensor-nets/tags.o sensor-nets/sensor-query.o \
 #	sensor-nets/flood-agent.o \
 
+OBJ_CC += ../../tbevent.o 
+
 # what was here before is now in emulate/
 OBJ_C =
 
@@ -285,6 +295,10 @@
 	emulate/nat.o  \
 	emulate/iptap.o \
 	emulate/tcptap.o
+
+##### nse with event system
+OBJ_EMULATE_CC += ../../tbnexthop.o
+####
 
 OBJ_EMULATE_C = \
 	emulate/inet.o
diff -ru dist-ns-allinone-2.1b9/ns-2.1b9/apps/telnet.cc ns-allinone-2.1b9/ns-2.1b9/apps/telnet.cc
--- dist-ns-allinone-2.1b9/ns-2.1b9/apps/telnet.cc	Fri Aug 14 14:09:33 1998
+++ ns-allinone-2.1b9/ns-2.1b9/apps/telnet.cc	Sun Oct  6 21:54:17 2002
@@ -77,7 +77,7 @@
 {
         if (running_) {
 	        /* call the TCP advance method */
-		agent_->sendmsg(agent_->size());
+		agent_->sendmsg(1); // send 1 byte packets instead of 1460
 		/* reschedule the timer */
 		double t = next();
 		timer_.resched(t);
diff -ru dist-ns-allinone-2.1b9/ns-2.1b9/common/scheduler.cc ns-allinone-2.1b9/ns-2.1b9/common/scheduler.cc
--- dist-ns-allinone-2.1b9/ns-2.1b9/common/scheduler.cc	Wed Apr 10 16:43:49 2002
+++ ns-allinone-2.1b9/ns-2.1b9/common/scheduler.cc	Sun Oct  6 22:22:18 2002
@@ -31,24 +31,58 @@
  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
  * SUCH DAMAGE.
  *
- * @(#) $Header: /nfs/jade/vint/CVSROOT/ns-2/common/scheduler.cc,v 1.65 2002/04/10 20:37:46 haldar Exp $
+ * @(#) $Header: /nfs/jade/vint/CVSROOT/ns-2/common/scheduler.cc,v 1.69 2002/07/23 21:35:21 yuri Exp $
  */
 
 #ifndef lint
 static const char rcsid[] =
-    "@(#) $Header: /nfs/jade/vint/CVSROOT/ns-2/common/scheduler.cc,v 1.65 2002/04/10 20:37:46 haldar Exp $ (LBL)";
+    "@(#) $Header: /nfs/jade/vint/CVSROOT/ns-2/common/scheduler.cc,v 1.69 2002/07/23 21:35:21 yuri Exp $ (LBL)";
 #endif
 
 #include <stdlib.h>
 #include <limits.h>
+#include <math.h>
+
 #include "config.h"
 #include "scheduler.h"
 #include "packet.h"
+#ifdef USEEVENTS
+#include "tbevent.h"
+#endif
+
 
 #ifdef MEMDEBUG_SIMULATIONS
 #include "mem-trace.h"
 #endif
 
+#ifdef MEASURE_EVENT_RATE
+
+unsigned long long event_dispatch_counter;
+unsigned int events_per_sec_arr[70];
+
+#endif
+
+#ifdef GETTIME_TSC
+
+#define read_tsc()      \
+    ({ \
+        unsigned long low, high; \
+        asm volatile( \
+        ".byte 0x0f; .byte 0x31" \
+        : "=d" (high), "=a" (low)); \
+        ((unsigned long long)high << 32) | low; \
+    })
+
+#define TSC_FREQ     851.94
+#define TSC_COUNT_PERSEC (TSC_FREQ * 1000000)
+
+#endif
+
+#ifdef SCHED_DEBUG
+static Tcl_HashTable newevents;
+#endif
+
+
 Scheduler* Scheduler::instance_;
 scheduler_uid_t Scheduler::uid_ = 1;
 
@@ -59,6 +93,9 @@
 
 Scheduler::Scheduler() : clock_(SCHED_START), halted_(0)
 {
+#ifdef SCHED_DEBUG
+	  Tcl_InitHashTable( &newevents, TCL_ONE_WORD_KEYS );
+#endif
 }
 
 Scheduler::~Scheduler(){
@@ -76,11 +113,14 @@
  * is much harder (because we've lost all context about who did
  * the scheduling).
  */
-void Scheduler::schedule(Handler* h, Event* e, double delay)
+void 
+Scheduler::schedule(Handler* h, Event* e, double delay)
 {
 	// handler should ALWAYS be set... if it's not, it's a bug in the caller
 	if (!h) {
-		printf("Scheduler: attempt to schedule an event with a NULL handler.  Don't DO that.\n");
+		fprintf(stderr,
+			"Scheduler: attempt to schedule an event with a NULL handler."
+			"  Don't DO that.\n");
 		abort();
 	};
 	if (e->uid_ > 0) {
@@ -91,7 +131,9 @@
 	if (delay < 0) {
 		// You probably don't want to do this
 		// (it probably represents a bug in your simulation).
-		fprintf(stderr, "warning: ns Scheduler::schedule: scheduling event\n\twith negative delay (%f) at time %f.\n", delay, clock_);
+		fprintf(stderr, 
+			"warning: ns Scheduler::schedule: scheduling event\n\t"
+			"with negative delay (%f) at time %f.\n", delay, clock_);
 	}
 
 	if (uid_ < 0) {
@@ -104,6 +146,17 @@
 
 	e->time_ = t;
 	insert(e);
+#ifdef SCHED_DEBUG
+	int newentry = 0 ;
+	Tcl_HashEntry *he = Tcl_CreateHashEntry( &newevents,
+						 (char *)((unsigned int)e->uid_),
+						 &newentry );
+	if( newentry == 0 ) {
+	  fprintf(stderr, "e->uid_ = %d already present. error\n", (unsigned int)e->uid_);
+	} else {
+	  Tcl_SetHashValue( he, (char *)h );
+	}
+#endif
 }
 
 void
@@ -117,7 +170,7 @@
 	 * Patch by Thomas Kaemer <Thomas.Kaemer@eas.iis.fhg.de>.
 	 */
 	while (!halted_ && (p = deque())) {
-		dispatch(p);
+		dispatch(p, p->time_);
 	}
 }
 
@@ -133,11 +186,23 @@
 {
 	if (t < clock_) {
 		fprintf(stderr, "ns: scheduler going backwards in time from %f to %f.\n", clock_, t);
+		abort();
 	}
 
+#ifdef SCHED_DEBUG
+	Tcl_HashEntry *he = Tcl_FindHashEntry(&newevents, (char *)((unsigned int)p->uid_));
+	if( he ) {
+	  Tcl_DeleteHashEntry(he);
+	} else {
+	  fprintf(stderr, "error. couldnt find event with uid = %d\n", (unsigned int)p->uid_);
+	}
+#endif
 	clock_ = t;
 	p->uid_ = -p->uid_;	// being dispatched
 	p->handler_->handle(p);	// dispatch
+#ifdef MEASURE_EVENT_RATE
+	event_dispatch_counter++;
+#endif
 }
 
 void
@@ -161,7 +226,8 @@
 	void handle(Event* event);
 } at_handler;
 
-void AtHandler::handle(Event* e)
+void 
+AtHandler::handle(Event* e)
 {
 	AtEvent* at = (AtEvent*)e;
 	Tcl::instance().eval(at->proc_);
@@ -174,7 +240,8 @@
 	clock_ = SCHED_START;
 }
 
-int Scheduler::command(int argc, const char*const* argv)
+int 
+Scheduler::command(int argc, const char*const* argv)
 {
 	Tcl& tcl = Tcl::instance();
 	if (instance_ == 0)
@@ -220,7 +287,7 @@
 		if (strcmp(argv[1], "at") == 0 ||
 		    strcmp(argv[1], "cancel") == 0) {
 			Event* p = lookup(STRTOUID(argv[2]));
-      if (p != 0) {
+			if (p != 0) {
 				/*XXX make sure it really is an atevent*/
 				cancel(p);
 				AtEvent* ae = (AtEvent*)p;
@@ -286,7 +353,8 @@
 	}
 } class_list_sched;
 
-void ListScheduler::insert(Event* e)
+void 
+ListScheduler::insert(Event* e)
 {
 	double t = e->time_;
 	Event** p;
@@ -303,7 +371,8 @@
  * must free the event if necessary; this routine only removes
  * it from the scheduler queue.
  */
-void ListScheduler::cancel(Event* e)
+void 
+ListScheduler::cancel(Event* e)
 {
 	Event** p;
 	if (e->uid_ <= 0)	// event not in queue
@@ -316,7 +385,8 @@
 	e->uid_ = - e->uid_;
 }
 
-Event* ListScheduler::lookup(scheduler_uid_t uid)
+Event* 
+ListScheduler::lookup(scheduler_uid_t uid)
 {
 	Event* e;
 	for (e = queue_; e != 0; e = e->next_)
@@ -397,9 +467,9 @@
 Heap::heap_delete(void* elem)
 {
 	int	i;
-		if ((i = heap_member(elem)) == 0)
+	if ((i = heap_member(elem)) == 0)
 		return 0;
-		for (--i; i; i = parent(i)) {
+	for (--i; i; i = parent(i)) {
 		swap(i, parent(i));
 	}
 	(void) heap_extract_min();
@@ -485,9 +555,10 @@
 	void*	min;				  /* return value */
 	unsigned int	i;
 	unsigned int	l, r, x;
-		if (h_size == 0)
+
+	if (h_size == 0)
 		return 0;
-		min = h_elems[0].he_elem;
+	min = h_elems[0].he_elem;
 	h_elems[0] = h_elems[--h_size];
 // Heapify:
 	i = 0;
@@ -523,7 +594,8 @@
 	}
 } class_heap_sched;
 
-Event* HeapScheduler::lookup(scheduler_uid_t uid)
+Event* 
+HeapScheduler::lookup(scheduler_uid_t uid)
 {
 	Event* e;
 	
@@ -553,6 +625,8 @@
  *  Comm. of ACM, 31(10):1220-1227, Oct 1988
  */
 
+#define CALENDAR_HASH(t) ((int)fmod((t)/width_, nbuckets_))
+
 static class CalendarSchedulerClass : public TclClass {
 public:
 	CalendarSchedulerClass() : TclClass("Scheduler/Calendar") {}
@@ -561,212 +635,305 @@
 	}
 } class_calendar_sched;
 
-CalendarScheduler::CalendarScheduler() {
-	reinit(2, 1.0, 0.0);
-	resizeenabled_ = 1;
-	max_ = 0.0;
+CalendarScheduler::CalendarScheduler() : cal_clock_(clock_) {
+	reinit(4, 1.0, cal_clock_);
 }
 
 CalendarScheduler::~CalendarScheduler() {
+	// XXX free events?
 	delete [] buckets_;
 	qsize_ = 0;
+	stat_qsize_ = 0;
 }
 
-void CalendarScheduler::insert(Event* e)
+void 
+CalendarScheduler::insert(Event* e)
 {
+	int i;
+	if (cal_clock_ > e->time_) {
+		// may happen in RT scheduler
+		cal_clock_ = e->time_;
+		i = lastbucket_ = CALENDAR_HASH(cal_clock_);
+	} else
+		i = CALENDAR_HASH(e->time_);
+
+	Event *head = buckets_[i].list_;
+	Event *before=0;
+
+	if (!head) {
+		buckets_[i].list_ = e;
+		e->next_ = e->prev_ = e;
+		++stat_qsize_; 
+		++buckets_[i].count_;
+	} else {
+		bool newhead;
+		if (e->time_ >= head->prev_->time_) {
+			// insert at the tail
+			before = head;
+			newhead = false;
+		} else {
+			// insert event in time sorted order, FIFO for sim-time events
+			for (before = head; e->time_ >= before->time_; before = before->next_)
+				;
+			newhead = (before == head);
+		}
 
-	/* (e->time_ * oneonwidth) needs to be less than the
-	 * largest integer on the machine for the mapping
-	 * of time to bucket to work properly.  if it is not
-	 * we need to re-calculate the width.
-	 */
-	if (e->time_ > max_) {
-		max_ = e->time_;
-		if (e->time_ * oneonwidth_ > ULONG_MAX) {
-			resize(nbuckets_);
+		e->next_ = before;
+		e->prev_ = before->prev_;
+		before->prev_ = e;
+		e->prev_->next_ = e;
+		if (newhead) {
+			buckets_[i].list_ = e;
+			//assert(e->time_ <= e->next_->time_);
+		}
+		//assert(e->prev_ != e);
+		if (e->prev_->time_ != e->time_) {
+			// unique timing
+			++stat_qsize_; 
+			++buckets_[i].count_;
 		}
 	}
-	// bucket number and address
-	int i = (int)(((long)(e->time_ * oneonwidth_)) & buckbits_); 
-	Event** p = buckets_ + i;
-
-	// insert event in stable time sorted order
-	while ((*p != NULL) && (e->time_ >= (*p)->time_))
-		p = &(*p)->next_;
+	++qsize_;
+	//assert(e == buckets_[i].list_ ||  e->prev_->time_ <= e->time_);
+	//assert(e == buckets_[i].list_->prev_ || e->next_->time_ >= e->time_);
 
-	e->next_ = *p;
-	*p = e;
+  	if (stat_qsize_ > top_threshold_) {
+  		resize(nbuckets_ << 1, cal_clock_);
+		return;
+	}
+}
+
+void 
+CalendarScheduler::insert2(Event* e)
+{
+	// Same as insert, but for inserts e *before* any same-time-events, if
+	//   there should be any.  Since it is used only by CalendarScheduler::newwidth(),
+	//   some important checks present in insert() need not be performed.
 
-	if (++qsize_ > top_threshold_)
-		resize(nbuckets_<<1);
+	int i = CALENDAR_HASH(e->time_);
+	Event *head = buckets_[i].list_;
+	Event *before=0;
+	if (!head) {
+		buckets_[i].list_ = e;
+		e->next_ = e->prev_ = e;
+		++stat_qsize_; 
+		++buckets_[i].count_;
+	} else {
+		bool newhead;
+		if (e->time_ > head->prev_->time_) { //strict LIFO, so > and not >=
+			// insert at the tail
+			before = head;
+			newhead = false;
+		} else {
+			// insert event in time sorted order, LIFO for sim-time events
+			for (before = head; e->time_ > before->time_; before = before->next_)
+				;
+			newhead = (before == head);
+		}
+
+		e->next_ = before;
+		e->prev_ = before->prev_;
+		before->prev_ = e;
+		e->prev_->next_ = e;
+		if (newhead) {
+			buckets_[i].list_ = e;
+			//assert(e->time_ <= e->next_->time_);
+		}
+
+		if (e != e->next_ && e->next_->time_ != e->time_) {
+			// unique timing
+			++stat_qsize_; 
+			++buckets_[i].count_;
+		}
+	}
+	//assert(e == buckets_[i].list_ ||  e->prev_->time_ <= e->time_);
+	//assert(e == buckets_[i].list_->prev_ || e->next_->time_ >= e->time_);
+
+	++qsize_;
+	// no need to check resizing
 }
 
-Event*
-CalendarScheduler::deque()
+const Event*
+CalendarScheduler::head()
 {
 	if (qsize_ == 0)
 		return NULL;
-	for (;;) {
-		int i = lastbucket_;
-		
-		// check for an event this `year'
-		do {
-			Event* e = buckets_[i];
-			if ((e != NULL) && (e->time_ < buckettop_)) {
-				buckets_[i] = e->next_;
-				lastbucket_ = i;
-				last_clock_ = e->time_;
-				if (--qsize_ < bot_threshold_)
-					resize(nbuckets_>>1);
-				return e;
-			} else {
-				if (++i == nbuckets_) {
-					i = 0;
-				/* Brad Karp, karp@eecs.harvard.edu:
-				   at the end of each year, eliminate roundoff
-				   error in buckettop_ */
-					buckettop_ = prevtop_ + nbuckets_ * width_;
-					prevtop_ = buckettop_;
-					
-				} else {
-					buckettop_+= width_;
-				}
-			}
-		} while (i != lastbucket_);
-		
-		// or direct search for the minimum event
-		int pos = 0;
-		Event* min;
-		do {
-			min = buckets_[pos++];
-		} while (min == NULL);
-		pos--;
-		
-		int k;
-		for (k = pos+1; k < nbuckets_; k++) {
-			Event* e = buckets_[k];
-			if ((e != NULL) && (e->time_ < min->time_)) {
-				min = e; pos = k;
-			}
-		}
-		
-		// adjust year and resume
-		lastbucket_ = pos;
-		last_clock_ = min->time_;
-		unsigned long n = (unsigned long)(min->time_ * oneonwidth_);
-		buckettop_ = width_*(n+1.5);
-		prevtop_ = buckettop_ - lastbucket_ * width_;
+
+	int l, i = lastbucket_;
+	int lastbucket_dec = (lastbucket_) ? lastbucket_ - 1 : nbuckets_ - 1;
+	double diff;
+	Event *e, *min_e = NULL;
+#define CAL_DEQUEUE(x) 						\
+do { 								\
+	if ((e = buckets_[i].list_) != NULL) {			\
+		diff = e->time_ - cal_clock_;			\
+		if (diff < diff##x##_)	{			\
+			l = i;					\
+			goto found_l;				\
+		}						\
+		if (min_e == NULL || min_e->time_ > e->time_) {	\
+			min_e = e;				\
+			l = i;					\
+		}						\
+	}							\
+	if (++i == nbuckets_) i = 0;				\
+} while (0)
+		 
+	// CAL_DEQUEUE applied successively will find the event to
+	// dequeue (within one year) and keep track of the
+	// minimum-priority event seen so far; the argument controls
+	// the criteria used to decide whether the event should be
+	// considered `within one year'.  Importantly, the number of
+	// buckets should not be less than 4.
+	CAL_DEQUEUE(0); 
+	CAL_DEQUEUE(1); 
+	for (; i != lastbucket_dec; ) {
+		CAL_DEQUEUE(2);
+	}
+	// one last bucket is left unchecked - take the minimum
+	// [could have done CAL_DEQUEUE(3) with diff3_ = bwidth*(nbuck*3/2-1)]
+	e = buckets_[i].list_;
+	if (min_e != NULL && 
+	    (e == NULL || min_e->time_ < e->time_))
+		e = min_e;
+	else {
+		//assert(e);
+		l = i;
+	}
+ found_l:
+	//assert(buckets_[l].count_ >= 0);
+	//assert(buckets_[l].list_ == e);
+
+	/* l is the index of the bucket to dequeue, e is the event */
+	/* 
+	 * still want to advance lastbucket_ and cal_clock_ to save
+	 * time when deque() follows. 
+	 */
+	lastbucket_ = l;
+ 	cal_clock_  = e->time_;
+	
+	return e;
+}
+
+Event* 
+CalendarScheduler::deque()
+{
+	Event *e = const_cast<Event *>(head());
+
+	if (!e)
+		return 0;
+
+	int l = lastbucket_;
+
+	// update stats and unlink
+	if (e->next_ == e || e->next_->time_ != e->time_) {
+		--stat_qsize_;
+		//assert(stat_qsize_ >= 0);
+		--buckets_[l].count_;
+		//assert(buckets_[l].count_ >= 0);
+
 	}
-	//return deque();
+	--qsize_;
+
+	if (e->next_ == e)
+		buckets_[l].list_ = 0;
+	else {
+		e->next_->prev_ = e->prev_;
+		e->prev_->next_ = e->next_;
+		buckets_[l].list_ = e->next_;
+	}
+
+	e->next_ = e->prev_ = NULL;
+
+
+	//if (buckets_[l].count_ == 0)
+	//	assert(buckets_[l].list_ == 0);
+
+ 	if (stat_qsize_ < bot_threshold_) {
+		resize(nbuckets_ >> 1, cal_clock_);
+	}
+
+	return e;
 }
 
-void CalendarScheduler::reinit(int nbuck, double bwidth, double start)
+void 
+CalendarScheduler::reinit(int nbuck, double bwidth, double start)
 {
-	buckets_ = new Event*[nbuck];
-	memset(buckets_, 0, sizeof(Event*)*nbuck);
+	buckets_ = new Bucket[nbuck];
+
+	memset(buckets_, 0, sizeof(Bucket)*nbuck); //faster than ctor
+
 	width_ = bwidth;
-	oneonwidth_ = 1.0 / width_;
 	nbuckets_ = nbuck;
-	buckbits_ = nbuck-1;
 	qsize_ = 0;
-	last_clock_ = start;
-	long n = (long)(start * oneonwidth_);
-	lastbucket_ = n & buckbits_;
-	buckettop_ = width_*(n+1.5);
-	prevtop_ = buckettop_ - lastbucket_ * width_;
+	stat_qsize_ = 0;
+
+	lastbucket_ =  CALENDAR_HASH(start);
+
+	diff0_ = bwidth*nbuck/2;
+	diff1_ = diff0_ + bwidth;
+	diff2_ = bwidth*nbuck;
+	//diff3_ = bwidth*(nbuck*3/2-1);
+
 	bot_threshold_ = (nbuck >> 1) - 2;
 	top_threshold_ = (nbuck << 1);
 }
 
-void CalendarScheduler::resize(int newsize)
+void 
+CalendarScheduler::resize(int newsize, double start)
 {
-	if (!resizeenabled_) return;
+	double bwidth = newwidth(newsize);
+
+	if (newsize < 4)
+		newsize = 4;
 
-	double bwidth = newwidth();
-	Event** oldb = buckets_;
+	Bucket *oldb = buckets_;
 	int oldn = nbuckets_;
 
+	reinit(newsize, bwidth, start);
+
 	// copy events to new buckets
-	reinit(newsize, bwidth, clock_);
 	int i;
-	for (i = oldn-1; i >= 0; i--) {
-		Event* e = oldb[i];
-		while (e != NULL) {
-			Event* en = e->next_;
-			insert(e);
-			e = en;
+
+	for (i = 0; i < oldn; ++i) {
+		// we can do inserts faster, if we use insert2, but to
+		// preserve FIFO, we have to start from the end of
+		// each bucket and use insert2
+		if  (oldb[i].list_) {
+			Event *tail = oldb[i].list_->prev_;
+			Event *e = tail; 
+			do {
+				Event* ep = e->prev_;
+				e->next_ = e->prev_ = 0;
+				insert2(e);
+				e = ep;
+			} while (e != tail);
 		}
 	}
 	delete [] oldb;
 }
 
-#define MIN_WIDTH (1.0e-6)
-#define MAX_HOLD  25
-
+// take samples from the most populated bucket.
 double
-CalendarScheduler::newwidth()
+CalendarScheduler::newwidth(int newsize)
 {
-	static Event* hold[MAX_HOLD];
-	int nsamples;
-
-	if (qsize_ < 2) return 1.0;
-	if (qsize_ < 5) nsamples = qsize_;
-	else nsamples = 5 + qsize_ / 10;
-	if (nsamples > MAX_HOLD) nsamples = MAX_HOLD;
-
-	// dequue and requeue sample events to gauge width
-	double olp = clock_;
-	double olt = buckettop_;
-	int olb = lastbucket_;
-	double olbt = prevtop_;
-
-	resizeenabled_ = 0;
-	for (int i = 0; i < nsamples; i++) hold[i] = deque();
-	// insert in the inverse order and using insert2 to take care of same-time events.
-	for (int j = nsamples-1; j >= 0; j--) insert2(hold[j]);
-	resizeenabled_ = 1;
-
-	clock_ = olp;
-	buckettop_ = olt;
-	prevtop_ = olbt;
-	lastbucket_ = olb;
-
-	// try to work out average cluster separation
-	double asep = (hold[nsamples-1]->time_ - hold[0]->time_) / (nsamples-1);
-	double asep2 = 0.0;
-	//double min = (clock_ + 1.0) * MIN_WIDTH; 
-	int count = 0;
-
-	for (int k = 1; k < nsamples; k++) {
-		double diff = hold[k]->time_ - hold[k-1]->time_;
-		if (diff < 2.0*asep) { asep2 += diff; count++; }
-	}
-
-	// but don't let things get too small for numerical stability
-	//double nw = count ? 3.0*(asep2/count) : asep;
-	//if (nw < min) nw = min;
-
-	// if count==0, i.e if all samples are scheduled at the same time, we don't know better than to keep the old estimate
-	double nw;
-	if (count == 0) {
-		nw = width_;
-	} else {
-		nw = 3.0*asep2/count;
+	int i;
+	short max_bucket = 0; // index of the fullest bucket
+	for (i = 1; i < nbuckets_; ++i) {
+		if (buckets_[i].count_ > buckets_[max_bucket].count_)
+			max_bucket = i;
 	}
+	int nsamples = buckets_[max_bucket].count_;
 
-	/* need to make sure that time_/width_ can be represented as
-	 * an int.  see the comment at the start of insert().
-	 */
-	/* optimisation suggested by Yuri is to increase value of
-	 * new-width by a factor and leave some space for future events,
-	 * so that we won't be resizing the queue everytime e->time_ 
-	 * > max_. 
-	 */
-	   
-	if (max_/nw > ULONG_MAX) {
-		//nw = max_/ULONG_MAX;
-		nw = max_ * CALENDAR_ALPHA / ULONG_MAX;
-	}
+	if (nsamples <= 4) return width_;
+	
+	double nw = buckets_[max_bucket].list_->prev_->time_ 
+		- buckets_[max_bucket].list_->time_;
+	assert(nw > 0);
+	
+	nw /= ((newsize < nsamples) ? newsize : nsamples); // min (newsize, nsamples)
+	nw *= 4.0;
+	
 	return nw;
 }
 
@@ -776,77 +943,90 @@
  * must free the event if necessary; this routine only removes
  * it from the scheduler queue.
  *
- * xxx: we may cancel the last event and invalidate the value of max_
- * xxx: thus using wider buckets than really necessary
  */
-void CalendarScheduler::cancel(Event* e)
+void 
+CalendarScheduler::cancel(Event* e)
 {
-	int i = (int)(((long)(e->time_ * oneonwidth_)) & buckbits_);
-
 	if (e->uid_ <= 0)	// event not in queue
 		return;
-	for (Event** p = buckets_ + i; (*p) != NULL; p = &(*p)->next_)
-		if ((*p) == e) {
-			(*p) = (*p)->next_;
-			e->uid_ = - e->uid_;
-			qsize_--;
-			return; 
-		}
-	abort();
-}
 
-Event* CalendarScheduler::lookup(scheduler_uid_t uid)
-{
-	for (int i = 0; i < nbuckets_; i++)
-		for (Event* p = buckets_[i]; p != NULL; p = p->next_)
-			if (p->uid_== uid) return p;
-	return NULL;
-}
+	int i = CALENDAR_HASH(e->time_);
 
-void CalendarScheduler::insert2(Event* e)
-{
-	// Same as insert, but for inserts e *before* any same-time-events, if
-	//   there should be any.  Since it is used only by CalendarScheduler::newwidth(),
-	//   some important checks present in insert() need not be performed.
+	assert(e->prev_->next_ == e);
+	assert(e->next_->prev_ == e);
 
-	// bucket number and address
-	int i = (int)(((long)(e->time_ * oneonwidth_)) & buckbits_); 
-	Event** p = buckets_ + i;
-
-	// insert event in stable time sorted order
-	while ((*p != NULL) && (e->time_ > (*p)->time_)) // > instead of >=!
-		p = &(*p)->next_;
+	if (e->next_ == e || 
+	    (e->next_->time_ != e->time_ &&
+	    (e->prev_->time_ != e->time_))) { 
+		--stat_qsize_;
+		assert(stat_qsize_ >= 0);
+		--buckets_[i].count_;
+		assert(buckets_[i].count_ >= 0);
+	}
+
+	if (e->next_ == e) {
+		assert(buckets_[i].list_ == e);
+		buckets_[i].list_ = 0;
+	} else {
+		e->next_->prev_ = e->prev_;
+		e->prev_->next_ = e->next_;
+		if (buckets_[i].list_ == e)
+			buckets_[i].list_ = e->next_;
+	}
 
-	e->next_ = *p;
-	*p = e;
-	++qsize_;
+	if (buckets_[i].count_ == 0)
+		assert(buckets_[i].list_ == 0);
+
+	e->uid_ = -e->uid_;
+	e->next_ = e->prev_ = NULL;
+
+	--qsize_;
+
+	return;
+}
+
+Event * 
+CalendarScheduler::lookup(scheduler_uid_t uid)
+{
+	for (int i = 0; i < nbuckets_; i++) {
+		Event* head =  buckets_[i].list_;
+		Event* p = head;
+		if (p) {
+			do {
+				if (p->uid_== uid) 
+					return p;
+				p = p->next_;
+			} while (p != head);
+		}
+	}
+	return NULL;
 }
 
 #ifndef WIN32
 #include <sys/time.h>
 #endif
 
-/*
- * Really should instance the list/calendar/heap discipline
- * inside a RealTimeScheduler or VirtualTimeScheduler
- */
-
-#ifdef notyet
 class RealTimeScheduler : public CalendarScheduler {
-#endif
-
-class RealTimeScheduler : public ListScheduler {
 public:
 	RealTimeScheduler();
 	virtual void run();
 	double start() const { return start_; }
 	virtual void reset();
+#ifdef USEEVENTS
+	int command(int argc, const char*const* argv);
+#endif
 protected:
 	void sync() { clock_ = tod(); }
-	int rwait(double);	// sleep
 	double tod();
 	double slop_;	// allowed drift between real-time and virt time
 	double start_;	// starting time
+#ifdef USEEVENTS
+        TbEventSink *evsink_;
+#endif
+#ifdef GETTIME_TSC
+        unsigned long long basetsc_ ;
+        double  oneontscfreq_;
+#endif
 };
 
 static class RealTimeSchedulerClass : public TclClass {
@@ -860,16 +1040,51 @@
 RealTimeScheduler::RealTimeScheduler() : start_(0.0)
 {
 	bind("maxslop_", &slop_);
+#ifdef USEEVENTS
+        evsink_ = 0 ;
+#endif
+#ifdef GETTIME_TSC
+        basetsc_ = 0 ;
+	oneontscfreq_ = 1.0 / (double)TSC_COUNT_PERSEC;
+#endif
 }
 
+#ifdef USEEVENTS
+  
+int RealTimeScheduler::command(int argc, const char*const* argv)
+{
+  Tcl& tcl = Tcl::instance();
+  if (instance_ == 0)
+    instance_ = this;
+  
+  
+  if( argc == 3 ) {
+    if(strcmp(argv[1], "tbevent-sink") == 0) {
+      evsink_ = (TbEventSink *)TclObject::lookup(argv[2]);
+      return(TCL_OK);
+    }
+  }
+
+  return(Scheduler::command(argc, argv));
+}  
+
+#endif
+
 double
 RealTimeScheduler::tod()
 {
+#ifdef GETTIME_TSC
+                 
+        unsigned long long curtsc = read_tsc();
+        return (((double)(curtsc - basetsc_)) * oneontscfreq_);
+
+#else
 	timeval tv;
 	gettimeofday(&tv, 0);
 	double s = tv.tv_sec;
 	s += (1e-6 * tv.tv_usec);
 	return (s - start_);
+#endif
 }
 
 void
@@ -877,81 +1092,81 @@
 {
 	clock_ = SCHED_START;
 	start_ = tod();
+#ifdef GETTIME_TSC   
+        basetsc_ = read_tsc();
+#endif
 }
 
-void RealTimeScheduler::run()
+#ifdef SCHED_DEBUG
+int done = 0;
+#endif
+
+void 
+RealTimeScheduler::run()
 { 
-	Event *p;
-	double now;
+        static const double RTSCHEDULER_MINWAIT = 1.0e-3; // don't wait for less
+	const Event *p;
+
+#ifdef USEEVENTS
+
+	if( evsink_ ) {
+	  evsink_->init();
+	  evsink_->subscribe();
+	}
 
+#endif
 	/*XXX*/
 	instance_ = this;
 
 	while (!halted_) {
-		now = tod();
-		if ((now - clock_) > slop_) {
+		clock_ = tod();
+		p = head();
+		if (p && (clock_ - p->time_) > slop_) {
 			fprintf(stderr,
-			"RealTimeScheduler: warning: slop %f exceeded limit %f [now:%f, clock_:%f]\n",
-				now - clock_, slop_, now, clock_);
+				"RealTimeScheduler: warning: slop "
+				"%f exceeded limit %f [clock_:%f, p->time_:%f]\n",
+				clock_ - p->time_, slop_, clock_, p->time_);
 		}
+		// handle "old events"
+		while (p && p->time_ <= clock_) {
 
-		//
-		// first handle any "old events"
-		//
-		while ((p = deque()) != NULL && (p->time_ <= now)) {
-			dispatch(p);
-		}
-
-		//
-		// now handle a "future event", if there is one
-		//
-		if (p != NULL) {
-			int rval = rwait(p->time_);
-			if (rval < 0) {
-				fprintf(stderr, "RTScheduler: wait problem\n");
-				abort();
-			} else if (rval == 0) {
-				//
-				// proper time to dispatch sim event... do so
-				//
-				dispatch(p, clock_);
-			} else {
-				//
-				// there was a simulator event which fired, and
-				// may have added something to the queue, which
-				// could cause our event p to not be the next,
-				// so put p back into the event queue and cont
-				//
-				insert(p);
-			}
-			continue;
+			dispatch(deque(), clock_);
+			if (halted_)
+				return;
+			p = head();
+			clock_ = tod();
 		}
 
-		//
-		// no sim events to handle at all, check with tcl
-		//
-		sync();
-		Tcl_DoOneEvent(TCL_DONT_WAIT);
-	}
-
-	return;	// we reach here only if halted
-}
-
-/*
- * wait until the specified amount has elapsed, or a tcl event has happened,
- * whichever comes first.  Return 1 if a tcl event happened, 0 if the
- * deadline has been reached, or -1 on error (shouldn't happen).
- */
+#ifdef USEEVENTS
+		if( evsink_ && evsink_->poll() == 1 ) {
+		  continue;
+		}
+#endif
 
-int
-RealTimeScheduler::rwait(double deadline)
-{
-	while (1) {
-		sync();
-		if (Tcl_DoOneEvent(TCL_DONT_WAIT) == 1)
-			return (1);
-		if (deadline <= tod())
-			return 0;
+#ifdef SCHED_DEBUG
+		if( clock_ >= 240.0 && done == 0 ) {
+		  fprintf( stderr, "After 60 secs. Hash Stats for newevents = %s\n",
+			   Tcl_HashStats(&newevents) );
+		  done = 1;
+		}
+#endif
+		
+		if (!p) {
+			// blocking wait for TCL events
+		        Tcl_WaitForEvent(0); // no sim events, wait forever
+			clock_ = tod();
+		} else {
+			double diff = p->time_ - clock_;
+			// blocking wait only if there is enough time
+			if (diff > RTSCHEDULER_MINWAIT) {
+				Tcl_Time to;
+				to.sec = long(diff);
+				to.usec = long(1e6*(diff - to.sec));
+				Tcl_WaitForEvent(&to);    // block
+				clock_ = tod();
+			}
+		}
+		Tcl_DoOneEvent(TCL_DONT_WAIT);
 	}
-	return -1;
+	// we reach here only if halted
 }
diff -ru dist-ns-allinone-2.1b9/ns-2.1b9/common/scheduler.h ns-allinone-2.1b9/ns-2.1b9/common/scheduler.h
--- dist-ns-allinone-2.1b9/ns-2.1b9/common/scheduler.h	Wed Apr 10 16:43:49 2002
+++ ns-allinone-2.1b9/ns-2.1b9/common/scheduler.h	Sun Oct  6 23:48:29 2002
@@ -31,7 +31,7 @@
  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
  * SUCH DAMAGE.
  *
- * @(#) $Header: /nfs/jade/vint/CVSROOT/ns-2/common/scheduler.h,v 1.22 2002/04/10 20:37:46 haldar Exp $ (LBL)
+ * @(#) $Header: /nfs/jade/vint/CVSROOT/ns-2/common/scheduler.h,v 1.25 2002/07/23 21:35:21 yuri Exp $ (LBL)
  */
 
 #ifndef ns_scheduler_h
@@ -56,6 +56,7 @@
 class Event {
 public:
 	Event* next_;		/* event list */
+	Event* prev_;
 	Handler* handler_;	/* handler to call when event ready */
 	double time_;		/* time at which event is ready */
 	scheduler_uid_t uid_;	/* unique ID */
@@ -73,7 +74,6 @@
 };
 
 #define	SCHED_START	0.0	/* start time (secs) */
-#define CALENDAR_ALPHA  2.0    /* used for resizing bucket width incase of overflow */
 
 class Scheduler : public TclObject {
 public:
@@ -86,7 +86,8 @@
 	virtual void insert(Event*) = 0;	// schedule event
 	virtual Event* lookup(scheduler_uid_t uid) = 0;	// look for event
 	virtual Event* deque() = 0;		// next event (removes from q)
-	inline double clock() const {		// simulator virtual time
+	virtual const Event* head() = 0;	// next event (not removed from q)
+	double clock() const {			// simulator virtual time
 		return (clock_);
 	}
 	virtual void sync() {};
@@ -109,11 +110,13 @@
 
 class ListScheduler : public Scheduler {
 public:
-	inline ListScheduler() : queue_(0) {}
-	virtual void cancel(Event*);
-	virtual void insert(Event*);
-	virtual Event* deque();
-	virtual Event* lookup(scheduler_uid_t uid);
+	ListScheduler() : queue_(0) {}
+	void cancel(Event*);
+	void insert(Event*);
+	Event* deque();
+	const Event* head() { return queue_; }
+	Event* lookup(scheduler_uid_t uid);
+
 protected:
 	Event* queue_;
 };
@@ -122,18 +125,19 @@
 
 class HeapScheduler : public Scheduler {
 public:
-	inline HeapScheduler() { hp_ = new Heap; } 
-	virtual void cancel(Event* e) {
+	HeapScheduler() { hp_ = new Heap; } 
+	void cancel(Event* e) {
 		if (e->uid_ <= 0)
 			return;
 		e->uid_ = - e->uid_;
 		hp_->heap_delete((void*) e);
 	}
-	virtual void insert(Event* e) {
+	void insert(Event* e) {
 		hp_->heap_insert(e->time_, (void*) e);
 	}
-	virtual Event* lookup(scheduler_uid_t uid);
-	virtual Event* deque();
+	Event* lookup(scheduler_uid_t uid);
+	Event* deque();
+	const Event* head() { return (const Event *)hp_->heap_min(); }
 protected:
 	Heap* hp_;
 };
@@ -141,38 +145,37 @@
 class CalendarScheduler : public Scheduler {
 public:
 	CalendarScheduler();
-	virtual ~CalendarScheduler();
-	virtual void cancel(Event*);
-	virtual void insert(Event*);
-	virtual Event* lookup(scheduler_uid_t uid);
-	virtual Event* deque();
+	~CalendarScheduler();
+	void cancel(Event*);
+	void insert(Event*);
+	Event* lookup(scheduler_uid_t uid);
+	Event* deque();
+	const Event* head();
 
 protected:
-	int resizeenabled_;
 	double width_;
-	double oneonwidth_; /* this variable is always equal 1/width_
-			     * we use it for a speedup (mul is cheaper than div),
-			     * but we may also lose precision with it.
-			     */
-	double buckettop_;
-	double last_clock_;
-	double prevtop_;
+	double diff0_, diff1_, diff2_; /* wrap-around checks */
+
+	int stat_qsize_;		/* # of distinct priorities in queue*/
 	int nbuckets_;
-	int buckbits_;
 	int lastbucket_;
 	int top_threshold_;
 	int bot_threshold_;
 
-	Event** buckets_;
+	struct Bucket {
+		Event *list_;
+		int    count_;
+	} *buckets_;
+		
 	int qsize_;
-	double max_;
 
 	virtual void reinit(int nbuck, double bwidth, double start);
-	virtual void resize(int newsize);
-	virtual double newwidth();
+	virtual void resize(int newsize, double start);
+	virtual double newwidth(int newsize);
 
 private:
 	virtual void insert2(Event*);
+	double cal_clock_;  // same as clock in sims, may be different in RT-scheduling.
 
 };
 
diff -ru dist-ns-allinone-2.1b9/ns-2.1b9/common/tclAppInit.cc ns-allinone-2.1b9/ns-2.1b9/common/tclAppInit.cc
--- dist-ns-allinone-2.1b9/ns-2.1b9/common/tclAppInit.cc	Fri Aug  3 16:56:48 2001
+++ ns-allinone-2.1b9/ns-2.1b9/common/tclAppInit.cc	Sun Oct  6 21:54:17 2002
@@ -186,6 +186,7 @@
 	return TCL_OK;
 }
 
+#if 0
 #ifndef WIN32
 void
 abort()
@@ -200,6 +201,7 @@
 #endif /*abort*/
 	/*NOTREACHED*/
 }
+#endif
 #endif
 
 }
diff -ru dist-ns-allinone-2.1b9/ns-2.1b9/common/timer-handler.cc ns-allinone-2.1b9/ns-2.1b9/common/timer-handler.cc
--- dist-ns-allinone-2.1b9/ns-2.1b9/common/timer-handler.cc	Fri Sep 11 19:32:28 1998
+++ ns-allinone-2.1b9/ns-2.1b9/common/timer-handler.cc	Sun Oct  6 21:54:17 2002
@@ -76,3 +76,40 @@
 	if (status_ == TIMER_HANDLING)
 		status_ = TIMER_IDLE;
 }
+
+#ifdef MEASURE_EVENT_RATE
+
+extern unsigned long long event_dispatch_counter;
+
+unsigned int idx;
+
+#define MAX_EVENT_ARR 70
+
+// circular buffer for the data
+extern unsigned int events_per_sec_arr[MAX_EVENT_ARR];
+
+
+void EventRateTimer::expire(Event *e) {
+
+  if ( idx % MAX_EVENT_ARR == MAX_EVENT_ARR-1 ) {
+
+    events_per_sec_arr[idx % MAX_EVENT_ARR] = event_dispatch_counter;
+    event_dispatch_counter = 0;
+    idx++;
+    
+    int i = 0 ;
+    for( ; i < MAX_EVENT_ARR-1 ; i++ ) {
+      fprintf(stderr, "%u, ", events_per_sec_arr[i] );
+    }
+    fprintf(stderr, "%u\n", events_per_sec_arr[MAX_EVENT_ARR-1] );    
+  } else {
+  
+    events_per_sec_arr[idx % MAX_EVENT_ARR] = event_dispatch_counter;
+    event_dispatch_counter = 0;
+    idx++;
+  }
+  resched(1.0);    
+    
+}
+
+#endif
diff -ru dist-ns-allinone-2.1b9/ns-2.1b9/common/timer-handler.h ns-allinone-2.1b9/ns-2.1b9/common/timer-handler.h
--- dist-ns-allinone-2.1b9/ns-2.1b9/common/timer-handler.h	Thu Nov  2 15:46:37 2000
+++ ns-allinone-2.1b9/ns-2.1b9/common/timer-handler.h	Sun Oct  6 21:54:17 2002
@@ -88,4 +88,15 @@
 // mode:c++
 // End:
 
+#ifdef MEASURE_EVENT_RATE
+
+class EventRateTimer : public TimerHandler {
+
+public:
+  virtual void expire(Event *e) ;
+
+};
+
+#endif
+
 #endif /* timer_handler_h */
diff -ru dist-ns-allinone-2.1b9/ns-2.1b9/emulate/iptap.cc ns-allinone-2.1b9/ns-2.1b9/emulate/iptap.cc
--- dist-ns-allinone-2.1b9/ns-2.1b9/emulate/iptap.cc	Tue May 15 15:23:38 2001
+++ ns-allinone-2.1b9/ns-2.1b9/emulate/iptap.cc	Sun Oct  6 23:08:01 2002
@@ -37,21 +37,64 @@
 #endif
 
 #include "iptap.h"
+#include "net.h"
+#include <sys/time.h>
 
+#ifdef USEROUTES
+#include "tbnexthop.h"
+
+static IPTapAgent *iface_to_iptap[IFNAMSIZ+1];
+static Tcl_HashTable ip_to_iptap;
+
+#endif
+
+#ifdef MEASURE_EVENT_RATE
+#include "timer-handler.h"
+
+EventRateTimer ert;
+unsigned int firstpacket;
+#endif
+
+#ifdef USEROUTES
+#ifdef __cplusplus
+extern "C" {
+#endif
+#include        "tbdefs.h"
+#include        "log.h"
+
+#ifdef __cplusplus
+}
+#endif
+#endif
 
 static class IPTapAgentClass : public TclClass {
  public:
-	IPTapAgentClass() : TclClass("Agent/IPTap") {}
+	IPTapAgentClass() : TclClass("Agent/IPTap") {
+#ifdef USEROUTES
+	  Tcl_InitHashTable( &ip_to_iptap, TCL_ONE_WORD_KEYS );
+#endif
+	}
 	TclObject* create(int, const char*const*) {
 		return (new IPTapAgent());
 	}
 } class_iptap_agent;
 
 
-IPTapAgent::IPTapAgent() 
+IPTapAgent::IPTapAgent()
+#ifdef MEASURE_DELAYS  
+                        :  firstpkt_in_burst(false),
+			   max_delay(0.0), bpf_ts_to_iptap_max_delay(0.0),
+			   bpf_ts_to_iptap_min_delay(100.0), data_idx(0)
+#endif
 {
   int i = 0;
   index = 0;
+#ifdef MEASURE_DELAYS
+  memset( bpf_ts_to_iptap, 0, sizeof(bpf_ts_to_iptap));
+#endif
+#ifdef USEROUTES
+  iface_index = 0;
+#endif
   for (; i < MAX_PACKETS ; i++) {
     ident[i] = -1;
     offset[i] = -1;
@@ -120,20 +163,21 @@
   
 }
 
+void
+IPTapAgent::pkt_handler(void *clientdata, Packet *p, const struct timeval &ts)
+{
+  IPTapAgent *inst = (IPTapAgent *)clientdata;
+  inst->processpkt(p, ts);
+}
+
+//#define MAX(a,b) ((a)>(b)?(a):(b))
+
+
 
-/*
- * ns scheduler calls TapAgent::dispatch which calls recvpkt.
- * 
- * recvpkt then calls the network (net_) to receive a packet from 
- * the bpf. Once it has the packet, it populates the ns packet ttl 
- * value and inject it into the simulator by calling target_->recv
- * 
- */
 void
-IPTapAgent::recvpkt()
+IPTapAgent::processpkt(Packet *p, const struct timeval &ts)
 {
   struct ip *ipheader;
-  struct tcphdr *tcpheader;
   unsigned char *buf;
   
   /* Ip header information from the grabbed packet. */
@@ -143,45 +187,39 @@
   
   /* TCP header info from the grabbed packet. */
   unsigned char tcphlen;
-  
-  if (net_->mode() != O_RDWR && net_->mode() != O_RDONLY) {
-    fprintf(stderr,
-	    "IPTapAgent(%s): recvpkt called while in write-only mode!\n",
-	    name());
-    return;
-  }
-  
-  if (maxpkt_ <= 0) {
-    fprintf(stderr,
-	    "IPTapAgent(%s): recvpkt: maxpkt_ value too low (%d)\n",
-	    name(), maxpkt_);
-    return;
-  }
-  
 
-  // allocate packet and a data payload
-  Packet* p = allocpkt(maxpkt_);
+#ifdef MEASURE_DELAYS
 
-  // fill up payload
-  sockaddr addr;	// not really used (yet)
-  double tstamp;
-  int cc = net_->recv(p->accessdata(), maxpkt_, addr, tstamp);
-  if (cc <= 0) {
-    if (cc < 0) {
-      perror("recv");
-    }
-    Packet::free(p);
-    return;
-  }
-  TDEBUG4("%f: IPTapAgent(%s): recvpkt, cc:%d\n", now(), name(), cc);
+  // This code keeps some delay data and drops the packet 
+  if( firstpkt_in_burst ) {
+    ts_firstpkt_in_burst = ts.tv_sec + ts.tv_usec * 1e-6 ;
+    firstpkt_in_burst = false;
+  }
+  timeval tv;
+  gettimeofday(&tv, 0);
+  double nowts = tv.tv_sec + (1e-6 * tv.tv_usec);
+  max_delay = MAX(nowts - ts_firstpkt_in_burst, max_delay);
+  bpf_ts_to_iptap[data_idx] = nowts - (ts.tv_sec + ts.tv_usec * 1e-6);
+  bpf_ts_to_iptap_max_delay = MAX(bpf_ts_to_iptap[data_idx],
+			      bpf_ts_to_iptap_max_delay);
+  bpf_ts_to_iptap_min_delay = MIN(bpf_ts_to_iptap[data_idx],
+			      bpf_ts_to_iptap_min_delay);
+  data_idx = (data_idx+1) %
+    (sizeof(bpf_ts_to_iptap)/sizeof(bpf_ts_to_iptap[0]));
 
-  /* 
-     At this point, all I have to do is to grab the ttl value 
-     from the received packet and put it in p's ttl field after
-     decrementing it. It's ok, if we don't recalculate the checksum
-     of the actual packet, because we'll do it at the end anyways.
-  */
+  Packet::free(p);
+  return;
+  
+#endif
 
+#ifdef MEASURE_EVENT_RATE
+  // schedule the event rate 
+  if ( firstpacket == 0 ) {
+    ert.sched(1.0);
+    firstpacket++;
+  }
+#endif
+  
   ipheader = (struct ip *) p->accessdata();
   buf = p->accessdata();
   iphlen = ipheader->ip_hl * 4;
@@ -193,12 +231,6 @@
     return;
   }
 
-  /* Discard if duplicate. */
-  if (isDuplicate(ntohs(ipheader->ip_id), ntohs(ipheader->ip_off))) {
-    Packet::free(p);
-    return;
-  }
-  
   datagramlen = ntohs(ipheader->ip_len);
 
   /* Put all the info in the ns headers. */
@@ -208,13 +240,146 @@
   hdr_ip *ih = HDR_IP(p);
   ih->ttl() = ttl;
 
+#ifdef USEROUTES
+  /* code to look up the interface index
+     over which we should spit out the
+     packet. with this interface index, we
+     find the iptap which is attached on
+     the corresponding simulated node from
+     where the packet will be spit out.
+     This ensures that the packet traverses
+     the simulated network and is spit out
+     into the real world from the right place
+  */
+  uint16_t dst_iface_index = 0;
+  //dst.s_addr = (u_int32_t)ntohl(ipheader->ip_dst.s_addr);
+
+  int newentry = 0;
+  // finds an entry if it exists, else creates a new one
+  Tcl_HashEntry *he = Tcl_CreateHashEntry( &ip_to_iptap,
+					   (char *)(ipheader->ip_dst.s_addr),
+					   &newentry );  
+  IPTapAgent *dst_agent = 0;
+  
+  // entry exists
+  if( newentry == 0 ) {
+
+    dst_agent = (IPTapAgent *)Tcl_GetHashValue(he);
+
+  } else { // entry was newly created and we need to lookup routing table
+    
+    if( (dst_iface_index = get_nexthop_if(ipheader->ip_dst)) != 0 ) {
+      dst_agent = iface_to_iptap[dst_iface_index];
+    }
+    Tcl_SetHashValue( he, (char *)dst_agent);
+
+  }
+
+  if( dst_agent ) {
+    ih->daddr() = dst_agent->addr();
+    ih->dport() = dst_agent->port();
+    goto injectsim;
+  } 
+  
+ /* if we fail to map a dest iptap object, we drop the packet */
+  fprintf( stderr, "dropping packet with ipaddr:%s at %f with iface_idx:%d\n",
+	   inet_ntoa(ipheader->ip_dst), Scheduler::instance().clock(), dst_iface_index );
+  drop(p);
+  return;
+  
+ injectsim:  
+#endif
+
   // inject into simulator
   target_->recv(p);
   return;
 }
 
 
+/*
+ * ns scheduler calls TapAgent::dispatch which calls recvpkt.
+ * 
+ * recvpkt then calls the network (net_) to receive a packet from 
+ * the bpf. Once it has the packet, it populates the ns packet ttl 
+ * value and inject it into the simulator by calling target_->recv
+ * 
+ */
+void
+IPTapAgent::recvpkt()
+{
+  struct ip *ipheader;
+  struct tcphdr *tcpheader;
+  unsigned char *buf;
+  
+  /* Ip header information from the grabbed packet. */
+  int iphlen;  
+  unsigned short datagramlen;
+  unsigned char ttl;
+  
+  /* TCP header info from the grabbed packet. */
+  unsigned char tcphlen;
 
+  if (net_incoming_->mode() != O_RDWR && net_incoming_->mode() != O_RDONLY) {
+    fprintf(stderr,
+	    "IPTapAgent(%s): recvpkt called while in write-only mode!\n",
+	    name());
+    return;
+  }
+  
+  // Should be Net/Pcap/Live. This calls back pkt_handler
+  // for every packet it sees in the pcap buffer
+#ifdef MEASURE_DELAYS
+  firstpkt_in_burst = true;
+#endif
+  int cc = net_incoming_->recv(pkt_handler, this);
+  if (cc <= 0) {
+    if (cc < 0) {
+      perror("recv");
+    }
+    return;
+  }
+  TDEBUG4("%f: IPTapAgent(%s): recvpkt, cc:%d\n", now(), name(), cc);
+
+  // nothing to do coz pkt_handler would have called processpkt()
+  // that would have injected packets into the simulator
+}
+
+#ifdef USEROUTES
+  
+int
+IPTapAgent::command(int argc, const char*const* argv)
+{
+	Tcl& tcl = Tcl::instance();
+
+	if (argc == 2) {
+#if MEASURE_DELAYS
+	  if( strcmp(argv[1], "print_delays") == 0 ) {
+	    printf("object %s : max_delay = %g "
+		   "bpf_ts_to_iptap_max_delay = %g "
+		   "bpf_ts_to_iptap_min_delay = %g\n",
+		   name(), max_delay, bpf_ts_to_iptap_max_delay,
+		   bpf_ts_to_iptap_min_delay);
+	    for( int i=0; i<sizeof(bpf_ts_to_iptap)/sizeof(bpf_ts_to_iptap[0]) ; i++ )
+	      printf("%.10f ", bpf_ts_to_iptap[i]);
+	    printf("\n");
+	    return (TCL_OK);
+	  }
+#endif
+	} else if (argc == 3) {
+		if (strcmp(argv[1], "network-incoming") == 0) {
+			PcapNetwork *net_in_ = (PcapNetwork *)TclObject::lookup(argv[2]);
+			if (net_in_ != 0) {
+			  iface_index = if_nametoindex( net_in_->srcname() ) ;
+			  if( iface_index > 0 && iface_index <= IFNAMSIZ ) {
+			    iface_to_iptap[iface_index] = this;
+			  }
+			}
+		}
+	}
+	return (TapAgent::command(argc, argv));
+}
+
+#endif
 
 /*
  * simulator schedules TapAgent::recv which calls sendpkt
@@ -231,23 +396,24 @@
   unsigned short dglen;
   struct ip *ipheader;
 
-  if (net_->mode() != O_RDWR && net_->mode() != O_WRONLY) {
+  if (net_outgoing_ == NULL) {
     fprintf(stderr,
-	    "IPTapAgent(%s): sendpkt called while in read-only mode!\n",
+	    "IPTapAgent(%s): sendpkt attempted with NULL net\n",
 	    name());
+    drop(p);
     return (-1);
   }
-  
-  // send packet into the live network
-  hdr_cmn* hc = HDR_CMN(p);
-  if (net_ == NULL) {
+
+  if (net_outgoing_->mode() != O_RDWR && net_outgoing_->mode() != O_WRONLY) {
     fprintf(stderr,
-	    "IPTapAgent(%s): sendpkt attempted with NULL net\n",
+	    "IPTapAgent(%s): sendpkt called while in read-only mode!\n",
 	    name());
-    drop(p);
     return (-1);
   }
   
+  // send packet into the live network
+  hdr_cmn* hc = HDR_CMN(p);
+  
   /*
     At this point, we should grab the ttl field from the ns
     packet, put it in the IP header of the actual packet,
@@ -277,13 +443,29 @@
   ipheader->ip_sum = (unsigned short) in_cksum((unsigned short *) ipheader,
 						sizeof(struct ip));
 
-  if (net_->send(p->accessdata(), hc->size()) < 0) {
+  /**** DONT NEED THE FOLLOWING CODE IF WE USE APPROPRIATE PCAP FILTERS
+	THAT HAVE "not ether src xx:xx:xx:xx:xx:xx" in it           ****/
+  // we need to store this packet so that we don't pick it up again
+  //  ident[index % MAX_PACKETS] = ntohs(ipheader->ip_id);
+  //  offset[index % MAX_PACKETS] = ntohs(ipheader->ip_off);
+  //  index++;  
+  
+  if (net_outgoing_->send(p->accessdata(), hc->size()) < 0) {
     fprintf(stderr,
 	    "IPTapAgent(%s): sendpkt (%p, %d): %s\n",
 	    name(), p->accessdata(), hc->size(), strerror(errno));
+    Packet::free(p); // memory leak fix from 2.1b8a 
     return (-1);
     
   }
+
+#if 0
+  if( hc->size() < 50 ) {
+    fprintf( stderr, "sent pkt %d\n", hc->size());
+  }
+#endif
+  
+  Packet::free(p); // memory leak fix from 2.1b8a 
   TDEBUG3("IPTapAgent(%s): sent packet (sz: %d)\n",
 	  name(), hc->size());
   return 0;
diff -ru dist-ns-allinone-2.1b9/ns-2.1b9/emulate/iptap.h ns-allinone-2.1b9/ns-2.1b9/emulate/iptap.h
--- dist-ns-allinone-2.1b9/ns-2.1b9/emulate/iptap.h	Fri Jan 11 15:06:09 2002
+++ ns-allinone-2.1b9/ns-2.1b9/emulate/iptap.h	Sun Oct  6 23:07:23 2002
@@ -38,29 +38,54 @@
 
 #include "tap.h"
 #include <netinet/in.h>
+#include <netinet/in_systm.h>
 #include <netinet/ip.h>
 #include <netinet/tcp.h>
 #include <sys/socket.h>
 #include "tcp.h"
 #include "ip.h"
 
-#define MAX_PACKETS 640
+#ifdef USEROUTES
+#include <net/if.h>
+#include "tb_routelookup.h"
+#endif
 
+#define MAX_PACKETS 640
 
 class IPTapAgent : public TapAgent {
 
  public:
   IPTapAgent();
+#ifdef USEROUTES
+  int command(int, const char*const*);
+#endif
 
  private:
   int ident[MAX_PACKETS];      /* All three used for duplicate */
   int offset[MAX_PACKETS];     /* packet detection. */
   int index;
+#ifdef USEROUTES
+  uint16_t iface_index;
+#endif
+#ifdef MEASURE_DELAYS
+  bool firstpkt_in_burst;
+  double ts_firstpkt_in_burst;
+#endif  
 
   unsigned short in_cksum(unsigned short *,int);
   void recvpkt();
   int sendpkt(Packet*);
   int isDuplicate(unsigned short, unsigned short);
+  void processpkt(Packet *, const struct timeval &);
+  static void pkt_handler(void *, Packet *, const struct timeval &);
+
+#ifdef MEASURE_DELAYS  
+  double max_delay;
+  double bpf_ts_to_iptap_max_delay;
+  double bpf_ts_to_iptap_min_delay;
+  int data_idx;
+  double bpf_ts_to_iptap[80000];
+#endif  
 };
 
 #endif /* iptap_h */
diff -ru dist-ns-allinone-2.1b9/ns-2.1b9/emulate/net-pcap.cc ns-allinone-2.1b9/ns-2.1b9/emulate/net-pcap.cc
--- dist-ns-allinone-2.1b9/ns-2.1b9/emulate/net-pcap.cc	Fri Sep 21 11:55:34 2001
+++ ns-allinone-2.1b9/ns-2.1b9/emulate/net-pcap.cc	Sun Oct  6 23:04:43 2002
@@ -57,92 +57,25 @@
 
 #ifdef __cplusplus
 extern "C" {
+#if !defined(__FreeBSD__)
 #include <pcap/pcap.h>
+#else
+#include <pcap.h>
+#endif
 }
 #else
+#if !defined(__FreeBSD__)
 #include <pcap/pcap.h>
+#else
+#include <pcap.h>
+#endif
 #endif
 
 #include "config.h"
 #include "scheduler.h"
 #include "net.h"
 #include "tclcl.h"
-
-/*
- * observations about pcap library
- *	device name is in the ifreq struct sense, should be doc'd
- *	pcap_lookupdev returns a ptr to static data
- *	q: does lookupdev only return devs in the AF_INET addr family?
- *	why does pcap_compile require a netmask? seems odd
- *	would like some way to tell it what buffer to use
- *	arriving packets have the link layer hdr at the beginning, doc
- *	not convenient/possible to open bpf read/write
- *	no real way to know what file (/dev/bpf?) it is using
- *		would be nice if pcap_lookdev helped out more by
- *		returning ifnet or ifreq or whatever structure
- *	pcap_lookupnet makes calls to get our addr, but
- *		then tosses it anyhow, should get us addr and netmask
- *	interface type codes could be via rfc1573
- *		see freebsd net/if_types.h
- *	want a way to set immed mode
- *	pcap_next masks errors by returning 0 if pcap_dispatch fails
- *	a pcap_t carries it's own internal buffer, and
- *		_dispatch gives pointers into it when invoked [eek]
- *	when you open pcap using a file, pcap_fileno always
- *		returns -1; not so convenient
- *	
- */
-
-#define	PNET_PSTATE_INACTIVE	0
-#define	PNET_PSTATE_ACTIVE	1
-
-//
-// PcapNetwork: a "network" (source or possibly sink of packets)
-//	this is a base class only-- the derived classes are:
-//	PcapLiveNetwork [a live net; currently bpf + ethernet]
-//	PcapFileNetwork [packets from a tcpdump-style trace file]
-//
-
-class PcapNetwork : public Network {
-
-public:
-	PcapNetwork() : t_firstpkt_(0.0),
-		pfd_(-1), pcnt_(0), local_netmask_(0) { }
-	int rchannel() { return(pfd_); }
-	int schannel() { return(pfd_); }
-	virtual int command(int argc, const char*const* argv);
-
-	virtual int open(int mode, const char *) = 0;
-	virtual int skiphdr() = 0;
-	virtual double gents(pcap_pkthdr*) = 0;		// generate timestamp
-	int recv(u_char *buf, int len, sockaddr&, double&); // get from net
-	int send(u_char *buf, int len);			// write to net
-	void close();
-	void reset();
-
-	int filter(const char*);	// compile + install a filter
-	int stat_pkts();
-	int stat_pdrops();
-
-	double offset_;			// time offset to 1st pkt in a trace
-	double t_firstpkt_;		// ts of 1st pkt recvd
-
-protected:
-	static void phandler(u_char* u, const pcap_pkthdr* h, const u_char* p);
-	virtual void bindvars() = 0;
-
-	char errbuf_[PCAP_ERRBUF_SIZE];		// place to put err msgs
-	char srcname_[PATH_MAX];		// device or file name
-	int pfd_;				// pcap fd
-	int pcnt_;				// # pkts counted
-	int state_;				// PNET_PSTATE_xxx (above)
-	int optimize_;				// bpf optimizer enable
-	pcap_t* pcap_;				// reference to pcap state
-	struct bpf_program bpfpgm_;		// generated program
-	struct pcap_stat pcs_;			// status
-
-	unsigned int local_netmask_;	// seems shouldn't be necessary :(
-};
+#include "packet.h"
 
 //
 // PcapLiveNetwork: a live network tap
@@ -187,7 +120,7 @@
 private:
 	// XXX somewhat specific to bpf-- this stuff is  a hack until pcap
 	// can be fixed to allow for opening the bpf r/w
-#ifdef MT_OWN_PCAP
+#ifdef MY_OWN_PCAP
 	pcap_t * pcap_open_live(char *, int slen, int prom, int, char *, int);
 	int bpf_open(pcap_t *p, char *errbuf, int how);
 #endif
@@ -307,6 +240,12 @@
         const u_char *pkt;
 };   
 
+struct pcap_singleton_callback {
+        netpkt_handler callback;
+        void *clientdata;
+        PcapNetwork *net;
+};   
+
 void
 PcapNetwork::phandler(u_char* userdata, const pcap_pkthdr* ph, const u_char* pkt)
 {
@@ -315,10 +254,50 @@
 	ps->pkt = (u_char*)pkt;
 }
 
+bool small_recd = false;
+
+void
+PcapNetwork::phandler_callback(u_char* userdata, const pcap_pkthdr* ph, const u_char* pkt)
+{
+	pcap_singleton_callback *ps = (pcap_singleton_callback*) userdata;	
+
+	Packet *p = Packet::alloc(ph->caplen);
+	PcapNetwork *inst = ps->net;
+	
+	if (++(inst->pcnt_) == 1) {
+		// mark time stamp of first pkt
+		inst->t_firstpkt_ = ph->ts.tv_sec + ph->ts.tv_usec * 0.000001;
+	}
+
+	// link layer header will be placed at the beginning from pcap
+	int s = inst->skiphdr();	// go to IP header
+	memcpy(p->accessdata(), pkt + s, ph->caplen - s);
+
+	ps->callback(ps->clientdata, p, ph->ts);
+}
+
 int
-PcapNetwork::recv(u_char *buf, int len, sockaddr& /*fromaddr*/, double &ts)
+PcapNetwork::recv(netpkt_handler callback, void *clientdata)
 {
+	if (state_ != PNET_PSTATE_ACTIVE) {
+		fprintf(stderr, "warning: net/pcap obj(%s) read-- not active\n",
+			name());
+		return -1;
+	}
+
+	int pktcnt = -1;		// all in buffer, or until error
+	int np;			// counts # of pkts dispatched
+	pcap_singleton_callback ps = { callback, clientdata, this };
+	
+	np = pcap_dispatch(pcap_, pktcnt, phandler_callback, (u_char *)&ps);
+
+	//assert( pcap_->cc == 0 );
+	return np;
+}
 
+int
+PcapNetwork::recv(u_char *buf, int len, sockaddr& /*fromaddr*/, double &ts)
+{
 	if (state_ != PNET_PSTATE_ACTIVE) {
 		fprintf(stderr, "warning: net/pcap obj(%s) read-- not active\n",
 			name());
@@ -356,7 +335,7 @@
 		// mark time stamp of first pkt
 		t_firstpkt_ = ph->ts.tv_sec + ph->ts.tv_usec * 0.000001;
 	}
-
+	
 	int n = MIN(ph->caplen, (unsigned)len);
 	ts = gents(ph);	// mark with timestamp
 	// link layer header will be placed at the beginning from pcap
@@ -489,6 +468,19 @@
 				"warning: pcap/live (%s) couldn't set immed\n",
 				name());
 			perror("ioctl(BIOCIMMEDIATE)");
+		}
+		if (ioctl(pfd_, BIOCFLUSH, 0) < 0) {
+			fprintf(stderr,
+				"warning: pcap/live (%s) couldn't flush bpf buffer\n",
+				name());
+			perror("ioctl(BIOCFLUSH)");
+		}
+		int seesent = 0;
+		if (ioctl(pfd_, BIOCSSEESENT, &seesent) < 0) {
+			fprintf(stderr,
+				"warning: pcap/live (%s) couldn't reset BIOCGSEESENT\n",
+				name());
+			perror("ioctl(BIOCGSEESENT)");
 		}
 	}
 #endif
diff -ru dist-ns-allinone-2.1b9/ns-2.1b9/emulate/net.h ns-allinone-2.1b9/ns-2.1b9/emulate/net.h
--- dist-ns-allinone-2.1b9/ns-2.1b9/emulate/net.h	Fri May 22 20:44:57 1998
+++ ns-allinone-2.1b9/ns-2.1b9/emulate/net.h	Sun Oct  6 23:06:56 2002
@@ -49,12 +49,16 @@
 #undef interface
 #endif
 
+class Packet;
+typedef void (*netpkt_handler)(void *userdata, Packet *p, const struct timeval &ts);
+
 class Network : public TclObject {
 public:
 	Network() : mode_(-1) { }
 	virtual int command(int argc, const char*const* argv);
 	virtual int send(u_char* buf, int len) = 0;
 	virtual int recv(u_char* buf, int len, sockaddr& from, double& ts) = 0;
+	virtual int recv(netpkt_handler callback, void *clientdata) {} // callback called for every packet
 	virtual int rchannel() = 0;
 	virtual int schannel() = 0;
 	int mode() { return mode_; }
@@ -63,5 +67,105 @@
 	static char* modename(int);	    // and the reverse
 protected:
 	int mode_;	// read/write bits (from fcntl.h)
+};
+
+#ifdef __cplusplus
+extern "C" {
+#if !defined(__FreeBSD__)
+#include <pcap/pcap.h>
+#else
+#include <pcap.h>
+#endif
+}
+#else
+#if !defined(__FreeBSD__)
+#include <pcap/pcap.h>
+#else
+#include <pcap.h>
+#endif
+#endif
+
+#include <sys/param.h>
+
+/*
+ * observations about pcap library
+ *	device name is in the ifreq struct sense, should be doc'd
+ *	pcap_lookupdev returns a ptr to static data
+ *	q: does lookupdev only return devs in the AF_INET addr family?
+ *	why does pcap_compile require a netmask? seems odd
+ *	would like some way to tell it what buffer to use
+ *	arriving packets have the link layer hdr at the beginning, doc
+ *	not convenient/possible to open bpf read/write
+ *	no real way to know what file (/dev/bpf?) it is using
+ *		would be nice if pcap_lookdev helped out more by
+ *		returning ifnet or ifreq or whatever structure
+ *	pcap_lookupnet makes calls to get our addr, but
+ *		then tosses it anyhow, should get us addr and netmask
+ *	interface type codes could be via rfc1573
+ *		see freebsd net/if_types.h
+ *	want a way to set immed mode
+ *	pcap_next masks errors by returning 0 if pcap_dispatch fails
+ *	a pcap_t carries it's own internal buffer, and
+ *		_dispatch gives pointers into it when invoked [eek]
+ *	when you open pcap using a file, pcap_fileno always
+ *		returns -1; not so convenient
+ *	
+ */
+
+#define	PNET_PSTATE_INACTIVE	0
+#define	PNET_PSTATE_ACTIVE	1
+
+//
+// PcapNetwork: a "network" (source or possibly sink of packets)
+//	this is a base class only-- the derived classes are:
+//	PcapLiveNetwork [a live net; currently bpf + ethernet]
+//	PcapFileNetwork [packets from a tcpdump-style trace file]
+//
+
+class PcapNetwork : public Network {
+
+public:
+	PcapNetwork() : t_firstpkt_(0.0),
+		pfd_(-1), pcnt_(0), local_netmask_(0) { }
+	int rchannel() { return(pfd_); }
+	int schannel() { return(pfd_); }
+	virtual int command(int argc, const char*const* argv);
+
+	virtual int open(int mode, const char *) = 0;
+	virtual int skiphdr() = 0;
+	virtual double gents(pcap_pkthdr*) = 0;		// generate timestamp
+	int recv(u_char *buf, int len, sockaddr&, double&); // get from net
+	int recv(netpkt_handler callback, void *clientdata); // get from net
+	int send(u_char *buf, int len);			// write to net
+	void close();
+	void reset();
+
+	int filter(const char*);	// compile + install a filter
+	int stat_pkts();
+	int stat_pdrops();
+
+	double offset_;			// time offset to 1st pkt in a trace
+	double t_firstpkt_;		// ts of 1st pkt recvd
+
+#ifdef USEROUTES
+        inline char *srcname() { return(srcname_); }
+#endif
+
+protected:
+	static void phandler(u_char* u, const pcap_pkthdr* h, const u_char* p);
+	static void phandler_callback(u_char* u, const pcap_pkthdr* h, const u_char* p);
+	virtual void bindvars() = 0;
+
+	char errbuf_[PCAP_ERRBUF_SIZE];		// place to put err msgs
+	char srcname_[PATH_MAX];		// device or file name
+	int pfd_;				// pcap fd
+	int pcnt_;				// # pkts counted
+	int state_;				// PNET_PSTATE_xxx (above)
+	int optimize_;				// bpf optimizer enable
+	pcap_t* pcap_;				// reference to pcap state
+	struct bpf_program bpfpgm_;		// generated program
+	struct pcap_stat pcs_;			// status
+
+	unsigned int local_netmask_;	// seems shouldn't be necessary :(
 };
 #endif
diff -ru dist-ns-allinone-2.1b9/ns-2.1b9/emulate/tap.cc ns-allinone-2.1b9/ns-2.1b9/emulate/tap.cc
--- dist-ns-allinone-2.1b9/ns-2.1b9/emulate/tap.cc	Tue May 15 15:19:27 2001
+++ ns-allinone-2.1b9/ns-2.1b9/emulate/tap.cc	Sun Oct  6 21:54:17 2002
@@ -46,7 +46,7 @@
 	}
 } class_tap_agent;
 
-TapAgent::TapAgent() : Agent(PT_LIVE), net_(NULL)
+TapAgent::TapAgent() : Agent(PT_LIVE), net_outgoing_(NULL), net_incoming_(NULL)
 {
 	bind("maxpkt_", &maxpkt_);
 }
@@ -55,11 +55,11 @@
 // link in a network to the agent.  Assumes net_ is non-zero
 //
 int
-TapAgent::linknet()
+TapAgent::linknet(Network *net)
 {
-	int mode = net_->mode();
-	int rchan = net_->rchannel();
-	int wchan = net_->schannel();
+	int mode = net->mode();
+	int rchan = net->rchannel();
+	int wchan = net->schannel();
 
 	unlink();
 	if (mode == O_RDONLY || mode == O_RDWR) {
@@ -67,7 +67,7 @@
 		if (rchan < 0) {
 			fprintf(stderr,
 		"TapAgent(%s): network %s not open for reading (mode:%d)\n",
-			    name(), net_->name(), mode);
+			    name(), net->name(), mode);
 			return (TCL_ERROR);
 		}
 		link(rchan, TCL_READABLE);
@@ -77,13 +77,13 @@
 		if (mode == -1) {
 			fprintf(stderr,
 			   "TapAgent(%s): Network(%s) not opened properly.\n",
-				name(), net_->name());
+				name(), net->name());
 			fprintf(stderr,
 			   "(choose: readonly, readwrite, or writeonly)\n");
 		} else {
 			fprintf(stderr,
 			    "TapAgent(%s): unknown mode %d in Network(%s)\n",
-				name(), mode, net_->name());
+				name(), mode, net->name());
 		}
 		return (TCL_ERROR);
 	}
@@ -93,7 +93,7 @@
 		if (wchan < 0) {
 			fprintf(stderr,
 			"TapAgent(%s): network %s not open for writing\n",
-			    name(), net_->name());
+			    name(), net->name());
 			return (TCL_ERROR);
 		}
 	}
@@ -112,10 +112,25 @@
 		} 
 	}
 	if (argc == 3) {
-		if (strcmp(argv[1], "network") == 0) {
-			net_ = (Network *)TclObject::lookup(argv[2]);
-			if (net_ != 0) {
-				return(linknet());
+		if (strcmp(argv[1], "network-outgoing") == 0) {
+			net_outgoing_ = (Network *)TclObject::lookup(argv[2]);
+			/* We don't need to monitor outgoing network (by calling linknet()) coz
+			   we just send packets to it. In case a particular
+			   network object does both, the user has to explicitly
+			   use the command network-incoming to monitor this fd */
+			if (net_outgoing_ == 0) {
+				fprintf(stderr,
+				"TapAgent(%s): unknown network %s\n",
+				    name(), argv[2]);
+				return (TCL_ERROR);
+			}
+			return(TCL_OK);
+		}	
+
+		if (strcmp(argv[1], "network-incoming") == 0) {
+			net_incoming_ = (Network *)TclObject::lookup(argv[2]);
+			if (net_incoming_ != 0) {
+				return(linknet(net_incoming_));
 			} else {
 				fprintf(stderr,
 				"TapAgent(%s): unknown network %s\n",
@@ -135,7 +150,7 @@
 TapAgent::recvpkt()
 {
 
-	if (net_->mode() != O_RDWR && net_->mode() != O_RDONLY) {
+	if (net_incoming_->mode() != O_RDWR && net_incoming_->mode() != O_RDONLY) {
 		fprintf(stderr,
 		  "TapAgent(%s): recvpkt called while in write-only mode!\n",
 		  name());
@@ -155,7 +170,7 @@
 	// fill up payload
 	sockaddr addr;	// not really used (yet)
 	double tstamp;
-	int cc = net_->recv(p->accessdata(), maxpkt_, addr, tstamp);
+	int cc = net_incoming_->recv(p->accessdata(), maxpkt_, addr, tstamp);
 	if (cc <= 0) {
 		if (cc < 0) {
 			perror("recv");
@@ -230,7 +245,7 @@
 int
 TapAgent::sendpkt(Packet* p)
 {
-	if (net_->mode() != O_RDWR && net_->mode() != O_WRONLY) {
+	if (net_outgoing_->mode() != O_RDWR && net_outgoing_->mode() != O_WRONLY) {
 		fprintf(stderr,
 		    "TapAgent(%s): sendpkt called while in read-only mode!\n",
 		    name());
@@ -239,14 +254,14 @@
 
 	// send packet into the live network
 	hdr_cmn* hc = HDR_CMN(p);
-	if (net_ == NULL) {
+	if (net_outgoing_ == NULL) {
 		fprintf(stderr,
 	         "TapAgent(%s): sendpkt attempted with NULL net\n",
 		 name());
 		drop(p);
 		return (-1);
 	}
-	if (net_->send(p->accessdata(), hc->size()) < 0) {
+	if (net_outgoing_->send(p->accessdata(), hc->size()) < 0) {
 		fprintf(stderr,
 		    "TapAgent(%s): sendpkt (%p, %d): %s\n",
 		    name(), p->accessdata(), hc->size(), strerror(errno));
diff -ru dist-ns-allinone-2.1b9/ns-2.1b9/emulate/tap.h ns-allinone-2.1b9/ns-2.1b9/emulate/tap.h
--- dist-ns-allinone-2.1b9/ns-2.1b9/emulate/tap.h	Tue May 15 15:23:38 2001
+++ ns-allinone-2.1b9/ns-2.1b9/emulate/tap.h	Sun Oct  6 21:54:17 2002
@@ -71,8 +71,9 @@
 protected:
 	int maxpkt_;		/* max size allocated to recv a pkt */
 	void dispatch(int);	/* invoked via scheduler on I/O event */
-	int linknet();		/* establish I/O handler */
-	Network* net_;		/* live network object */
+	int linknet(Network *);		/* establish I/O handler */
+	Network* net_outgoing_;	/* live network object for outgoing packets */
+	Network* net_incoming_;		/* live network object for incoming packets */
 	double now() { return Scheduler::instance().clock(); }
 };
 
diff -ru dist-ns-allinone-2.1b9/ns-2.1b9/emulate/tcptap.cc ns-allinone-2.1b9/ns-2.1b9/emulate/tcptap.cc
--- dist-ns-allinone-2.1b9/ns-2.1b9/emulate/tcptap.cc	Fri Sep 21 11:55:34 2001
+++ ns-allinone-2.1b9/ns-2.1b9/emulate/tcptap.cc	Sun Oct  6 23:02:17 2002
@@ -33,7 +33,7 @@
 
 #ifndef lint
 static const char rcsid[] =
-    "@(#) $Header: /nfs/jade/vint/CVSROOT/ns-2/emulate/tcptap.cc,v 1.2 2001/09/20 19:05:21 alefiyah Exp $ (ISI)";
+    "@(#) $Header: /home/anoncvs/PUBLIC_CVSROOT/ns-2/emulate/tcptap.cc,v 1.4 2002/09/23 23:25:05 alefiyah Exp $ (ISI)";
 #endif
 
 #include "tcptap.h"
@@ -97,6 +97,11 @@
       return (TCL_OK);
     }
 
+    if (strcmp(argv[1], "nsport") == 0) {
+      nsnode.sin_port = atoi(argv[2]);
+      return (TCL_OK);
+    }
+
     if (strcmp(argv[1], "advertised-window") == 0) {
       adv_window = atoi(argv[2]);
       return (TCL_OK);
@@ -298,18 +303,15 @@
 
 }
 
+void
+TCPTapAgent::pkt_handler(void *clientdata, Packet *p, const struct timeval &ts)
+{
+  TCPTapAgent *inst = (TCPTapAgent *)clientdata;
+  inst->processpkt(p, ts);
+}
 
-
-/*
- * ns scheduler calls TapAgent::dispatch which calls recvpkt.
- * 
- * recvpkt then calls the network (net_) to receive a packet from 
- * the bpf. Once it has the packet, it converts to ns FullTCP packet
- * format and inject it into the simulator by calling target_->recv
- * 
- */
 void
-TCPTapAgent::recvpkt()
+TCPTapAgent::processpkt(Packet *p, const struct timeval &ts)
 {
   struct ip *ipheader;
   struct tcphdr *tcpheader;
@@ -318,36 +320,6 @@
   /* Ip header information from the grabbed packet. */
   unsigned char ttl;
   
-  if (net_->mode() != O_RDWR && net_->mode() != O_RDONLY) {
-    fprintf(stderr,
-	    "TCPTapAgent(%s): recvpkt called while in write-only mode!\n",
-	    name());
-    return;
-  }
-  
-  if (maxpkt_ <= 0) {
-    fprintf(stderr,
-	    "TCPTapAgent(%s): recvpkt: maxpkt_ value too low (%d)\n",
-	    name(), maxpkt_);
-    return;
-  }
-  
-  // allocate packet and a data payload
-  Packet* p = allocpkt(maxpkt_);
-
-  // fill up payload
-  sockaddr addr;	// not really used (yet)
-  double tstamp;
-  int cc = net_->recv(p->accessdata(), maxpkt_, addr, tstamp);
-  if (cc <= 0) {
-    if (cc < 0) {
-      perror("recv");
-    }
-    Packet::free(p);
-    return;
-  }
-  TDEBUG4("%f: TCPTapAgent(%s): recvpkt, cc:%d\n", now(), name(), cc);
-
   /* Code to drop packet, if needed 
   dropp++;
   if ((dropp % 10) == 0) {
@@ -461,12 +433,45 @@
   hdr_cmn *ns_cmnhdr = HDR_CMN(nspacket);
   ns_cmnhdr->size() = ntohs(ipheader->ip_len);
 
+  Packet::free(p);
 
   // inject into simulator
   target_->recv(nspacket);
   return;
 }
 
+/*
+ * ns scheduler calls TapAgent::dispatch which calls recvpkt.
+ * 
+ * recvpkt then calls the network (net_incoming_) to receive as many packets
+ * as there are from the packet capture facility.
+ * For every packet received through the callback, it converts to ns
+ * FullTcp packet and injects it into the simulator by calling target_->recv
+ * 
+ */
+void
+TCPTapAgent::recvpkt()
+{
+  if (net_incoming_->mode() != O_RDWR && net_incoming_->mode() != O_RDONLY) {
+    fprintf(stderr,
+	    "TCPTapAgent(%s): recvpkt called while in write-only mode!\n",
+	    name());
+    return;
+  }
+  
+  int cc = net_incoming_->recv(pkt_handler, this);
+  if (cc <= 0) {
+    if (cc < 0) {
+      perror("recv");
+    }
+    return;
+  }
+  TDEBUG4("%f: TCPTapAgent(%s): recvpkt, cc:%d\n", now(), name(), cc);
+
+  // nothing to do coz pkt_handler would have called processpkt()
+  // that would have injected packets into the simulator
+}
+
 
 
 
@@ -474,7 +479,7 @@
  * simulator schedules TapAgent::recv which calls sendpkt
  *
  * Grabs a ns Full TCP packet, converts it into real TCP packet 
- * and injects onto the network using net_->send
+ * and injects onto the network using net_outgoing_->send
  *
  */
 int
@@ -486,25 +491,24 @@
   int hlength = IP_HEADER_LEN + TCP_HEADER_LEN;
   struct tcphdr *tcpheader;
 
-  if (net_->mode() != O_RDWR && net_->mode() != O_WRONLY) {
+  if (net_outgoing_ == NULL) {
     fprintf(stderr,
-	    "TCPTapAgent(%s): sendpkt called while in read-only mode!\n",
+	    "TCPTapAgent(%s): sendpkt attempted with NULL net\n",
 	    name());
+    drop(p);
     return (-1);
   }
-  
-  // send packet into the live network
-  hdr_cmn* ns_cmnhdr = HDR_CMN(p);
-  if (net_ == NULL) {
+
+  if (net_outgoing_->mode() != O_RDWR && net_outgoing_->mode() != O_WRONLY) {
     fprintf(stderr,
-	    "TCPTapAgent(%s): sendpkt attempted with NULL net\n",
+	    "TCPTapAgent(%s): sendpkt called while in read-only mode!\n",
 	    name());
-    drop(p);
     return (-1);
   }
   
+  // send packet into the live network
+  hdr_cmn* ns_cmnhdr = HDR_CMN(p);
   hdr_tcp* ns_tcphdr = HDR_TCP(p);
-
   hdr_ip * ns_iphdr = HDR_IP(p);
   received_ttl = ns_iphdr->ttl_;
 
@@ -543,16 +547,18 @@
      Limits the packets going out to only IP + TCP header. 
      ns will act as an ACK machine.
    */
-  byteswritten = net_->send(packet, hlength + datalen);
+  byteswritten = net_outgoing_->send(packet, hlength + datalen);
   if (byteswritten < 0) {
     fprintf(stderr,"TCPTapAgent(%s): sendpkt (%p, %d): %s\n",
 	    name(), p->accessdata(), ns_cmnhdr->size(), strerror(errno));
     Packet::free(p);
+    free(packet);
     return (-1);
     
   }
   
-  TDEBUG3("TCPTapAgent(%s): sent packet (sz: %d)\n", name(), hc->size());
+  free(packet);
+  TDEBUG3("TCPTapAgent(%s): sent packet (sz: %d)\n", name(), byteswritten);
   return 0;
 }
 
diff -ru dist-ns-allinone-2.1b9/ns-2.1b9/emulate/tcptap.h ns-allinone-2.1b9/ns-2.1b9/emulate/tcptap.h
--- dist-ns-allinone-2.1b9/ns-2.1b9/emulate/tcptap.h	Fri Jan 11 15:06:09 2002
+++ ns-allinone-2.1b9/ns-2.1b9/emulate/tcptap.h	Sun Oct  6 22:59:30 2002
@@ -30,7 +30,7 @@
  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
  * SUCH DAMAGE.
  *
- * @(#) $Header: /nfs/jade/vint/CVSROOT/ns-2/emulate/tcptap.h,v 1.2 2001/12/20 18:18:44 haldar Exp $ (ISI)
+ * @(#) $Header: /home/anoncvs/PUBLIC_CVSROOT/ns-2/emulate/tcptap.h,v 1.4 2002/09/23 23:27:10 alefiyah Exp $ (ISI)
  */
 
 #ifndef tcptap_h
@@ -38,6 +38,7 @@
 
 #include "tap.h"
 #include <netinet/in.h>
+#include <netinet/in_systm.h>
 #include <netinet/ip.h>
 #include <netinet/tcp.h>
 #include <sys/socket.h>
@@ -50,10 +51,10 @@
 #define DEFAULT_ADV_WINDOW    65535 /* Large enough so that min(cong, adv 
 					window) is cong */
 #define DEFAULT_EXT_PORT       8192
-#define DEFAULT_EXT_ADDR "128.9.160.95"
+#define DEFAULT_EXT_ADDR "192.168.123.116"
 
 #define DEFAULT_NS_PORT        16384
-#define DEFAULT_NS_ADDR   "10.0.0.1"
+#define DEFAULT_NS_ADDR   "192.168.123.253"
 
 
 #define TCPIP_BASE_PKTSIZE      40      /* base TCP/IP header in real life */
@@ -93,6 +94,8 @@
   void tcp_gen(char *, unsigned short, unsigned short, Packet *);
   void recvpkt();
   int sendpkt(Packet*);
+  void processpkt(Packet *, const struct timeval &);
+  static void pkt_handler(void *, Packet *, const struct timeval &);
   
  public:
   TCPTapAgent();
diff -ru dist-ns-allinone-2.1b9/ns-2.1b9/link/delay.h ns-allinone-2.1b9/ns-2.1b9/link/delay.h
--- dist-ns-allinone-2.1b9/ns-2.1b9/link/delay.h	Sun Nov  1 18:03:33 1998
+++ ns-allinone-2.1b9/ns-2.1b9/link/delay.h	Sun Oct  6 21:54:17 2002
@@ -44,6 +44,10 @@
 #include "ip.h"
 #include "connector.h"
 
+#ifdef ADD_ETHER_OVERHEAD
+#include <net/ethernet.h>
+#endif
+
 class LinkDelay : public Connector {
  public:
 	LinkDelay();
@@ -52,7 +56,11 @@
 	void handle(Event* e);
 	double delay() { return delay_; }
 	inline double txtime(Packet* p) {
+#ifndef ADD_ETHER_OVERHEAD
 		return (8. * hdr_cmn::access(p)->size() / bandwidth_);
+#else
+		return (8. * (hdr_cmn::access(p)->size() + ETHER_HDR_LEN) / bandwidth_);
+#endif
 	}
 	double bandwidth() const { return bandwidth_; }
 	void pktintran(int src, int group);
diff -ru dist-ns-allinone-2.1b9/ns-2.1b9/tcp/tcp-full.cc ns-allinone-2.1b9/ns-2.1b9/tcp/tcp-full.cc
--- dist-ns-allinone-2.1b9/ns-2.1b9/tcp/tcp-full.cc	Wed Mar 20 19:14:56 2002
+++ ns-allinone-2.1b9/ns-2.1b9/tcp/tcp-full.cc	Sun Oct  6 21:54:17 2002
@@ -76,7 +76,7 @@
  *
  * Some warnings and comments:
  *	this version of TCP will not work correctly if the sequence number
- *	goes above 2147483648 due to sequence number wrap
+ *	goes above  due to sequence number wrap
  *
  *	this version of TCP by default sends data at the beginning of a
  *	connection in the "typical" way... That is,
@@ -358,16 +358,16 @@
 	case TCPS_CLOSED:
 	case TCPS_LISTEN:
                 reset();
-                curseq_ = iss_ + nb;
+                INCR_SEQ( curseq_, SEQ_ADD(iss_, nb));
                 connect();              // initiate new connection
 		break;
 
 	case TCPS_ESTABLISHED:
 	case TCPS_SYN_SENT:
 	case TCPS_SYN_RECEIVED:
-                if (curseq_ < iss_) 
+	        if (SEQ_LT(curseq_, iss_) ) 
                         curseq_ = iss_; 
-                curseq_ += nb;
+                INCR_SEQ(curseq_, nb);
 		break;
 
 	default:
@@ -433,7 +433,7 @@
 void
 FullTcpAgent::usrclosed()
 {
-	curseq_ = maxseq_ - 1;	// now, no more data
+	curseq_ = SEQ_SUB(maxseq_, 1);	// now, no more data
 	infinite_send_ = FALSE;	// stop infinite send
 
 	switch (state_) {
@@ -715,7 +715,7 @@
 int
 FullTcpAgent::rcvseqinit(int seq, int dlen)
 {
-	return (seq + dlen + 1);
+	return (SEQ_ADD(seq, dlen + 1));
 }
 
 /*
@@ -743,8 +743,8 @@
 FullTcpAgent::pack(Packet *pkt)
 {
 	hdr_tcp *tcph = hdr_tcp::access(pkt);
-	return (tcph->ackno() >= highest_ack_ &&
-		tcph->ackno() < recover_);
+	return (SEQ_GE(tcph->ackno(), highest_ack_) &&
+		SEQ_LT(tcph->ackno(), recover_));
 }
 
 /*
@@ -801,6 +801,9 @@
         tcph->hlen() = tcpip_base_hdr_size_;
 	tcph->hlen() += build_options(tcph);
 
+	/* Fill in maxseg_ for MSS negotiation in TCPTap (NSE) */
+	tcph->maxseg() = maxseg_;
+	
 	/*
 	 * Explicit Congestion Notification (ECN) related:
 	 * Bits in header:
@@ -909,24 +912,24 @@
 	else
 		size_ =  maxseg_ + headersize();
 
-	int is_retransmit = (seqno < maxseq_);
+	int is_retransmit = SEQ_LT(seqno, maxseq_);
 	int quiet = (highest_ack_ == maxseq_);
 	int pflags = outflags();
 	int syn = (seqno == iss_);
 	int emptying_buffer = FALSE;
 	int buffered_bytes = (infinite_send_) ? TCP_MAXSEQ :
-				curseq_ - highest_ack_ + 1;
+				SEQ_ADD( SEQ_SUB(curseq_, highest_ack_), 1);
 
 	int win = window() * maxseg_;	// window (in bytes)
-	int off = seqno - highest_ack_;	// offset of seg in window
+	int off = SEQ_SUB(seqno, highest_ack_);	// offset of seg in window
 	int datalen;
 	int amtsent = 0;
 
 	// be careful if we have not received any ACK yet
 	if (highest_ack_ < 0) {
 		if (!infinite_send_)
-			buffered_bytes = curseq_ - iss_;;
-		off = seqno - iss_;
+			buffered_bytes = SEQ_SUB(curseq_, iss_);
+		off = SEQ_SUB(seqno, iss_);
 	}
 
 	if (syn && !data_on_syn_)
@@ -965,7 +968,7 @@
 	// a dataless SYN packet counts also
 	//
 
-	if (!infinite_send_ && ((seqno + datalen) > curseq_ || 
+	if (!infinite_send_ && (SEQ_GT( SEQ_ADD(seqno, datalen), curseq_) || 
 	    (syn && datalen == 0))) {
 		emptying_buffer = TRUE;
 		//
@@ -1069,15 +1072,15 @@
 	 * around until we actually send a segment
 	 */
 
-	int reliable = datalen + syn + fin; // seq #'s reliably sent
+	int reliable = SEQ_ADD(datalen, syn + fin); // seq #'s reliably sent
 	if (cong_action_ && reliable > 0)
 		cong_action_ = FALSE;
 
 	// highest: greatest sequence number sent + 1
 	//	and adjusted for SYNs and FINs which use up one number
 
-	int highest = seqno + reliable;
-	if (highest > maxseq_) {
+	int highest = SEQ_ADD(seqno, reliable);
+	if (SEQ_GT(highest, maxseq_)) {
 		maxseq_ = highest;
 		//
 		// if we are using conventional RTT estimation,
@@ -1176,10 +1179,11 @@
         int win = window() * maxseg_;
         int topwin = curseq_; // 1 seq number past the last byte we can send
 
-        if ((topwin > highest_ack_ + win) || infinite_send_)
-                topwin = highest_ack_ + win; 
+	int hiack_plus_win = SEQ_ADD(highest_ack_, win);
+        if (SEQ_GT(topwin, hiack_plus_win) || infinite_send_)
+                INCR_SEQ( topwin, hiack_plus_win); 
 
-	return (seq < topwin);
+	return (SEQ_LT(seq, topwin));
 }
 /*
  * Process an ACK
@@ -1200,7 +1204,7 @@
 	hdr_tcp *tcph = hdr_tcp::access(pkt);
 
 	register int ackno = tcph->ackno();
-	int progress = (ackno > highest_ack_);
+	int progress = SEQ_GT(ackno, highest_ack_);
 
 	if (ackno == maxseq_) {
 		cancel_rtx_timer();	// all data ACKd
@@ -1219,7 +1223,7 @@
 	// update t_seqno_ here, otherwise we would be doing
 	// go-back-n.
 
-	if (t_seqno_ < highest_ack_)
+	if (SEQ_LT(t_seqno_, highest_ack_))
 		t_seqno_ = highest_ack_; // seq# to send next
 
         /*
@@ -1235,7 +1239,7 @@
 			recent_age_ = now();
 			recent_ = tcph->ts();
 			rtt_update(now() - tcph->ts_echo());
-		} else if (rtt_active_ && ackno > rtt_seq_) {
+		} else if (rtt_active_ && SEQ_GT(ackno,rtt_seq_)) {
 			// got an RTT sample, record it
 			// "t_backoff_ = 1;" deleted by T. Kelly.
 			rtt_active_ = FALSE;
@@ -1337,10 +1341,10 @@
 	if (flags_ & TF_ACKNOW)
 		return TRUE;
 
-	int spa = (spa_thresh_ > 0 && ((rcv_nxt_ - irs_)  < spa_thresh_)) ?
+	int spa = (spa_thresh_ > 0 && (SEQ_SUB(rcv_nxt_,irs_)  < spa_thresh_)) ?
 		1 : segs_per_ack_;
 		
-	return ((rcv_nxt_ - last_ack_sent_) >= (spa * maxseg_));
+	return (SEQ_SUB(rcv_nxt_, last_ack_sent_) >= (spa * maxseg_));
 }
 
 /*
@@ -1479,7 +1483,7 @@
 		 * See RFC1323 (now RFC1323 bis)
                  */
                 if (ts_option_ && !fh->no_ts_ &&
-		    tcph->seqno() <= last_ack_sent_) {
+		    SEQ_LE(tcph->seqno(), last_ack_sent_)) {
 			/*
 			 * this is the case where the ts value is newer than
 			 * the last one we've seen, and the seq # is the one
@@ -1517,7 +1521,7 @@
 			// If we are in fast
 			// recovery, go below so we can remember to deflate
 			// the window if we need to
-			if (ackno > highest_ack_ && ackno < maxseq_ &&
+			if (SEQ_GT(ackno, highest_ack_) && SEQ_LT(ackno, maxseq_) &&
 			    cwnd_ >= wnd_ && !fastrecov_) {
 				newack(pkt);	// update timers,  highest_ack_
 				send_much(0, REASON_NORMAL, maxburst_);
@@ -1535,7 +1539,7 @@
 			//	this routine scans all tcpcb's looking for
 			//	DELACK segments and when it finds them
 			//	changes DELACK to ACKNOW and calls tcp_output()
-			rcv_nxt_ += datalen;
+			INCR_SEQ(rcv_nxt_, datalen);
 			flags_ |= TF_DELACK;
 			recvBytes(datalen); // notify application of "delivery"
 			//
@@ -1636,7 +1640,7 @@
 
 		/* drop if it's a SYN+ACK and the ack field is bad */
 		if ((tiflags & TH_ACK) &&
-			((ackno <= iss_) || (ackno > maxseq_))) {
+			(SEQ_LE(ackno, iss_) || SEQ_GT(ackno, maxseq_))) {
 			// not an ACK for our SYN, discard
 			fprintf(stderr,
 			    "%f: FullTcpAgent::recv(%s): bad ACK for our SYN: ",
@@ -1730,14 +1734,14 @@
 			 * SYN+ACK, so t_seqno_ will have been
 			 * advanced to 2... reduce this
 			 */
-			t_seqno_--;	// CHECKME
+			DECR_SEQ(t_seqno_, 1);	// CHECKME
 		}
 
 trimthenstep6:
 		/*
 		 * advance the seq# to correspond to first data byte
 		 */
-		tcph->seqno()++;
+		INCR_SEQ(tcph->seqno(), 1);
 
 		if (tiflags & TH_ACK)
 			goto process_ACK;
@@ -1807,13 +1811,13 @@
 	// do anything with it.  In particular, would like to
 	// avoid ACKing an incoming FIN+ACK while in CLOSING
 	//
-	todrop = rcv_nxt_ - tcph->seqno();  // how much overlap?
+	todrop = SEQ_SUB(rcv_nxt_, tcph->seqno());  // how much overlap?
 
 	if (todrop > 0 && ((tiflags & (TH_SYN)) || datalen > 0)) {
 //printf("%f(%s): trim 1..todrop:%d, dlen:%d\n",now(), name(), todrop, datalen);
 		if (tiflags & TH_SYN) {
 			tiflags &= ~TH_SYN;
-			tcph->seqno()++;
+			INCR_SEQ(tcph->seqno(), 1);
 			th->size()--;	// XXX Must decrease packet size too!!
 					// Q: Why?.. this is only a SYN
 			todrop--;
@@ -1850,7 +1854,7 @@
 		 * Trim duplicate data from the front of the packet
 		 */
 
-		tcph->seqno() += todrop;
+		INCR_SEQ(tcph->seqno(), todrop);
 		th->size() -= todrop;	// XXX Must decrease size too!!
 					// why? [kf]..prob when put in RQ
 		datalen -= todrop;
@@ -1863,7 +1867,7 @@
 	 * record the timestamp.
 	 * See RFC1323 (now RFC1323 bis)
 	 */
-	if (ts_option_ && !fh->no_ts_ && tcph->seqno() <= last_ack_sent_) {
+	if (ts_option_ && !fh->no_ts_ && SEQ_LE(tcph->seqno(), last_ack_sent_)) {
 		/*
 		 * this is the case where the ts value is newer than
 		 * the last one we've seen, and the seq # is the one we expect
@@ -1894,7 +1898,7 @@
 
 	switch (state_) {
 	case TCPS_SYN_RECEIVED:	/* want ACK for our SYN+ACK */
-		if (ackno < highest_ack_ || ackno > maxseq_) {
+		if (SEQ_LT(ackno, highest_ack_) || SEQ_GT(ackno, maxseq_)) {
 			// not in useful range
 		    	fprintf(stderr,
 		    		"%f: FullTcpAgent(%s): ack(%d) not in range while in SYN_RECEIVED: ",
@@ -1968,13 +1972,13 @@
 		//	try not to be fooled by data
 		//
 
-		if (fastrecov_ && (datalen == 0 || ackno > highest_ack_))
+		if (fastrecov_ && (datalen == 0 || SEQ_GT(ackno, highest_ack_)))
 			pipe_ -= maxseg_;
 
 		// look for dup ACKs (dup ack numbers, no data)
 		//
 		// do fast retransmit/recovery if at/past thresh
-		if (ackno <= highest_ack_) {
+		if (SEQ_LE(ackno, highest_ack_)) {
 			// a pure ACK which doesn't advance highest_ack_
 			if (datalen == 0 && (!dupseg_fix_ || !dupseg)) {
 
@@ -1998,7 +2002,7 @@
                                  */
 
 				if ((rtx_timer_.status() != TIMER_PENDING) ||
-				    ackno < highest_ack_) {
+				    SEQ_LT(ackno, highest_ack_)) {
 					// Q: significance of timer not pending?
 					// ACK below highest_ack_
 					oldack();
@@ -2038,7 +2042,7 @@
 
 process_ACK:
 
-		if (ackno > maxseq_) {
+		if (SEQ_GT(ackno, maxseq_)) {
 			// ack more than we sent(!?)
 			fprintf(stderr,
 			    "%f: FullTcpAgent::recv(%s) too-big ACK (maxseq:%d): ",
@@ -2099,7 +2103,7 @@
 		 * If no data (only SYN) was ACK'd,
 		 *    skip rest of ACK processing.
 		 */
-		if (ackno == (highest_ack_ + 1))
+		if (ackno == SEQ_ADD(highest_ack_, 1))
 			goto step6;
 
 		// if we are delaying initial cwnd growth (probably due to
@@ -2213,7 +2217,7 @@
 			// accept the data here as-is (i.e. don't
 			// require being in ESTABLISHED state)
 			flags_ |= TF_DELACK;
-			rcv_nxt_ += datalen;
+			INCR_SEQ(rcv_nxt_, datalen);
 			tiflags = tcph->flags() & TH_FIN;
 
 			// give to "application" here
@@ -2231,11 +2235,11 @@
 			// Note that we may have just a FIN here (datalen = 0)
 			int rcv_nxt_old_ = rcv_nxt_; // notify app. if changes
 			tiflags = reass(pkt);
-			if (rcv_nxt_ > rcv_nxt_old_) {
+			if (SEQ_GT(rcv_nxt_, rcv_nxt_old_)) {
 				// if rcv_nxt_ has advanced, must have
 				// been a hole fill.  In this case, there
 				// is something to give to application
-				recvBytes(rcv_nxt_ - rcv_nxt_old_);
+				recvBytes(SEQ_SUB(rcv_nxt_, rcv_nxt_old_));
 			}
 			flags_ |= TF_ACKNOW;
 
@@ -2264,7 +2268,7 @@
 	if (tiflags & TH_FIN) {
 		if (TCPS_HAVERCVDFIN(state_) == 0) {
 			flags_ |= TF_ACKNOW;
- 			rcv_nxt_++;
+ 			INCR_SEQ(rcv_nxt_, 1);
 		}
 		switch (state_) {
                 /*
@@ -2301,7 +2305,7 @@
 
 	if (needoutput || (flags_ & TF_ACKNOW))
 		send_much(1, REASON_NORMAL, maxburst_);
-	else if (curseq_ >= highest_ack_ || infinite_send_)
+	else if (SEQ_GE(curseq_, highest_ack_) || infinite_send_)
 		send_much(0, REASON_NORMAL, maxburst_);
 	// K: which state to return to when nothing left?
 
@@ -2332,9 +2336,9 @@
 	if (tiflags & TH_ACK) {
 		sendpacket(ackno, 0, 0x0, 0, REASON_NORMAL);
 	} else {
-		int ack = tcph->seqno() + datalen;
+		int ack = SEQ_ADD(tcph->seqno(), datalen);
 		if (tiflags & TH_SYN)
-			ack--;
+			DECR_SEQ(ack, 1);
 		sendpacket(0, ack, TH_ACK, 0, REASON_NORMAL);
 	}
 drop:
@@ -2362,7 +2366,7 @@
 FullTcpAgent::dupack_action()
 {   
 
-        int recovered = (highest_ack_ > recover_);
+        int recovered = SEQ_GT(highest_ack_, recover_);
 
 	fastrecov_ = TRUE;
 	rtxbytes_ = 0;
@@ -2548,7 +2552,7 @@
 void
 TahoeFullTcpAgent::dupack_action()
 {  
-        int recovered = (highest_ack_ > recover_);
+        int recovered = SEQ_GT(highest_ack_, recover_);
 
 	fastrecov_ = TRUE;
 	rtxbytes_ = 0;
@@ -2665,11 +2669,11 @@
 SackFullTcpAgent::dupack_action()
 {
 
-        int recovered = (highest_ack_ > recover_);
+        int recovered = SEQ_GT(highest_ack_, recover_);
 
 	fastrecov_ = TRUE;
 	rtxbytes_ = 0;
-	pipe_ = maxseq_ - highest_ack_ - sq_.total();
+	pipe_ = SEQ_SUB( SEQ_SUB(maxseq_, highest_ack_), sq_.total());
 
 //printf("%f: SACK DUPACK-ACTION:pipe_:%d, sq-total:%d, bugfix:%d, cwnd:%d, highest_ack:%d, recover_:%d\n",
 //now(), pipe_, sq_.total(), bug_fix_, int(cwnd_), int(highest_ack_), recover_);
@@ -2709,7 +2713,7 @@
 	recover_ = maxseq_;	// where I am when recovery starts
 
 	int amt = fast_retransmit(highest_ack_);
-	h_seqno_ = highest_ack_ + amt;
+	h_seqno_ = SEQ_ADD(highest_ack_, amt);
 
 //printf("%f: FAST-RTX seq:%d, h_seqno_ is now:%d, pipe:%d, cwnd:%d, recover:%d\n",
 //now(), int(highest_ack_), h_seqno_, pipe_, int(cwnd_), recover_);
@@ -2722,12 +2726,12 @@
 void
 SackFullTcpAgent::pack_action(Packet* p)
 {
-	if (!sq_.empty() && sack_min_ < highest_ack_) {
+	if (!sq_.empty() && SEQ_LT(sack_min_, highest_ack_)) {
 		sack_min_ = highest_ack_;
 		sq_.cleartonxt();
 	}
 	pipe_ -= maxseg_;	// see comment in tcp-sack1.cc
-	if (h_seqno_ < highest_ack_)
+	if (SEQ_LT(h_seqno_, highest_ack_))
 		h_seqno_ = highest_ack_;
 }
 
@@ -2737,7 +2741,7 @@
 //printf("%f: EXITING fast recovery, recover:%d\n",
 //now(), recover_);
 	fastrecov_ = pipectrl_ = FALSE;
-        if (!sq_.empty() && sack_min_ < highest_ack_) {
+        if (!sq_.empty() && SEQ_LT(sack_min_, highest_ack_)) {
                 sack_min_ = highest_ack_;
                 sq_.cleartonxt();
         }
@@ -2823,8 +2827,8 @@
 		return (FullTcpAgent::send_allowed(seq));
 
 	// don't overshoot receiver's advertised window
-	int topawin = highest_ack_ + int(wnd_) * maxseg_;
-	if (seq >= topawin) {
+	int topawin = SEQ_ADD(highest_ack_, int(wnd_) * maxseg_);
+	if (SEQ_GE(seq, topawin)) {
 //printf("%f: SEND(%d) NOT ALLOWED DUE TO AWIN:%d, pipe:%d, cwnd:%d\n",
 //now(), seq, topawin, pipe_, int(cwnd_));
 		return FALSE;
@@ -2846,7 +2850,7 @@
 SackFullTcpAgent::nxt_tseq()
 {
 
-	int in_recovery = (highest_ack_ < recover_);
+	int in_recovery = SEQ_LT(highest_ack_, recover_);
 	int seq = h_seqno_;
 
 	if (!in_recovery) {
@@ -2885,13 +2889,13 @@
 			// adjust h_seqno, as we may have
 			// been "jumped ahead" by learning
 			// about a filled hole
-			if (seq > h_seqno_)
+			if (SEQ_GT(seq, h_seqno_))
 				h_seqno_ = seq;
 			return (seq);
 		} else if (fcnt <= 0)
 			break;
 		else {
-			seq += maxseg_;
+			INCR_SEQ(seq, maxseg_);
 		}
 	}
 //if (int(t_seqno_) > 1)
diff -ru dist-ns-allinone-2.1b9/ns-2.1b9/tcp/tcp-full.h ns-allinone-2.1b9/ns-2.1b9/tcp/tcp-full.h
--- dist-ns-allinone-2.1b9/ns-2.1b9/tcp/tcp-full.h	Sun Dec  2 19:41:16 2001
+++ ns-allinone-2.1b9/ns-2.1b9/tcp/tcp-full.h	Sun Oct  6 21:54:17 2002
@@ -104,6 +104,20 @@
 #define PF_TIMEOUT 0x04	    /* protocol defined */
 #define	TCP_PAWS_IDLE	(24 * 24 * 60 * 60)	/* 24 days in secs */
 
+#define SEQ_LT(a,b)  (((a)<(b) && (b)-(a) < TCP_MAXSEQ/2) || ((a)>(b) && (a)-(b) >= TCP_MAXSEQ/2))
+#define SEQ_LE(a,b)  (((a)<=(b) && (b)-(a) < TCP_MAXSEQ/2) || ((a)>(b) && (a)-(b) >= TCP_MAXSEQ/2))
+#define SEQ_GT(a,b)  (((a)>(b) && (a)-(b) < TCP_MAXSEQ/2) || ((a)<(b) && (b)-(a) >= TCP_MAXSEQ/2))
+#define SEQ_GE(a,b)  (((a)>=(b) && (a)-(b) < TCP_MAXSEQ/2) || ((a)<(b) && (b)-(a) >= TCP_MAXSEQ/2))
+#define INCR_SEQ(num, val) (num) = ((num) + (val)) % TCP_MAXSEQ
+#define SEQ_ADD(num, val) (((num) + (val)) % TCP_MAXSEQ)
+inline int SEQ_SUB(int num, int val) {
+  int ret = num - val;
+    return( abs(ret) < TCP_MAXSEQ/2 ? ret : ((int)(((long long)(num) - (val) + TCP_MAXSEQ) % TCP_MAXSEQ)) );
+}
+#define DECR_SEQ(num, val) (num) = SEQ_SUB((num), (val))
+#define SEQ_MIN(x,y) (SEQ_LT((x),(y))?(x):(y))
+#define SEQ_MAX(x,y) (SEQ_GT((x),(y))?(x):(y))
+
 class FullTcpAgent;
 class DelAckTimer : public TimerHandler {
 public:
@@ -187,9 +201,9 @@
 	}
 	virtual void sent(int seq, int amt) {
 		if (seq == t_seqno_)
-			t_seqno_ += amt;
+			INCR_SEQ(t_seqno_, amt);
 		pipe_ += amt;
-		if (seq < int(maxseq_))
+		if (SEQ_LT(seq, int(maxseq_)))
 			rtxbytes_ += amt;
 	}
 	virtual void oldack() {			// what to do on old ack
diff -ru dist-ns-allinone-2.1b9/ns-2.1b9/tcp/tcp.h ns-allinone-2.1b9/ns-2.1b9/tcp/tcp.h
--- dist-ns-allinone-2.1b9/ns-2.1b9/tcp/tcp.h	Fri Mar 29 19:40:43 2002
+++ ns-allinone-2.1b9/ns-2.1b9/tcp/tcp.h	Sun Oct  6 21:54:17 2002
@@ -54,6 +54,8 @@
 	int ackno_;             /* ACK number for FullTcp */
 	int hlen_;              /* header len (bytes) for FullTcp */
 	int tcp_flags_;         /* TCP flags for FullTcp */
+        int maxseg_;            /* MSS for TCPTap to negotiate in the SYN segment
+				   needed in NSE */
 
 	static int offset_;	// offset for this header
 	inline static int& offset() { return offset_; }
@@ -72,6 +74,7 @@
 	int& hlen() { return (hlen_); }
 	int& ackno() { return (ackno_); }  
 	int& flags() { return (tcp_flags_); }
+	int& maxseg() { return (maxseg_); }
 };
 
 /* these are used to mark packets as to why we xmitted them */
diff -ru dist-ns-allinone-2.1b9/ns-2.1b9/tools/random.cc ns-allinone-2.1b9/ns-2.1b9/tools/random.cc
--- dist-ns-allinone-2.1b9/ns-2.1b9/tools/random.cc	Tue Aug  8 23:51:14 2000
+++ ns-allinone-2.1b9/ns-2.1b9/tools/random.cc	Sun Oct  6 21:54:17 2002
@@ -47,11 +47,13 @@
 #define GCC_THROW
 #endif
 
+#if 0
 RANDOM_RETURN_TYPE
 random() GCC_THROW
 {
 	printf("random() called in ns.\nRandom is not portable, please use Random::uniform() instead.\n");
 	abort();
 }
+#endif
 
 #endif /* !WIN32 */
diff -ru dist-ns-allinone-2.1b9/ns-2.1b9/trace/cmu-trace.cc ns-allinone-2.1b9/ns-2.1b9/trace/cmu-trace.cc
--- dist-ns-allinone-2.1b9/ns-2.1b9/trace/cmu-trace.cc	Mon Apr  1 16:07:28 2002
+++ ns-allinone-2.1b9/ns-2.1b9/trace/cmu-trace.cc	Sun Oct  6 21:54:17 2002
@@ -826,6 +826,8 @@
 			break;
 		case PT_GAF:
 			break;
+		case PT_LIVE:
+			break;
 		default:
 			fprintf(stderr, "%s - invalid packet type (%s).\n",
 				__PRETTY_FUNCTION__, packet_info.name(ch->ptype()));
