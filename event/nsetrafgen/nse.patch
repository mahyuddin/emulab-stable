diff -ru dist-ns-allinone-2.1b9/install ns-allinone-2.1b9/install
--- dist-ns-allinone-2.1b9/install	Mon Apr 22 18:42:09 2002
+++ ns-allinone-2.1b9/install	Wed Jun 19 12:06:51 2002
@@ -39,224 +39,82 @@
 
 # Get current path
 CUR_PATH=`pwd`
+  
+if [ -x /usr/local/tcl8.3.2/bin/tclsh8.3 ] ; then
+  V_TCLSH=/usr/local/tcl8.3.2/bin/tclsh8.3 
+  export V_TCLSH
+  WITHTCL_PATH=/usr/local/tcl8.3.2
+  export WITHTCL_PATH
+
+else
+
+  # Build Tcl8.3.2
+  
+  echo "============================================================"
+  echo "* Build tcl$TCLVER"
+  echo "============================================================"
+  
+  cd ./tcl$TCLVER/unix
+  if [ -f Makefile ] ; then 
+	  make distclean
+  fi
+  
+  blame='Tcl is not part of the ns project.  Please see www.Scriptics.com
+  to see if they have a fix for your platform.'
+  ./configure --enable-gcc --disable-shared --prefix=$CUR_PATH || die "tcl8.3.2 configuration failed! Exiting ..."
+  if make 
+  then 
+	  echo "tcl$TCLVER make succeeded."
+	  make install || die "tcl$TCLVER installation failed."
+	  echo "tcl$TCLVER installation succeeded."
+	  cp ../generic/*.h ../../include
+  else
+	  echo "tcl$TCLVER make failed! Exiting ..."
+	  echo "For problems with Tcl/Tk see http://www.scriptics.com"
+	  exit
+  fi
+
+  cd ../../
+
+  WITHTCL_PATH=$CUR_PATH/tcl$TCLVER
+
+fi
+
+if [ -d /usr/local/otcl-1.0a8 ] ; then
+
+  WITHOTCL_PATH=/usr/local/otcl-1.0a8
+  export WITHOTCL_PATH
+
+else
+
+  # Build otcl
+
+  echo "============================================================"
+  echo "* Build OTcl-$OTCLVER"
+  echo "============================================================"
+  
+  cd ./otcl-$OTCLVER
+  
+  blame='Please check http://www.isi.edu/nsnam/ns/ns-problems.html
+  for common problems and bug fixes.'
+  ./configure --with-tcl=$WITHTCL_PATH || die "otcl-$OTCLVER configuration failed! Exiting ..."
+  
+  if make 
+  then
+	  echo "otcl-$OTCLVER has been installed successfully."
+  else
+	  echo "otcl-$OTCLVER make failed! Exiting ..."
+	  echo "See http://www.isi.edu/nsnam/ns/ns-problems.html for problems"
+	  exit
+  fi
+  
+  cd ..
 
-# Compile and install xgraph
+  WITHOTCL_PATH=`pwd`/otcl-$OTCLVER
+  export WITHOTCL_PATH
 
-echo "============================================================"
-echo "* Build XGraph-$XGRAPHVER"
-echo "============================================================"
-
-cd ./xgraph-$XGRAPHVER
-./configure
-if make
-then
-	echo "xgraph has been installed successfully. "
-else 
-	echo "Can not create xgraph; But xgraph is an optional package, continuing..."
-fi
-
-cd ../
-
-# Compile and install cweb and sgblib
-
-echo "============================================================"
-echo "* Build CWeb"
-echo "============================================================"
-
-cd ./cweb
-
-if [ ! -f ./Makefile ]
-then
-	echo "ns-allinone unable to install cweb for you. Please install it manually. cweb is used by sgb to create sgblibrary needed by scenario-generator. But this will not affect the use of ns as such, so continue.."
-else
-	echo "Making cweb"
-	touch *.c
-	make all || warn "cweb failed to make, but it's optional"
-	# xxx: other stuff will fail...
-	chmod 755 cweave
-	chmod 755 ctangle
-	cd ..
-	#echo "cd .."
-	if [ ! -d bin ]
-	then
-		mkdir bin
-	fi
-	cd bin
-	ln -s $CUR_PATH/cweb/cweave cweave
-	ln -s $CUR_PATH/cweb/ctangle ctangle
-fi
-
-cd ..
-PATH=$CUR_PATH/bin:$PATH
-export PATH
-
-echo "============================================================"
-echo "* Build Stanford GraphBase"
-echo "============================================================"
-
-cd ./sgb
-if [ ! -f ./Makefile ]
-	then
-	echo "Unable to create sgb library. This library is used by gt-itm and so for scenario generators. If you already have sgblib (possible if you are on solaris,sunos or freebsd platforms) you may still be able to run gt-itm. so continuing.."
-else
-	echo "Making sgb"
-	if make tests
-	then
-                if [ -f libgb.a ] ; then
-                        rm -f ../gt-itm/lib/libgb.a
-                        cp libgb.a ../gt-itm/lib/libgb.a
-                else 
-                        echo "* Wierd: sgb said it has been built but we can't find libgb.a!
-"
-                        exit -1
-                fi
-	else
-		echo "Unable to create sgb library, but it's optional, so continuing..."
-	fi
-fi
-
-cd ..
-
-# Compile and install gt-itm & sgb2ns
-
-echo "============================================================"
-echo "* Build GT-ITM"
-echo "============================================================"
-
-if [ -f ./gt-itm/lib/libgb.a ]
-then
- if [ ! -f ./gt-itm/src/Makefile ] 
-    then
-    echo "ns-alline is unable to install gt-itm sgb2ns for you, please install"
-    echo "them manually. You can't run scenario generator without gt-itm"
-    echo "and sgb2ns. But it will not affect you use ns, so continue ..."
- else
-    cd ./gt-itm/src
-    if make
-    then
-      echo "gt-itm has been installed successfully."
-    fi
-    
-    cd ../sgb2ns
-    if make
-    then
-      echo "sgb2ns has been installed successfully."
-    fi
-   cd ../../
- fi
-else
-    echo "sgb lib not found. gt-itm & sgb2ns could not be installed. Continuing.."
-fi
-
-# Build zlib
-
-echo "============================================================"
-echo "* Build zlib"
-echo "============================================================"
-
-cd ./zlib-1.1.3
-
-if ./configure --exec-prefix=../ --prefix=../
-then
-	if make
-	then
-		echo "Zlib has been installed successfully."
-	else
-		warn "Zlib make failed, but it's optional Continue ..."
-	fi
-else
-	warn "Zlib-1.1.3 configuration failed, but it's optional, so continuing ..."
-fi
-
-cd ../
-
-# Build Tcl8.3.2
-
-echo "============================================================"
-echo "* Build tcl$TCLVER"
-echo "============================================================"
-
-cd ./tcl$TCLVER/unix
-if [ -f Makefile ] ; then 
-	make distclean
-fi
-
-blame='Tcl is not part of the ns project.  Please see www.Scriptics.com
-to see if they have a fix for your platform.'
-./configure --enable-gcc --disable-shared --prefix=$CUR_PATH || die "tcl8.3.2 configuration failed! Exiting ..."
-if make 
-then 
-	echo "tcl$TCLVER make succeeded."
-	make install || die "tcl$TCLVER installation failed."
-	echo "tcl$TCLVER installation succeeded."
-	cp ../generic/*.h ../../include
-else
-	echo "tcl$TCLVER make failed! Exiting ..."
-	echo "For problems with Tcl/Tk see http://www.scriptics.com"
-	exit
-fi
-
-cd ../../
-
-# compile and install tk
-
-echo "============================================================"
-echo "* Build Tk$TKVER"
-echo "============================================================"
-
-cd ./tk$TKVER/unix
-if [ -f Makefile ] ; then
-	make distclean
-fi
-
-blame='Tk is not part of the ns project.  Please see www.Scriptics.com
-to see if they have a fix for your platform.'
-./configure --enable-gcc --disable-shared --prefix=$CUR_PATH || die "tk8.3.2 configuration failed! Exiting ..."
-if make 
-then
-	echo "tk$TKVER build succeeded."
-	make install || die "tk$TKVER installation failed."
-	echo "tk$TKVER installation succeeded."
-else
-	echo "tk$TKVER make failed! Exiting ..."
-	echo "For problems with Tcl/Tk see http://www.scriptics.com"
-	exit
 fi
 
-cd ../../
-
-#
-# Since our configures search for tclsh in $PATH, the following 
-# is needed. This is necessary for otcl/tclcl/ns/nam
-#
-PATH=$CUR_PATH/tcl$TCLVER/unix:$CUR_PATH/tk$TKVER/unix:$PATH
-export PATH
-LD_LIBRARY_PATH=$CUR_PATH/tcl$TCLVER/unix:$CUR_PATH/tk$TKVER/unix:$LD_LIBRARY_PATH
-export LD_LIBRARY_PATH
-
-# Build otcl
-
-echo "============================================================"
-echo "* Build OTcl-$OTCLVER"
-echo "============================================================"
-
-cd ./otcl-$OTCLVER
-
-blame='Please check http://www.isi.edu/nsnam/ns/ns-problems.html
-for common problems and bug fixes.'
-./configure || die "otcl-$OTCLVER configuration failed! Exiting ..."
-
-if make 
-then
-	echo "otcl-$OTCLVER has been installed successfully."
-else
-	echo "otcl-$OTCLVER make failed! Exiting ..."
-	echo "See http://www.isi.edu/nsnam/ns/ns-problems.html for problems"
-	exit
-fi
-
-cd ..
-
 # Build tclcl
 
 echo "============================================================"
@@ -265,7 +123,7 @@
 
 cd ./tclcl-$TCLCLVER
 
-./configure || die "tclcl-$TCLCLVER configuration failed! Exiting ..."
+./configure --enable-static --with-tcl=$WITHTCL_PATH --with-otcl=$WITHOTCL_PATH || die "tclcl-$TCLCLVER configuration failed! Exiting ..."
 
 if make
 then
@@ -286,40 +144,22 @@
 echo "============================================================"
 
 cd ./ns-$NSVER
-./configure || die "Ns configuration failed! Exiting ..."
 
-if make
+./configure --enable-static --with-tcl=$WITHTCL_PATH --with-otcl=$WITHOTCL_PATH || die "Ns configuration failed! Exiting ..."
+
+
+if make nse
 then
-	echo " Ns has been installed successfully." 
+	echo " Nse has been installed successfully." 
 else
-	echo "Ns make failed!"
+	echo "Nse make failed!"
 	echo "See http://www.isi.edu/nsnam/ns/ns-problems.html for problems"
 	exit
 fi
 
 cd ../
 
-# Build nam
-
-echo "============================================================"
-echo "* Build nam-$NAMVER"
-echo "============================================================"
-
-cd ./nam-$NAMVER
-
-./configure || die "Nam configuration failed! Exiting ..."
-
-if make
-then 
-    echo "Nam has been installed successfully."
-else
-    echo "Nam make failed! Continue ..."
-    echo "See http://www.isi.edu/nsnam/ns-problems.html for problems"
-fi
-
-cd ../
-
-# Install nam, ns, xgraph into bin
+# Install nse
 
 if [ ! -d bin ] ; then
     mkdir bin
@@ -327,55 +167,14 @@
 
 cd bin
 
-ln -s $CUR_PATH/ns-$NSVER/ns ns
-
-if test -x $CUR_PATH/nam-$NAMVER/nam
-then
-    ln -s $CUR_PATH/nam-$NAMVER/nam nam
-else
-    echo "Please compile your nam separately."
-fi
-
-if test -x $CUR_PATH/xgraph-$XGRAPHVER/xgraph
-then
-    ln -s $CUR_PATH/xgraph-$XGRAPHVER/xgraph xgraph
-else
-    echo "Please compile your xgraph separately."
-fi
-
-if test -x $CUR_PATH/gt-itm/bin/sgb2ns
-then 
-    ln -s $CUR_PATH/gt-itm/bin/sgb2ns sgb2ns
-    ln -s $CUR_PATH/gt-itm/bin/sgb2hierns sgb2hierns
-    ln -s $CUR_PATH/gt-itm/bin/sgb2comns sgb2comns
-    ln -s $CUR_PATH/gt-itm/bin/itm itm
-    ln -s $CUR_PATH/gt-itm/bin/sgb2alt sgb2alt
-    ln -s $CUR_PATH/gt-itm/bin/edriver edriver
-else
-    echo "Please compile your gt-itm & sgb2ns separately."
-fi
+ln -s $CUR_PATH/ns-$NSVER/nse nse
 
 echo "Ns-allinone package has been installed successfully."
 echo "Here are the installation places:"
 echo "tcl$TCLVER:	$CUR_PATH/{bin,include,lib}"
-echo "tk$TKVER:		$CUR_PATH/{bin,include,lib}"
 echo "otcl:		$CUR_PATH/otcl-$OTCLVER"
 echo "tclcl:		$CUR_PATH/tclcl-$TCLCLVER"
-echo "ns:		$CUR_PATH/ns-$NSVER/ns"
-
-if [ -x $CUR_PATH/nam-$NAMVER/nam ]
-then
-echo "nam:	$CUR_PATH/nam-$NAMVER/nam"
-fi
-
-if [ -x $CUR_PATH/xgraph-$XGRAPHVER/xgraph ]
-then
-echo "xgraph:	$CUR_PATH/xgraph-$XGRAPHVER"
-fi
-if [ -x $CUR_PATH/gt-itm/bin/sgb2ns ] 
-then
-echo "gt-itm:   $CUR_PATH/itm, edriver, sgb2alt, sgb2ns, sgb2comns, sgb2hierns"
-fi
+echo "nse:		$CUR_PATH/ns-$NSVER/nse"
 
 echo ""
 echo "----------------------------------------------------------------------------------"
diff -ru dist-ns-allinone-2.1b9/ns-2.1b9/Makefile.in ns-allinone-2.1b9/ns-2.1b9/Makefile.in
--- dist-ns-allinone-2.1b9/ns-2.1b9/Makefile.in	Mon Mar 18 15:39:26 2002
+++ ns-allinone-2.1b9/ns-2.1b9/Makefile.in	Wed Jun 19 12:09:34 2002
@@ -78,6 +78,14 @@
 
 CFLAGS	= $(CCOPT) $(DEFINE)
 
+#### with event system
+INCLUDES += -I../.. -I../../../lib -I../../../../lib/libtb `elvin-config --cflags vin4c`
+CFLAGS += -DUSEEVENTS -DUSEROUTES -DADD_ETHER_OVERHEAD
+LIB += -L../../../lib -L../../../../lib/libtb -levent -ltb
+LIB += `elvin-config --libs vin4c`
+STATIC += -static
+####
+
 # Explicitly define compilation rules since SunOS 4's make doesn't like gcc.
 # Also, gcc does not remove the .o before forking 'as', which can be a
 # problem if you don't own the file but can write to the directory.
@@ -266,6 +274,8 @@
 #	sensor-nets/tags.o sensor-nets/sensor-query.o \
 #	sensor-nets/flood-agent.o \
 
+OBJ_CC += ../../tbevent.o 
+
 # what was here before is now in emulate/
 OBJ_C =
 
@@ -285,6 +295,10 @@
 	emulate/nat.o  \
 	emulate/iptap.o \
 	emulate/tcptap.o
+
+##### nse with event system
+OBJ_EMULATE_CC += ../../tbnexthop.o
+####
 
 OBJ_EMULATE_C = \
 	emulate/inet.o
diff -ru dist-ns-allinone-2.1b9/ns-2.1b9/apps/telnet.cc ns-allinone-2.1b9/ns-2.1b9/apps/telnet.cc
--- dist-ns-allinone-2.1b9/ns-2.1b9/apps/telnet.cc	Fri Aug 14 14:09:33 1998
+++ ns-allinone-2.1b9/ns-2.1b9/apps/telnet.cc	Wed Jun 19 12:06:51 2002
@@ -77,7 +77,7 @@
 {
         if (running_) {
 	        /* call the TCP advance method */
-		agent_->sendmsg(agent_->size());
+		agent_->sendmsg(1); // send 1 byte packets instead of 1460
 		/* reschedule the timer */
 		double t = next();
 		timer_.resched(t);
diff -ru dist-ns-allinone-2.1b9/ns-2.1b9/common/scheduler.cc ns-allinone-2.1b9/ns-2.1b9/common/scheduler.cc
--- dist-ns-allinone-2.1b9/ns-2.1b9/common/scheduler.cc	Wed Apr 10 16:43:49 2002
+++ ns-allinone-2.1b9/ns-2.1b9/common/scheduler.cc	Wed Jun 19 12:06:51 2002
@@ -44,11 +44,22 @@
 #include "config.h"
 #include "scheduler.h"
 #include "packet.h"
+#ifdef USEEVENTS
+#include "tbevent.h"
+#endif
+#include <unistd.h>
 
 #ifdef MEMDEBUG_SIMULATIONS
 #include "mem-trace.h"
 #endif
 
+#ifdef MEASURE_EVENT_RATE
+
+unsigned long long event_dispatch_counter;
+unsigned int events_per_sec_arr[70];
+
+#endif
+
 Scheduler* Scheduler::instance_;
 scheduler_uid_t Scheduler::uid_ = 1;
 
@@ -138,6 +149,11 @@
 	clock_ = t;
 	p->uid_ = -p->uid_;	// being dispatched
 	p->handler_->handle(p);	// dispatch
+
+#ifdef MEASURE_EVENT_RATE
+	event_dispatch_counter++;
+#endif
+
 }
 
 void
@@ -841,12 +857,20 @@
 	virtual void run();
 	double start() const { return start_; }
 	virtual void reset();
+#ifdef USEEVENTS
+	int command(int argc, const char*const* argv);
+#endif
 protected:
 	void sync() { clock_ = tod(); }
 	int rwait(double);	// sleep
 	double tod();
 	double slop_;	// allowed drift between real-time and virt time
 	double start_;	// starting time
+
+#ifdef USEEVENTS
+        TbEventSink *evsink_;
+#endif
+  
 };
 
 static class RealTimeSchedulerClass : public TclClass {
@@ -859,9 +883,35 @@
 
 RealTimeScheduler::RealTimeScheduler() : start_(0.0)
 {
+
+#ifdef USEEVENTS
+        evsink_ = 0 ;
+#endif
+       
 	bind("maxslop_", &slop_);
 }
 
+#ifdef USEEVENTS
+  
+int RealTimeScheduler::command(int argc, const char*const* argv)
+{
+  Tcl& tcl = Tcl::instance();
+  if (instance_ == 0)
+    instance_ = this;
+  
+  
+  if( argc == 3 ) {
+    if(strcmp(argv[1], "tbevent-sink") == 0) {
+      evsink_ = (TbEventSink *)TclObject::lookup(argv[2]);
+      return(TCL_OK);
+    }
+  }
+
+  return(Scheduler::command(argc, argv));
+}  
+
+#endif
+
 double
 RealTimeScheduler::tod()
 {
@@ -876,7 +926,12 @@
 RealTimeScheduler::reset()
 {
 	clock_ = SCHED_START;
-	start_ = tod();
+
+	timeval tv;
+	gettimeofday(&tv, 0);
+	double s = tv.tv_sec;
+	s += (1e-6 * tv.tv_usec);
+	start_ = s;
 }
 
 void RealTimeScheduler::run()
@@ -884,6 +939,19 @@
 	Event *p;
 	double now;
 
+#ifdef USEEVENTS
+
+	if( evsink_ ) {
+	  evsink_->init();
+	  evsink_->subscribe();
+
+	  // Our time starts now
+	  reset();
+
+	}
+
+#endif
+	
 	/*XXX*/
 	instance_ = this;
 
@@ -899,7 +967,7 @@
 		// first handle any "old events"
 		//
 		while ((p = deque()) != NULL && (p->time_ <= now)) {
-			dispatch(p);
+			dispatch(p, clock_);
 		}
 
 		//
@@ -932,6 +1000,11 @@
 		//
 		sync();
 		Tcl_DoOneEvent(TCL_DONT_WAIT);
+#ifdef USEEVENTS
+		if( evsink_ ) {
+		  evsink_->poll();
+		}
+#endif
 	}
 
 	return;	// we reach here only if halted
@@ -948,8 +1021,208 @@
 {
 	while (1) {
 		sync();
+#ifndef USEEVENTS
 		if (Tcl_DoOneEvent(TCL_DONT_WAIT) == 1)
-			return (1);
+  		        return(1);
+#else
+		
+		int ret1 = Tcl_DoOneEvent(TCL_DONT_WAIT);
+		int ret2 = 0;
+		if( evsink_ ) {
+		  ret2 = evsink_->poll();
+		}
+		if( ret1 || ret2 )
+		  return(1);
+#endif
+		if (deadline <= tod())
+			return 0;
+	}
+	return -1;
+}
+
+class RealTimeCalendarScheduler : public CalendarScheduler {
+public:
+	RealTimeCalendarScheduler();
+	virtual void run();
+	double start() const { return start_; }
+	virtual void reset();
+#ifdef USEEVENTS
+	int command(int argc, const char*const* argv);
+#endif
+protected:
+	void sync() { clock_ = tod(); }
+	int rwait(double);	// sleep
+	double tod();
+	double slop_;	// allowed drift between real-time and virt time
+	double start_;	// starting time
+
+#ifdef USEEVENTS
+        TbEventSink *evsink_;
+#endif
+  
+};
+
+static class RealTimeCalendarSchedulerClass : public TclClass {
+public:
+	RealTimeCalendarSchedulerClass() : TclClass("Scheduler/RealTimeCalendar") {}
+	TclObject* create(int /* argc */, const char*const* /* argv */) {
+		return (new RealTimeCalendarScheduler);
+	}
+} class_realtimecalendar_sched;
+
+RealTimeCalendarScheduler::RealTimeCalendarScheduler() : start_(0.0)
+{
+
+#ifdef USEEVENTS
+        evsink_ = 0 ;
+#endif
+       
+	bind("maxslop_", &slop_);
+}
+
+#ifdef USEEVENTS
+  
+int RealTimeCalendarScheduler::command(int argc, const char*const* argv)
+{
+  Tcl& tcl = Tcl::instance();
+  if (instance_ == 0)
+    instance_ = this;
+  
+  
+  if( argc == 3 ) {
+    if(strcmp(argv[1], "tbevent-sink") == 0) {
+      evsink_ = (TbEventSink *)TclObject::lookup(argv[2]);
+      return(TCL_OK);
+    }
+  }
+
+  return(Scheduler::command(argc, argv));
+}  
+
+#endif
+
+double
+RealTimeCalendarScheduler::tod()
+{
+	timeval tv;
+	gettimeofday(&tv, 0);
+	double s = tv.tv_sec;
+	s += (1e-6 * tv.tv_usec);
+	return (s - start_);
+}
+
+void
+RealTimeCalendarScheduler::reset()
+{
+	clock_ = SCHED_START;
+
+	timeval tv;
+	gettimeofday(&tv, 0);
+	double s = tv.tv_sec;
+	s += (1e-6 * tv.tv_usec);
+	start_ = s;
+}
+
+void RealTimeCalendarScheduler::run()
+{ 
+	Event *p;
+	double now;
+
+#ifdef USEEVENTS
+
+	if( evsink_ ) {
+	  evsink_->init();
+	  evsink_->subscribe();
+
+	  // Our time starts now
+	  reset();
+
+	}
+
+#endif
+	
+	/*XXX*/
+	instance_ = this;
+
+	while (!halted_) {
+		now = tod();
+		if ((now - clock_) > slop_) {
+			fprintf(stderr,
+			"RealTimeCalendarScheduler: warning: slop %f exceeded limit %f [now:%f, clock_:%f]\n",
+				now - clock_, slop_, now, clock_);
+		}
+
+		//
+		// first handle any "old events"
+		//
+		while ((p = deque()) != NULL && (p->time_ <= now)) {
+			dispatch(p, clock_);
+		}
+
+		//
+		// now handle a "future event", if there is one
+		//
+		if (p != NULL) {
+			int rval = rwait(p->time_);
+			if (rval < 0) {
+				fprintf(stderr, "RTScheduler: wait problem\n");
+				abort();
+			} else if (rval == 0) {
+				//
+				// proper time to dispatch sim event... do so
+				//
+				dispatch(p, clock_);
+			} else {
+				//
+				// there was a simulator event which fired, and
+				// may have added something to the queue, which
+				// could cause our event p to not be the next,
+				// so put p back into the event queue and cont
+				//
+				insert(p);
+			}
+			continue;
+		}
+
+		//
+		// no sim events to handle at all, check with tcl
+		//
+		sync();
+		Tcl_DoOneEvent(TCL_DONT_WAIT);
+#ifdef USEEVENTS
+		if( evsink_ ) {
+		  evsink_->poll();
+		}
+#endif
+	}
+
+	return;	// we reach here only if halted
+}
+
+/*
+ * wait until the specified amount has elapsed, or a tcl event has happened,
+ * whichever comes first.  Return 1 if a tcl event happened, 0 if the
+ * deadline has been reached, or -1 on error (shouldn't happen).
+ */
+
+int
+RealTimeCalendarScheduler::rwait(double deadline)
+{
+	while (1) {
+		sync();
+#ifndef USEEVENTS
+		if (Tcl_DoOneEvent(TCL_DONT_WAIT) == 1)
+  		        return(1);
+#else
+		
+		int ret1 = Tcl_DoOneEvent(TCL_DONT_WAIT);
+		int ret2 = 0;
+		if( evsink_ ) {
+		  ret2 = evsink_->poll();
+		}
+		if( ret1 || ret2 )
+		  return(1);
+#endif
 		if (deadline <= tod())
 			return 0;
 	}
diff -ru dist-ns-allinone-2.1b9/ns-2.1b9/common/tclAppInit.cc ns-allinone-2.1b9/ns-2.1b9/common/tclAppInit.cc
--- dist-ns-allinone-2.1b9/ns-2.1b9/common/tclAppInit.cc	Fri Aug  3 16:56:48 2001
+++ ns-allinone-2.1b9/ns-2.1b9/common/tclAppInit.cc	Wed Jun 19 12:06:51 2002
@@ -186,6 +186,7 @@
 	return TCL_OK;
 }
 
+#if 0
 #ifndef WIN32
 void
 abort()
@@ -200,6 +201,7 @@
 #endif /*abort*/
 	/*NOTREACHED*/
 }
+#endif
 #endif
 
 }
diff -ru dist-ns-allinone-2.1b9/ns-2.1b9/common/timer-handler.cc ns-allinone-2.1b9/ns-2.1b9/common/timer-handler.cc
--- dist-ns-allinone-2.1b9/ns-2.1b9/common/timer-handler.cc	Fri Sep 11 19:32:28 1998
+++ ns-allinone-2.1b9/ns-2.1b9/common/timer-handler.cc	Wed Jun 19 12:06:51 2002
@@ -76,3 +76,40 @@
 	if (status_ == TIMER_HANDLING)
 		status_ = TIMER_IDLE;
 }
+
+#ifdef MEASURE_EVENT_RATE
+
+extern unsigned long long event_dispatch_counter;
+
+unsigned int idx;
+
+#define MAX_EVENT_ARR 70
+
+// circular buffer for the data
+extern unsigned int events_per_sec_arr[MAX_EVENT_ARR];
+
+
+void EventRateTimer::expire(Event *e) {
+
+  if ( idx % MAX_EVENT_ARR == MAX_EVENT_ARR-1 ) {
+
+    events_per_sec_arr[idx % MAX_EVENT_ARR] = event_dispatch_counter;
+    event_dispatch_counter = 0;
+    idx++;
+    
+    int i = 0 ;
+    for( ; i < MAX_EVENT_ARR-1 ; i++ ) {
+      fprintf(stderr, "%u, ", events_per_sec_arr[i] );
+    }
+    fprintf(stderr, "%u\n", events_per_sec_arr[MAX_EVENT_ARR-1] );    
+  } else {
+  
+    events_per_sec_arr[idx % MAX_EVENT_ARR] = event_dispatch_counter;
+    event_dispatch_counter = 0;
+    idx++;
+  }
+  resched(1.0);    
+    
+}
+
+#endif
diff -ru dist-ns-allinone-2.1b9/ns-2.1b9/common/timer-handler.h ns-allinone-2.1b9/ns-2.1b9/common/timer-handler.h
--- dist-ns-allinone-2.1b9/ns-2.1b9/common/timer-handler.h	Thu Nov  2 15:46:37 2000
+++ ns-allinone-2.1b9/ns-2.1b9/common/timer-handler.h	Wed Jun 19 12:06:51 2002
@@ -88,4 +88,15 @@
 // mode:c++
 // End:
 
+#ifdef MEASURE_EVENT_RATE
+
+class EventRateTimer : public TimerHandler {
+
+public:
+  virtual void expire(Event *e) ;
+
+};
+
+#endif
+
 #endif /* timer_handler_h */
diff -ru dist-ns-allinone-2.1b9/ns-2.1b9/emulate/iptap.cc ns-allinone-2.1b9/ns-2.1b9/emulate/iptap.cc
--- dist-ns-allinone-2.1b9/ns-2.1b9/emulate/iptap.cc	Tue May 15 15:23:38 2001
+++ ns-allinone-2.1b9/ns-2.1b9/emulate/iptap.cc	Wed Jun 19 12:06:51 2002
@@ -37,11 +37,42 @@
 #endif
 
 #include "iptap.h"
+#include "net.h"
 
+#ifdef USEROUTES
+#include "tbnexthop.h"
+
+static IPTapAgent *iface_to_iptap[IFNAMSIZ+1];
+static Tcl_HashTable ip_to_iptap;
+
+#endif
+
+#ifdef MEASURE_EVENT_RATE
+#include "timer-handler.h"
+
+EventRateTimer ert;
+unsigned int firstpacket;
+#endif
+
+#ifdef USEROUTES
+#ifdef __cplusplus
+extern "C" {
+#endif
+#include        "tbdefs.h"
+#include        "log.h"
+
+#ifdef __cplusplus
+}
+#endif
+#endif
 
 static class IPTapAgentClass : public TclClass {
  public:
-	IPTapAgentClass() : TclClass("Agent/IPTap") {}
+	IPTapAgentClass() : TclClass("Agent/IPTap") {
+#ifdef USEROUTES
+	  Tcl_InitHashTable( &ip_to_iptap, TCL_ONE_WORD_KEYS );
+#endif
+	}
 	TclObject* create(int, const char*const*) {
 		return (new IPTapAgent());
 	}
@@ -52,6 +83,9 @@
 {
   int i = 0;
   index = 0;
+#ifdef USEROUTES
+  iface_index = 0;
+#endif
   for (; i < MAX_PACKETS ; i++) {
     ident[i] = -1;
     offset[i] = -1;
@@ -143,8 +177,16 @@
   
   /* TCP header info from the grabbed packet. */
   unsigned char tcphlen;
+
+#ifdef MEASURE_EVENT_RATE
+  // schedule the event rate 
+  if ( firstpacket == 0 ) {
+    ert.sched(1.0);
+    firstpacket++;
+  }
+#endif
   
-  if (net_->mode() != O_RDWR && net_->mode() != O_RDONLY) {
+  if (net_incoming_->mode() != O_RDWR && net_incoming_->mode() != O_RDONLY) {
     fprintf(stderr,
 	    "IPTapAgent(%s): recvpkt called while in write-only mode!\n",
 	    name());
@@ -165,7 +207,7 @@
   // fill up payload
   sockaddr addr;	// not really used (yet)
   double tstamp;
-  int cc = net_->recv(p->accessdata(), maxpkt_, addr, tstamp);
+  int cc = net_incoming_->recv(p->accessdata(), maxpkt_, addr, tstamp);
   if (cc <= 0) {
     if (cc < 0) {
       perror("recv");
@@ -193,11 +235,13 @@
     return;
   }
 
+  /**** DONT NEED THE FOLLOWING CODE IF WE USE APPROPRIATE PCAP FILTERS
+	THAT HAVE "not ether src xx:xx:xx:xx:xx:xx" in it           ****/
   /* Discard if duplicate. */
-  if (isDuplicate(ntohs(ipheader->ip_id), ntohs(ipheader->ip_off))) {
-    Packet::free(p);
-    return;
-  }
+  //  if (isDuplicate(ntohs(ipheader->ip_id), ntohs(ipheader->ip_off))) {
+  //    Packet::free(p);
+  //    return;
+  //  }  
   
   datagramlen = ntohs(ipheader->ip_len);
 
@@ -208,13 +252,83 @@
   hdr_ip *ih = HDR_IP(p);
   ih->ttl() = ttl;
 
+#ifdef USEROUTES
+  /* code to look up the interface index
+     over which we should spit out the
+     packet. with this interface index, we
+     find the iptap which is attached on
+     the corresponding simulated node from
+     where the packet will be spit out.
+     This ensures that the packet traverses
+     the simulated network and is spit out
+     into the real world from the right place
+  */
+  uint16_t dst_iface_index = 0;
+  //dst.s_addr = (u_int32_t)ntohl(ipheader->ip_dst.s_addr);
+
+  int newentry = 0;
+  // finds an entry if it exists, else creates a new one
+  Tcl_HashEntry *he = Tcl_CreateHashEntry( &ip_to_iptap,
+					   (char *)(ipheader->ip_dst.s_addr),
+					   &newentry );  
+  IPTapAgent *dst_agent = 0;
+  
+  // entry exists
+  if( newentry == 0 ) {
+
+    dst_agent = (IPTapAgent *)Tcl_GetHashValue(he);
+
+  } else { // entry was newly created and we need to lookup routing table
+    
+    if( (dst_iface_index = get_nexthop_if(ipheader->ip_dst)) != 0 ) {
+      dst_agent = iface_to_iptap[dst_iface_index];
+    }
+    Tcl_SetHashValue( he, (char *)dst_agent);
+
+  }
+
+  if( dst_agent ) {
+    ih->daddr() = dst_agent->addr();
+    ih->dport() = dst_agent->port();
+    goto injectsim;
+  } 
+  
+ /* if we fail to map a dest iptap object, we drop the packet */
+  fprintf( stderr, "dropping packet with ipaddr:%s at %f with iface_idx:%d\n",
+	   inet_ntoa(ipheader->ip_dst), Scheduler::instance().clock(), dst_iface_index );
+  drop(p);
+  return;
+  
+ injectsim:  
+#endif
+
   // inject into simulator
   target_->recv(p);
   return;
 }
 
+#ifdef USEROUTES
+  
+int
+IPTapAgent::command(int argc, const char*const* argv)
+{
+	Tcl& tcl = Tcl::instance();
 
+	if (argc == 3) {
+		if (strcmp(argv[1], "network-incoming") == 0) {
+			PcapNetwork *net_in_ = (PcapNetwork *)TclObject::lookup(argv[2]);
+			if (net_in_ != 0) {
+			  iface_index = if_nametoindex( net_in_->srcname() ) ;
+			  if( iface_index > 0 && iface_index <= IFNAMSIZ ) {
+			    iface_to_iptap[iface_index] = this;
+			  }
+			}
+		}
+	}
+	return (TapAgent::command(argc, argv));
+}
 
+#endif
 
 /*
  * simulator schedules TapAgent::recv which calls sendpkt
@@ -231,23 +345,24 @@
   unsigned short dglen;
   struct ip *ipheader;
 
-  if (net_->mode() != O_RDWR && net_->mode() != O_WRONLY) {
+  if (net_outgoing_ == NULL) {
     fprintf(stderr,
-	    "IPTapAgent(%s): sendpkt called while in read-only mode!\n",
+	    "IPTapAgent(%s): sendpkt attempted with NULL net\n",
 	    name());
+    drop(p);
     return (-1);
   }
-  
-  // send packet into the live network
-  hdr_cmn* hc = HDR_CMN(p);
-  if (net_ == NULL) {
+
+  if (net_outgoing_->mode() != O_RDWR && net_outgoing_->mode() != O_WRONLY) {
     fprintf(stderr,
-	    "IPTapAgent(%s): sendpkt attempted with NULL net\n",
+	    "IPTapAgent(%s): sendpkt called while in read-only mode!\n",
 	    name());
-    drop(p);
     return (-1);
   }
   
+  // send packet into the live network
+  hdr_cmn* hc = HDR_CMN(p);
+  
   /*
     At this point, we should grab the ttl field from the ns
     packet, put it in the IP header of the actual packet,
@@ -277,13 +392,22 @@
   ipheader->ip_sum = (unsigned short) in_cksum((unsigned short *) ipheader,
 						sizeof(struct ip));
 
-  if (net_->send(p->accessdata(), hc->size()) < 0) {
+  /**** DONT NEED THE FOLLOWING CODE IF WE USE APPROPRIATE PCAP FILTERS
+	THAT HAVE "not ether src xx:xx:xx:xx:xx:xx" in it           ****/
+  // we need to store this packet so that we don't pick it up again
+  //  ident[index % MAX_PACKETS] = ntohs(ipheader->ip_id);
+  //  offset[index % MAX_PACKETS] = ntohs(ipheader->ip_off);
+  //  index++;  
+  
+  if (net_outgoing_->send(p->accessdata(), hc->size()) < 0) {
     fprintf(stderr,
 	    "IPTapAgent(%s): sendpkt (%p, %d): %s\n",
 	    name(), p->accessdata(), hc->size(), strerror(errno));
+    Packet::free(p); // memory leak fix from 2.1b8a 
     return (-1);
     
   }
+  Packet::free(p); // memory leak fix from 2.1b8a 
   TDEBUG3("IPTapAgent(%s): sent packet (sz: %d)\n",
 	  name(), hc->size());
   return 0;
diff -ru dist-ns-allinone-2.1b9/ns-2.1b9/emulate/iptap.h ns-allinone-2.1b9/ns-2.1b9/emulate/iptap.h
--- dist-ns-allinone-2.1b9/ns-2.1b9/emulate/iptap.h	Fri Jan 11 15:06:09 2002
+++ ns-allinone-2.1b9/ns-2.1b9/emulate/iptap.h	Wed Jun 19 12:06:51 2002
@@ -38,24 +38,35 @@
 
 #include "tap.h"
 #include <netinet/in.h>
+#include <netinet/in_systm.h>
 #include <netinet/ip.h>
 #include <netinet/tcp.h>
 #include <sys/socket.h>
 #include "tcp.h"
 #include "ip.h"
 
-#define MAX_PACKETS 640
+#ifdef USEROUTES
+#include <net/if.h>
+#include "tb_routelookup.h"
+#endif
 
+#define MAX_PACKETS 640
 
 class IPTapAgent : public TapAgent {
 
  public:
   IPTapAgent();
+#ifdef USEROUTES
+  int command(int, const char*const*);
+#endif
 
  private:
   int ident[MAX_PACKETS];      /* All three used for duplicate */
   int offset[MAX_PACKETS];     /* packet detection. */
   int index;
+#ifdef USEROUTES
+  uint16_t iface_index;
+#endif
 
   unsigned short in_cksum(unsigned short *,int);
   void recvpkt();
diff -ru dist-ns-allinone-2.1b9/ns-2.1b9/emulate/net-pcap.cc ns-allinone-2.1b9/ns-2.1b9/emulate/net-pcap.cc
--- dist-ns-allinone-2.1b9/ns-2.1b9/emulate/net-pcap.cc	Fri Sep 21 11:55:34 2001
+++ ns-allinone-2.1b9/ns-2.1b9/emulate/net-pcap.cc	Wed Jun 19 12:06:51 2002
@@ -57,10 +57,18 @@
 
 #ifdef __cplusplus
 extern "C" {
+#if !defined(__FreeBSD__)
 #include <pcap/pcap.h>
+#else
+#include <pcap.h>
+#endif
 }
 #else
+#if !defined(__FreeBSD__)
 #include <pcap/pcap.h>
+#else
+#include <pcap.h>
+#endif
 #endif
 
 #include "config.h"
@@ -68,81 +76,6 @@
 #include "net.h"
 #include "tclcl.h"
 
-/*
- * observations about pcap library
- *	device name is in the ifreq struct sense, should be doc'd
- *	pcap_lookupdev returns a ptr to static data
- *	q: does lookupdev only return devs in the AF_INET addr family?
- *	why does pcap_compile require a netmask? seems odd
- *	would like some way to tell it what buffer to use
- *	arriving packets have the link layer hdr at the beginning, doc
- *	not convenient/possible to open bpf read/write
- *	no real way to know what file (/dev/bpf?) it is using
- *		would be nice if pcap_lookdev helped out more by
- *		returning ifnet or ifreq or whatever structure
- *	pcap_lookupnet makes calls to get our addr, but
- *		then tosses it anyhow, should get us addr and netmask
- *	interface type codes could be via rfc1573
- *		see freebsd net/if_types.h
- *	want a way to set immed mode
- *	pcap_next masks errors by returning 0 if pcap_dispatch fails
- *	a pcap_t carries it's own internal buffer, and
- *		_dispatch gives pointers into it when invoked [eek]
- *	when you open pcap using a file, pcap_fileno always
- *		returns -1; not so convenient
- *	
- */
-
-#define	PNET_PSTATE_INACTIVE	0
-#define	PNET_PSTATE_ACTIVE	1
-
-//
-// PcapNetwork: a "network" (source or possibly sink of packets)
-//	this is a base class only-- the derived classes are:
-//	PcapLiveNetwork [a live net; currently bpf + ethernet]
-//	PcapFileNetwork [packets from a tcpdump-style trace file]
-//
-
-class PcapNetwork : public Network {
-
-public:
-	PcapNetwork() : t_firstpkt_(0.0),
-		pfd_(-1), pcnt_(0), local_netmask_(0) { }
-	int rchannel() { return(pfd_); }
-	int schannel() { return(pfd_); }
-	virtual int command(int argc, const char*const* argv);
-
-	virtual int open(int mode, const char *) = 0;
-	virtual int skiphdr() = 0;
-	virtual double gents(pcap_pkthdr*) = 0;		// generate timestamp
-	int recv(u_char *buf, int len, sockaddr&, double&); // get from net
-	int send(u_char *buf, int len);			// write to net
-	void close();
-	void reset();
-
-	int filter(const char*);	// compile + install a filter
-	int stat_pkts();
-	int stat_pdrops();
-
-	double offset_;			// time offset to 1st pkt in a trace
-	double t_firstpkt_;		// ts of 1st pkt recvd
-
-protected:
-	static void phandler(u_char* u, const pcap_pkthdr* h, const u_char* p);
-	virtual void bindvars() = 0;
-
-	char errbuf_[PCAP_ERRBUF_SIZE];		// place to put err msgs
-	char srcname_[PATH_MAX];		// device or file name
-	int pfd_;				// pcap fd
-	int pcnt_;				// # pkts counted
-	int state_;				// PNET_PSTATE_xxx (above)
-	int optimize_;				// bpf optimizer enable
-	pcap_t* pcap_;				// reference to pcap state
-	struct bpf_program bpfpgm_;		// generated program
-	struct pcap_stat pcs_;			// status
-
-	unsigned int local_netmask_;	// seems shouldn't be necessary :(
-};
 
 //
 // PcapLiveNetwork: a live network tap
diff -ru dist-ns-allinone-2.1b9/ns-2.1b9/emulate/net.h ns-allinone-2.1b9/ns-2.1b9/emulate/net.h
--- dist-ns-allinone-2.1b9/ns-2.1b9/emulate/net.h	Fri May 22 20:44:57 1998
+++ ns-allinone-2.1b9/ns-2.1b9/emulate/net.h	Wed Jun 19 12:06:51 2002
@@ -64,4 +64,102 @@
 protected:
 	int mode_;	// read/write bits (from fcntl.h)
 };
+
+#ifdef __cplusplus
+extern "C" {
+#if !defined(__FreeBSD__)
+#include <pcap/pcap.h>
+#else
+#include <pcap.h>
+#endif
+}
+#else
+#if !defined(__FreeBSD__)
+#include <pcap/pcap.h>
+#else
+#include <pcap.h>
+#endif
+#endif
+
+#include <sys/param.h>
+
+/*
+ * observations about pcap library
+ *	device name is in the ifreq struct sense, should be doc'd
+ *	pcap_lookupdev returns a ptr to static data
+ *	q: does lookupdev only return devs in the AF_INET addr family?
+ *	why does pcap_compile require a netmask? seems odd
+ *	would like some way to tell it what buffer to use
+ *	arriving packets have the link layer hdr at the beginning, doc
+ *	not convenient/possible to open bpf read/write
+ *	no real way to know what file (/dev/bpf?) it is using
+ *		would be nice if pcap_lookdev helped out more by
+ *		returning ifnet or ifreq or whatever structure
+ *	pcap_lookupnet makes calls to get our addr, but
+ *		then tosses it anyhow, should get us addr and netmask
+ *	interface type codes could be via rfc1573
+ *		see freebsd net/if_types.h
+ *	want a way to set immed mode
+ *	pcap_next masks errors by returning 0 if pcap_dispatch fails
+ *	a pcap_t carries it's own internal buffer, and
+ *		_dispatch gives pointers into it when invoked [eek]
+ *	when you open pcap using a file, pcap_fileno always
+ *		returns -1; not so convenient
+ *	
+ */
+
+#define	PNET_PSTATE_INACTIVE	0
+#define	PNET_PSTATE_ACTIVE	1
+
+//
+// PcapNetwork: a "network" (source or possibly sink of packets)
+//	this is a base class only-- the derived classes are:
+//	PcapLiveNetwork [a live net; currently bpf + ethernet]
+//	PcapFileNetwork [packets from a tcpdump-style trace file]
+//
+
+class PcapNetwork : public Network {
+
+public:
+	PcapNetwork() : t_firstpkt_(0.0),
+		pfd_(-1), pcnt_(0), local_netmask_(0) { }
+	int rchannel() { return(pfd_); }
+	int schannel() { return(pfd_); }
+	virtual int command(int argc, const char*const* argv);
+
+	virtual int open(int mode, const char *) = 0;
+	virtual int skiphdr() = 0;
+	virtual double gents(pcap_pkthdr*) = 0;		// generate timestamp
+	int recv(u_char *buf, int len, sockaddr&, double&); // get from net
+	int send(u_char *buf, int len);			// write to net
+	void close();
+	void reset();
+
+	int filter(const char*);	// compile + install a filter
+	int stat_pkts();
+	int stat_pdrops();
+
+	double offset_;			// time offset to 1st pkt in a trace
+	double t_firstpkt_;		// ts of 1st pkt recvd
+
+#ifdef USEROUTES
+        inline char *srcname() { return(srcname_); }
+#endif
+
+protected:
+	static void phandler(u_char* u, const pcap_pkthdr* h, const u_char* p);
+	virtual void bindvars() = 0;
+
+	char errbuf_[PCAP_ERRBUF_SIZE];		// place to put err msgs
+	char srcname_[PATH_MAX];		// device or file name
+	int pfd_;				// pcap fd
+	int pcnt_;				// # pkts counted
+	int state_;				// PNET_PSTATE_xxx (above)
+	int optimize_;				// bpf optimizer enable
+	pcap_t* pcap_;				// reference to pcap state
+	struct bpf_program bpfpgm_;		// generated program
+	struct pcap_stat pcs_;			// status
+
+	unsigned int local_netmask_;	// seems shouldn't be necessary :(
+};
 #endif
diff -ru dist-ns-allinone-2.1b9/ns-2.1b9/emulate/tap.cc ns-allinone-2.1b9/ns-2.1b9/emulate/tap.cc
--- dist-ns-allinone-2.1b9/ns-2.1b9/emulate/tap.cc	Tue May 15 15:19:27 2001
+++ ns-allinone-2.1b9/ns-2.1b9/emulate/tap.cc	Wed Jun 19 12:06:51 2002
@@ -46,7 +46,7 @@
 	}
 } class_tap_agent;
 
-TapAgent::TapAgent() : Agent(PT_LIVE), net_(NULL)
+TapAgent::TapAgent() : Agent(PT_LIVE), net_outgoing_(NULL), net_incoming_(NULL)
 {
 	bind("maxpkt_", &maxpkt_);
 }
@@ -55,11 +55,11 @@
 // link in a network to the agent.  Assumes net_ is non-zero
 //
 int
-TapAgent::linknet()
+TapAgent::linknet(Network *net)
 {
-	int mode = net_->mode();
-	int rchan = net_->rchannel();
-	int wchan = net_->schannel();
+	int mode = net->mode();
+	int rchan = net->rchannel();
+	int wchan = net->schannel();
 
 	unlink();
 	if (mode == O_RDONLY || mode == O_RDWR) {
@@ -67,7 +67,7 @@
 		if (rchan < 0) {
 			fprintf(stderr,
 		"TapAgent(%s): network %s not open for reading (mode:%d)\n",
-			    name(), net_->name(), mode);
+			    name(), net->name(), mode);
 			return (TCL_ERROR);
 		}
 		link(rchan, TCL_READABLE);
@@ -77,13 +77,13 @@
 		if (mode == -1) {
 			fprintf(stderr,
 			   "TapAgent(%s): Network(%s) not opened properly.\n",
-				name(), net_->name());
+				name(), net->name());
 			fprintf(stderr,
 			   "(choose: readonly, readwrite, or writeonly)\n");
 		} else {
 			fprintf(stderr,
 			    "TapAgent(%s): unknown mode %d in Network(%s)\n",
-				name(), mode, net_->name());
+				name(), mode, net->name());
 		}
 		return (TCL_ERROR);
 	}
@@ -93,7 +93,7 @@
 		if (wchan < 0) {
 			fprintf(stderr,
 			"TapAgent(%s): network %s not open for writing\n",
-			    name(), net_->name());
+			    name(), net->name());
 			return (TCL_ERROR);
 		}
 	}
@@ -112,10 +112,25 @@
 		} 
 	}
 	if (argc == 3) {
-		if (strcmp(argv[1], "network") == 0) {
-			net_ = (Network *)TclObject::lookup(argv[2]);
-			if (net_ != 0) {
-				return(linknet());
+		if (strcmp(argv[1], "network-outgoing") == 0) {
+			net_outgoing_ = (Network *)TclObject::lookup(argv[2]);
+			/* We don't need to monitor outgoing network (by calling linknet()) coz
+			   we just send packets to it. In case a particular
+			   network object does both, the user has to explicitly
+			   use the command network-incoming to monitor this fd */
+			if (net_outgoing_ == 0) {
+				fprintf(stderr,
+				"TapAgent(%s): unknown network %s\n",
+				    name(), argv[2]);
+				return (TCL_ERROR);
+			}
+			return(TCL_OK);
+		}	
+
+		if (strcmp(argv[1], "network-incoming") == 0) {
+			net_incoming_ = (Network *)TclObject::lookup(argv[2]);
+			if (net_incoming_ != 0) {
+				return(linknet(net_incoming_));
 			} else {
 				fprintf(stderr,
 				"TapAgent(%s): unknown network %s\n",
@@ -135,7 +150,7 @@
 TapAgent::recvpkt()
 {
 
-	if (net_->mode() != O_RDWR && net_->mode() != O_RDONLY) {
+	if (net_incoming_->mode() != O_RDWR && net_incoming_->mode() != O_RDONLY) {
 		fprintf(stderr,
 		  "TapAgent(%s): recvpkt called while in write-only mode!\n",
 		  name());
@@ -155,7 +170,7 @@
 	// fill up payload
 	sockaddr addr;	// not really used (yet)
 	double tstamp;
-	int cc = net_->recv(p->accessdata(), maxpkt_, addr, tstamp);
+	int cc = net_incoming_->recv(p->accessdata(), maxpkt_, addr, tstamp);
 	if (cc <= 0) {
 		if (cc < 0) {
 			perror("recv");
@@ -230,7 +245,7 @@
 int
 TapAgent::sendpkt(Packet* p)
 {
-	if (net_->mode() != O_RDWR && net_->mode() != O_WRONLY) {
+	if (net_outgoing_->mode() != O_RDWR && net_outgoing_->mode() != O_WRONLY) {
 		fprintf(stderr,
 		    "TapAgent(%s): sendpkt called while in read-only mode!\n",
 		    name());
@@ -239,14 +254,14 @@
 
 	// send packet into the live network
 	hdr_cmn* hc = HDR_CMN(p);
-	if (net_ == NULL) {
+	if (net_outgoing_ == NULL) {
 		fprintf(stderr,
 	         "TapAgent(%s): sendpkt attempted with NULL net\n",
 		 name());
 		drop(p);
 		return (-1);
 	}
-	if (net_->send(p->accessdata(), hc->size()) < 0) {
+	if (net_outgoing_->send(p->accessdata(), hc->size()) < 0) {
 		fprintf(stderr,
 		    "TapAgent(%s): sendpkt (%p, %d): %s\n",
 		    name(), p->accessdata(), hc->size(), strerror(errno));
diff -ru dist-ns-allinone-2.1b9/ns-2.1b9/emulate/tap.h ns-allinone-2.1b9/ns-2.1b9/emulate/tap.h
--- dist-ns-allinone-2.1b9/ns-2.1b9/emulate/tap.h	Tue May 15 15:23:38 2001
+++ ns-allinone-2.1b9/ns-2.1b9/emulate/tap.h	Wed Jun 19 12:06:51 2002
@@ -71,8 +71,9 @@
 protected:
 	int maxpkt_;		/* max size allocated to recv a pkt */
 	void dispatch(int);	/* invoked via scheduler on I/O event */
-	int linknet();		/* establish I/O handler */
-	Network* net_;		/* live network object */
+	int linknet(Network *);		/* establish I/O handler */
+	Network* net_outgoing_;	/* live network object for outgoing packets */
+	Network* net_incoming_;		/* live network object for incoming packets */
 	double now() { return Scheduler::instance().clock(); }
 };
 
diff -ru dist-ns-allinone-2.1b9/ns-2.1b9/emulate/tcptap.cc ns-allinone-2.1b9/ns-2.1b9/emulate/tcptap.cc
--- dist-ns-allinone-2.1b9/ns-2.1b9/emulate/tcptap.cc	Fri Sep 21 11:55:34 2001
+++ ns-allinone-2.1b9/ns-2.1b9/emulate/tcptap.cc	Wed Jun 19 12:06:51 2002
@@ -91,6 +91,12 @@
       }
       return (TCL_OK);
     }
+
+    if (strcmp(argv[1], "nsport") == 0) {
+      nsnode.sin_port = atoi(argv[2]);
+      return (TCL_OK);
+    }
+
     
     if (strcmp(argv[1], "extport") == 0) {
       extnode.sin_port = atoi(argv[2]);
@@ -198,6 +204,8 @@
   ipheader->ip_v = IPVERSION;
 
   ipheader->ip_len = length;
+  ipheader->ip_off = IP_DF; /* most common now. fragmentation is quite bad on
+			       performance */
   ipheader->ip_id = 0;
   ipheader->ip_ttl = ttl;
   ipheader->ip_p = protocol;
@@ -318,7 +326,7 @@
   /* Ip header information from the grabbed packet. */
   unsigned char ttl;
   
-  if (net_->mode() != O_RDWR && net_->mode() != O_RDONLY) {
+  if (net_incoming_->mode() != O_RDWR && net_incoming_->mode() != O_RDONLY) {
     fprintf(stderr,
 	    "TCPTapAgent(%s): recvpkt called while in write-only mode!\n",
 	    name());
@@ -338,7 +346,7 @@
   // fill up payload
   sockaddr addr;	// not really used (yet)
   double tstamp;
-  int cc = net_->recv(p->accessdata(), maxpkt_, addr, tstamp);
+  int cc = net_incoming_->recv(p->accessdata(), maxpkt_, addr, tstamp);
   if (cc <= 0) {
     if (cc < 0) {
       perror("recv");
@@ -406,8 +414,21 @@
   ns_tcphdr->flags() = 0;
   if (tcpheader->th_flags & TH_FIN)
     ns_tcphdr->flags() |= TH_FIN;
-  if (tcpheader->th_flags & TH_SYN) 
+  if (tcpheader->th_flags & TH_SYN) {
         ns_tcphdr->flags() |= TH_SYN;
+
+
+	/* For server side TCP in NSE, we need to store
+	   the source addr and port for the next packet
+	   we send => we ignore the command settings.
+	   We gotta check if this is a SYN+ACK in which case
+	   we are not server side */
+	if( (tcpheader->th_flags & TH_ACK) == 0 ) {
+	  extnode.sin_port =  ntohs(tcpheader->th_sport);
+	  extnode.sin_addr = ipheader->ip_src;
+	}
+  }
+
   if (tcpheader->th_flags & TH_RST) 
         ns_tcphdr->flags() |= TH_RST;
   if (tcpheader->th_flags & TH_PUSH) 
@@ -462,6 +483,9 @@
   ns_cmnhdr->size() = ntohs(ipheader->ip_len);
 
 
+  // We no longer need Packet p. memory leak fix from 2.1b8a 
+  Packet::free(p);
+  
   // inject into simulator
   target_->recv(nspacket);
   return;
@@ -474,7 +498,7 @@
  * simulator schedules TapAgent::recv which calls sendpkt
  *
  * Grabs a ns Full TCP packet, converts it into real TCP packet 
- * and injects onto the network using net_->send
+ * and injects onto the network using net_outgoing_->send
  *
  */
 int
@@ -486,7 +510,7 @@
   int hlength = IP_HEADER_LEN + TCP_HEADER_LEN;
   struct tcphdr *tcpheader;
 
-  if (net_->mode() != O_RDWR && net_->mode() != O_WRONLY) {
+  if (net_outgoing_->mode() != O_RDWR && net_outgoing_->mode() != O_WRONLY) {
     fprintf(stderr,
 	    "TCPTapAgent(%s): sendpkt called while in read-only mode!\n",
 	    name());
@@ -495,7 +519,7 @@
   
   // send packet into the live network
   hdr_cmn* ns_cmnhdr = HDR_CMN(p);
-  if (net_ == NULL) {
+  if (net_outgoing_ == NULL) {
     fprintf(stderr,
 	    "TCPTapAgent(%s): sendpkt attempted with NULL net\n",
 	    name());
@@ -508,6 +532,10 @@
   hdr_ip * ns_iphdr = HDR_IP(p);
   received_ttl = ns_iphdr->ttl_;
 
+  if (ns_tcphdr->tcp_flags_ & TH_SYN) {
+      hlength += 4; // adding 4 bytes for MSS option
+  }
+
   // Here we check if ns has sent any data in the packet.
   datalen = ns_cmnhdr->size() - ns_tcphdr->hlen();
   packet = (unsigned char *) calloc (1, sizeof(unsigned char) * 
@@ -528,30 +556,49 @@
 
   tcp_gen((char *)tcpheader, nsnode.sin_port, extnode.sin_port, p);
 
-#ifndef LINUX_TCP_HEADER
-  tcpheader->th_sum = trans_check(IPPROTO_TCP, (char *) tcpheader,
-				  sizeof(struct tcphdr) + datalen,
-				  nsnode.sin_addr, extnode.sin_addr);
-#else 
-  tcpheader->check = trans_check(IPPROTO_TCP, (char *) tcpheader,
-				  sizeof(struct tcphdr) + datalen,
-				  nsnode.sin_addr, extnode.sin_addr);
+  unsigned short thsum = 0;
+  // In the case of SYN packet, we negotiate MSS
+   if (ns_tcphdr->tcp_flags_ & TH_SYN) {
+       unsigned char *mss_opt = (unsigned char *) (packet + IP_HEADER_LEN + TCP_HEADER_LEN);
+       *mss_opt++ = 0x02;
+       *mss_opt++ = 0x04;
+
+       unsigned short *mss_val = (unsigned short *)mss_opt;
+       *mss_val = htons(ns_tcphdr->maxseg());
+       
+       tcpheader->th_off += 1;
+
+       thsum = trans_check(IPPROTO_TCP, (char *) tcpheader,
+				       sizeof(struct tcphdr) + 4 + datalen, 
+				       nsnode.sin_addr, extnode.sin_addr);
+   } else {
+       thsum = trans_check(IPPROTO_TCP, (char *) tcpheader,
+	  			       sizeof(struct tcphdr) + datalen,
+				       nsnode.sin_addr, extnode.sin_addr);
+   }
 
-#endif 
+#ifndef LINUX_TCP_HEADER
+   tcpheader->th_sum = thsum;
+#else
+   tcpheader->check = thsum;
+#endif
 
   /* 
      Limits the packets going out to only IP + TCP header. 
      ns will act as an ACK machine.
    */
-  byteswritten = net_->send(packet, hlength + datalen);
+  byteswritten = net_outgoing_->send(packet, hlength + datalen);
   if (byteswritten < 0) {
     fprintf(stderr,"TCPTapAgent(%s): sendpkt (%p, %d): %s\n",
 	    name(), p->accessdata(), ns_cmnhdr->size(), strerror(errno));
     Packet::free(p);
+    free(packet); // freeing the calloc'ed packet. memory leak fix from 2.1b8a  
     return (-1);
     
   }
   
+  free(packet); // freeing the calloc'ed packet. memory leak fix from 2.1b8a 
+
   TDEBUG3("TCPTapAgent(%s): sent packet (sz: %d)\n", name(), hc->size());
   return 0;
 }
diff -ru dist-ns-allinone-2.1b9/ns-2.1b9/emulate/tcptap.h ns-allinone-2.1b9/ns-2.1b9/emulate/tcptap.h
--- dist-ns-allinone-2.1b9/ns-2.1b9/emulate/tcptap.h	Fri Jan 11 15:06:09 2002
+++ ns-allinone-2.1b9/ns-2.1b9/emulate/tcptap.h	Wed Jun 19 12:06:51 2002
@@ -38,6 +38,7 @@
 
 #include "tap.h"
 #include <netinet/in.h>
+#include <netinet/in_systm.h>
 #include <netinet/ip.h>
 #include <netinet/tcp.h>
 #include <sys/socket.h>
diff -ru dist-ns-allinone-2.1b9/ns-2.1b9/link/delay.h ns-allinone-2.1b9/ns-2.1b9/link/delay.h
--- dist-ns-allinone-2.1b9/ns-2.1b9/link/delay.h	Sun Nov  1 18:03:33 1998
+++ ns-allinone-2.1b9/ns-2.1b9/link/delay.h	Wed Jun 19 12:06:51 2002
@@ -44,6 +44,10 @@
 #include "ip.h"
 #include "connector.h"
 
+#ifdef ADD_ETHER_OVERHEAD
+#include <net/ethernet.h>
+#endif
+
 class LinkDelay : public Connector {
  public:
 	LinkDelay();
@@ -52,7 +56,11 @@
 	void handle(Event* e);
 	double delay() { return delay_; }
 	inline double txtime(Packet* p) {
+#ifndef ADD_ETHER_OVERHEAD
 		return (8. * hdr_cmn::access(p)->size() / bandwidth_);
+#else
+		return (8. * (hdr_cmn::access(p)->size() + ETHER_HDR_LEN) / bandwidth_);
+#endif
 	}
 	double bandwidth() const { return bandwidth_; }
 	void pktintran(int src, int group);
diff -ru dist-ns-allinone-2.1b9/ns-2.1b9/tcl/lib/ns-default.tcl ns-allinone-2.1b9/ns-2.1b9/tcl/lib/ns-default.tcl
--- dist-ns-allinone-2.1b9/ns-2.1b9/tcl/lib/ns-default.tcl	Wed Apr 10 16:44:10 2002
+++ ns-allinone-2.1b9/ns-2.1b9/tcl/lib/ns-default.tcl	Wed Jun 19 12:06:51 2002
@@ -66,6 +66,7 @@
 CMUTrace set debug_ false
 
 Scheduler/RealTime set maxslop_ 0.010; # max allowed slop b4 error (sec)
+Scheduler/RealTimeCalendar set maxslop_ 0.010; # max allowed slop b4 error (sec)
 
 #
 # Queues and associated
diff -ru dist-ns-allinone-2.1b9/ns-2.1b9/tcp/tcp-full.cc ns-allinone-2.1b9/ns-2.1b9/tcp/tcp-full.cc
--- dist-ns-allinone-2.1b9/ns-2.1b9/tcp/tcp-full.cc	Wed Mar 20 19:14:56 2002
+++ ns-allinone-2.1b9/ns-2.1b9/tcp/tcp-full.cc	Wed Jun 19 12:06:51 2002
@@ -76,7 +76,7 @@
  *
  * Some warnings and comments:
  *	this version of TCP will not work correctly if the sequence number
- *	goes above 2147483648 due to sequence number wrap
+ *	goes above  due to sequence number wrap
  *
  *	this version of TCP by default sends data at the beginning of a
  *	connection in the "typical" way... That is,
@@ -358,16 +358,16 @@
 	case TCPS_CLOSED:
 	case TCPS_LISTEN:
                 reset();
-                curseq_ = iss_ + nb;
+                INCR_SEQ( curseq_, SEQ_ADD(iss_, nb));
                 connect();              // initiate new connection
 		break;
 
 	case TCPS_ESTABLISHED:
 	case TCPS_SYN_SENT:
 	case TCPS_SYN_RECEIVED:
-                if (curseq_ < iss_) 
+	        if (SEQ_LT(curseq_, iss_) ) 
                         curseq_ = iss_; 
-                curseq_ += nb;
+                INCR_SEQ(curseq_, nb);
 		break;
 
 	default:
@@ -433,7 +433,7 @@
 void
 FullTcpAgent::usrclosed()
 {
-	curseq_ = maxseq_ - 1;	// now, no more data
+	curseq_ = SEQ_SUB(maxseq_, 1);	// now, no more data
 	infinite_send_ = FALSE;	// stop infinite send
 
 	switch (state_) {
@@ -715,7 +715,7 @@
 int
 FullTcpAgent::rcvseqinit(int seq, int dlen)
 {
-	return (seq + dlen + 1);
+	return (SEQ_ADD(seq, dlen + 1));
 }
 
 /*
@@ -743,8 +743,8 @@
 FullTcpAgent::pack(Packet *pkt)
 {
 	hdr_tcp *tcph = hdr_tcp::access(pkt);
-	return (tcph->ackno() >= highest_ack_ &&
-		tcph->ackno() < recover_);
+	return (SEQ_GE(tcph->ackno(), highest_ack_) &&
+		SEQ_LT(tcph->ackno(), recover_));
 }
 
 /*
@@ -801,6 +801,9 @@
         tcph->hlen() = tcpip_base_hdr_size_;
 	tcph->hlen() += build_options(tcph);
 
+	/* Fill in maxseg_ for MSS negotiation in TCPTap (NSE) */
+	tcph->maxseg() = maxseg_;
+	
 	/*
 	 * Explicit Congestion Notification (ECN) related:
 	 * Bits in header:
@@ -909,24 +912,24 @@
 	else
 		size_ =  maxseg_ + headersize();
 
-	int is_retransmit = (seqno < maxseq_);
+	int is_retransmit = SEQ_LT(seqno, maxseq_);
 	int quiet = (highest_ack_ == maxseq_);
 	int pflags = outflags();
 	int syn = (seqno == iss_);
 	int emptying_buffer = FALSE;
 	int buffered_bytes = (infinite_send_) ? TCP_MAXSEQ :
-				curseq_ - highest_ack_ + 1;
+				SEQ_ADD( SEQ_SUB(curseq_, highest_ack_), 1);
 
 	int win = window() * maxseg_;	// window (in bytes)
-	int off = seqno - highest_ack_;	// offset of seg in window
+	int off = SEQ_SUB(seqno, highest_ack_);	// offset of seg in window
 	int datalen;
 	int amtsent = 0;
 
 	// be careful if we have not received any ACK yet
 	if (highest_ack_ < 0) {
 		if (!infinite_send_)
-			buffered_bytes = curseq_ - iss_;;
-		off = seqno - iss_;
+			buffered_bytes = SEQ_SUB(curseq_, iss_);
+		off = SEQ_SUB(seqno, iss_);
 	}
 
 	if (syn && !data_on_syn_)
@@ -965,7 +968,7 @@
 	// a dataless SYN packet counts also
 	//
 
-	if (!infinite_send_ && ((seqno + datalen) > curseq_ || 
+	if (!infinite_send_ && (SEQ_GT( SEQ_ADD(seqno, datalen), curseq_) || 
 	    (syn && datalen == 0))) {
 		emptying_buffer = TRUE;
 		//
@@ -1069,15 +1072,15 @@
 	 * around until we actually send a segment
 	 */
 
-	int reliable = datalen + syn + fin; // seq #'s reliably sent
+	int reliable = SEQ_ADD(datalen, syn + fin); // seq #'s reliably sent
 	if (cong_action_ && reliable > 0)
 		cong_action_ = FALSE;
 
 	// highest: greatest sequence number sent + 1
 	//	and adjusted for SYNs and FINs which use up one number
 
-	int highest = seqno + reliable;
-	if (highest > maxseq_) {
+	int highest = SEQ_ADD(seqno, reliable);
+	if (SEQ_GT(highest, maxseq_)) {
 		maxseq_ = highest;
 		//
 		// if we are using conventional RTT estimation,
@@ -1176,10 +1179,11 @@
         int win = window() * maxseg_;
         int topwin = curseq_; // 1 seq number past the last byte we can send
 
-        if ((topwin > highest_ack_ + win) || infinite_send_)
-                topwin = highest_ack_ + win; 
+	int hiack_plus_win = SEQ_ADD(highest_ack_, win);
+        if (SEQ_GT(topwin, hiack_plus_win) || infinite_send_)
+                INCR_SEQ( topwin, hiack_plus_win); 
 
-	return (seq < topwin);
+	return (SEQ_LT(seq, topwin));
 }
 /*
  * Process an ACK
@@ -1200,7 +1204,7 @@
 	hdr_tcp *tcph = hdr_tcp::access(pkt);
 
 	register int ackno = tcph->ackno();
-	int progress = (ackno > highest_ack_);
+	int progress = SEQ_GT(ackno, highest_ack_);
 
 	if (ackno == maxseq_) {
 		cancel_rtx_timer();	// all data ACKd
@@ -1219,7 +1223,7 @@
 	// update t_seqno_ here, otherwise we would be doing
 	// go-back-n.
 
-	if (t_seqno_ < highest_ack_)
+	if (SEQ_LT(t_seqno_, highest_ack_))
 		t_seqno_ = highest_ack_; // seq# to send next
 
         /*
@@ -1235,7 +1239,7 @@
 			recent_age_ = now();
 			recent_ = tcph->ts();
 			rtt_update(now() - tcph->ts_echo());
-		} else if (rtt_active_ && ackno > rtt_seq_) {
+		} else if (rtt_active_ && SEQ_GT(ackno,rtt_seq_)) {
 			// got an RTT sample, record it
 			// "t_backoff_ = 1;" deleted by T. Kelly.
 			rtt_active_ = FALSE;
@@ -1337,10 +1341,10 @@
 	if (flags_ & TF_ACKNOW)
 		return TRUE;
 
-	int spa = (spa_thresh_ > 0 && ((rcv_nxt_ - irs_)  < spa_thresh_)) ?
+	int spa = (spa_thresh_ > 0 && (SEQ_SUB(rcv_nxt_,irs_)  < spa_thresh_)) ?
 		1 : segs_per_ack_;
 		
-	return ((rcv_nxt_ - last_ack_sent_) >= (spa * maxseg_));
+	return (SEQ_SUB(rcv_nxt_, last_ack_sent_) >= (spa * maxseg_));
 }
 
 /*
@@ -1479,7 +1483,7 @@
 		 * See RFC1323 (now RFC1323 bis)
                  */
                 if (ts_option_ && !fh->no_ts_ &&
-		    tcph->seqno() <= last_ack_sent_) {
+		    SEQ_LE(tcph->seqno(), last_ack_sent_)) {
 			/*
 			 * this is the case where the ts value is newer than
 			 * the last one we've seen, and the seq # is the one
@@ -1517,7 +1521,7 @@
 			// If we are in fast
 			// recovery, go below so we can remember to deflate
 			// the window if we need to
-			if (ackno > highest_ack_ && ackno < maxseq_ &&
+			if (SEQ_GT(ackno, highest_ack_) && SEQ_LT(ackno, maxseq_) &&
 			    cwnd_ >= wnd_ && !fastrecov_) {
 				newack(pkt);	// update timers,  highest_ack_
 				send_much(0, REASON_NORMAL, maxburst_);
@@ -1535,7 +1539,7 @@
 			//	this routine scans all tcpcb's looking for
 			//	DELACK segments and when it finds them
 			//	changes DELACK to ACKNOW and calls tcp_output()
-			rcv_nxt_ += datalen;
+			INCR_SEQ(rcv_nxt_, datalen);
 			flags_ |= TF_DELACK;
 			recvBytes(datalen); // notify application of "delivery"
 			//
@@ -1636,7 +1640,7 @@
 
 		/* drop if it's a SYN+ACK and the ack field is bad */
 		if ((tiflags & TH_ACK) &&
-			((ackno <= iss_) || (ackno > maxseq_))) {
+			(SEQ_LE(ackno, iss_) || SEQ_GT(ackno, maxseq_))) {
 			// not an ACK for our SYN, discard
 			fprintf(stderr,
 			    "%f: FullTcpAgent::recv(%s): bad ACK for our SYN: ",
@@ -1730,14 +1734,14 @@
 			 * SYN+ACK, so t_seqno_ will have been
 			 * advanced to 2... reduce this
 			 */
-			t_seqno_--;	// CHECKME
+			DECR_SEQ(t_seqno_, 1);	// CHECKME
 		}
 
 trimthenstep6:
 		/*
 		 * advance the seq# to correspond to first data byte
 		 */
-		tcph->seqno()++;
+		INCR_SEQ(tcph->seqno(), 1);
 
 		if (tiflags & TH_ACK)
 			goto process_ACK;
@@ -1807,13 +1811,13 @@
 	// do anything with it.  In particular, would like to
 	// avoid ACKing an incoming FIN+ACK while in CLOSING
 	//
-	todrop = rcv_nxt_ - tcph->seqno();  // how much overlap?
+	todrop = SEQ_SUB(rcv_nxt_, tcph->seqno());  // how much overlap?
 
 	if (todrop > 0 && ((tiflags & (TH_SYN)) || datalen > 0)) {
 //printf("%f(%s): trim 1..todrop:%d, dlen:%d\n",now(), name(), todrop, datalen);
 		if (tiflags & TH_SYN) {
 			tiflags &= ~TH_SYN;
-			tcph->seqno()++;
+			INCR_SEQ(tcph->seqno(), 1);
 			th->size()--;	// XXX Must decrease packet size too!!
 					// Q: Why?.. this is only a SYN
 			todrop--;
@@ -1850,7 +1854,7 @@
 		 * Trim duplicate data from the front of the packet
 		 */
 
-		tcph->seqno() += todrop;
+		INCR_SEQ(tcph->seqno(), todrop);
 		th->size() -= todrop;	// XXX Must decrease size too!!
 					// why? [kf]..prob when put in RQ
 		datalen -= todrop;
@@ -1863,7 +1867,7 @@
 	 * record the timestamp.
 	 * See RFC1323 (now RFC1323 bis)
 	 */
-	if (ts_option_ && !fh->no_ts_ && tcph->seqno() <= last_ack_sent_) {
+	if (ts_option_ && !fh->no_ts_ && SEQ_LE(tcph->seqno(), last_ack_sent_)) {
 		/*
 		 * this is the case where the ts value is newer than
 		 * the last one we've seen, and the seq # is the one we expect
@@ -1894,7 +1898,7 @@
 
 	switch (state_) {
 	case TCPS_SYN_RECEIVED:	/* want ACK for our SYN+ACK */
-		if (ackno < highest_ack_ || ackno > maxseq_) {
+		if (SEQ_LT(ackno, highest_ack_) || SEQ_GT(ackno, maxseq_)) {
 			// not in useful range
 		    	fprintf(stderr,
 		    		"%f: FullTcpAgent(%s): ack(%d) not in range while in SYN_RECEIVED: ",
@@ -1968,13 +1972,13 @@
 		//	try not to be fooled by data
 		//
 
-		if (fastrecov_ && (datalen == 0 || ackno > highest_ack_))
+		if (fastrecov_ && (datalen == 0 || SEQ_GT(ackno, highest_ack_)))
 			pipe_ -= maxseg_;
 
 		// look for dup ACKs (dup ack numbers, no data)
 		//
 		// do fast retransmit/recovery if at/past thresh
-		if (ackno <= highest_ack_) {
+		if (SEQ_LE(ackno, highest_ack_)) {
 			// a pure ACK which doesn't advance highest_ack_
 			if (datalen == 0 && (!dupseg_fix_ || !dupseg)) {
 
@@ -1998,7 +2002,7 @@
                                  */
 
 				if ((rtx_timer_.status() != TIMER_PENDING) ||
-				    ackno < highest_ack_) {
+				    SEQ_LT(ackno, highest_ack_)) {
 					// Q: significance of timer not pending?
 					// ACK below highest_ack_
 					oldack();
@@ -2038,7 +2042,7 @@
 
 process_ACK:
 
-		if (ackno > maxseq_) {
+		if (SEQ_GT(ackno, maxseq_)) {
 			// ack more than we sent(!?)
 			fprintf(stderr,
 			    "%f: FullTcpAgent::recv(%s) too-big ACK (maxseq:%d): ",
@@ -2099,7 +2103,7 @@
 		 * If no data (only SYN) was ACK'd,
 		 *    skip rest of ACK processing.
 		 */
-		if (ackno == (highest_ack_ + 1))
+		if (ackno == SEQ_ADD(highest_ack_, 1))
 			goto step6;
 
 		// if we are delaying initial cwnd growth (probably due to
@@ -2213,7 +2217,7 @@
 			// accept the data here as-is (i.e. don't
 			// require being in ESTABLISHED state)
 			flags_ |= TF_DELACK;
-			rcv_nxt_ += datalen;
+			INCR_SEQ(rcv_nxt_, datalen);
 			tiflags = tcph->flags() & TH_FIN;
 
 			// give to "application" here
@@ -2231,11 +2235,11 @@
 			// Note that we may have just a FIN here (datalen = 0)
 			int rcv_nxt_old_ = rcv_nxt_; // notify app. if changes
 			tiflags = reass(pkt);
-			if (rcv_nxt_ > rcv_nxt_old_) {
+			if (SEQ_GT(rcv_nxt_, rcv_nxt_old_)) {
 				// if rcv_nxt_ has advanced, must have
 				// been a hole fill.  In this case, there
 				// is something to give to application
-				recvBytes(rcv_nxt_ - rcv_nxt_old_);
+				recvBytes(SEQ_SUB(rcv_nxt_, rcv_nxt_old_));
 			}
 			flags_ |= TF_ACKNOW;
 
@@ -2264,7 +2268,7 @@
 	if (tiflags & TH_FIN) {
 		if (TCPS_HAVERCVDFIN(state_) == 0) {
 			flags_ |= TF_ACKNOW;
- 			rcv_nxt_++;
+ 			INCR_SEQ(rcv_nxt_, 1);
 		}
 		switch (state_) {
                 /*
@@ -2301,7 +2305,7 @@
 
 	if (needoutput || (flags_ & TF_ACKNOW))
 		send_much(1, REASON_NORMAL, maxburst_);
-	else if (curseq_ >= highest_ack_ || infinite_send_)
+	else if (SEQ_GE(curseq_, highest_ack_) || infinite_send_)
 		send_much(0, REASON_NORMAL, maxburst_);
 	// K: which state to return to when nothing left?
 
@@ -2332,9 +2336,9 @@
 	if (tiflags & TH_ACK) {
 		sendpacket(ackno, 0, 0x0, 0, REASON_NORMAL);
 	} else {
-		int ack = tcph->seqno() + datalen;
+		int ack = SEQ_ADD(tcph->seqno(), datalen);
 		if (tiflags & TH_SYN)
-			ack--;
+			DECR_SEQ(ack, 1);
 		sendpacket(0, ack, TH_ACK, 0, REASON_NORMAL);
 	}
 drop:
@@ -2362,7 +2366,7 @@
 FullTcpAgent::dupack_action()
 {   
 
-        int recovered = (highest_ack_ > recover_);
+        int recovered = SEQ_GT(highest_ack_, recover_);
 
 	fastrecov_ = TRUE;
 	rtxbytes_ = 0;
@@ -2548,7 +2552,7 @@
 void
 TahoeFullTcpAgent::dupack_action()
 {  
-        int recovered = (highest_ack_ > recover_);
+        int recovered = SEQ_GT(highest_ack_, recover_);
 
 	fastrecov_ = TRUE;
 	rtxbytes_ = 0;
@@ -2665,11 +2669,11 @@
 SackFullTcpAgent::dupack_action()
 {
 
-        int recovered = (highest_ack_ > recover_);
+        int recovered = SEQ_GT(highest_ack_, recover_);
 
 	fastrecov_ = TRUE;
 	rtxbytes_ = 0;
-	pipe_ = maxseq_ - highest_ack_ - sq_.total();
+	pipe_ = SEQ_SUB( SEQ_SUB(maxseq_, highest_ack_), sq_.total());
 
 //printf("%f: SACK DUPACK-ACTION:pipe_:%d, sq-total:%d, bugfix:%d, cwnd:%d, highest_ack:%d, recover_:%d\n",
 //now(), pipe_, sq_.total(), bug_fix_, int(cwnd_), int(highest_ack_), recover_);
@@ -2709,7 +2713,7 @@
 	recover_ = maxseq_;	// where I am when recovery starts
 
 	int amt = fast_retransmit(highest_ack_);
-	h_seqno_ = highest_ack_ + amt;
+	h_seqno_ = SEQ_ADD(highest_ack_, amt);
 
 //printf("%f: FAST-RTX seq:%d, h_seqno_ is now:%d, pipe:%d, cwnd:%d, recover:%d\n",
 //now(), int(highest_ack_), h_seqno_, pipe_, int(cwnd_), recover_);
@@ -2722,12 +2726,12 @@
 void
 SackFullTcpAgent::pack_action(Packet* p)
 {
-	if (!sq_.empty() && sack_min_ < highest_ack_) {
+	if (!sq_.empty() && SEQ_LT(sack_min_, highest_ack_)) {
 		sack_min_ = highest_ack_;
 		sq_.cleartonxt();
 	}
 	pipe_ -= maxseg_;	// see comment in tcp-sack1.cc
-	if (h_seqno_ < highest_ack_)
+	if (SEQ_LT(h_seqno_, highest_ack_))
 		h_seqno_ = highest_ack_;
 }
 
@@ -2737,7 +2741,7 @@
 //printf("%f: EXITING fast recovery, recover:%d\n",
 //now(), recover_);
 	fastrecov_ = pipectrl_ = FALSE;
-        if (!sq_.empty() && sack_min_ < highest_ack_) {
+        if (!sq_.empty() && SEQ_LT(sack_min_, highest_ack_)) {
                 sack_min_ = highest_ack_;
                 sq_.cleartonxt();
         }
@@ -2823,8 +2827,8 @@
 		return (FullTcpAgent::send_allowed(seq));
 
 	// don't overshoot receiver's advertised window
-	int topawin = highest_ack_ + int(wnd_) * maxseg_;
-	if (seq >= topawin) {
+	int topawin = SEQ_ADD(highest_ack_, int(wnd_) * maxseg_);
+	if (SEQ_GE(seq, topawin)) {
 //printf("%f: SEND(%d) NOT ALLOWED DUE TO AWIN:%d, pipe:%d, cwnd:%d\n",
 //now(), seq, topawin, pipe_, int(cwnd_));
 		return FALSE;
@@ -2846,7 +2850,7 @@
 SackFullTcpAgent::nxt_tseq()
 {
 
-	int in_recovery = (highest_ack_ < recover_);
+	int in_recovery = SEQ_LT(highest_ack_, recover_);
 	int seq = h_seqno_;
 
 	if (!in_recovery) {
@@ -2885,13 +2889,13 @@
 			// adjust h_seqno, as we may have
 			// been "jumped ahead" by learning
 			// about a filled hole
-			if (seq > h_seqno_)
+			if (SEQ_GT(seq, h_seqno_))
 				h_seqno_ = seq;
 			return (seq);
 		} else if (fcnt <= 0)
 			break;
 		else {
-			seq += maxseg_;
+			INCR_SEQ(seq, maxseg_);
 		}
 	}
 //if (int(t_seqno_) > 1)
diff -ru dist-ns-allinone-2.1b9/ns-2.1b9/tcp/tcp-full.h ns-allinone-2.1b9/ns-2.1b9/tcp/tcp-full.h
--- dist-ns-allinone-2.1b9/ns-2.1b9/tcp/tcp-full.h	Sun Dec  2 19:41:16 2001
+++ ns-allinone-2.1b9/ns-2.1b9/tcp/tcp-full.h	Wed Jun 19 12:06:51 2002
@@ -104,6 +104,20 @@
 #define PF_TIMEOUT 0x04	    /* protocol defined */
 #define	TCP_PAWS_IDLE	(24 * 24 * 60 * 60)	/* 24 days in secs */
 
+#define SEQ_LT(a,b)  (((a)<(b) && (b)-(a) < TCP_MAXSEQ/2) || ((a)>(b) && (a)-(b) >= TCP_MAXSEQ/2))
+#define SEQ_LE(a,b)  (((a)<=(b) && (b)-(a) < TCP_MAXSEQ/2) || ((a)>(b) && (a)-(b) >= TCP_MAXSEQ/2))
+#define SEQ_GT(a,b)  (((a)>(b) && (a)-(b) < TCP_MAXSEQ/2) || ((a)<(b) && (b)-(a) >= TCP_MAXSEQ/2))
+#define SEQ_GE(a,b)  (((a)>=(b) && (a)-(b) < TCP_MAXSEQ/2) || ((a)<(b) && (b)-(a) >= TCP_MAXSEQ/2))
+#define INCR_SEQ(num, val) (num) = ((num) + (val)) % TCP_MAXSEQ
+#define SEQ_ADD(num, val) (((num) + (val)) % TCP_MAXSEQ)
+inline int SEQ_SUB(int num, int val) {
+  int ret = num - val;
+    return( abs(ret) < TCP_MAXSEQ/2 ? ret : ((int)(((long long)(num) - (val) + TCP_MAXSEQ) % TCP_MAXSEQ)) );
+}
+#define DECR_SEQ(num, val) (num) = SEQ_SUB((num), (val))
+#define SEQ_MIN(x,y) (SEQ_LT((x),(y))?(x):(y))
+#define SEQ_MAX(x,y) (SEQ_GT((x),(y))?(x):(y))
+
 class FullTcpAgent;
 class DelAckTimer : public TimerHandler {
 public:
@@ -187,9 +201,9 @@
 	}
 	virtual void sent(int seq, int amt) {
 		if (seq == t_seqno_)
-			t_seqno_ += amt;
+			INCR_SEQ(t_seqno_, amt);
 		pipe_ += amt;
-		if (seq < int(maxseq_))
+		if (SEQ_LT(seq, int(maxseq_)))
 			rtxbytes_ += amt;
 	}
 	virtual void oldack() {			// what to do on old ack
diff -ru dist-ns-allinone-2.1b9/ns-2.1b9/tcp/tcp.h ns-allinone-2.1b9/ns-2.1b9/tcp/tcp.h
--- dist-ns-allinone-2.1b9/ns-2.1b9/tcp/tcp.h	Fri Mar 29 19:40:43 2002
+++ ns-allinone-2.1b9/ns-2.1b9/tcp/tcp.h	Wed Jun 19 12:06:51 2002
@@ -54,6 +54,8 @@
 	int ackno_;             /* ACK number for FullTcp */
 	int hlen_;              /* header len (bytes) for FullTcp */
 	int tcp_flags_;         /* TCP flags for FullTcp */
+        int maxseg_;            /* MSS for TCPTap to negotiate in the SYN segment
+				   needed in NSE */
 
 	static int offset_;	// offset for this header
 	inline static int& offset() { return offset_; }
@@ -72,6 +74,7 @@
 	int& hlen() { return (hlen_); }
 	int& ackno() { return (ackno_); }  
 	int& flags() { return (tcp_flags_); }
+	int& maxseg() { return (maxseg_); }
 };
 
 /* these are used to mark packets as to why we xmitted them */
diff -ru dist-ns-allinone-2.1b9/ns-2.1b9/tools/random.cc ns-allinone-2.1b9/ns-2.1b9/tools/random.cc
--- dist-ns-allinone-2.1b9/ns-2.1b9/tools/random.cc	Tue Aug  8 23:51:14 2000
+++ ns-allinone-2.1b9/ns-2.1b9/tools/random.cc	Wed Jun 19 12:06:51 2002
@@ -47,11 +47,13 @@
 #define GCC_THROW
 #endif
 
+#if 0
 RANDOM_RETURN_TYPE
 random() GCC_THROW
 {
 	printf("random() called in ns.\nRandom is not portable, please use Random::uniform() instead.\n");
 	abort();
 }
+#endif
 
 #endif /* !WIN32 */
diff -ru dist-ns-allinone-2.1b9/ns-2.1b9/trace/cmu-trace.cc ns-allinone-2.1b9/ns-2.1b9/trace/cmu-trace.cc
--- dist-ns-allinone-2.1b9/ns-2.1b9/trace/cmu-trace.cc	Mon Apr  1 16:07:28 2002
+++ ns-allinone-2.1b9/ns-2.1b9/trace/cmu-trace.cc	Wed Jun 19 12:10:28 2002
@@ -826,6 +826,8 @@
 			break;
 		case PT_GAF:
 			break;
+		case PT_LIVE:
+			break;
 		default:
 			fprintf(stderr, "%s - invalid packet type (%s).\n",
 				__PRETTY_FUNCTION__, packet_info.name(ch->ptype()));
