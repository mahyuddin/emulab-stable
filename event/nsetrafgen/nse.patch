--- dist-ns-allinone-2.26/install	Wed Feb 26 16:07:51 2003
+++ ns-allinone-2.26/install	Thu Jun  5 16:55:16 2003
@@ -41,301 +41,47 @@
 # Get current path
 CUR_PATH=`pwd`
 
-# Check if we are using Cygwin, and if so, if it is a bona fide install
-# Cygwin patches contributed by Nicolas Christin <nicolas@cs.virginia.edu>
+if [ -x /usr/local/tcl8.3.2/bin/tclsh8.3 ] ; then
+  V_TCLSH=/usr/local/tcl8.3.2/bin/tclsh8.3 
+  export V_TCLSH
+  WITHTCL_PATH=/usr/local/tcl8.3.2
+  export WITHTCL_PATH
 
-echo "============================================================"
-echo "* Testing for Cygwin environment"
-echo "============================================================"
-
-if [ -x /usr/bin/uname ]; then
-        # it may be a Cygwin install
-        test_cygwin=`uname | tr [a-z] [A-Z] | sed -e 's|.*CYGWIN.*|true|'`;
-        if  [ "${test_cygwin}" = "true" ]; then
-                echo "Cygwin detected";
-                echo "Note: Cygwin install is still considered EXPERIMENTAL";
-                echo "";
-                echo -n "Checking Cygwin version is >=1.3.12... "
-                cmaj=` uname -r | sed -e 's/^\([0-9]*\)\.\([0-9]*\).\([0-9]*\).*/\1/'`;
-                echo $cmaj | grep -v [0-9] >/dev/null 2>&1
-                if [ "$?" -eq "0" ]; then
-                        cmaj=0;
-                fi;
-                cmin=` uname -r | sed -e 's/^\([0-9]*\)\.\([0-9]*\).\([0-9]*\).*/\2/'`;
-                echo $cmin | grep -v [0-9] >/dev/null 2>&1
-                if [ "$?" -eq "0" ]; then
-                        cmin=0;
-                fi;
-                cpat=` uname -r | sed -e 's/^\([0-9]*\)\.\([0-9]*\).\([0-9]*\).*/\3/'`;
-                echo $cpat | grep -v [0-9] >/dev/null 2>&1
-                if [ "$?" -eq "0" ]; then
-                        cpat=0;
-                fi;
-                echo -n "$cmaj.$cmin.$cpat ";
-                if ([ "$cmaj" -gt "1" ]) || ([ "$cmaj" -eq "1" ] && [ $cmin -gt "3" ]) || ([ "$cmaj" -eq 1 ] && [ $cmin -eq "3" ] && [ "$cpat" -ge "12" ]); then
-                        echo "should be ok";
-                else
-                        echo "*** POSSIBLE PROBLEM ***";
-                        echo "";
-                        echo "ns-allinone-${NSVER} has not been tested under versions of Cygwin older than";
-                        echo "1.3.12. Your version ($cmaj.$cmin.$cpat) appears to be older than that. Success of";
-                        echo "the install process is therefore NOT GUARANTEED.";
-                        echo "";
-                        cygversion="failed";                
-		fi;
-                echo -n "Checking filesystems are mounted as UNIX filetype... ";
-                mount | grep "textmode" >/dev/null 2>&1;
-                if [ "$?" -eq "0" ]; then
-                        echo "*** NO! ***";
-                        mount_test="failed";
-                        echo "";
-                        echo "It appears that some of your Cygwin shares are mounted as DOS file";
-                        echo "type. This has not been tested, but is likely to result in failure of";
-                        echo "validation tests. Success of the install process is also NOT";
-                        echo "GUARANTEED.";
-                        echo "";
-                        echo "Refer to the Cygwin user guide for how to install Cygwin with the UNIX";
-                        echo "file text mode.";
-                        echo "";
-                else
-                        echo "yes";
-                        echo -n "Checking default mode is binmode... ";
-                        echo ${CYGWIN} | grep "nobinmode" >/dev/null 2>&1;
-                        if [ "$?" -eq "0" ]; then
-                                cyg_env_var="failed";
-                                echo "*** NO! ***";
-                                echo "";
-                                echo "Your \$CYGWIN environment variable specifies \"nobinmode\". This is";
-                                echo "likely to result in failure of validation tests, and (possibly) of";
-                                echo "the whole install process. You need to have the \$CYGWIN environment";
-                                echo "variable set to \"binmode\". Please refer to the Cygwin user guide for";
-                                echo "details on how to change this.";
-                                echo "";
-                        else 
-                                echo "yes";
-                        fi;
-                fi;                           
-                if [ "$cygversion" = "failed" ] || [ "$cyg_env_var" = "failed" ] || [ "$mount_test" = "failed" ]; then
-                        echo "";
-                        echo "Tests indicate that your installation of Cygwin may not be suitable for";
-                        echo "installing ns-2 allinone.";
-                        echo "";
-                        echo -n "Do you wish to proceed regardless? [y/n] "
-                        read answer;
-                        if [ "$answer" != "y" ] && [ "$answer" != "Y" ]; then
-                                die "Installation aborted...";
-                        fi;
-                fi;
-                echo "Patching Tcl for Cygwin.";
-                if [ ! -f ./tcl${TCLVER}/generic/tcl.h.orig ]; then
-                        cp ./tcl${TCLVER}/generic/tcl.h ./tcl${TCLVER}/generic/tcl.h.orig;
-                        echo "The original tcl${TCLVER}/generic/tcl.h is backed up as tcl${TCLVER}/generic/tcl.h.orig";
-                        sed -e 's/\#define _TCL/\#define _TCL\`\`\#ifdef __CYGWIN__\`\#define HAVE_TM_ZONE 1\`\#endif \/\* __CYGWIN__ \*\//g' ./tcl${TCLVER}/generic/tcl.h.orig | tr '\`' '\n' > ./tcl${TCLVER}/generic/tcl.h;
-                fi;
-                touch ./tcl${TCLVER}/generic/tclStubInit.c;
-                echo "Patching sgb for Cygwin.";
-                cp ./sgb/Makefile ./sgb/Makefile.orig;
-                echo "The original sgb/Makefile is backed up as sgb/Makefile.orig";
-                sed -e 's|rm \(.*\)test_io test_graph test_flip test_sample\(.*\)|rm -f \1test_io.exe test_graph.exe test_flip.exe test_sample.exe\2|' ./sgb/Makefile.orig > ./sgb/Makefile;
-                echo "Setting executable format to .exe...";
-                EXE=".exe";
-        else
-                echo "Cygwin not detected, proceeding with regular install.";
-                EXE=;
-        fi;
-else
-        echo "Cygwin not detected, proceeding with regular install.";
-fi;
-
-
-
-# Compile and install xgraph
-
-echo "============================================================"
-echo "* Build XGraph-$XGRAPHVER"
-echo "============================================================"
-
-cd ./xgraph-$XGRAPHVER
-./configure --prefix=../
-if  [ "${test_cygwin}" = "true" ]; then
-       touch stamp-h;
-fi;
-if make
-then
-	echo "xgraph has been installed successfully. "
-else 
-	echo "Can not create xgraph; But xgraph is an optional package, continuing..."
-fi
-
-cd ../
-
-# Compile and install cweb and sgblib
-
-echo "============================================================"
-echo "* Build CWeb"
-echo "============================================================"
-
-cd ./cweb
-
-if [ ! -f ./Makefile ]
-then
-	echo "ns-allinone unable to install cweb for you. Please install it manually. cweb is used by sgb to create sgblibrary needed by scenario-generator. But this will not affect the use of ns as such, so continue.."
-else
-	echo "Making cweb"
-	touch *.c
-	make all || warn "cweb failed to make, but it's optional"
-	# xxx: other stuff will fail...
-	chmod 755 cweave${EXE}
-	chmod 755 ctangle${EXE}
-	cd ..
-	#echo "cd .."
-	if [ ! -d bin ]
-	then
-		mkdir bin
-	fi
-	cd bin
-	ln -s $CUR_PATH/cweb/cweave${EXE} cweave${EXE}
-	ln -s $CUR_PATH/cweb/ctangle${EXE} ctangle${EXE}
-fi
-
-cd ..
-PATH=$CUR_PATH/bin:$PATH
-export PATH
-
-echo "============================================================"
-echo "* Build Stanford GraphBase"
-echo "============================================================"
-
-cd ./sgb
-if [ ! -f ./Makefile ]
-	then
-	echo "Unable to create sgb library. This library is used by gt-itm and so for scenario generators. If you already have sgblib (possible if you are on solaris,sunos or freebsd platforms) you may still be able to run gt-itm. so continuing.."
-else
-	echo "Making sgb"
-	if make tests
-	then
-                if [ -f libgb.a ] ; then
-                        rm -f ../gt-itm/lib/libgb.a
-			cp libgb.a ../gt-itm/lib/libgb.a
-                else 
-		        echo "* Weird: sgb said it has been built but we can't find libgb.a! "
-			exit -1
-                fi
-	else
-	        echo "Unable to create sgb library, but it's optional, so continuing..."
-	fi
-fi
-
-cd ..
-
-# Compile and install gt-itm & sgb2ns
-
-echo "============================================================"
-echo "* Build GT-ITM"
-echo "============================================================"
-
-if [ -f ./gt-itm/lib/libgb.a ]
-then
- if [ ! -f ./gt-itm/src/Makefile ] 
-    then
-    echo "ns-alline is unable to install gt-itm sgb2ns for you, please install"
-    echo "them manually. You can't run scenario generator without gt-itm"
-    echo "and sgb2ns. But it will not affect you use ns, so continue ..."
- else
-    cd ./gt-itm/src
-    if make
-    then
-      echo "gt-itm has been installed successfully."
-    fi
-    
-    cd ../sgb2ns
-    if make
-    then
-      echo "sgb2ns has been installed successfully."
-    fi
-   cd ../../
- fi
-else
-    echo "sgb lib not found. gt-itm & sgb2ns could not be installed. Continuing.."
-fi
-
-# Build zlib
-
-echo "============================================================"
-echo "* Build zlib"
-echo "============================================================"
-
-cd ./zlib-1.1.4
-
-if ./configure --exec-prefix=../ --prefix=../
-then
-	if make
-	then
-		echo "Zlib has been installed successfully."
-	else
-		warn "Zlib make failed, but it's optional Continue ..."
-	fi
-else
-	warn "Zlib-1.1.4 configuration failed, but it's optional, so continuing ..."
-fi
-
-cd ../
-
-# Build Tcl8.3.5
-
-echo "============================================================"
-echo "* Build tcl$TCLVER"
-echo "============================================================"
-
-cd ./tcl$TCLVER/unix
-if [ -f Makefile ] ; then 
-	make distclean
-fi
-
-blame='Tcl is not part of the ns project.  Please see www.Scriptics.com
-to see if they have a fix for your platform.'
-./configure --enable-gcc --disable-shared --prefix=$CUR_PATH || die "tcl8.3.2 configuration failed! Exiting ..."
-if make 
-then 
-	echo "tcl$TCLVER make succeeded."
-	make install || die "tcl$TCLVER installation failed."
-	echo "tcl$TCLVER installation succeeded."
-	cp ../generic/*.h ../../include
 else
-	echo "tcl$TCLVER make failed! Exiting ..."
-	echo "For problems with Tcl/Tk see http://www.scriptics.com"
-	exit
-fi
 
-cd ../../
+  # Build Tcl8.3.5
+
+  echo "============================================================"
+  echo "* Build tcl$TCLVER"
+  echo "============================================================"
+
+  cd ./tcl$TCLVER/unix
+  if [ -f Makefile ] ; then 
+	  make distclean
+  fi
+
+  blame='Tcl is not part of the ns project.  Please see www.Scriptics.com
+  to see if they have a fix for your platform.'
+  ./configure --enable-gcc --disable-shared --prefix=$CUR_PATH || die "tcl8.3.2 configuration failed! Exiting ..."
+  if make 
+  then 
+  	  echo "tcl$TCLVER make succeeded."
+	  make install || die "tcl$TCLVER installation failed."
+	  echo "tcl$TCLVER installation succeeded."
+	  cp ../generic/*.h ../../include
+  else
+	  echo "tcl$TCLVER make failed! Exiting ..."
+	  echo "For problems with Tcl/Tk see http://www.scriptics.com"
+	  exit
+  fi
 
-# compile and install tk
+  cd ../../
 
-echo "============================================================"
-echo "* Build Tk$TKVER"
-echo "============================================================"
+  WITHTCL_PATH=$CUR_PATH/tcl$TCLVER
+  export WITHTCL_PATH
 
-cd ./tk$TKVER/unix
-if [ -f Makefile ] ; then
-	make distclean
 fi
 
-blame='Tk is not part of the ns project.  Please see www.Scriptics.com
-to see if they have a fix for your platform.'
-./configure --enable-gcc --disable-shared --prefix=$CUR_PATH || die "tk8.3.2 configuration failed! Exiting ..."
-if make 
-then
-	echo "tk$TKVER build succeeded."
-	make install || die "tk$TKVER installation failed."
-	echo "tk$TKVER installation succeeded."
-else
-	echo "tk$TKVER make failed! Exiting ..."
-	echo "For problems with Tcl/Tk see http://www.scriptics.com"
-	exit
-fi
-
-cd ../../
-
 #
 # Since our configures search for tclsh in $PATH, the following 
 # is needed. This is necessary for otcl/tclcl/ns/nam
@@ -345,28 +91,40 @@
 LD_LIBRARY_PATH=$CUR_PATH/tcl$TCLVER/unix:$CUR_PATH/tk$TKVER/unix:$LD_LIBRARY_PATH
 export LD_LIBRARY_PATH
 
-# Build otcl
+if [ -d /usr/local/otcl-1.0a8 ] ; then
 
-echo "============================================================"
-echo "* Build OTcl-$OTCLVER"
-echo "============================================================"
+  WITHOTCL_PATH=/usr/local/otcl-1.0a8
+  export WITHOTCL_PATH
 
-cd ./otcl-$OTCLVER
+else
 
-blame='Please check http://www.isi.edu/nsnam/ns/ns-problems.html
-for common problems and bug fixes.'
-./configure || die "otcl-$OTCLVER configuration failed! Exiting ..."
+  # Build otcl
 
-if make 
-then
-	echo "otcl-$OTCLVER has been installed successfully."
-else
-	echo "otcl-$OTCLVER make failed! Exiting ..."
-	echo "See http://www.isi.edu/nsnam/ns/ns-problems.html for problems"
-	exit
-fi
+  echo "============================================================"
+  echo "* Build OTcl-$OTCLVER"
+  echo "============================================================"
+
+  cd ./otcl-$OTCLVER
+
+  blame='Please check http://www.isi.edu/nsnam/ns/ns-problems.html
+  for common problems and bug fixes.'
+  ./configure || die "otcl-$OTCLVER configuration failed! Exiting ..."
 
-cd ..
+  if make 
+  then
+  	  echo "otcl-$OTCLVER has been installed successfully."
+  else
+	  echo "otcl-$OTCLVER make failed! Exiting ..."
+	  echo "See http://www.isi.edu/nsnam/ns/ns-problems.html for problems"
+	  exit
+  fi
+
+  cd ..
+
+  WITHOTCL_PATH=`pwd`/otcl-$OTCLVER
+  export WITHOTCL_PATH
+
+fi
 
 # Build tclcl
 
@@ -376,7 +134,7 @@
 
 cd ./tclcl-$TCLCLVER
 
-./configure || die "tclcl-$TCLCLVER configuration failed! Exiting ..."
+./configure --enable-static --with-tcl=$WITHTCL_PATH --with-otcl=$WITHOTCL_PATH || die "tclcl-$TCLCLVER configuration failed! Exiting ..."
 
 if make
 then
@@ -397,40 +155,20 @@
 echo "============================================================"
 
 cd ./ns-$NSVER
-./configure || die "Ns configuration failed! Exiting ..."
+./configure --enable-static --with-tcl=$WITHTCL_PATH --with-otcl=$WITHOTCL_PATH || die "Ns configuration failed! Exiting ..."
 
-if make
+if make nse
 then
-	echo " Ns has been installed successfully." 
+	echo " Nse has been installed successfully." 
 else
-	echo "Ns make failed!"
+	echo "Nse make failed!"
 	echo "See http://www.isi.edu/nsnam/ns/ns-problems.html for problems"
 	exit
 fi
 
 cd ../
 
-# Build nam
-
-echo "============================================================"
-echo "* Build nam-$NAMVER"
-echo "============================================================"
-
-cd ./nam-$NAMVER
-
-./configure --with-tclcl=$CUR_PATH/tclcl-$TCLCLVER  || die "Nam configuration failed! Exiting ..."
-
-if make
-then 
-    echo "Nam has been installed successfully."
-else
-    echo "Nam make failed! Continue ..."
-    echo "See http://www.isi.edu/nsnam/ns-problems.html for problems"
-fi
-
-cd ../
-
-# Install nam, ns, xgraph into bin
+# Install nse into bin
 
 if [ ! -d bin ] ; then
     mkdir bin
@@ -438,55 +176,14 @@
 
 cd bin
 
-ln -s $CUR_PATH/ns-$NSVER/ns${EXE} ns${EXE}
-
-if test -x $CUR_PATH/nam-$NAMVER/nam${EXE}
-then
-    ln -s $CUR_PATH/nam-$NAMVER/nam${EXE} nam${EXE}
-else
-    echo "Please compile your nam separately."
-fi
-
-if test -x $CUR_PATH/xgraph-$XGRAPHVER/xgraph${EXE}
-then
-    ln -s $CUR_PATH/xgraph-$XGRAPHVER/xgraph${EXE} xgraph${EXE}
-else
-    echo "Please compile your xgraph separately."
-fi
-
-if test -x $CUR_PATH/gt-itm/bin/sgb2ns${EXE}
-then 
-    ln -s $CUR_PATH/gt-itm/bin/sgb2ns${EXE} sgb2ns${EXE}
-    ln -s $CUR_PATH/gt-itm/bin/sgb2hierns${EXE} sgb2hierns${EXE}
-    ln -s $CUR_PATH/gt-itm/bin/sgb2comns${EXE} sgb2comns${EXE}
-    ln -s $CUR_PATH/gt-itm/bin/itm${EXE} itm${EXE}
-    ln -s $CUR_PATH/gt-itm/bin/sgb2alt${EXE} sgb2alt${EXE}
-    ln -s $CUR_PATH/gt-itm/bin/edriver${EXE} edriver${EXE}
-else
-    echo "Please compile your gt-itm & sgb2ns separately."
-fi
+ln -s $CUR_PATH/ns-$NSVER/nse nse
 
 echo "Ns-allinone package has been installed successfully."
 echo "Here are the installation places:"
 echo "tcl$TCLVER:	$CUR_PATH/{bin,include,lib}"
-echo "tk$TKVER:		$CUR_PATH/{bin,include,lib}"
 echo "otcl:		$CUR_PATH/otcl-$OTCLVER"
 echo "tclcl:		$CUR_PATH/tclcl-$TCLCLVER"
-echo "ns:		$CUR_PATH/ns-$NSVER/ns"
-
-if [ -x $CUR_PATH/nam-$NAMVER/nam ]
-then
-echo "nam:	$CUR_PATH/nam-$NAMVER/nam"
-fi
-
-if [ -x $CUR_PATH/xgraph-$XGRAPHVER/xgraph ]
-then
-echo "xgraph:	$CUR_PATH/xgraph-$XGRAPHVER"
-fi
-if [ -x $CUR_PATH/gt-itm/bin/sgb2ns ] 
-then
-echo "gt-itm:   $CUR_PATH/itm, edriver, sgb2alt, sgb2ns, sgb2comns, sgb2hierns"
-fi
+echo "nse:		$CUR_PATH/ns-$NSVER/nse"
 
 echo ""
 echo "----------------------------------------------------------------------------------"
--- dist-ns-allinone-2.26/ns-2.26/Makefile.in	Thu Feb 27 17:51:25 2003
+++ ns-allinone-2.26/ns-2.26/Makefile.in	Thu Jun  5 17:10:45 2003
@@ -79,6 +79,14 @@
 
 CFLAGS	= $(CCOPT) $(DEFINE)
 
+#### with event system
+INCLUDES += -I../.. -I../../../lib -I../../../../lib/libtb `elvin-config --cflags vin4c`
+CFLAGS += -DUSEEVENTS -DUSEROUTES -DADD_ETHER_OVERHEAD -DGETTIME_TSC
+LIB += -L../../../lib -L../../../../lib/libtb -levent -ltb
+LIB += `elvin-config --libs vin4c`
+STATIC += -static
+####
+
 # Explicitly define compilation rules since SunOS 4's make doesn't like gcc.
 # Also, gcc does not remove the .o before forking 'as', which can be a
 # problem if you don't own the file but can write to the directory.
@@ -276,6 +284,7 @@
 	mcast/lms-sender.o \
 	@V_STLOBJ@
 
+OBJ_CC += ../../tbevent.o
 
 # don't allow comments to follow continuation lines
 
@@ -303,6 +312,10 @@
 	emulate/nat.o  \
 	emulate/iptap.o \
 	emulate/tcptap.o
+
+##### nse with event system
+OBJ_EMULATE_CC += ../../tbnexthop.o
+####
 
 OBJ_EMULATE_C = \
 	emulate/inet.o
--- dist-ns-allinone-2.26/ns-2.26/apps/telnet.cc	Wed Feb 26 15:07:16 2003
+++ ns-allinone-2.26/ns-2.26/apps/telnet.cc	Thu Jun  5 17:12:02 2003
@@ -77,7 +77,7 @@
 {
         if (running_) {
 	        /* call the TCP advance method */
-		agent_->sendmsg(agent_->size());
+		agent_->sendmsg(1); // send 1 byte packets instead of 1460
 		/* reschedule the timer */
 		double t = next();
 		timer_.resched(t);
--- dist-ns-allinone-2.26/ns-2.26/common/scheduler.cc	Wed Feb 26 15:07:41 2003
+++ ns-allinone-2.26/ns-2.26/common/scheduler.cc	Fri Jun  6 18:19:59 2003
@@ -46,12 +46,42 @@
 #include "config.h"
 #include "scheduler.h"
 #include "packet.h"
+#ifdef USEEVENTS
+#include "tbevent.h"
+#endif
 
 
 #ifdef MEMDEBUG_SIMULATIONS
 #include "mem-trace.h"
 #endif
 
+#ifdef MEASURE_EVENT_RATE
+
+unsigned long long event_dispatch_counter;
+unsigned int events_per_sec_arr[70];
+
+#endif
+
+#ifdef GETTIME_TSC
+
+#define read_tsc()      \
+    ({ \
+        unsigned long low, high; \
+        asm volatile( \
+        ".byte 0x0f; .byte 0x31" \
+        : "=d" (high), "=a" (low)); \
+        ((unsigned long long)high << 32) | low; \
+    })
+
+#define TSC_FREQ     851.94
+#define TSC_COUNT_PERSEC (TSC_FREQ * 1000000)
+
+#endif
+
+#ifdef SCHED_DEBUG
+static Tcl_HashTable newevents;
+#endif
+
 Scheduler* Scheduler::instance_;
 scheduler_uid_t Scheduler::uid_ = 1;
 
@@ -62,6 +92,9 @@
 
 Scheduler::Scheduler() : clock_(SCHED_START), halted_(0)
 {
+#ifdef SCHED_DEBUG
+	  Tcl_InitHashTable( &newevents, TCL_ONE_WORD_KEYS );
+#endif
 }
 
 Scheduler::~Scheduler(){
@@ -112,6 +145,17 @@
 
 	e->time_ = t;
 	insert(e);
+#ifdef SCHED_DEBUG
+	int newentry = 0 ;
+	Tcl_HashEntry *he = Tcl_CreateHashEntry( &newevents,
+						 (char *)((unsigned int)e->uid_),
+						 &newentry );
+	if( newentry == 0 ) {
+	  fprintf(stderr, "e->uid_ = %d already present. error\n", (unsigned int)e->uid_);
+	} else {
+	  Tcl_SetHashValue( he, (char *)h );
+	}
+#endif
 }
 
 void
@@ -579,7 +623,7 @@
 	}
 } class_calendar_sched;
 
-CalendarScheduler::CalendarScheduler() : cal_clock_(clock_) {
+CalendarScheduler::CalendarScheduler() : cal_clock_(clock_), cached_head_(0) {
 	reinit(4, 1.0, cal_clock_);
 }
 
@@ -598,6 +642,7 @@
 		// may happen in RT scheduler
 		cal_clock_ = e->time_;
 		i = lastbucket_ = CALENDAR_HASH(cal_clock_);
+		cached_head_ = e;
 	} else
 		i = CALENDAR_HASH(e->time_);
 
@@ -703,6 +748,10 @@
 	if (qsize_ == 0)
 		return NULL;
 
+	if (cached_head_) {
+	  return cached_head_;	  
+	}
+
 	int l, i = lastbucket_;
 	int lastbucket_dec = (lastbucket_) ? lastbucket_ - 1 : nbuckets_ - 1;
 	double diff;
@@ -755,7 +804,7 @@
 	 */
 	lastbucket_ = l;
  	cal_clock_  = e->time_;
-	
+	cached_head_ = e;
 	return e;
 }
 
@@ -797,6 +846,8 @@
 		resize(nbuckets_ >> 1, cal_clock_);
 	}
 
+	cached_head_ = 0;
+
 	return e;
 }
 
@@ -926,6 +977,9 @@
 
 	--qsize_;
 
+	if ( e == cached_head_ )
+	  cached_head_ = 0;
+
 	return;
 }
 
@@ -956,11 +1010,23 @@
 	virtual void run();
 	double start() const { return start_; }
 	virtual void reset();
+#ifdef USEEVENTS
+	int command(int argc, const char*const* argv);
+#endif
 protected:
 	void sync() { clock_ = tod(); }
+	virtual void dispatch(Event*, double);	// exec event, set clock_
 	double tod();
 	double slop_;	// allowed drift between real-time and virt time
 	double start_;	// starting time
+#ifdef USEEVENTS
+        TbEventSink *evsink_;
+#endif
+#ifdef GETTIME_TSC
+        unsigned long long basetsc_ ;
+        double  oneontscfreq_;
+        double  tscfreq_;
+#endif
 };
 
 static class RealTimeSchedulerClass : public TclClass {
@@ -974,16 +1040,85 @@
 RealTimeScheduler::RealTimeScheduler() : start_(0.0)
 {
 	bind("maxslop_", &slop_);
+#ifdef USEEVENTS
+        evsink_ = 0 ;
+#endif
+#ifdef GETTIME_TSC
+        basetsc_ = 0 ;
+	oneontscfreq_ = 1.0 / (double)TSC_COUNT_PERSEC;
+	tscfreq_ = TSC_COUNT_PERSEC;
+#endif
+}
+
+#ifdef USEEVENTS
+  
+int RealTimeScheduler::command(int argc, const char*const* argv)
+{
+  Tcl& tcl = Tcl::instance();
+  if (instance_ == 0)
+    instance_ = this;
+  
+  
+  if( argc == 3 ) {
+    if(strcmp(argv[1], "tbevent-sink") == 0) {
+      evsink_ = (TbEventSink *)TclObject::lookup(argv[2]);
+      return(TCL_OK);
+    } else if (strcmp(argv[1], "cpuspeed") == 0) {
+      double ret;
+      if( (ret = atof(argv[2])) != 0 ) {
+	tscfreq_ = ret;
+	oneontscfreq_ = 1.0 / tscfreq_;
+      }
+      return(TCL_OK);
+    }
+  }
+
+  return(Scheduler::command(argc, argv));
+}  
+
+#endif
+
+/*
+ * dispatch a single simulator event by setting the system
+ * virtul clock to the event's timestamp and calling its handler.
+ * Note that the event may have side effects of placing other items
+ * in the scheduling queue
+ */
+
+void
+RealTimeScheduler::dispatch(Event* p, double t)
+{
+
+#ifdef SCHED_DEBUG
+	Tcl_HashEntry *he = Tcl_FindHashEntry(&newevents, (char *)((unsigned int)p->uid_));
+	if( he ) {
+	  Tcl_DeleteHashEntry(he);
+	} else {
+	  fprintf(stderr, "error. couldnt find event with uid = %d\n", (unsigned int)p->uid_);
+	}
+#endif
+	clock_ = t;
+	p->uid_ = -p->uid_;	// being dispatched
+	p->handler_->handle(p);	// dispatch
+#ifdef MEASURE_EVENT_RATE
+	event_dispatch_counter++;
+#endif
 }
 
 double
 RealTimeScheduler::tod()
 {
+#ifdef GETTIME_TSC
+                 
+        unsigned long long curtsc = read_tsc();
+        return (((double)(curtsc - basetsc_)) * oneontscfreq_);
+#else
 	timeval tv;
 	gettimeofday(&tv, 0);
 	double s = tv.tv_sec;
 	s += (1e-6 * tv.tv_usec);
 	return (s - start_);
+#endif
 }
 
 void
@@ -991,20 +1126,42 @@
 {
 	clock_ = SCHED_START;
 	start_ = tod();
+#ifdef GETTIME_TSC   
+        basetsc_ = read_tsc();
+#endif
 }
 
+#ifdef SCHED_DEBUG
+int done = 0;
+#endif
+
 void 
 RealTimeScheduler::run()
 { 
 	static const double RTSCHEDULER_MINWAIT = 1.0e-3; // don't wait for less
+	static const double delta = 1.0e-4; // should be smaller than above
 	const Event *p;
+	bool gethead = true;
+
+#ifdef USEEVENTS
+
+	if( evsink_ ) {
+	  evsink_->init();
+	  evsink_->subscribe();
+	}
+
+#endif
 
 	/*XXX*/
 	instance_ = this;
 
 	while (!halted_) {
+		if( gethead ) {
+		  p = head();
+		  gethead = false;
+		}
 		clock_ = tod();
-		p = head();
+
 		if (p && (clock_ - p->time_) > slop_) {
 			fprintf(stderr,
 				"RealTimeScheduler: warning: slop "
@@ -1014,12 +1171,31 @@
 		// handle "old events"
 		while (p && p->time_ <= clock_) {
 
+#ifdef DISPATCH_IN_RT
 			dispatch(deque(), clock_);
+#else
+			dispatch(deque(), p->time_);
+#endif
 			if (halted_)
 				return;
 			p = head();
 			clock_ = tod();
 		}
+
+#ifdef USEEVENTS
+		if( evsink_ && evsink_->poll() == 1 ) {
+		  gethead = true;
+		  continue;
+		}
+#endif
+
+#ifdef SCHED_DEBUG
+		if( clock_ >= 240.0 && done == 0 ) {
+		  fprintf( stderr, "After 60 secs. Hash Stats for newevents = %s\n",
+			   Tcl_HashStats(&newevents) );
+		  done = 1;
+		}
+#endif
 		
 		if (!p) {
 			// blocking wait for TCL events
@@ -1031,12 +1207,14 @@
 			if (diff > RTSCHEDULER_MINWAIT) {
 				Tcl_Time to;
 				to.sec = long(diff);
-				to.usec = long(1e6*(diff - to.sec));
+				to.usec = long(1e6*((diff - delta) - to.sec)); // wait for delta less
 				Tcl_WaitForEvent(&to);    // block
 				clock_ = tod();
 			}
 		}
-		Tcl_DoOneEvent(TCL_DONT_WAIT);
+		if( Tcl_DoOneEvent(TCL_DONT_WAIT) == 1 ) {
+		  gethead = true;
+		}
 	}
 	// we reach here only if halted
 }
--- dist-ns-allinone-2.26/ns-2.26/common/scheduler.h	Wed Feb 26 15:07:41 2003
+++ ns-allinone-2.26/ns-2.26/common/scheduler.h	Thu Jun  5 18:17:20 2003
@@ -98,7 +98,7 @@
 protected:
 	void dumpq();	// for debug: remove + print remaining events
 	void dispatch(Event*);	// execute an event
-	void dispatch(Event*, double);	// exec event, set clock_
+	virtual void dispatch(Event*, double);	// exec event, set clock_
 	Scheduler();
 	virtual ~Scheduler();
 	int command(int argc, const char*const* argv);
@@ -176,6 +176,7 @@
 private:
 	virtual void insert2(Event*);
 	double cal_clock_;  // same as clock in sims, may be different in RT-scheduling.
+	const Event *cached_head_;
 
 };
 
--- dist-ns-allinone-2.26/ns-2.26/common/tclAppInit.cc	Wed Feb 26 15:07:42 2003
+++ ns-allinone-2.26/ns-2.26/common/tclAppInit.cc	Thu Jun  5 18:18:08 2003
@@ -186,6 +186,7 @@
 	return TCL_OK;
 }
 
+#if 0
 #ifndef WIN32
 void
 abort()
@@ -200,6 +201,7 @@
 #endif /*abort*/
 	/*NOTREACHED*/
 }
+#endif
 #endif
 
 }
--- dist-ns-allinone-2.26/ns-2.26/common/timer-handler.cc	Wed Feb 26 15:07:42 2003
+++ ns-allinone-2.26/ns-2.26/common/timer-handler.cc	Thu Jun  5 18:21:36 2003
@@ -76,3 +76,40 @@
 	if (status_ == TIMER_HANDLING)
 		status_ = TIMER_IDLE;
 }
+
+#ifdef MEASURE_EVENT_RATE
+
+extern unsigned long long event_dispatch_counter;
+
+unsigned int idx;
+
+#define MAX_EVENT_ARR 70
+
+// circular buffer for the data
+extern unsigned int events_per_sec_arr[MAX_EVENT_ARR];
+
+
+void EventRateTimer::expire(Event *e) {
+
+  if ( idx % MAX_EVENT_ARR == MAX_EVENT_ARR-1 ) {
+
+    events_per_sec_arr[idx % MAX_EVENT_ARR] = event_dispatch_counter;
+    event_dispatch_counter = 0;
+    idx++;
+    
+    int i = 0 ;
+    for( ; i < MAX_EVENT_ARR-1 ; i++ ) {
+      fprintf(stderr, "%u, ", events_per_sec_arr[i] );
+    }
+    fprintf(stderr, "%u\n", events_per_sec_arr[MAX_EVENT_ARR-1] );    
+  } else {
+  
+    events_per_sec_arr[idx % MAX_EVENT_ARR] = event_dispatch_counter;
+    event_dispatch_counter = 0;
+    idx++;
+  }
+  resched(1.0);    
+    
+}
+
+#endif
--- dist-ns-allinone-2.26/ns-2.26/common/timer-handler.h	Wed Feb 26 15:07:42 2003
+++ ns-allinone-2.26/ns-2.26/common/timer-handler.h	Thu Jun  5 18:22:38 2003
@@ -88,4 +88,15 @@
 // mode:c++
 // End:
 
+#ifdef MEASURE_EVENT_RATE
+
+class EventRateTimer : public TimerHandler {
+
+public:
+  virtual void expire(Event *e) ;
+
+};
+
+#endif
+
 #endif /* timer_handler_h */
--- dist-ns-allinone-2.26/ns-2.26/emulate/iptap.cc	Wed Feb 26 15:08:40 2003
+++ ns-allinone-2.26/ns-2.26/emulate/iptap.cc	Fri Jun  6 19:08:41 2003
@@ -37,21 +37,82 @@
 #endif
 
 #include "iptap.h"
+#include <sys/time.h>
+#include <netinet/in.h>
+
+#ifdef USEROUTES
+#include "tbnexthop.h"
+
+static IPTapAgent *iface_to_iptap[IFNAMSIZ+1];
+static Tcl_HashTable ip_to_iptap;
+
+// used for storing pairs for which we have created
+// ipfw rules
+struct SrcDestAddr {
+  struct in_addr src;
+  struct in_addr dst;
+};
+
+#endif
+
+#ifdef MEASURE_EVENT_RATE
+#include "timer-handler.h"
+
+EventRateTimer ert;
+unsigned int firstpacket;
+#endif
+
+#ifdef USEROUTES
+#ifdef __cplusplus
+extern "C" {
+#endif
+#include        "tbdefs.h"
+#include        "log.h"
+
+#ifdef __cplusplus
+}
+#endif
+#endif
 
 
 static class IPTapAgentClass : public TclClass {
  public:
-	IPTapAgentClass() : TclClass("Agent/IPTap") {}
+	IPTapAgentClass() : TclClass("Agent/IPTap") {
+#ifdef USEROUTES
+	  Tcl_InitHashTable( &ip_to_iptap, TCL_ONE_WORD_KEYS );
+#endif
+	}
 	TclObject* create(int, const char*const*) {
+#ifdef MEASURE_EVENT_RATE
+	  // schedule the event rate 
+	  if ( firstpacket == 0 ) {
+	    ert.sched(1.0);
+	    firstpacket++;
+	  }
+#endif
 		return (new IPTapAgent());
 	}
 } class_iptap_agent;
 
 
 IPTapAgent::IPTapAgent() 
+#ifdef MEASURE_DELAYS  
+                        :  firstpkt_in_burst(false),
+			   max_delay(0.0), bpf_ts_to_iptap_max_delay(0.0),
+			   bpf_ts_to_iptap_min_delay(100.0), data_idx(0)
+#endif
 {
   int i = 0;
   index = 0;
+#ifdef MEASURE_DELAYS
+  memset( bpf_ts_to_iptap, 0, sizeof(bpf_ts_to_iptap));
+#endif
+#ifdef USEROUTES
+  iface_index = 0;
+  inet_aton( "255.255.255.0", &ipmask ); // default mask
+  Tcl_InitHashTable( &rttable, TCL_ONE_WORD_KEYS );
+  Tcl_InitHashTable( &ipfwruleexists, sizeof(SrcDestAddr) );
+#endif
   for (; i < MAX_PACKETS ; i++) {
     ident[i] = -1;
     offset[i] = -1;
@@ -141,6 +202,52 @@
   
   /* TCP header info from the grabbed packet. */
   unsigned char tcphlen;
+
+#ifdef MEASURE_DELAYS
+
+  double delay ;
+  // This code keeps some delay data and drops the packet 
+  if( firstpkt_in_burst ) {
+    ts_firstpkt_in_burst = ts.tv_sec + ts.tv_usec * 1e-6 ;
+    firstpkt_in_burst = false;
+    delay = 0.0;
+  } else {
+    delay = double(ts.tv_sec + ts.tv_usec * 1e-6) - ts_firstpkt_in_burst;
+    timeval tv;
+    gettimeofday(&tv, 0);
+    double nowts = tv.tv_sec + (1e-6 * tv.tv_usec);
+    max_delay = MAX(nowts - ts_firstpkt_in_burst, max_delay);
+  }
+
+
+#endif
+
+  
+#if 0
+  timeval tv;
+  gettimeofday(&tv, 0);
+  double nowts = tv.tv_sec + (1e-6 * tv.tv_usec);
+  max_delay = MAX(nowts - ts_firstpkt_in_burst, max_delay);
+  bpf_ts_to_iptap[data_idx] = nowts - (ts.tv_sec + ts.tv_usec * 1e-6);
+  bpf_ts_to_iptap_max_delay = MAX(bpf_ts_to_iptap[data_idx],
+			      bpf_ts_to_iptap_max_delay);
+  bpf_ts_to_iptap_min_delay = MIN(bpf_ts_to_iptap[data_idx],
+			      bpf_ts_to_iptap_min_delay);
+  data_idx = (data_idx+1) %
+    (sizeof(bpf_ts_to_iptap)/sizeof(bpf_ts_to_iptap[0]));
+
+  Packet::free(p);
+  return;
+  
+#endif
+
+#if 0 //MEASURE_EVENT_RATE
+  // schedule the event rate 
+  if ( firstpacket == 0 ) {
+    ert.sched(1.0);
+    firstpacket++;
+  }
+#endif
   
   /* 
      At this point, all I have to do is to grab the ttl value 
@@ -180,15 +287,116 @@
   hdr_ip *ih = HDR_IP(p);
   ih->ttl() = ttl;
 
+#ifdef USEROUTES
+  /* code to look up the interface index
+     over which we should spit out the
+     packet. with this interface index, we
+     find the iptap which is attached on
+     the corresponding simulated node from
+     where the packet will be spit out.
+     This ensures that the packet traverses
+     the simulated network and is spit out
+     into the real world from the right place
+  */
+  //dst.s_addr = (u_int32_t)ntohl(ipheader->ip_dst.s_addr);
+  IPTapAgent *dst_agent = 0;
+
+  // Try looking up a route for the host
+  Tcl_HashEntry *localhe = Tcl_FindHashEntry( &rttable,
+					      (char *)(ipheader->ip_dst.s_addr) );
+
+  // If that doesn't work, try a net route anding with the mask
+  if( localhe == 0 ) {
+    localhe = Tcl_FindHashEntry( &rttable,
+				 (char *)(ipheader->ip_dst.s_addr & ipmask.s_addr) );
+  }
+
+  RouteEntry *entry = 0;
+  if( localhe != 0 && (entry = (RouteEntry *)Tcl_GetHashValue(localhe)) != 0 ) {
+    
+    dst_agent = iface_to_iptap[entry->nexthop_iface];
+
+    /* Some destinations, we don't need ipfw rules coz the destinations
+       are directly connected */
+    if( entry->ipfwruleneeded ) {
+      
+      /* Now we consult our hashtable based on source addresses and if an entry
+	 exists, it means that we had previously inserted the rule */
+      int newentry = 0;
+      SrcDestAddr pair = {ipheader->ip_src,entry->dst};
+      Tcl_HashEntry *ruleexists = Tcl_CreateHashEntry( &ipfwruleexists,
+						       (char *)(&pair),
+						       &newentry );
+      
+      if( newentry ) {      
+	int rulenum = ipfw_addfwd( entry->nexthop, ipheader->ip_src,
+				   entry->dst, ipmask, true );
+	Tcl_SetHashValue( ruleexists, (char *)rulenum );
+      } // else we don't need to do anything
+    }
+						     
+  } else {
+
+    /* Routes were not installed for this dest. This means that the
+       destination is directly connected. In that case, just look it
+       up from the physical node's routing table and cache it in our
+       rttable */
+
+    int nexthop_iface;
+    if( (nexthop_iface = get_nexthop_if(ipheader->ip_dst)) != 0 ) {
+
+      dst_agent = iface_to_iptap[nexthop_iface];
+      
+      int newentry = 0;
+      localhe = Tcl_CreateHashEntry( &rttable,
+				     (char *)(ipheader->ip_dst.s_addr),
+				     &newentry );
+      
+      RouteEntry *entry = 0;
+      if( newentry ) {
+	entry = new RouteEntry;
+	Tcl_SetHashValue( localhe, (char *)entry);
+      } else {
+	entry = (RouteEntry *)Tcl_GetHashValue(localhe);
+      }
+      entry->dst = ipheader->ip_dst;
+      entry->nexthop = ipheader->ip_dst;
+      entry->nexthop_iface = nexthop_iface;
+      entry->ipfwruleneeded = false;
+    }
+    
+  }
+
+  if( dst_agent ) {
+    ih->daddr() = dst_agent->addr();
+    ih->dport() = dst_agent->port();
+    goto injectsim;
+  } 
+
+#if 0
+ /* if we fail to map a dest iptap object, we drop the packet */
+  fprintf( stderr, "dropping packet with dest ipaddr:%s at %f\n",
+	   inet_ntoa(ipheader->ip_dst), Scheduler::instance().clock() );
+#endif
+  drop(p);
+  return;
+  
+ injectsim:  
+#endif
+
+#ifdef MEASURE_DELAYS
+  Scheduler::instance().schedule( target_, p, max_delay );
+#else 
   // inject into simulator
   target_->recv(p);
+#endif
   return;
 }
 
 /*
  * ns scheduler calls TapAgent::dispatch which calls recvpkt.
  * 
- * recvpkt then calls the network (net_) to receive as many packets
+ * recvpkt then calls the network (net_incoming_) to receive as many packets
  * as there are from the packet capture facility.
  * For every packet received through the callback, it populates the ns packet
  * ttl value and inject it into the simulator by calling target_->recv
@@ -197,14 +405,17 @@
 void
 IPTapAgent::recvpkt()
 {
-  if (net_->mode() != O_RDWR && net_->mode() != O_RDONLY) {
+  if (net_incoming_->mode() != O_RDWR && net_incoming_->mode() != O_RDONLY) {
     fprintf(stderr,
 	    "IPTapAgent(%s): recvpkt called while in write-only mode!\n",
 	    name());
     return;
   }
   
-  int cc = net_->recv(pkt_handler, this);
+#ifdef MEASURE_DELAYS
+  firstpkt_in_burst = true;
+#endif
+  int cc = net_incoming_->recv(pkt_handler, this);
   if (cc <= 0) {
     if (cc < 0) {
       perror("recv");
@@ -219,13 +430,100 @@
 }
 
 
+#ifdef USEROUTES
+  
+int
+IPTapAgent::command(int argc, const char*const* argv)
+{
+	Tcl& tcl = Tcl::instance();
+
+	if (argc == 2) {
+#if MEASURE_DELAYS
+	  if( strcmp(argv[1], "print_delays") == 0 ) {
+	    printf("object %s : max_delay = %g "
+		   "bpf_ts_to_iptap_max_delay = %g "
+		   "bpf_ts_to_iptap_min_delay = %g\n",
+		   name(), max_delay, bpf_ts_to_iptap_max_delay,
+		   bpf_ts_to_iptap_min_delay);
+	    for( int i=0; i<sizeof(bpf_ts_to_iptap)/sizeof(bpf_ts_to_iptap[0]) ; i++ )
+	      printf("%.10f ", bpf_ts_to_iptap[i]);
+	    printf("\n");
+	    return (TCL_OK);
+	  }
+#endif
+	} else if (argc == 3) {
+		if (strcmp(argv[1], "network-incoming") == 0) {
+			PcapNetwork *net_in_ = (PcapNetwork *)TclObject::lookup(argv[2]);
+			if (net_in_ != 0) {
+			  iface_index = if_nametoindex( net_in_->srcname() ) ;
+			  if( iface_index > 0 && iface_index <= IFNAMSIZ ) {
+			    iface_to_iptap[iface_index] = this;
+			  }
+			}
+		} else if( strcmp(argv[1], "ipmask") == 0) {
+		  struct in_addr tmpmask;
+		  if( inet_aton( argv[2], &tmpmask ) == 1 ) {
+		    ipmask = tmpmask;
+		    return(TCL_OK);
+		  } else {
+		    return(TCL_ERROR);
+		  }
+		}
+	} else if (argc == 4) {
+	  if (strcmp(argv[1], "addroute") == 0 ) {
+	    struct in_addr dst;
+	    struct in_addr nexthop;
+
+	    if( inet_aton( argv[2], &dst ) == 0 ) {
+	      fprintf( stderr, "IPTapAgent(%s): Invalid ipaddress %s\n",
+		       name(), argv[2] );
+	      return(TCL_ERROR);
+	    }
+	    if( inet_aton(argv[3], &nexthop) == 0 ) {
+	      fprintf( stderr, "IPTapAgent(%s): Invalid ipaddress %s\n",
+		       name(), argv[3] );
+	      return(TCL_ERROR);
+	    }
+	    // entry exists
+	    int nexthop_iface;
+	    if( (nexthop_iface = get_nexthop_if(nexthop)) == 0 ) {
+	      fprintf( stderr, "IPTapAgent(%s): Route nonexistent for nexthop %s\n",
+		       argv[3] );
+	      return(TCL_ERROR);
+	    }
+
+	    // finds an entry if it exists, else creates a new one
+	    int newentry = 0;
+	    Tcl_HashEntry *he = Tcl_CreateHashEntry( &rttable,
+						     (char *)(dst.s_addr),
+						     &newentry );
+	    
+	    RouteEntry *entry = 0;
+	    if( newentry ) {
+	      entry = new RouteEntry;
+	      Tcl_SetHashValue( he, (char *)entry);
+	    } else {
+	      entry = (RouteEntry *)Tcl_GetHashValue(he);
+	    }
+	    entry->dst = dst;
+	    entry->nexthop = nexthop;
+	    entry->nexthop_iface = nexthop_iface;
+	    entry->ipfwruleneeded = true;
+	    
+	    return(TCL_OK);
+	  }
+	}
+	return (TapAgent::command(argc, argv));
+}
+
+#endif
 
 
 /*
  * simulator schedules TapAgent::recv which calls sendpkt
  *
  * Grabs a ns packet, converts it into real packet 
- * and injects onto the network using net_->send
+ * and injects onto the network using net_outgoing_->send
  */
 int
 IPTapAgent::sendpkt(Packet* p)
@@ -236,7 +534,7 @@
   unsigned short dglen;
   struct ip *ipheader;
 
-  if (net_->mode() != O_RDWR && net_->mode() != O_WRONLY) {
+  if (net_outgoing_->mode() != O_RDWR && net_outgoing_->mode() != O_WRONLY) {
     fprintf(stderr,
 	    "IPTapAgent(%s): sendpkt called while in read-only mode!\n",
 	    name());
@@ -245,7 +543,7 @@
   
   // send packet into the live network
   hdr_cmn* hc = HDR_CMN(p);
-  if (net_ == NULL) {
+  if (net_outgoing_ == NULL) {
     fprintf(stderr,
 	    "IPTapAgent(%s): sendpkt attempted with NULL net\n",
 	    name());
@@ -282,7 +580,7 @@
   ipheader->ip_sum = (unsigned short) in_cksum((unsigned short *) ipheader,
 						sizeof(struct ip));
 
-  if (net_->send(p->accessdata(), hc->size()) < 0) {
+  if (net_outgoing_->send(p->accessdata(), hc->size()) < 0) {
     fprintf(stderr,
 	    "IPTapAgent(%s): sendpkt (%p, %d): %s\n",
 	    name(), p->accessdata(), hc->size(), strerror(errno));
@@ -290,6 +588,11 @@
     return (-1);
     
   }
+#if 0
+  if( hc->size() < 50 ) {
+    fprintf( stderr, "sent pkt %d\n", hc->size());
+  }
+#endif
   Packet::free(p);
   TDEBUG3("IPTapAgent(%s): sent packet (sz: %d)\n",
 	  name(), hc->size());
--- dist-ns-allinone-2.26/ns-2.26/emulate/iptap.h	Wed Feb 26 15:08:40 2003
+++ ns-allinone-2.26/ns-2.26/emulate/iptap.h	Fri Jun  6 18:30:53 2003
@@ -46,18 +46,45 @@
 #include "tcp.h"
 #include "ip.h"
 
+#ifdef USEROUTES
+#include <net/if.h>
+#endif
+
 #define MAX_PACKETS 640
 
+#ifdef USEROUTES
+
+struct RouteEntry {
+  struct in_addr dst;
+  struct in_addr nexthop;
+  int nexthop_iface;
+  bool ipfwruleneeded;
+};
+
+#endif
 
 class IPTapAgent : public TapAgent {
 
  public:
   IPTapAgent();
+#ifdef USEROUTES
+  int command(int, const char*const*);
+#endif
 
  private:
   int ident[MAX_PACKETS];      /* All three used for duplicate */
   int offset[MAX_PACKETS];     /* packet detection. */
   int index;
+#ifdef USEROUTES
+  uint16_t iface_index;
+  struct in_addr ipmask;
+  Tcl_HashTable rttable;
+  Tcl_HashTable ipfwruleexists;
+#endif
+#ifdef MEASURE_DELAYS
+  bool firstpkt_in_burst;
+  double ts_firstpkt_in_burst;
+#endif  
 
   unsigned short in_cksum(unsigned short *,int);
   void recvpkt();
@@ -66,6 +93,13 @@
   void processpkt(Packet *, const struct timeval &);
   static void pkt_handler(void *, Packet *, const struct timeval &);
 
+#ifdef MEASURE_DELAYS  
+  double max_delay;
+  double bpf_ts_to_iptap_max_delay;
+  double bpf_ts_to_iptap_min_delay;
+  int data_idx;
+  double bpf_ts_to_iptap[80000];
+#endif  
 };
 
 #endif /* iptap_h */
--- dist-ns-allinone-2.26/ns-2.26/emulate/net-pcap.cc	Wed Feb 26 15:08:40 2003
+++ ns-allinone-2.26/ns-2.26/emulate/net-pcap.cc	Fri Jun  6 14:16:06 2003
@@ -69,83 +69,6 @@
 #include "tclcl.h"
 #include "packet.h"
 
-/*
- * observations about pcap library
- *	device name is in the ifreq struct sense, should be doc'd
- *	pcap_lookupdev returns a ptr to static data
- *	q: does lookupdev only return devs in the AF_INET addr family?
- *	why does pcap_compile require a netmask? seems odd
- *	would like some way to tell it what buffer to use
- *	arriving packets have the link layer hdr at the beginning, doc
- *	not convenient/possible to open bpf read/write
- *	no real way to know what file (/dev/bpf?) it is using
- *		would be nice if pcap_lookdev helped out more by
- *		returning ifnet or ifreq or whatever structure
- *	pcap_lookupnet makes calls to get our addr, but
- *		then tosses it anyhow, should get us addr and netmask
- *	interface type codes could be via rfc1573
- *		see freebsd net/if_types.h
- *	want a way to set immed mode
- *	pcap_next masks errors by returning 0 if pcap_dispatch fails
- *	a pcap_t carries it's own internal buffer, and
- *		_dispatch gives pointers into it when invoked [eek]
- *	when you open pcap using a file, pcap_fileno always
- *		returns -1; not so convenient
- *	
- */
-
-#define	PNET_PSTATE_INACTIVE	0
-#define	PNET_PSTATE_ACTIVE	1
-
-//
-// PcapNetwork: a "network" (source or possibly sink of packets)
-//	this is a base class only-- the derived classes are:
-//	PcapLiveNetwork [a live net; currently bpf + ethernet]
-//	PcapFileNetwork [packets from a tcpdump-style trace file]
-//
-
-class PcapNetwork : public Network {
-
-public:
-	PcapNetwork() : t_firstpkt_(0.0),
-		pfd_(-1), pcnt_(0), local_netmask_(0) { }
-	int rchannel() { return(pfd_); }
-	int schannel() { return(pfd_); }
-	virtual int command(int argc, const char*const* argv);
-
-	virtual int open(int mode, const char *) = 0;
-	virtual int skiphdr() = 0;
-	virtual double gents(pcap_pkthdr*) = 0;		// generate timestamp
-	int recv(u_char *buf, int len, sockaddr&, double&); // get from net
-	int send(u_char *buf, int len);			// write to net
-	int recv(netpkt_handler callback, void *clientdata); // get from net
-	void close();
-	void reset();
-
-	int filter(const char*);	// compile + install a filter
-	int stat_pkts();
-	int stat_pdrops();
-
-	double offset_;			// time offset to 1st pkt in a trace
-	double t_firstpkt_;		// ts of 1st pkt recvd
-
-protected:
-	static void phandler(u_char* u, const pcap_pkthdr* h, const u_char* p);
-	static void phandler_callback(u_char* u, const pcap_pkthdr* h, const u_char* p);
-	virtual void bindvars() = 0;
-
-	char errbuf_[PCAP_ERRBUF_SIZE];		// place to put err msgs
-	char srcname_[PATH_MAX];		// device or file name
-	int pfd_;				// pcap fd
-	int pcnt_;				// # pkts counted
-	int state_;				// PNET_PSTATE_xxx (above)
-	int optimize_;				// bpf optimizer enable
-	pcap_t* pcap_;				// reference to pcap state
-	struct bpf_program bpfpgm_;		// generated program
-	struct pcap_stat pcs_;			// status
-
-	unsigned int local_netmask_;	// seems shouldn't be necessary :(
-};
 
 //
 // PcapLiveNetwork: a live network tap
@@ -539,6 +462,19 @@
 				"warning: pcap/live (%s) couldn't set immed\n",
 				name());
 			perror("ioctl(BIOCIMMEDIATE)");
+		}
+		if (ioctl(pfd_, BIOCFLUSH, 0) < 0) {
+			fprintf(stderr,
+				"warning: pcap/live (%s) couldn't flush bpf buffer\n",
+				name());
+			perror("ioctl(BIOCFLUSH)");
+		}
+		int seesent = 0;
+		if (ioctl(pfd_, BIOCSSEESENT, &seesent) < 0) {
+			fprintf(stderr,
+				"warning: pcap/live (%s) couldn't reset BIOCGSEESENT\n",
+				name());
+			perror("ioctl(BIOCGSEESENT)");
 		}
 	}
 #endif
--- dist-ns-allinone-2.26/ns-2.26/emulate/net.h	Wed Feb 26 15:08:40 2003
+++ ns-allinone-2.26/ns-2.26/emulate/net.h	Fri Jun  6 13:59:46 2003
@@ -75,4 +75,97 @@
 protected:
 	int mode_;	// read/write bits (from fcntl.h)
 };
+
+#ifdef __cplusplus
+extern "C" {
+#include <pcap.h>
+}
+#else
+#include <pcap.h>
+#endif
+
+#include <sys/param.h>
+
+/*
+ * observations about pcap library
+ *	device name is in the ifreq struct sense, should be doc'd
+ *	pcap_lookupdev returns a ptr to static data
+ *	q: does lookupdev only return devs in the AF_INET addr family?
+ *	why does pcap_compile require a netmask? seems odd
+ *	would like some way to tell it what buffer to use
+ *	arriving packets have the link layer hdr at the beginning, doc
+ *	not convenient/possible to open bpf read/write
+ *	no real way to know what file (/dev/bpf?) it is using
+ *		would be nice if pcap_lookdev helped out more by
+ *		returning ifnet or ifreq or whatever structure
+ *	pcap_lookupnet makes calls to get our addr, but
+ *		then tosses it anyhow, should get us addr and netmask
+ *	interface type codes could be via rfc1573
+ *		see freebsd net/if_types.h
+ *	want a way to set immed mode
+ *	pcap_next masks errors by returning 0 if pcap_dispatch fails
+ *	a pcap_t carries it's own internal buffer, and
+ *		_dispatch gives pointers into it when invoked [eek]
+ *	when you open pcap using a file, pcap_fileno always
+ *		returns -1; not so convenient
+ *	
+ */
+
+#define	PNET_PSTATE_INACTIVE	0
+#define	PNET_PSTATE_ACTIVE	1
+
+//
+// PcapNetwork: a "network" (source or possibly sink of packets)
+//	this is a base class only-- the derived classes are:
+//	PcapLiveNetwork [a live net; currently bpf + ethernet]
+//	PcapFileNetwork [packets from a tcpdump-style trace file]
+//
+
+class PcapNetwork : public Network {
+
+public:
+	PcapNetwork() : t_firstpkt_(0.0),
+		pfd_(-1), pcnt_(0), local_netmask_(0) { }
+	int rchannel() { return(pfd_); }
+	int schannel() { return(pfd_); }
+	virtual int command(int argc, const char*const* argv);
+
+	virtual int open(int mode, const char *) = 0;
+	virtual int skiphdr() = 0;
+	virtual double gents(pcap_pkthdr*) = 0;		// generate timestamp
+	int recv(u_char *buf, int len, sockaddr&, double&); // get from net
+	int send(u_char *buf, int len);			// write to net
+	int recv(netpkt_handler callback, void *clientdata); // get from net
+	void close();
+	void reset();
+
+	int filter(const char*);	// compile + install a filter
+	int stat_pkts();
+	int stat_pdrops();
+
+	double offset_;			// time offset to 1st pkt in a trace
+	double t_firstpkt_;		// ts of 1st pkt recvd
+
+#ifdef USEROUTES
+        inline char *srcname() { return(srcname_); }
+#endif
+
+protected:
+	static void phandler(u_char* u, const pcap_pkthdr* h, const u_char* p);
+	static void phandler_callback(u_char* u, const pcap_pkthdr* h, const u_char* p);
+	virtual void bindvars() = 0;
+
+	char errbuf_[PCAP_ERRBUF_SIZE];		// place to put err msgs
+	char srcname_[PATH_MAX];		// device or file name
+	int pfd_;				// pcap fd
+	int pcnt_;				// # pkts counted
+	int state_;				// PNET_PSTATE_xxx (above)
+	int optimize_;				// bpf optimizer enable
+	pcap_t* pcap_;				// reference to pcap state
+	struct bpf_program bpfpgm_;		// generated program
+	struct pcap_stat pcs_;			// status
+
+	unsigned int local_netmask_;	// seems shouldn't be necessary :(
+};
+
 #endif
--- dist-ns-allinone-2.26/ns-2.26/emulate/tap.cc	Wed Feb 26 15:08:42 2003
+++ ns-allinone-2.26/ns-2.26/emulate/tap.cc	Fri Jun  6 16:42:44 2003
@@ -46,7 +46,7 @@
 	}
 } class_tap_agent;
 
-TapAgent::TapAgent() : Agent(PT_LIVE), net_(NULL)
+TapAgent::TapAgent() : Agent(PT_LIVE), net_outgoing_(NULL), net_incoming_(NULL)
 {
 	bind("maxpkt_", &maxpkt_);
 }
@@ -55,11 +55,11 @@
 // link in a network to the agent.  Assumes net_ is non-zero
 //
 int
-TapAgent::linknet()
+TapAgent::linknet(Network *net)
 {
-	int mode = net_->mode();
-	int rchan = net_->rchannel();
-	int wchan = net_->schannel();
+	int mode = net->mode();
+	int rchan = net->rchannel();
+	int wchan = net->schannel();
 
 	unlink();
 	if (mode == O_RDONLY || mode == O_RDWR) {
@@ -67,7 +67,7 @@
 		if (rchan < 0) {
 			fprintf(stderr,
 		"TapAgent(%s): network %s not open for reading (mode:%d)\n",
-			    name(), net_->name(), mode);
+			    name(), net->name(), mode);
 			return (TCL_ERROR);
 		}
 		link(rchan, TCL_READABLE);
@@ -77,13 +77,13 @@
 		if (mode == -1) {
 			fprintf(stderr,
 			   "TapAgent(%s): Network(%s) not opened properly.\n",
-				name(), net_->name());
+				name(), net->name());
 			fprintf(stderr,
 			   "(choose: readonly, readwrite, or writeonly)\n");
 		} else {
 			fprintf(stderr,
 			    "TapAgent(%s): unknown mode %d in Network(%s)\n",
-				name(), mode, net_->name());
+				name(), mode, net->name());
 		}
 		return (TCL_ERROR);
 	}
@@ -93,7 +93,7 @@
 		if (wchan < 0) {
 			fprintf(stderr,
 			"TapAgent(%s): network %s not open for writing\n",
-			    name(), net_->name());
+			    name(), net->name());
 			return (TCL_ERROR);
 		}
 	}
@@ -112,10 +112,25 @@
 		} 
 	}
 	if (argc == 3) {
-		if (strcmp(argv[1], "network") == 0) {
-			net_ = (Network *)TclObject::lookup(argv[2]);
-			if (net_ != 0) {
-				return(linknet());
+		if (strcmp(argv[1], "network-outgoing") == 0) {
+			net_outgoing_ = (Network *)TclObject::lookup(argv[2]);
+			/* We don't need to monitor outgoing network (by calling linknet()) coz
+			   we just send packets to it. In case a particular
+			   network object does both, the user has to explicitly
+			   use the command network-incoming to monitor this fd */
+			if (net_outgoing_ == 0) {
+				fprintf(stderr,
+				"TapAgent(%s): unknown network %s\n",
+				    name(), argv[2]);
+				return (TCL_ERROR);
+			}
+			return(TCL_OK);
+		}	
+
+		if (strcmp(argv[1], "network-incoming") == 0) {
+			net_incoming_ = (Network *)TclObject::lookup(argv[2]);
+			if (net_incoming_ != 0) {
+				return(linknet(net_incoming_));
 			} else {
 				fprintf(stderr,
 				"TapAgent(%s): unknown network %s\n",
@@ -135,7 +150,7 @@
 TapAgent::recvpkt()
 {
 
-	if (net_->mode() != O_RDWR && net_->mode() != O_RDONLY) {
+	if (net_incoming_->mode() != O_RDWR && net_incoming_->mode() != O_RDONLY) {
 		fprintf(stderr,
 		  "TapAgent(%s): recvpkt called while in write-only mode!\n",
 		  name());
@@ -155,7 +170,7 @@
 	// fill up payload
 	sockaddr addr;	// not really used (yet)
 	double tstamp;
-	int cc = net_->recv(p->accessdata(), maxpkt_, addr, tstamp);
+	int cc = net_incoming_->recv(p->accessdata(), maxpkt_, addr, tstamp);
 	if (cc <= 0) {
 		if (cc < 0) {
 			perror("recv");
@@ -230,7 +245,7 @@
 int
 TapAgent::sendpkt(Packet* p)
 {
-	if (net_->mode() != O_RDWR && net_->mode() != O_WRONLY) {
+	if (net_outgoing_->mode() != O_RDWR && net_outgoing_->mode() != O_WRONLY) {
 		fprintf(stderr,
 		    "TapAgent(%s): sendpkt called while in read-only mode!\n",
 		    name());
@@ -239,14 +254,14 @@
 
 	// send packet into the live network
 	hdr_cmn* hc = HDR_CMN(p);
-	if (net_ == NULL) {
+	if (net_outgoing_ == NULL) {
 		fprintf(stderr,
 	         "TapAgent(%s): sendpkt attempted with NULL net\n",
 		 name());
 		drop(p);
 		return (-1);
 	}
-	if (net_->send(p->accessdata(), hc->size()) < 0) {
+	if (net_outgoing_->send(p->accessdata(), hc->size()) < 0) {
 		fprintf(stderr,
 		    "TapAgent(%s): sendpkt (%p, %d): %s\n",
 		    name(), p->accessdata(), hc->size(), strerror(errno));
--- dist-ns-allinone-2.26/ns-2.26/emulate/tap.h	Wed Feb 26 15:08:42 2003
+++ ns-allinone-2.26/ns-2.26/emulate/tap.h	Fri Jun  6 16:44:51 2003
@@ -71,8 +71,9 @@
 protected:
 	int maxpkt_;		/* max size allocated to recv a pkt */
 	void dispatch(int);	/* invoked via scheduler on I/O event */
-	int linknet();		/* establish I/O handler */
-	Network* net_;		/* live network object */
+	int linknet(Network *);		/* establish I/O handler */
+	Network* net_outgoing_;	/* live network object for outgoing packets */
+	Network* net_incoming_;		/* live network object for incoming packets */
 	double now() { return Scheduler::instance().clock(); }
 };
 
--- dist-ns-allinone-2.26/ns-2.26/emulate/tcptap.cc	Wed Feb 26 15:08:42 2003
+++ ns-allinone-2.26/ns-2.26/emulate/tcptap.cc	Fri Jun  6 19:17:24 2003
@@ -97,6 +97,11 @@
       return (TCL_OK);
     }
 
+    if (strcmp(argv[1], "nsport") == 0) {
+      nsnode.sin_port = atoi(argv[2]);
+      return (TCL_OK);
+    }
+
     if (strcmp(argv[1], "advertised-window") == 0) {
       adv_window = atoi(argv[2]);
       return (TCL_OK);
@@ -438,7 +443,7 @@
 /*
  * ns scheduler calls TapAgent::dispatch which calls recvpkt.
  * 
- * recvpkt then calls the network (net_) to receive as many packets
+ * recvpkt then calls the network (net_incoming_) to receive as many packets
  * as there are from the packet capture facility.
  * For every packet received through the callback, it converts to ns
  * FullTcp packet and injects it into the simulator by calling target_->recv
@@ -447,14 +452,14 @@
 void
 TCPTapAgent::recvpkt()
 {
-  if (net_->mode() != O_RDWR && net_->mode() != O_RDONLY) {
+  if (net_incoming_->mode() != O_RDWR && net_incoming_->mode() != O_RDONLY) {
     fprintf(stderr,
 	    "TCPTapAgent(%s): recvpkt called while in write-only mode!\n",
 	    name());
     return;
   }
   
-  int cc = net_->recv(pkt_handler, this);
+  int cc = net_incoming_->recv(pkt_handler, this);
   if (cc <= 0) {
     if (cc < 0) {
       perror("recv");
@@ -474,7 +479,7 @@
  * simulator schedules TapAgent::recv which calls sendpkt
  *
  * Grabs a ns Full TCP packet, converts it into real TCP packet 
- * and injects onto the network using net_->send
+ * and injects onto the network using net_outgoing_->send
  *
  */
 int
@@ -486,7 +491,7 @@
   int hlength = IP_HEADER_LEN + TCP_HEADER_LEN;
   struct tcphdr *tcpheader;
 
-  if (net_->mode() != O_RDWR && net_->mode() != O_WRONLY) {
+  if (net_outgoing_->mode() != O_RDWR && net_outgoing_->mode() != O_WRONLY) {
     fprintf(stderr,
 	    "TCPTapAgent(%s): sendpkt called while in read-only mode!\n",
 	    name());
@@ -495,7 +500,7 @@
   
   // send packet into the live network
   hdr_cmn* ns_cmnhdr = HDR_CMN(p);
-  if (net_ == NULL) {
+  if (net_outgoing_ == NULL) {
     fprintf(stderr,
 	    "TCPTapAgent(%s): sendpkt attempted with NULL net\n",
 	    name());
@@ -543,7 +548,7 @@
      Limits the packets going out to only IP + TCP header. 
      ns will act as an ACK machine.
    */
-  byteswritten = net_->send(packet, hlength + datalen);
+  byteswritten = net_outgoing_->send(packet, hlength + datalen);
   if (byteswritten < 0) {
     fprintf(stderr,"TCPTapAgent(%s): sendpkt (%p, %d): %s\n",
 	    name(), p->accessdata(), ns_cmnhdr->size(), strerror(errno));
--- dist-ns-allinone-2.26/ns-2.26/link/delay.h	Wed Feb 26 15:08:54 2003
+++ ns-allinone-2.26/ns-2.26/link/delay.h	Fri Jun  6 16:54:24 2003
@@ -44,6 +44,10 @@
 #include "ip.h"
 #include "connector.h"
 
+#ifdef ADD_ETHER_OVERHEAD
+#include <net/ethernet.h>
+#endif
+
 class LinkDelay : public Connector {
  public:
 	LinkDelay();
@@ -52,7 +56,11 @@
 	void handle(Event* e);
 	double delay() { return delay_; }
 	inline double txtime(Packet* p) {
+#ifndef ADD_ETHER_OVERHEAD
 		return (8. * hdr_cmn::access(p)->size() / bandwidth_);
+#else
+		return (8. * (hdr_cmn::access(p)->size() + ETHER_HDR_LEN) / bandwidth_);
+#endif
 	}
 	double bandwidth() const { return bandwidth_; }
 	void pktintran(int src, int group);
--- dist-ns-allinone-2.26/ns-2.26/tcp/tcp-full.cc	Wed Feb 26 15:11:24 2003
+++ ns-allinone-2.26/ns-2.26/tcp/tcp-full.cc	Fri Jun  6 17:14:57 2003
@@ -76,7 +76,7 @@
  *
  * Some warnings and comments:
  *	this version of TCP will not work correctly if the sequence number
- *	goes above 2147483648 due to sequence number wrap
+ *	goes above 1073741824 due to sequence number wrap
  *
  *	this version of TCP by default sends data at the beginning of a
  *	connection in the "typical" way... That is,
@@ -360,16 +360,16 @@
 	case TCPS_CLOSED:
 	case TCPS_LISTEN:
                 reset();
-                curseq_ = iss_ + nb;
+                INCR_SEQ( curseq_, SEQ_ADD(iss_, nb));
                 connect();              // initiate new connection
 		break;
 
 	case TCPS_ESTABLISHED:
 	case TCPS_SYN_SENT:
 	case TCPS_SYN_RECEIVED:
-                if (curseq_ < iss_) 
+	        if (SEQ_LT(curseq_, iss_) ) 
                         curseq_ = iss_; 
-                curseq_ += nb;
+                INCR_SEQ(curseq_, nb);
 		break;
 
 	default:
@@ -454,7 +454,7 @@
 void
 FullTcpAgent::usrclosed()
 {
-	curseq_ = maxseq_ - 1;	// now, no more data
+	curseq_ = SEQ_SUB(maxseq_, 1);	// now, no more data
 	infinite_send_ = FALSE;	// stop infinite send
 
 	switch (state_) {
@@ -736,7 +736,7 @@
 int
 FullTcpAgent::rcvseqinit(int seq, int dlen)
 {
-	return (seq + dlen + 1);
+	return (SEQ_ADD(seq, dlen + 1));
 }
 
 /*
@@ -764,8 +764,8 @@
 FullTcpAgent::pack(Packet *pkt)
 {
 	hdr_tcp *tcph = hdr_tcp::access(pkt);
-	return (tcph->ackno() >= highest_ack_ &&
-		tcph->ackno() < recover_);
+	return (SEQ_GE(tcph->ackno(), highest_ack_) &&
+		SEQ_LT(tcph->ackno(), recover_));
 }
 
 /*
@@ -822,6 +822,9 @@
         tcph->hlen() = tcpip_base_hdr_size_;
 	tcph->hlen() += build_options(tcph);
 
+	/* Fill in maxseg_ for MSS negotiation in TCPTap (NSE) */
+	tcph->maxseg() = maxseg_;
+	
 	/*
 	 * Explicit Congestion Notification (ECN) related:
 	 * Bits in header:
@@ -930,24 +933,24 @@
 	else
 		size_ =  maxseg_ + headersize();
 
-	int is_retransmit = (seqno < maxseq_);
+	int is_retransmit = SEQ_LT(seqno, maxseq_);
 	int quiet = (highest_ack_ == maxseq_);
 	int pflags = outflags();
 	int syn = (seqno == iss_);
 	int emptying_buffer = FALSE;
 	int buffered_bytes = (infinite_send_) ? TCP_MAXSEQ :
-				curseq_ - highest_ack_ + 1;
+				SEQ_ADD( SEQ_SUB(curseq_, highest_ack_), 1);
 
 	int win = window() * maxseg_;	// window (in bytes)
-	int off = seqno - highest_ack_;	// offset of seg in window
+	int off = SEQ_SUB(seqno, highest_ack_);	// offset of seg in window
 	int datalen;
 	//int amtsent = 0;
 
 	// be careful if we have not received any ACK yet
 	if (highest_ack_ < 0) {
 		if (!infinite_send_)
-			buffered_bytes = curseq_ - iss_;;
-		off = seqno - iss_;
+			buffered_bytes = SEQ_SUB(curseq_, iss_);
+		off = SEQ_SUB(seqno, iss_);
 	}
 
 	if (syn && !data_on_syn_)
@@ -989,7 +992,7 @@
 	// a dataless SYN packet counts also
 	//
 
-	if (!infinite_send_ && ((seqno + datalen) > curseq_ || 
+	if (!infinite_send_ && (SEQ_GT( SEQ_ADD(seqno, datalen), curseq_) || 
 	    (syn && datalen == 0))) {
 		emptying_buffer = TRUE;
 		//
@@ -1106,15 +1109,15 @@
 	 * around until we actually send a segment
 	 */
 
-	int reliable = datalen + syn + fin; // seq #'s reliably sent
+	int reliable = SEQ_ADD(datalen, syn + fin); // seq #'s reliably sent
 	if (cong_action_ && reliable > 0)
 		cong_action_ = FALSE;
 
 	// highest: greatest sequence number sent + 1
 	//	and adjusted for SYNs and FINs which use up one number
 
-	int highest = seqno + reliable;
-	if (highest > maxseq_) {
+	int highest = SEQ_ADD(seqno, reliable);
+	if (SEQ_GT(highest, maxseq_)) {
 		maxseq_ = highest;
 		//
 		// if we are using conventional RTT estimation,
@@ -1207,10 +1210,11 @@
         int win = window() * maxseg_;
         int topwin = curseq_; // 1 seq number past the last byte we can send
 
-        if ((topwin > highest_ack_ + win) || infinite_send_)
-                topwin = highest_ack_ + win; 
+	int hiack_plus_win = SEQ_ADD(highest_ack_, win);
+        if (SEQ_GT(topwin, hiack_plus_win) || infinite_send_)
+                INCR_SEQ( topwin, hiack_plus_win); 
 
-	return (seq < topwin);
+	return (SEQ_LT(seq, topwin));
 }
 /*
  * Process an ACK
@@ -1231,7 +1235,7 @@
 	hdr_tcp *tcph = hdr_tcp::access(pkt);
 
 	register int ackno = tcph->ackno();
-	int progress = (ackno > highest_ack_);
+	int progress = SEQ_GT(ackno, highest_ack_);
 
 	if (ackno == maxseq_) {
 		cancel_rtx_timer();	// all data ACKd
@@ -1250,7 +1254,7 @@
 	// update t_seqno_ here, otherwise we would be doing
 	// go-back-n.
 
-	if (t_seqno_ < highest_ack_)
+	if (SEQ_LT(t_seqno_, highest_ack_))
 		t_seqno_ = highest_ack_; // seq# to send next
 
         /*
@@ -1266,7 +1270,7 @@
 			recent_age_ = now();
 			recent_ = tcph->ts();
 			rtt_update(now() - tcph->ts_echo());
-		} else if (rtt_active_ && ackno > rtt_seq_) {
+		} else if (rtt_active_ && SEQ_GT(ackno,rtt_seq_)) {
 			// got an RTT sample, record it
 			// "t_backoff_ = 1;" deleted by T. Kelly.
 			rtt_active_ = FALSE;
@@ -1368,10 +1372,10 @@
 	if (flags_ & TF_ACKNOW)
 		return TRUE;
 
-	int spa = (spa_thresh_ > 0 && ((rcv_nxt_ - irs_)  < spa_thresh_)) ?
+	int spa = (spa_thresh_ > 0 && (SEQ_SUB(rcv_nxt_,irs_)  < spa_thresh_)) ?
 		1 : segs_per_ack_;
 		
-	return ((rcv_nxt_ - last_ack_sent_) >= (spa * maxseg_));
+	return (SEQ_SUB(rcv_nxt_, last_ack_sent_) >= (spa * maxseg_));
 }
 
 /*
@@ -1510,7 +1514,7 @@
 		 * See RFC1323 (now RFC1323 bis)
                  */
                 if (ts_option_ && !fh->no_ts_ &&
-		    tcph->seqno() <= last_ack_sent_) {
+		    SEQ_LE(tcph->seqno(), last_ack_sent_)) {
 			/*
 			 * this is the case where the ts value is newer than
 			 * the last one we've seen, and the seq # is the one
@@ -1548,7 +1552,7 @@
 			// If we are in fast
 			// recovery, go below so we can remember to deflate
 			// the window if we need to
-			if (ackno > highest_ack_ && ackno < maxseq_ &&
+			if (SEQ_GT(ackno, highest_ack_) && SEQ_LT(ackno, maxseq_) &&
 			    cwnd_ >= wnd_ && !fastrecov_) {
 				newack(pkt);	// update timers,  highest_ack_
 				send_much(0, REASON_NORMAL, maxburst_);
@@ -1566,7 +1570,7 @@
 			//	this routine scans all tcpcb's looking for
 			//	DELACK segments and when it finds them
 			//	changes DELACK to ACKNOW and calls tcp_output()
-			rcv_nxt_ += datalen;
+			INCR_SEQ(rcv_nxt_, datalen);
 			flags_ |= TF_DELACK;
 			recvBytes(datalen); // notify application of "delivery"
 			//
@@ -1667,7 +1671,7 @@
 
 		/* drop if it's a SYN+ACK and the ack field is bad */
 		if ((tiflags & TH_ACK) &&
-			((ackno <= iss_) || (ackno > maxseq_))) {
+			(SEQ_LE(ackno, iss_) || SEQ_GT(ackno, maxseq_))) {
 			// not an ACK for our SYN, discard
 			fprintf(stderr,
 			    "%f: FullTcpAgent::recv(%s): bad ACK for our SYN: ",
@@ -1761,14 +1765,14 @@
 			 * SYN+ACK, so t_seqno_ will have been
 			 * advanced to 2... reduce this
 			 */
-			t_seqno_--;	// CHECKME
+			DECR_SEQ(t_seqno_, 1);	// CHECKME
 		}
 
 trimthenstep6:
 		/*
 		 * advance the seq# to correspond to first data byte
 		 */
-		tcph->seqno()++;
+		INCR_SEQ(tcph->seqno(), 1);
 
 		if (tiflags & TH_ACK)
 			goto process_ACK;
@@ -1838,13 +1842,13 @@
 	// do anything with it.  In particular, would like to
 	// avoid ACKing an incoming FIN+ACK while in CLOSING
 	//
-	todrop = rcv_nxt_ - tcph->seqno();  // how much overlap?
+	todrop = SEQ_SUB(rcv_nxt_, tcph->seqno());  // how much overlap?
 
 	if (todrop > 0 && ((tiflags & (TH_SYN)) || datalen > 0)) {
 //printf("%f(%s): trim 1..todrop:%d, dlen:%d\n",now(), name(), todrop, datalen);
 		if (tiflags & TH_SYN) {
 			tiflags &= ~TH_SYN;
-			tcph->seqno()++;
+			INCR_SEQ(tcph->seqno(), 1);
 			th->size()--;	// XXX Must decrease packet size too!!
 					// Q: Why?.. this is only a SYN
 			todrop--;
@@ -1881,7 +1885,7 @@
 		 * Trim duplicate data from the front of the packet
 		 */
 
-		tcph->seqno() += todrop;
+		INCR_SEQ(tcph->seqno(), todrop);
 		th->size() -= todrop;	// XXX Must decrease size too!!
 					// why? [kf]..prob when put in RQ
 		datalen -= todrop;
@@ -1894,7 +1898,7 @@
 	 * record the timestamp.
 	 * See RFC1323 (now RFC1323 bis)
 	 */
-	if (ts_option_ && !fh->no_ts_ && tcph->seqno() <= last_ack_sent_) {
+	if (ts_option_ && !fh->no_ts_ && SEQ_LE(tcph->seqno(), last_ack_sent_)) {
 		/*
 		 * this is the case where the ts value is newer than
 		 * the last one we've seen, and the seq # is the one we expect
@@ -1925,7 +1929,7 @@
 
 	switch (state_) {
 	case TCPS_SYN_RECEIVED:	/* want ACK for our SYN+ACK */
-		if (ackno < highest_ack_ || ackno > maxseq_) {
+		if (SEQ_LT(ackno, highest_ack_) || SEQ_GT(ackno, maxseq_)) {
 			// not in useful range
 		    	fprintf(stderr,
 		    		"%f: FullTcpAgent(%s): ack(%d) not in range while in SYN_RECEIVED: ",
@@ -1999,13 +2003,13 @@
 		//	try not to be fooled by data
 		//
 
-		if (fastrecov_ && (datalen == 0 || ackno > highest_ack_))
+		if (fastrecov_ && (datalen == 0 || SEQ_GT(ackno, highest_ack_)))
 			pipe_ -= maxseg_;
 
 		// look for dup ACKs (dup ack numbers, no data)
 		//
 		// do fast retransmit/recovery if at/past thresh
-		if (ackno <= highest_ack_) {
+		if (SEQ_LE(ackno, highest_ack_)) {
 			// a pure ACK which doesn't advance highest_ack_
 			if (datalen == 0 && (!dupseg_fix_ || !dupseg)) {
 
@@ -2029,7 +2033,7 @@
                                  */
 
 				if ((rtx_timer_.status() != TIMER_PENDING) ||
-				    ackno < highest_ack_) {
+				    SEQ_LT(ackno, highest_ack_)) {
 					// Q: significance of timer not pending?
 					// ACK below highest_ack_
 					oldack();
@@ -2069,7 +2073,7 @@
 
 process_ACK:
 
-		if (ackno > maxseq_) {
+		if (SEQ_GT(ackno, maxseq_)) {
 			// ack more than we sent(!?)
 			fprintf(stderr,
 			    "%f: FullTcpAgent::recv(%s) too-big ACK (maxseq:%d): ",
@@ -2130,7 +2134,7 @@
 		 * If no data (only SYN) was ACK'd,
 		 *    skip rest of ACK processing.
 		 */
-		if (ackno == (highest_ack_ + 1))
+		if (ackno == SEQ_ADD(highest_ack_, 1))
 			goto step6;
 
 		// if we are delaying initial cwnd growth (probably due to
@@ -2244,7 +2248,7 @@
 			// accept the data here as-is (i.e. don't
 			// require being in ESTABLISHED state)
 			flags_ |= TF_DELACK;
-			rcv_nxt_ += datalen;
+			INCR_SEQ(rcv_nxt_, datalen);
 			tiflags = tcph->flags() & TH_FIN;
 
 			// give to "application" here
@@ -2262,11 +2266,11 @@
 			// Note that we may have just a FIN here (datalen = 0)
 			int rcv_nxt_old_ = rcv_nxt_; // notify app. if changes
 			tiflags = reass(pkt);
-			if (rcv_nxt_ > rcv_nxt_old_) {
+			if (SEQ_GT(rcv_nxt_, rcv_nxt_old_)) {
 				// if rcv_nxt_ has advanced, must have
 				// been a hole fill.  In this case, there
 				// is something to give to application
-				recvBytes(rcv_nxt_ - rcv_nxt_old_);
+				recvBytes(SEQ_SUB(rcv_nxt_, rcv_nxt_old_));
 			}
 			flags_ |= TF_ACKNOW;
 
@@ -2295,7 +2299,7 @@
 	if (tiflags & TH_FIN) {
 		if (TCPS_HAVERCVDFIN(state_) == 0) {
 			flags_ |= TF_ACKNOW;
- 			rcv_nxt_++;
+ 			INCR_SEQ(rcv_nxt_, 1);
 		}
 		switch (state_) {
                 /*
@@ -2332,7 +2336,7 @@
 
 	if (needoutput || (flags_ & TF_ACKNOW))
 		send_much(1, REASON_NORMAL, maxburst_);
-	else if (curseq_ >= highest_ack_ || infinite_send_)
+	else if (SEQ_GE(curseq_, highest_ack_) || infinite_send_)
 		send_much(0, REASON_NORMAL, maxburst_);
 	// K: which state to return to when nothing left?
 
@@ -2363,9 +2367,9 @@
 	if (tiflags & TH_ACK) {
 		sendpacket(ackno, 0, 0x0, 0, REASON_NORMAL);
 	} else {
-		int ack = tcph->seqno() + datalen;
+		int ack = SEQ_ADD(tcph->seqno(), datalen);
 		if (tiflags & TH_SYN)
-			ack--;
+			DECR_SEQ(ack, 1);
 		sendpacket(0, ack, TH_ACK, 0, REASON_NORMAL);
 	}
 drop:
@@ -2393,7 +2397,7 @@
 FullTcpAgent::dupack_action()
 {   
 
-        int recovered = (highest_ack_ > recover_);
+        int recovered = SEQ_GT(highest_ack_, recover_);
 
 	fastrecov_ = TRUE;
 	rtxbytes_ = 0;
@@ -2579,7 +2583,7 @@
 void
 TahoeFullTcpAgent::dupack_action()
 {  
-        int recovered = (highest_ack_ > recover_);
+        int recovered = SEQ_GT(highest_ack_, recover_);
 
 	fastrecov_ = TRUE;
 	rtxbytes_ = 0;
@@ -2696,11 +2700,11 @@
 SackFullTcpAgent::dupack_action()
 {
 
-        int recovered = (highest_ack_ > recover_);
+        int recovered = SEQ_GT(highest_ack_, recover_);
 
 	fastrecov_ = TRUE;
 	rtxbytes_ = 0;
-	pipe_ = maxseq_ - highest_ack_ - sq_.total();
+	pipe_ = SEQ_SUB( SEQ_SUB(maxseq_, highest_ack_), sq_.total());
 
 //printf("%f: SACK DUPACK-ACTION:pipe_:%d, sq-total:%d, bugfix:%d, cwnd:%d, highest_ack:%d, recover_:%d\n",
 //now(), pipe_, sq_.total(), bug_fix_, int(cwnd_), int(highest_ack_), recover_);
@@ -2740,7 +2744,7 @@
 	recover_ = maxseq_;	// where I am when recovery starts
 
 	int amt = fast_retransmit(highest_ack_);
-	h_seqno_ = highest_ack_ + amt;
+	h_seqno_ = SEQ_ADD(highest_ack_, amt);
 
 //printf("%f: FAST-RTX seq:%d, h_seqno_ is now:%d, pipe:%d, cwnd:%d, recover:%d\n",
 //now(), int(highest_ack_), h_seqno_, pipe_, int(cwnd_), recover_);
@@ -2753,12 +2757,12 @@
 void
 SackFullTcpAgent::pack_action(Packet* p)
 {
-	if (!sq_.empty() && sack_min_ < highest_ack_) {
+	if (!sq_.empty() && SEQ_LT(sack_min_, highest_ack_)) {
 		sack_min_ = highest_ack_;
 		sq_.cleartonxt();
 	}
 	pipe_ -= maxseg_;	// see comment in tcp-sack1.cc
-	if (h_seqno_ < highest_ack_)
+	if (SEQ_LT(h_seqno_, highest_ack_))
 		h_seqno_ = highest_ack_;
 }
 
@@ -2768,7 +2772,7 @@
 //printf("%f: EXITING fast recovery, recover:%d\n",
 //now(), recover_);
 	fastrecov_ = pipectrl_ = FALSE;
-        if (!sq_.empty() && sack_min_ < highest_ack_) {
+        if (!sq_.empty() && SEQ_LT(sack_min_, highest_ack_)) {
                 sack_min_ = highest_ack_;
                 sq_.cleartonxt();
         }
@@ -2854,8 +2858,8 @@
 		return (FullTcpAgent::send_allowed(seq));
 
 	// don't overshoot receiver's advertised window
-	int topawin = highest_ack_ + int(wnd_) * maxseg_;
-	if (seq >= topawin) {
+	int topawin = SEQ_ADD(highest_ack_, int(wnd_) * maxseg_);
+	if (SEQ_GE(seq, topawin)) {
 //printf("%f: SEND(%d) NOT ALLOWED DUE TO AWIN:%d, pipe:%d, cwnd:%d\n",
 //now(), seq, topawin, pipe_, int(cwnd_));
 		return FALSE;
@@ -2877,7 +2881,7 @@
 SackFullTcpAgent::nxt_tseq()
 {
 
-	int in_recovery = (highest_ack_ < recover_);
+	int in_recovery = SEQ_LT(highest_ack_, recover_);
 	int seq = h_seqno_;
 
 	if (!in_recovery) {
@@ -2916,13 +2920,13 @@
 			// adjust h_seqno, as we may have
 			// been "jumped ahead" by learning
 			// about a filled hole
-			if (seq > h_seqno_)
+			if (SEQ_GT(seq, h_seqno_))
 				h_seqno_ = seq;
 			return (seq);
 		} else if (fcnt <= 0)
 			break;
 		else {
-			seq += maxseg_;
+			INCR_SEQ(seq, maxseg_);
 		}
 	}
 //if (int(t_seqno_) > 1)
--- dist-ns-allinone-2.26/ns-2.26/tcp/tcp-full.h	Wed Feb 26 15:11:24 2003
+++ ns-allinone-2.26/ns-2.26/tcp/tcp-full.h	Fri Jun  6 17:18:37 2003
@@ -104,6 +104,20 @@
 #define PF_TIMEOUT 0x04	    /* protocol defined */
 #define	TCP_PAWS_IDLE	(24 * 24 * 60 * 60)	/* 24 days in secs */
 
+#define SEQ_LT(a,b)  (((a)<(b) && (b)-(a) < TCP_MAXSEQ/2) || ((a)>(b) && (a)-(b) >= TCP_MAXSEQ/2))
+#define SEQ_LE(a,b)  (((a)<=(b) && (b)-(a) < TCP_MAXSEQ/2) || ((a)>(b) && (a)-(b) >= TCP_MAXSEQ/2))
+#define SEQ_GT(a,b)  (((a)>(b) && (a)-(b) < TCP_MAXSEQ/2) || ((a)<(b) && (b)-(a) >= TCP_MAXSEQ/2))
+#define SEQ_GE(a,b)  (((a)>=(b) && (a)-(b) < TCP_MAXSEQ/2) || ((a)<(b) && (b)-(a) >= TCP_MAXSEQ/2))
+#define INCR_SEQ(num, val) (num) = ((num) + (val)) % TCP_MAXSEQ
+#define SEQ_ADD(num, val) (((num) + (val)) % TCP_MAXSEQ)
+inline int SEQ_SUB(int num, int val) {
+  int ret = num - val;
+    return( abs(ret) < TCP_MAXSEQ/2 ? ret : ((int)(((long long)(num) - (val) + TCP_MAXSEQ) % TCP_MAXSEQ)) );
+}
+#define DECR_SEQ(num, val) (num) = SEQ_SUB((num), (val))
+#define SEQ_MIN(x,y) (SEQ_LT((x),(y))?(x):(y))
+#define SEQ_MAX(x,y) (SEQ_GT((x),(y))?(x):(y))
+
 class FullTcpAgent;
 class DelAckTimer : public TimerHandler {
 public:
@@ -190,9 +204,9 @@
 	}
 	virtual void sent(int seq, int amt) {
 		if (seq == t_seqno_)
-			t_seqno_ += amt;
+			INCR_SEQ(t_seqno_, amt);
 		pipe_ += amt;
-		if (seq < int(maxseq_))
+		if (SEQ_LT(seq, int(maxseq_)))
 			rtxbytes_ += amt;
 	}
 	virtual void oldack() {			// what to do on old ack
--- dist-ns-allinone-2.26/ns-2.26/tcp/tcp.h	Wed Feb 26 15:11:25 2003
+++ ns-allinone-2.26/ns-2.26/tcp/tcp.h	Fri Jun  6 17:22:30 2003
@@ -56,6 +56,8 @@
 	int tcp_flags_;         /* TCP flags for FullTcp */
 	int last_rtt_;		/* more recent RTT measurement in ms, */
 				/*   for statistics only */
+        int maxseg_;            /* MSS for TCPTap to negotiate in the SYN segment
+				   needed in NSE */
 
 	static int offset_;	// offset for this header
 	inline static int& offset() { return offset_; }
@@ -75,6 +77,7 @@
 	int& ackno() { return (ackno_); }  
 	int& flags() { return (tcp_flags_); }
 	int& last_rtt() { return (last_rtt_); }
+	int& maxseg() { return (maxseg_); }
 };
 
 /* these are used to mark packets as to why we xmitted them */
--- dist-ns-allinone-2.26/ns-2.26/tools/random.cc	Wed Feb 26 15:11:28 2003
+++ ns-allinone-2.26/ns-2.26/tools/random.cc	Fri Jun  6 17:23:54 2003
@@ -47,11 +47,13 @@
 #define GCC_THROW
 #endif
 
+#if 0
 RANDOM_RETURN_TYPE
 random() GCC_THROW
 {
 	printf("random() called in ns.\nRandom is not portable, please use Random::uniform() instead.\n");
 	abort();
 }
+#endif
 
 #endif /* !WIN32 */
--- dist-ns-allinone-2.26/ns-2.26/trace/cmu-trace.cc	Wed Feb 26 15:11:29 2003
+++ ns-allinone-2.26/ns-2.26/trace/cmu-trace.cc	Fri Jun  6 17:24:39 2003
@@ -941,6 +941,8 @@
 		case PT_GAF:
 		case PT_PING:
 			break;
+		case PT_LIVE:
+			break;
 		default:
 			fprintf(stderr, "%s - invalid packet type (%s).\n",
 				__PRETTY_FUNCTION__, packet_info.name(ch->ptype()));
