#!/usr/bin/perl -w
#
# Linktest test script.
#
# @author: davidand
use strict;
use Class::Struct;
use constant STATIC => "Static";
use lib '@prefix@/lib';
use event;

# path to linktest special ns
use constant LINKTEST_NSPATH => "@LINKTEST_NSPATH@";

# log files used by tests.
use constant CRUDE_DAT => "/tmp/crude.dat"; # binary data
use constant CRUDE_DEC => "/tmp/crude.dec"; # decoded binary data
use constant RUDE_CFG  => "/tmp/rude.cfg";
use constant PATHRATE_DAT => "/tmp/pathrate.dat";

# rude sample size for loss
# TODO: modulate this based on link speed..
# in practice, 56kb maxes out around 100 pps.
# above 256Kb 400 is OK.
use constant SEND_RATE => 400; # rude sends 1 more than specified here.
use constant SEND_COUNT => 401;

# pathrate test limits -- see &valid_bw comment.
use constant HI_BW => 85000000;
use constant LO_BW =>  1000000;
use constant HI_LOSS => 0;

# supported OS's as returned by uname.
use constant BSD => "FreeBSD";
use constant LINUX => "Linux";

# tolerance levelS
use constant LAT_TOL => 0.71; # units of ms
use constant BW_TOL => 3; # units of mb
use constant LOSS_TOL => 3; # number of standard deviations of binomial rv

# test levels
use constant PARSE_ONLY => 0;   # parse and exit
use constant ONEHOP_LEVEL => 1; # direct link connectivity & latency
use constant NHOP_LEVEL => 2;   # prior plus static routing
use constant LOSS_LEVEL => 3;   # prior plus loss
use constant BW_LEVEL => 4; # prior plus bandwidth

# test names
use constant TEST_STATIC_ROUTING => "Static Routing";
use constant TEST_LATENCY_RTT => "Latency (Round Trip)";
use constant TEST_LOSS => "Loss (One-Way)";
use constant TEST_BW_PATHRATE => "Bandwidth (Pathrate)";

# error suffix for logging linktest and development (fatal) errors
use constant SUFFIX_ERROR => ".error";
use constant SUFFIX_FATAL => ".fatal";
use constant SUFFIX_TOPO =>  ".topology";

##############################################################################
# Globals
##############################################################################

# see init() for initialization of globals
my $ns_file;    # ns file full path
my $synserv;    # synch server node
my $rtproto;    # routing protocol
my $hostname;   # this host's name
my $exp_id;     # experiment id
my $proj_id;    # project id
my $gid;        # group id
my $platform;   # name of platform
my $testlevel=99; # which tests to run (default, all)
my $crude_pid;  # pid of a crude process to harvest rude streams
my $pathrate_snd_pid; # pid of a pathrate_snd process to harvest rcv streams
my $verbosity = 0; # enable debug statements
my $cumulative = 1; # cumulative tests (default,all)
my $barr_count;   # used by synserv host, nubmer of hosts -1
my $server = "boss";       # event server. default to boss.

my @hosts; # hosts: list of text strings containing host names.
           # sorted alphabetically
my @links; # links: list of edge structs.
           # sorted alphabetically by src . dst

# struct for representing a link.
struct ( edge => {
    src => '$',
    dst => '$',
    bw  => '$',
    delay => '$',
    loss => '$',
});
                                   # note, no measured_delay

my $expt_path;  # experiment path (ie, tbdata) set by init.
my $linktest_path;   # log path (ie tbdata/linktest) set by init.

# full path to custom NS build. 
my $ns_cmd; 

# path in which to run ns (must have hacked tb_compat.tcl present)
# TODO: this should get a configure variable.
my $run_in_path = "/users/davidand/testbed/event/linktest";

##############################################################################
# Main control
##############################################################################


&proc_cmd;

&init;

if($testlevel == PARSE_ONLY) {
    &debug_top;
}

if(($cumulative && $testlevel >= ONEHOP_LEVEL)
   || (!$cumulative && $testlevel == ONEHOP_LEVEL)) {
    &debug("\nTesting Single Hop Connectivity and Latency...\n\n");
    &ping_latency_test;
}

if((($cumulative && $testlevel >= NHOP_LEVEL)
    || (!$cumulative && $testlevel == NHOP_LEVEL))
   && defined($rtproto) && $rtproto eq STATIC) {
    &debug("\nTesting Static Routing...\n\n");
    &static_rt_test; # nodes not covered by 1hop test
}

if (($cumulative && $testlevel >=LOSS_LEVEL)
    || (!$cumulative && $testlevel ==LOSS_LEVEL)) {
    &debug("\nTesting Loss...\n\n");
    &stream_test; 
}

if(($cumulative && $testlevel >=BW_LEVEL)
   || (!$cumulative && $testlevel == BW_LEVEL)) {
    &debug("\nTesting Bandwidth...\n\n");
    &bw_test;
}

&send_done;

##############################################################################
# Test procedures
##############################################################################

# does the current node have a link?
# @return: 1 for yes, 0 else
sub linked_node {
    my $node = shift @_;
    foreach my $edge (@links) {
        if($node eq $edge->src
           || $node eq $edge->dst) {
            return 1;
        }
    }
    return 0;
}


# Static routing test
# 
# Attempt to reach all nodes with default TTL
sub static_rt_test {

    # only need to attempt to reach nodes that are not on direct links
    # WITH THIS HOST!!
    #
    # direct linked nodes are covered by the single-hop test.
    my @host_copy = @hosts;

    my @this_1hops; # 1hop destinations from this host.

    foreach my $edge(@links) {
	if($edge->src eq $hostname) {
	    push @this_1hops, $edge->dst;
	} elsif ($edge->dst eq $hostname) {
	    push @this_1hops, $edge->src;
	}
    }


    for(my $i=0;$i<@host_copy;$i++) {
	if($host_copy[$i] eq $hostname) {
	    $host_copy[$i] = undef;
	} else {
	    # zap any host in the dst list.
	    foreach my $dst( @this_1hops ) {
		if(defined($host_copy[$i])
		   && ($dst eq $host_copy[$i])) {
		    $host_copy[$i] = undef;
		} 
	    }
	}
    }

    my @waitlist;
    # fork processes to run the pings in parallel.
    for(my $i=0;$i<@host_copy;$i++) {
	if(defined($host_copy[$i])
           && linked_node($host_copy[$i])
           ) {
	    my $dst = $host_copy[$i];
	    my $pid = fork();
	    if(!$pid) {
		my ($recv_cnt,$ignored) = &ping_node($dst,0);
		if(!$recv_cnt) {
		    my $newEdge = new edge;
		    $newEdge->src($hostname);
		    $newEdge->dst($dst);
		    &error(TEST_STATIC_ROUTING,$newEdge , "$hostname could not ping $dst");
		} else {
		    &debug("Attempting to reach $dst... OK\n");
		}
		exit;
	    } else {
		push @waitlist,$pid;
	    }
	}
    }
    &wait_all(\@waitlist);
}

# Ping directly connected nodes and get RTT.
#
# note: since there were intermittent problems with the OWD
# measurement on BSD, hold off on using NTP/Crude/rude for
# latency measurement and the best fit. However, keep the
# variance from the OWD test. See /users/davidand/magic/rude
sub ping_latency_test {
    my @waitlist;
    my @edge_copy = @links;

    while(&has_elems(\@edge_copy)) {
	my ($edge,$other_edge) = &get_twoway_assign(\@edge_copy);
	if(defined($edge) && defined($other_edge)) {

	    if($hostname eq $edge->src ) {
		my $pid = fork();
		if(!$pid) {

		    # call ping_node with ttl=1
		    my ($result_cnt, $avg_latency) = &ping_node($edge->dst,1);
		    my $expected = $edge->delay + $other_edge->delay;		    
		    my $diff = abs($avg_latency - $expected);
		    my $output = sprintf ": %.3f/%.3f/%.3f\n", $avg_latency
			, $expected, $diff;
		    
		    my $msg = "RTT " . $edge->src . " to " . $edge->dst . $output;
		    &debug($msg);
		    if($diff>LAT_TOL) {
			&error (TEST_LATENCY_RTT, $edge
			    , "Measured latency $avg_latency exceeded expected latency $expected by $diff");
		    }

		    exit(0);

		} else {
		    push @waitlist, $pid;
		}
	    }
#
	}
    }

    &wait_all(\@waitlist);
}




# Stream test
#
# See /users/davidand/magic/parallelism/README for some comments about
# why it's OK to run crude/rude in both directions simultaneously.
#
# Due to problems found while testing, the stream test doesn't check latency,
# only loss. See bas:/users/davidand/writeup2/finalpaper.pdf for test details.
sub stream_test {
    my %analyze;
    my %recv_cnt;
    my $stream_id = 1;
    my @edge_copy = @links;
    while(&has_elems(\@edge_copy)) {
	my ($edge,$other_edge) = &get_twoway_assign(\@edge_copy);
	if(defined($edge) && defined($other_edge)) {
	    if($hostname eq $edge->src) {
		# TODO: parameterize this call
		open FCFG,">" . RUDE_CFG || &fatal ("Could not open " . RUDE_CFG);
		print FCFG "START NOW\n";
		print FCFG "0000 $stream_id ON 3001 " . $edge->dst . ":10001 CONSTANT " . SEND_RATE . " 20\n";
		print FCFG "1000 $stream_id OFF\n";
		close FCFG;
		# run the test
		system "rude -s" . RUDE_CFG . " 1>/dev/null 2>/dev/null";
		$analyze{$stream_id} = $other_edge;
	    } elsif ($hostname eq $other_edge->src) {
		open FCFG,">" . RUDE_CFG || &fatal ("Could not open " . RUDE_CFG);
		print FCFG "START NOW\n";
		print FCFG "0000 $stream_id ON 3001 " . $other_edge->dst . ":10001 CONSTANT " . SEND_RATE . " 20\n";
		print FCFG "1000 $stream_id OFF\n";
		close FCFG;
		# run the test
		system "rude -s" . RUDE_CFG . " 1>/dev/null 2>/dev/null";
		$analyze{$stream_id} = $edge;
	    }
	}
	$stream_id++;
	&barrier();
    }

    # ok, shut down crude.
    system "kill -9 $crude_pid";

    # now, analyze the data that this node RECEIVED, which will be the
    # data that the other node sent.
    system "crude -d " . CRUDE_DAT . " > " . CRUDE_DEC;
    open CLOG, "" . CRUDE_DEC || &fatal ("Could not open " . CRUDE_DEC);
    while(<CLOG>) {
	if(/ID=(\d+) /) {
	    $recv_cnt{$1}++;
	}
    }
    close CLOG;

    foreach my $key (keys %analyze) {
	my $edge = $analyze{$key};
	my $recved = $recv_cnt{$key};
	if(!defined($recved)) {
	    $recved=0;
	    &error (TEST_LOSS,$edge,"No packets received from " . $edge->src);
	} else {
	    my $expected = &round($edge->loss * SEND_COUNT);
	    my $actual = (SEND_COUNT - $recved);
	    my $msg = "Stream from " . $edge->src . ": " 
		. $actual
		. "/" . $expected
		. "\n";
	    &debug($msg);
	    # for now, check sqrt(np(1-p)), even though that doesn't account for sample size.
	    my $dev = sqrt(SEND_COUNT * $edge->loss * (1 - $edge->loss));
	    $dev = &round($dev);
	    my $tol = LOSS_TOL * $dev;
	    if( $actual < ($expected - $tol)
		|| 
		$actual > ($expected + $tol)) {
		my $errmsg = "Measured loss $actual exceeded expected loss $expected by "
		    . abs ($expected - $tol);
		&error(TEST_LOSS, $edge, $errmsg);
	    }
	}

    }


    # one more barrier, want to make sure io intensive processes
    # finish before the bandwidth test.
    &barrier();
}



# Bandwidth test
#
# See /users/davidand/magic/parallelism/README for some comments about
# why each Pathrate process gets its own machine while running.
sub bw_test {
    my @analyze_list;
    my @edge_copy;
    @edge_copy = @links;

    # blitz old data
    if (-e PATHRATE_DAT) {
	unlink PATHRATE_DAT || &fatal ("Could not delete " . PATHRATE_DAT);
    }


    # all nodes will execute the same reductions on the edge list
    # on their own so that the number of barriers is the same.
    while(&has_elems(\@edge_copy)) {
	my $edge = &get_assign(\@edge_copy);

	if(defined($edge) ) {
	    if($hostname eq $edge->dst && &valid_bw($edge)) {
		push @analyze_list, $edge;

		my $cmd = "pathrate_rcv -Q -s " . $edge->src . " -q -N "
		    . PATHRATE_DAT;
		system "$cmd";
#		&debug("Pathrate rcv from " . $edge->src . "...OK\n");
	    } 
	}
	&barrier();
    }

    # ok to shut down collector.
    system "kill -9 $pathrate_snd_pid";
    
    # read the log file.
    if(@analyze_list) {
	open PLOG, "".PATHRATE_DAT || &fatal ("Could not open " . PATHRATE_DAT);
	while(<PLOG>) {
	    my $edge = shift(@analyze_list);
	    my $sender = $edge->src;
	    if(/SNDR=$sender.*CAPL=(\d+\.\d+)Mbps.*CAPH=(\d+\.\d+)Mbps/) {
		my $expected = $edge->bw / 1000000;
		my $low = $1;
		my $hi = $2;
		my $diff;
		if($expected > $2) {
		    $diff = $expected - $2;
		} elsif ($expected < $1) {
		    $diff = $1 - $expected;
		} else {
		    $diff = 0;
		}
		
		
		my $output = sprintf "Receive from " . $edge->src
		    . ": $1/$2/%.1f/%.1f\n", $expected, $diff;
		&debug($output);

		if($diff > BW_TOL) {
		    &error (TEST_BW_PATHRATE, $edge, "Measured bandwidth range $low to $hi Mbps differed from expected $expected by $diff");
		}

	    } else {
		&fatal("Error while parsing " . PATHRATE_DAT);
	    }
	}
    }
    
}


##############################################################################
# Utility methods
##############################################################################

# When delay nodes are present, Pathrate has problems getting above
# approx 90Mb measurements on 100Mb links. See
# /users/davidand/magic/pathrate for details.  Pathrate usually
# fails under 1Mbps.
# Further, loss causes pathrate to fail. So skip pathrate if loss is
# over 2%.
# Basically we only want to run Pathrate if there's a good chance of
# successful measurement, since it's rather lengthy to run (16s average).
sub valid_bw {
    my $edge = shift @_;
    if($edge->bw >= LO_BW
       && $edge->bw <= HI_BW
       && $edge->loss <= HI_LOSS
       ) {
	return 1;
    } else {
	return 0;
    }
	

}


# Handles reading NS output.
sub get_topo {
    my $ns_outfile = shift(@_);

    open NSOUT,$ns_outfile || &fatal("Could not open $ns_outfile");
    while(<NSOUT>) {
	chomp;

	# load the output from ns.
	# the file format is simple:
	# expr := h <node name>
	#      || l <src node> <dst node> <bw (Mb/s)> <latency (s)> <loss (%)>
	if( /^h (\S+)/ ) {
	    push @hosts, $1
	} elsif ( /^l (\S+)\s+(\S+)\s+(\d+)\s+(\d\.\d+)\s+(\d\.\d+)/) {
	    my $newEdge = new edge;
	    $newEdge->src($1);
	    $newEdge->dst($2);
	    $newEdge->bw($3);
	    $newEdge->delay($4 * 1000); # units of ms
	    $newEdge->loss($5);
	    push @links, $newEdge;

	# currently recognize only Static routing
	} elsif (/^r Static/i) {
	    $rtproto = STATIC;
	}
    }
    close NSOUT;

    # sorted order.
    @hosts = sort { $a cmp $b } @hosts;
    @links = sort { $a->src . $a->dst cmp $b->src . $b->dst } @links;

}


# prints out the topology read in from the NS file
sub debug_top {
    &debug("ns script: $ns_file\n");
    &debug("nodes:\n");
    foreach my $vert (@hosts) {
	&debug( " " . $vert . "\n");
    }
    &debug("links:\n");
    foreach my $edge (@links) {
	&debug( " " . $edge->src . " " . $edge->dst . " " . $edge->bw
		. " " . $edge->delay . " " . $edge->loss . "\n"
		);
    }
    &debug("routing protocol: $rtproto\n") if defined($rtproto);
}

# log to expt problem directory.
sub error {
    my($test,$edge,$msg) = @_;

    my $output = "$test\n";
    $output .= "  Link:  " . $edge->src . " to " . $edge->dst . "\n";
    $output .=     "  Error: $msg\n\n";

    my $fname = $linktest_path . "/" . $hostname . SUFFIX_ERROR;
    open ERRF,">>$fname" || &fatal("Could not open $fname");
    print ERRF $output;
    close ERRF;
    if($verbosity) {
	print STDERR $output;
    }
}

# log to fatal file and exit.
sub fatal {
    my ($msg) = @_;

    my $output = "Fatal Error: $msg";

    if(defined($linktest_path) && defined($hostname)) {
	my $fname = $linktest_path . "/" . $hostname . SUFFIX_FATAL;
	open ERRF,">$fname" || die "Could not open $fname for fatal error logging! $output";
	print ERRF $output;
	close ERRF;
    }
    die $output;
}


# synch all nodes
sub barrier {
    my $cmd;
    if($hostname eq $synserv) {
	# note, the synserver should know what the node count is
	# since it parsed the NS file.
	&fatal("barrcount not defined!") unless defined($barr_count);
	$cmd = "emulab-sync -i $barr_count";
    } else {
	$cmd = "emulab-sync";
    }
#    &debug($cmd . "\n");
    system $cmd;

}

sub debug {
    return unless $verbosity;
    print "@_";
}


# initialize globals and set up linktest directory if needed.
sub init {
    my @results = `uname`;
    $platform = $results[0];
    chomp($platform);

    if($platform eq BSD) {
	$ns_cmd = LINKTEST_NSPATH ."/fbsd/ns";
    } elsif ($platform eq LINUX) {
	$ns_cmd = LINKTEST_NSPATH ."/linux/ns";
    } else {
	&fatal("Platform $platform is not currently supported.");
    }

    # if this is a dry run, get out here.
    if($testlevel <= PARSE_ONLY) {
	my $outname = "/tmp/linktest" . SUFFIX_TOPO;
	chdir($run_in_path);
	system "$ns_cmd $ns_file > $outname";
	&get_topo($outname);
	return;
    }

    # get the experiment info
    my $fname = "@CLIENT_VARDIR@/boot/nickname";
    &fatal("Could not locate $fname") unless -e $fname;
    my $tmp = `cat $fname`;
    ($hostname, $exp_id, $proj_id) = split /\./, $tmp;
    chomp $hostname;
    chomp $exp_id;
    chomp $proj_id;
    $gid = $proj_id; # temporarily ignoring groups

    # get the experiment path and log path
    $expt_path = "/proj/$proj_id/exp/$exp_id/tbdata";
    $linktest_path = "$expt_path/linktest";
    $ns_file = "$expt_path/$exp_id-modify.ns" unless defined($ns_file);
    $ns_file = "$expt_path/$exp_id.ns" unless -e $ns_file;    
    &fatal("Could not locate $ns_file") unless -e $ns_file;

    my $ssname = "@CLIENT_VARDIR@/boot/syncserver";
    &fatal("Could not locate an emulab-sync server") unless -e $ssname;

    $tmp = `cat $ssname`;
    ($synserv) = split/\./, $tmp;
    chomp $synserv;

    # synserv machine makes the linktest directory and invokes ns.
    my $outname = "$linktest_path/$exp_id" . SUFFIX_TOPO;
    if($hostname eq $synserv) {
	if( -e $linktest_path ) {
	    &fatal("Path $linktest_path is not a directory") unless -d $linktest_path;

	    # blitz files from the last time.
	    opendir (DIR,$linktest_path) || &fatal("Could not open $linktest_path");
	    my @dirfiles = grep (!/^\.\.?$/,readdir(DIR));
	    foreach (@dirfiles) {
		unlink "$linktest_path/$_" || &fatal("Could not delete $_");
	    }

	} else {
	    mkdir ($linktest_path,0777) or &fatal("Could not create directory $linktest_path");
	}

	chdir($run_in_path);
	system "$ns_cmd $ns_file > $outname";
    }

    # start up collector streams if necessary.
    if($testlevel >=LOSS_LEVEL) {
	$crude_pid = fork();
	if(!$crude_pid) {
	    unlink CRUDE_DAT if -e CRUDE_DAT;
	    open(STDOUT, ">/dev/null") ; # redirct output to null
	    exec "crude -l " . CRUDE_DAT;
	}
    }
    if($testlevel >=BW_LEVEL) {
	$pathrate_snd_pid = fork();
	if(!$pathrate_snd_pid) {
	    exec "pathrate_snd -i -q";
	}
    }

    # synserver host reads the ns file early to get the node count.
    # not using ready count, in practice sometimes didn't get a ready
    # in some cases (expt modify).
    if($hostname eq $synserv) {
	&get_topo($outname) ;
	$barr_count = @hosts;
	$barr_count--;
    }

    # big first synch waiting for collector startup and ns execution.
    &barrier;

    # now all nodes read in the topology file output by ns.
    &get_topo($outname) unless $hostname eq $synserv;
}    

# pings a node. 
# this test is core functionality. Have tested at 1Kbps, hence 0.1 interval.
# Binomial RV: at 20% loss (95% th percentile of loss in survey)
# chance of no packets getting through is approximately 0.
#
# @param[0] := host to ping
# @param[1] := ttl, 0 for default
# @return: (received_count, avg_latency ms)
sub ping_node {
    my ($host,$ttl) = @_;
    my $count = 0;
    my $avg_latency = 0;

    # set deadline to prevent long waits
    my $cmd;
    if($ttl) {
	if($platform eq BSD) {
	    $cmd = "sudo ping -c 10 -q -i 0.1 -t 1 -m $ttl $host";
	} elsif($platform eq LINUX) {
	    $cmd = "sudo ping -c 10 -q -i 0.1 -w 1 -t $ttl $host";
	}
    } else {
	if($platform eq BSD) {
	    $cmd = "sudo ping -c 10 -q -i 0.1 -t 1 $host";
	} elsif($platform eq LINUX) {
	    $cmd = "sudo ping -c 10 -q -i 0.1 -w 1 $host";
	}
    }

    my @results = `$cmd`;
    my $reslt_cnt = @results;
    my $result = $results[$reslt_cnt-2];
    if($platform eq BSD && $result =~ /(\d+) packets received/) {
	$count = $1;
    } elsif($platform eq LINUX && $result =~ /(\d+) received/) {
	$count = $1;
    }

    if($count) {
	$result = $results[$reslt_cnt-1];
	if($result=~ /\/(\d+\.\d+)\//) {
	    $avg_latency = $1;
	}
    }
    
    return ($count, $avg_latency);
}



# returns one edge at a time, reserving two nodes.
sub get_assign {
    my ($todo_ref) = @_; # must maintain sorted order invariant
    my $task = undef;
    my @thisrun;

    # build a fresh hash to see which nodes are in use.
    my %inuse;
    foreach (@hosts) {
	$inuse{$_}=0;
    }

    for(my $i=0;$i<@{$todo_ref};$i++) {
	my $edge = @{$todo_ref}[$i];
	if(defined($edge) && !($inuse{$edge->src} || $inuse {$edge->dst})) {
	    $inuse{$edge->src} = 1;
	    $inuse{$edge->dst} = 1;
	    push @thisrun,$edge;
	    @{$todo_ref}[$i] = undef;
	}
    }

    # figure out the tasks for this particular host.
    foreach my $edge (@thisrun) {
	if($hostname eq $edge->src || $hostname eq $edge->dst ) {
	    $task = $edge;
	}
    }

    # each machine should reduce the todo list the same order due to
    # alphabetic sorting of info from the ns file.
    # only thing left to do is return this machines' assignment for processing.
    return $task; # or undef if no jobs left for this host.
}


# returns two edges at a time, reserving two nodes.
sub get_twoway_assign {
    my ($todo_ref) = @_;
    my $task = undef;
    my $other_task = undef;
    my @thisrun;

    # build a fresh hash to see which nodes are in use.
    my %inuse;
    foreach (@hosts) {
	$inuse{$_}=0;
    }

    for(my $i=0;$i<@{$todo_ref};$i++) {
	my $edge = @{$todo_ref}[$i];
	if(defined($edge) && !($inuse{$edge->src} || $inuse {$edge->dst})) {
	    $inuse{$edge->src} = 1;
	    $inuse{$edge->dst} = 1;
	    push @thisrun, $edge;
	    @{$todo_ref}[$i]=undef;

	    # get the other side
	    for(my $j=$i;$j<@{$todo_ref};$j++) {
		my $otheredge = @{$todo_ref}[$j];
		if(defined($otheredge)
		   && $edge->src eq  $otheredge->dst
		   && $edge->dst eq $otheredge->src) {
		    push @thisrun,$otheredge;
		    @{$todo_ref}[$j] = undef;
		}
	    }
	    
	}
    }


    # figure out the tasks for this particular host.
    foreach my $edge (@thisrun) {
	if($hostname eq $edge->src || $hostname eq $edge->dst) {
	    $task = $edge;
	}
    }
    if(defined($task)) {
	foreach my $edge (@thisrun) {
	    if($task->dst eq $edge->src && $task->src eq $edge->dst) {
		$other_task = $edge;
	    }
	}
    }

    return ($task,$other_task); # or undef if no jobs left for this machine.


}

sub has_elems {
    my ($todo_ref) = @_;
    foreach (@{$todo_ref}) {
	if(defined($_)) {
	    return 1;
	}
    }
    return 0;
}


sub round {
    my($number) = shift;
    return int($number + .5);
}

# wait for all procs in the list argument to exit
sub wait_all {
    my ($list_ref) = @_;
    foreach my $pid ( @{$list_ref}) {
	waitpid($pid,0);
    }
}

# process cmd line
sub proc_cmd {
    my %options=();

    # NOTE: arguments come in the form X=something.
    # due to event thing. rather than finessing for getopt,
    # just parse argv.
    
    foreach my $arg (@ARGV) {
	if($arg =~ /VERBOSE=(\d)/) {
	    $verbosity=$1;
	}
	if($arg =~ /THROUGH=(\d)/) {
	    $testlevel=$1;
	}
	if($arg =~ /TEST=(\d)/) {
	    $cumulative=0;
	    $testlevel=$1;
	}
	if($arg =~ /FILE=(\S+)/) {
	    $ns_file = $1;
	}
    }
    if($testlevel == PARSE_ONLY
       && !defined($ns_file)) {
	&fatal("Parse-only mode was requested but no filename was supplied");
    }
    &debug( "got arguments: @ARGV\n");
}

# send the event indicating that the test has completed.
sub send_done {
    
    my $URL = "elvin://$server";

    my $handle = event_register($URL,0);
    if (!$handle) { &fatal("Unable to register with event system"); }

    my $tuple = address_tuple_alloc();
    if (!$tuple) { &fatal("Could not allocate an address tuple"); }

    %$tuple = ( objtype => "LINKTEST",
		eventtype => "STOP",
		host => "*");

    my $notification = event_notification_alloc($handle,$tuple);
    if (!$notification) { &fatal("Could not allocate notification"); }

    if (!event_notify($handle, $notification)) {
	&fatal("could not send test event notification");
    }

    event_notification_free($handle, $notification);

    if (event_unregister($handle) == 0) {
	&fatal("could not unregister with event system");
    }

}
