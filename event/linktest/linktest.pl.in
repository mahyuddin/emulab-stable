#!/usr/bin/perl -w -T
#
# Linktest test script.
#
# @author: davidand
#
use strict;
use Class::Struct;
use POSIX qw(uname);
use IO::Handle;

# path to applications and files
use constant LINKTEST_NSPATH => "@LINKTEST_NSPATH@";
use constant PATH_NICKNAME => "@CLIENT_VARDIR@/boot/nickname";
use constant PATH_KEYFILE => "@CLIENT_VARDIR@/boot/eventkey";
use constant PATH_RUDE => "/usr/local/bin/rude";
use constant PATH_CRUDE => "/usr/local/bin/crude";
use constant PATH_PATHRATE_SND => "/usr/local/bin/pathrate_snd";
use constant PATH_PATHRATE_RCV => "/usr/local/bin/pathrate_rcv";
use constant PATH_EMULAB_SYNC => "@CLIENT_BINDIR@/emulab-sync";
use constant PATH_LTEVENT => "@CLIENT_BINDIR@/ltevent";

# log files used by tests.
use constant CRUDE_DAT => "/tmp/crude.dat"; # binary data
use constant RUDE_CFG  => "/tmp/rude.cfg";
use constant PATHRATE_DAT => "/tmp/pathrate.dat";

# pathrate test limits.
use constant LIMIT_BW_HI => 50000000;
use constant LIMIT_BW_LO =>  1000000;
use constant LIMIT_BW_LOSS => 0;

# A hack to make sure that we don't get bogged down in being too
# accurate! Make sure the 
# error is a certain significance before we start reporting it.
use constant INSIGNIFICANT_LAT_ERROR => 0.40;  # ms  (quite wide)
use constant INSIGNIFICANT_BW_ERROR  => 1.00;  # mb  (quite wide)

# latency must be corrected for xmit delay under this speed.
use constant LAT_LOW_BW => 10000000;

# slow send rate (for bw 256kbps to 1Mbps)
use constant SLOW_BW => 256000;
use constant SLOW_SEND => 400;
use constant FAST_SEND => 1002;

# misc contstants
use constant BSD => "FreeBSD";
use constant LINUX => "Linux";
use constant RTPROTO_STATIC => "Static";
use constant EVENT_STOP => "STOP";
use constant PING_SEND_COUNT => 10;
use constant SYNC_NAMESPACE => "linktest";

# test levels
use constant TEST_LATENCY => 1; # direct link connectivity & latency
use constant TEST_RT_STATIC => 2;   # prior plus static routing
use constant TEST_LOSS => 3;   # prior plus loss
use constant TEST_BW => 4; # prior plus bandwidth

# test names
use constant NAME_RT_STATIC => "Static Routing";
use constant NAME_LATENCY => "Latency (Round Trip)";
use constant NAME_LOSS => "Loss";
use constant NAME_BW => "Bandwidth";

# error suffix for logging linktest and development (fatal) errors
use constant SUFFIX_ERROR => ".error";
use constant SUFFIX_FATAL => ".fatal";
use constant SUFFIX_TOPO =>  ".topology";
use constant DEBUG_ALL => 2; # debug level for all debug info, not just msgs.
use constant LOG_CHANCE => 0.10; # chance of logging.

# more paths
use constant RUN_PATH => "@CLIENT_BINDIR@"; # where the linktest-ns runs.

# struct for representing a link.
struct ( edge => {
    src => '$',
    dst => '$',
    bw  => '$',
    delay => '$',
    loss => '$'
});

# security: constrain the path
$ENV{'PATH'} = '/bin:/usr/bin:/usr/local/bin';

##############################################################################
# Globals
##############################################################################

# see init() for initialization of globals
my $ns_file;    # ns file full path
my $synserv;    # synch server node
my $rtproto;    # routing protocol
my $hostname;   # this hosts name
my $exp_id;     # experiment id
my $proj_id;    # project id
my $gid;        # group id
my $platform;   # name of platform
my $startat=1;  # which test to start at
my $stopat=99;  # which test to stop at
my @kill_list;  # PIDs maintained through the life of linktest
                    # which get killed as part of cleanup.
my $debug_level = 0; # enable debug statements
                    # 1 = print debug statements.
                    # 2 = show STDOUT and STDERR
my $barr_count;   # used by synserv host, nubmer of hosts -1
my $event_server;       # event server
my $log_file;    # common logfile for information saved over time.

my @hosts; # hosts: list of text strings containing host names.
           # sorted alphabetically
my @links; # links: list of edge structs.
           # sorted alphabetically by src . dst
                                  
my $expt_path;  # experiment path (ie, tbdata) set by init.
my $linktest_path;   # log path (ie tbdata/linktest) set by init.

# full path to custom NS build. 
my $ns_cmd; 

# signal handler in case the process is killed.
$SIG{INT} = sub {
    &debug("Linktest killed by SIGINT.\n");
    &cleanup;
    exit(1);
};

# security
$ENV{'PATH'} = '/bin:/usr/bin';

##############################################################################
# Main control
##############################################################################
&proc_cmd;

&init;

&debug_top;

if(&dotest(TEST_LATENCY)) {
    &debug("\nTesting Single Hop Connectivity and Latency...\n\n");
    &latency_test;
}

if(&dotest(TEST_RT_STATIC)
    && defined($rtproto)
    && $rtproto eq RTPROTO_STATIC) {

    &debug("\nTesting Static Routing...\n\n");
    &static_rt_test; # nodes not covered by 1hop test
}

if(&dotest(TEST_LOSS)) {
    &debug("\nTesting Loss...\n\n");
    &loss_test; 
}
if(&dotest(TEST_BW)){
    &debug("\nTesting Bandwidth...\n\n");
    &bw_test;
}

&cleanup;

&send_done;

&debug("Done\n");

exit(0);

##############################################################################
# Test procedures
##############################################################################


sub write_rude_cfg {
    my ($stream_id, $edge) = @_;
    open FCFG,">" . RUDE_CFG ||  die &fatal ("Could not open " . RUDE_CFG);
    print FCFG "START NOW\n";
    print FCFG "0000 $stream_id ON 3001 " . $edge->dst . ":10001 CONSTANT " . &get_loss_sample_size($edge) . " 20\n";
    print FCFG "1000 $stream_id OFF\n";
    close FCFG;

}

sub get_loss_sample_size {
    my $edge = shift @_;
    if($edge->loss > 0) {
	return &round( 10 / $edge->loss);
    } else {
	return SLOW_SEND; # just in case a slow link with no loss.
    }
}

sub print_link {
    my $edge = shift @_;
    return $edge->src . " to " . $edge->dst . " (" . ($edge->bw / 1000000)  . 
	" Mbps, " . $edge->delay . "ms, " . $edge->loss . "% loss)";
}
# See /users/davidand/magic/parallelism/README for some comments about
# why it's OK to run crude/rude in both directions simultaneously.
#
# Due to problems found while testing, the stream test doesn't check latency,
# only loss. See bas:/users/davidand/writeup2/finalpaper.pdf for test details.
sub loss_test {
    my %analyze;
    my %recv_cnt;
    my $stream_id = 1;
    my @edge_copy = @links;
    while(&has_elems(\@edge_copy)) {
	my ($edge,$other_edge) = &get_twoway_assign(\@edge_copy);
	if(defined($edge) && defined($other_edge)) {
	    if($hostname eq $edge->src) {
		if(valid_loss($edge)) {
		    &write_rude_cfg($stream_id,$edge);
		    &my_system(PATH_RUDE,"-s", RUDE_CFG);
		    $analyze{$stream_id} = $other_edge;
		} else {
		    &debug("Skipping loss test for " . &print_link($edge) . "\n");
		}
	    } elsif ($hostname eq $other_edge->src) {
		if(valid_loss($other_edge)) {
		    &write_rude_cfg($stream_id,$other_edge);
		    &my_system(PATH_RUDE,"-s", RUDE_CFG);
		    $analyze{$stream_id} = $edge;
		} else {
		    &debug("Skipping loss test for " . &print_link($other_edge) . "\n");
		}
	    }
	}
	$stream_id++;
	&barrier();
    }

    # wait for any stragglers due to delay-- there is a  race
    # between the barrier sync on the control net and the expt net latency.
    # XXX should actually sleep as a function of the max latency for speed.
    sleep(1);

    # count packets received for each stream.
    my @results = &my_tick(PATH_CRUDE,"-d",CRUDE_DAT);
    my $result_count = @results;
    &debug("result_count from crude: $result_count\n");
    foreach (@results) {
	if(/ID=(\d+) /) {
	    $recv_cnt{$1}++;
	}
    }

    # analyze only links for which a stream was received here.
    foreach my $key (keys %analyze) {
	my $edge = $analyze{$key};
	my $received = $recv_cnt{$key};

	if(!defined($received)) {
	    $received=0;
	    &error (NAME_LOSS,$edge,"No packets received from " . $edge->src);
	} else {
	    # this is a large sample test about proportion p.
	    # this is considered a valid statistical estimate for np >= 10.
	    my $p = 1 - $edge->loss;
	    my $n = &get_loss_sample_size($edge) + 1 ;


	    my $p_hat = $received / $n;
	    my $numerator = $p_hat - $p;
	    my $denominator = sqrt( $p * (1 - $p_hat) / $n);

	    if( $edge->loss == 0) {
		if($received < $n) {

		    &log("$platform," . TEST_LOSS . "," 
			 . $edge->loss . ","
			 . $n . ","
			 . $received . "\n");
		    
		    my $errmsg = "Unexpected loss occurred (n=$n, received=$received)\n";
		    &error(NAME_LOSS, $edge, $errmsg);
		} # note, no logging of succesful 0-loss. (too common).
	    } elsif($denominator == 0) {
		my $errmsg = "No packets were lost (n=$n, plr=" . $edge->loss .")";
		&error(NAME_LOSS, $edge, $errmsg);
	    } else {
		&log("$platform," . TEST_LOSS . "," 
		     . $edge->loss . ","
		     . $n . ","
		     . $received . "\n");
		
		my $z = $numerator / $denominator;
		my $reject_region = 2.58; # alpha = 0.1, normal distro by CLT
		if(abs($z) > $reject_region) {
		    my $errmsg = "Probable loss misconfiguration (n:$n, received: $received; expected proportion: $p, measured proportion=$p_hat)";
		    &error(NAME_LOSS, $edge, $errmsg);
		}
	    }
	}

    }


    # one more barrier, want to make sure io intensive processes
    # finish before the bandwidth test.
    &barrier();
}


# does the current node have a link?
# @return: 1 for yes, 0 else
sub linked_node {
    my $node = shift @_;
    foreach my $edge (@links) {
        if($node eq $edge->src
           || $node eq $edge->dst) {
            return 1;
        }
    }
    return 0;
}


# Static routing test
# 
# Attempt to reach all nodes with default TTL
sub static_rt_test {

    # only need to attempt to reach nodes that are not on direct links
    # WITH THIS HOST!!
    #
    # direct linked nodes are covered by the single-hop test.
    my @host_copy = @hosts;

    my @this_1hops; # 1hop destinations from this host.

    foreach my $edge(@links) {
	if($edge->src eq $hostname) {
	    push @this_1hops, $edge->dst;
	} elsif ($edge->dst eq $hostname) {
	    push @this_1hops, $edge->src;
	}
    }

    for(my $i=0;$i<@host_copy;$i++) {
	if($host_copy[$i] eq $hostname) {
	    $host_copy[$i] = undef;
	} else {
	    # zap any host in the dst list.
	    foreach my $dst( @this_1hops ) {
		if(defined($host_copy[$i])
		   && ($dst eq $host_copy[$i])) {
		    $host_copy[$i] = undef;
		} 
	    }
	}
    }

    my @waitlist;
    # fork processes to run the pings in parallel.
    for(my $i=0;$i<@host_copy;$i++) {
	if(defined($host_copy[$i])
           && linked_node($host_copy[$i])
           ) {
	    my $dst = $host_copy[$i];
	    my $pid = fork();
	    if(!$pid) {
		my ($recv_cnt,$ignored1, $ignored2) = &ping_node($dst,0);
		if(!$recv_cnt) {
		    my $newEdge = new edge;
		    $newEdge->src($hostname);
		    $newEdge->dst($dst);
		    &error(NAME_RT_STATIC,$newEdge , "$hostname could not ping $dst");
		} else {
		    &debug("Attempting to reach $dst... OK\n");
		}
		exit;
	    } else {
		push @waitlist,$pid;
	    }
	}
    }
    &wait_all(\@waitlist);
}


# Ping directly connected nodes and get RTT.
#
# Note: using RTT is suboptimal because it doesnt split out
# links individually. However, due to problems when running crude/rude
# with timestamps on BSD, I am falling back to RTT for now.
sub latency_test {
    my @waitlist;
    my @edge_copy = @links;

    while(&has_elems(\@edge_copy)) {
	my ($edge,$other_edge) = &get_twoway_assign(\@edge_copy);
	if(defined($edge) && defined($other_edge)) {
	    if($hostname eq $edge->src ) {
		# todo: consider ignoring latency if no delay node.
		if(&valid_latency($edge) && &valid_latency($other_edge)
		   ) {
		    my $pid = fork();
		    if(!$pid) {

			# call ping_node with ttl=1
			my ($result_cnt, $sample_avg, $sample_dev) = &ping_node($edge->dst,1);


			my $n = PING_SEND_COUNT;

			if($result_cnt == 0) {
			    my $errmsg = "No packets were received (n=$n)\n";
			    &error(NAME_LATENCY, $edge, $errmsg);
			} else {

# facts from analysis in /users/davidand/public/calibrate.
# came from 40 independent swapins (enough for normality assumption)
# (note that data actually is normal at any particular latency point, 
# according to described.lst)

# best fit regression for the error as a function of total latency, according to sas.
# see regression1.lst and regression1.sas
#-0.00523(actual)     0.00003096 fbsd
#-0.00530(actual)     0.00003478 linux
# roughly identical, so use:
#-0.005(actual)

# inherent delay in the system (with a delay node) is
# see described.lst and described.sas
# 0.337737  fbsd
# 0.362282  linux (median was 0.328000)
# for now, round to:
# 0.333 ms
# since I don't have a way to know which is which.

# Also, described.lst provides good support for the notion that
# the distribution of latencies is normal. For Fbsd all of the 
# distributions were normal, and most were for Linux. So, use this
# assumption in order to send fewer test packets.
			   

			    # the null hypothesis value, u.
			    my $u = $edge->delay + $other_edge->delay;
			    
			    # the calibration as a function of $u
			    $u += 0.333 - 0.005 * $u / 2;


# calibration did not include transport delay,
# so only factor it in under the calibrated level.

			    # transport delay: 64 bytes + 18 bytes eth/crc
			    # to units of ms.
			    if($edge->bw < LAT_LOW_BW) {
				$u += 1000 * (82 * 8) / $edge->bw;
			    }
			    if($other_edge->bw < LAT_LOW_BW) {
				$u += 1000 * (82 * 8) / $other_edge->bw;
			    }
			    
			    my $x_bar = $sample_avg;
			    my $numerator = $x_bar - $u;

			    my $S = $sample_dev;
			    

			    my $denominator = $S / sqrt($n);

			    if($denominator == 0) {
				my $errmsg = "Invalid sample standard deviation (possible parse problem, please report). (n=$n, u=$u, x_bar=$x_bar, S=$S)";
				&error(NAME_LATENCY, $edge, $errmsg);
			    } else {
				my $z = $numerator / $denominator;

				&log("$platform," . TEST_LATENCY . "," 
				     . $edge->delay . ","
				     . $other_edge->delay . ","
				     . $u . ","
				     . "$n,$sample_avg,$sample_dev,$z\n");

				my $t_reject = 3.250; # alpha = 0.01, df=9

				if(abs($z) > $t_reject
				   && (abs($x_bar - $u) > INSIGNIFICANT_LAT_ERROR)
				   ) {
				    my $errmsg = "Probable latency misconfiguration (expected=$u, measured mean=$x_bar).";
				    &error(NAME_LATENCY, $edge, $errmsg);
				}
			    }

			}
			exit(0);

		    } else {
			push @waitlist, $pid;
		    }
		} else {
		    &debug("Skipping latency test for " . &print_link($edge) . " to " . &print_link($other_edge) . "\n");
		}
	    }
#
	}
    }

    &wait_all(\@waitlist);
}


# Bandwidth test
#
# See /users/davidand/magic/parallelism/README for some comments about
# why each Pathrate process gets its own machine while running.
sub bw_test {
    my @analyze_list;
    my @edge_copy;
    @edge_copy = @links;



    # all nodes will execute the same reductions on the edge list
    # on their own so that the number of barriers is the same.
    while(&has_elems(\@edge_copy)) {
	my $edge = &get_assign(\@edge_copy);

	if(defined($edge) ) {
	    if($hostname eq $edge->dst) {
		if (&valid_bw($edge)) {
		    push @analyze_list, $edge;
		    
		    &my_system(PATH_PATHRATE_RCV, "-Q","-s",$edge->src,"-q","-N", PATHRATE_DAT);
		} else {
		    &debug("Skipping bandwidth test for " . &print_link($edge) . "\n");

		}
	    } 
	}
	&barrier();
    }


    # read the log file.
    if(@analyze_list) {
	my @results = &read_file(PATHRATE_DAT);
	foreach (@results) {
	    my $edge = shift(@analyze_list);
	    my $sender = $edge->src;
	    if(/SNDR=$sender.*CAPL=(\d+\.\d+)Mbps.*CAPH=(\d+\.\d+)Mbps/) {
		my $expected = $edge->bw / 1000000;
		my $low = $1;
		my $hi = $2;

		&log("$platform," . TEST_BW . "," 
		     . $expected . ","
		     . $low . ","
		     . $hi . "\n");

		my $diff;
		if($expected > $2) {
		    $diff = $expected - $2;
		} elsif ($expected < $1) {
		    $diff = $1 - $expected;
		} else {
		    $diff = 0;
		}

		my $output = sprintf "Receive from " . $edge->src
		    . ": $1/$2/%.1f/%.1f\n", $expected, $diff;
		&debug($output);

		if($diff > INSIGNIFICANT_BW_ERROR) {
		    &error (NAME_BW, $edge, "Bandwidth estimate $low to $hi Mbps does not include expected bandwidth $expected Mbps");
		}

	    } else {
		 die &fatal("Error while parsing " . PATHRATE_DAT);
	    }
	}
    }
    
}

# enforce BW limits for Pathrate
sub valid_bw {
    my $edge = shift @_;
    if($edge->bw >= LIMIT_BW_LO
       && $edge->bw <= LIMIT_BW_HI
       && $edge->loss <= LIMIT_BW_LOSS
       ) {
	return 1;
    } else {
	return 0;
    }
}

# Note, slow bandwidths may cause a problem. 256 kbps can safely handle 400
# pps in crude, so some combinations of loss may overwhelm the link.
sub valid_loss {
    my $edge = shift @_;
    if($edge->bw >= SLOW_BW && $edge->bw < LIMIT_BW_LO) {
	if(&get_loss_sample_size($edge) > SLOW_SEND) {
	    return 0;
	} else {
	    return 1;
	}
    } elsif( $edge->bw >= LIMIT_BW_LO) {
	# also want an upper limit.
	if(&get_loss_sample_size($edge) > FAST_SEND) {
	    return 0;
	} else {
	    return 1;
	}
    } else {
	return 0;
    }
}

# allow all tests, but this hasn't really been tested much under 1Mb.
sub valid_latency {
    return 1;

}


# Handles reading NS output.
sub get_topo {
    my $ns_outfile = shift(@_);

    my @results = &read_file($ns_outfile);
    foreach (@results) {

	# load the output from ns.
	# the file format is simple:
	# expr := h <node name>
	#      || l <src node> <dst node> <bw (Mb/s)> <latency (s)> <loss (%)>
	if( /^h (\S+)/ ) {
	    push @hosts, $1
	} elsif ( /^l (\S+)\s+(\S+)\s+(\d+)\s+(\d\.\d+)\s+(\d\.\d+)/) {
	    my $newEdge = new edge;
	    $newEdge->src($1);
	    $newEdge->dst($2);
	    $newEdge->bw($3);
	    $newEdge->delay($4 * 1000); # units of ms
	    $newEdge->loss($5);
	    push @links, $newEdge;

	# currently recognize only Static routing
	} elsif (/^r Static/i) {
	    $rtproto = RTPROTO_STATIC;
	}
    }

    # sorted order.
    @hosts = sort { $a cmp $b } @hosts;
    @links = sort { $a->src . $a->dst cmp $b->src . $b->dst } @links;

}


# prints out the topology read in from the NS file
sub debug_top {
    &debug("ns script: $ns_file\n");
    &debug("event server: $event_server\n");
    &debug("nodes:\n");
    foreach my $vert (@hosts) {
	&debug( " " . $vert . "\n");
    }
    &debug("links:\n");
    foreach my $edge (@links) {
	&debug( " " . $edge->src . " " . $edge->dst . " " . $edge->bw
		. " " . $edge->delay . " " . $edge->loss . "\n"
		);
    }
    &debug("routing protocol: $rtproto\n") if defined($rtproto);
}

# log to expt problem directory.
sub error {
    my($test,$edge,$msg) = @_;

    my $output = "$test\n";
    $output .= "  Link:  " . &print_link($edge) . "\n";
    $output .=     "  Error: $msg\n\n";

    &debug($output);    
    &append_file($linktest_path . "/" . $hostname . SUFFIX_ERROR,
		 $output);
}

# log to fatal file and exit.
sub fatal {
    my ($msg) = @_;
    my @output;
    push @output,"Fatal Error: $msg";

    if(defined($linktest_path) && defined($hostname)) {
	my $fname = $linktest_path . "/" . $hostname . SUFFIX_FATAL;
	&write_file($fname,@output);
    }
    
    # clean up any child proceses
    &cleanup;

    return $output[0];
}


# synch all nodes
sub barrier {
    if($hostname eq $synserv) {
	# note, the synserver should know what the node count is
	# since it parsed the NS file.
	die &fatal("barrcount not defined!") unless defined($barr_count);
	if($barr_count) {
	    &my_system(PATH_EMULAB_SYNC,"-i",$barr_count,"-n",SYNC_NAMESPACE);
	}
    } else {
	&my_system(PATH_EMULAB_SYNC,"-n",SYNC_NAMESPACE);
    }

}

sub debug {
    return unless $debug_level;
    print "@_";
}


# initialize globals and set up linktest directory if needed.
sub init {
    ($platform) = POSIX::uname();

    if($platform eq BSD) {
	$ns_cmd = LINKTEST_NSPATH ."/fbsd/ns";
    } elsif ($platform eq LINUX) {
	$ns_cmd = LINKTEST_NSPATH ."/linux/ns";
    } else {
	 die &fatal("Platform $platform is not currently supported.");
    }

    # get the experiment info
    my $fname = PATH_NICKNAME;
    die &fatal("Could not locate $fname") unless -e $fname;
    my @results = &read_file($fname);
    ($hostname, $exp_id, $proj_id) = split /\./, $results[0];
    chomp $hostname;
    chomp $exp_id;
    chomp $proj_id;
    $gid = $proj_id; # temporarily ignoring groups

    # get the experiment path and log path
    $expt_path = "/proj/$proj_id/exp/$exp_id/tbdata";
    $log_file = "/proj/$proj_id/ltdata";
    $linktest_path = "$expt_path/linktest";
    if(!defined($ns_file)) {
	if(-e "$expt_path/$exp_id-modify.ns") {
	    $ns_file = "$expt_path/$exp_id-modify.ns";
	} elsif (-e "$expt_path/$exp_id.ns") {
	    $ns_file = "$expt_path/$exp_id.ns";
	} else {
	    die &fatal("Could not locate an ns file.");
	}
    }

    my $ssname = "@CLIENT_VARDIR@/boot/syncserver";
     die &fatal("Could not locate an emulab-sync server") unless -e $ssname;

    @results = &read_file($ssname);
    ($synserv) = split/\./, $results[0];
    chomp $synserv;

    # synserv machine makes the linktest directory and invokes ns.
    my $outname = "$linktest_path/$exp_id" . SUFFIX_TOPO;
    if($hostname eq $synserv) {
	if( -e $linktest_path ) {
	     die &fatal("Path $linktest_path is not a directory") unless -d $linktest_path;

	    # blitz all files in the shared directory from the previous run.
	    opendir (DIR,$linktest_path) ||  die &fatal("Could not open $linktest_path");
	    my @dirfiles = grep (!/^\.\.?$/,readdir(DIR));
	    foreach (@dirfiles) {
		&do_unlink("$linktest_path/$_");
	    }
	    closedir(DIR);

	} else {
	    mkdir (&check_filename($linktest_path),0777) or  die &fatal("Could not create directory $linktest_path");
	}

	chdir(RUN_PATH);
	@results = &my_tick($ns_cmd,
			    &check_filename($ns_file));
	&write_file($outname,@results);
    }
    
    # blitz local files from last run.
    &do_unlink(CRUDE_DAT);
    &do_unlink(PATHRATE_DAT);
    &do_unlink(RUDE_CFG);

    # start up collector streams if necessary.
    if(&dotest(TEST_LOSS)){
	&my_system_initonly(PATH_CRUDE,"-l",CRUDE_DAT);
    }
    if(&dotest(TEST_BW)){
	&my_system_initonly(PATH_PATHRATE_SND,"-i","-q");
    }
    if(&dotest(TEST_LOSS) || &dotest(TEST_BW)) {
	sleep(1); # give collectors time to start up (potential race)
    }

    # synserver host reads the ns file early to get the node count.
    # not using ready count, in practice sometimes didn't get a ready
    # in some cases (expt modify).
    if($hostname eq $synserv) {
	&get_topo($outname) ;
	$barr_count = @hosts;
	$barr_count--;
    }

    # what is event server...
    @results = &my_tick("@CLIENT_BINDIR@/tmcc","bossinfo");
    if(@results && $results[0] =~ /^([\w\.]*)\s/) {
	$event_server = $1; 
    } else {
	die &fatal("Could not determine event server name");
    }


    # big first synch waiting for collector startup and ns execution.
    &barrier;

    # now all nodes read in the topology file output by ns.
    &get_topo($outname) unless $hostname eq $synserv;
}    

# Ping test, which does service both for latency and static
# routing/connectivity tests. Note, send-rate is only 10
# so this can run even on a 1kbps link. 10 packets are enough
# for connectivity even with high loss (plr 0.1, still 0.999 chance
# of getting through).
# 
# @param[0] := host to ping
# @param[1] := ttl, 0 for default
# @return: (received_count, avg_latency ms)
sub ping_node {
    my ($host,$ttl) = @_;
    my $count = 0;
    my $avg_latency = 0;
    my $stddev = 0;

    my $send_count = PING_SEND_COUNT;
    my $timeout = 1; # 1 second
    my $send_rate = $timeout / $send_count;

    # set deadline to prevent long waits
    my $cmd;
    if($ttl) {

	# TODO: figure out a way not to have to specify the whole path to
	# standard programs ping and sudo.
	# for some reason including them in the env didn't work.
	if($platform eq BSD) {
	    $cmd = "/usr/local/bin/sudo /sbin/ping -c $send_count -q -i $send_rate -t $timeout -m $ttl $host";
	} elsif($platform eq LINUX) {
	    $cmd = "/usr/bin/sudo /bin/ping -c $send_count -q -i $send_rate -w $timeout -t $ttl $host";
	}
    } else {
	if($platform eq BSD) {
	    $cmd = "/usr/local/bin/sudo /sbin/ping -c $send_count -q -i $send_rate -t $timeout $host";
	} elsif($platform eq LINUX) {
	    $cmd = "/usr/bin/sudo /bin/ping -c $send_count -q -i $send_rate -w $timeout $host";
	}
    }

    # note backticks passes SIGINT to child procs
    my @args = split(/\s+/,$cmd);
    my @results = &my_tick(@args);

    my $reslt_cnt = @results;
    my $result = $results[$reslt_cnt-2];
    if($platform eq BSD && $result =~ /(\d+) packets received/) {
	$count = $1;
    } elsif($platform eq LINUX && $result =~ /(\d+) received/) {
	$count = $1;
    }

    if($count) {
	$result = $results[$reslt_cnt-1];
	if($result=~ /\d+\.\d+\/(\d+\.\d+)\/\d+\.\d+\/(\d+\.\d+)/) {
	    $avg_latency = $1;
	    $stddev = $2;
	}
    }
    return ($count, $avg_latency, $stddev);
}



# returns one edge at a time, reserving two nodes.
sub get_assign {
    my ($todo_ref) = @_; # must maintain sorted order invariant
    my $task = undef;
    my @thisrun;

    # build a fresh hash to see which nodes are in use.
    my %inuse;
    foreach (@hosts) {
	$inuse{$_}=0;
    }

    for(my $i=0;$i<@{$todo_ref};$i++) {
	my $edge = @{$todo_ref}[$i];
	if(defined($edge) && !($inuse{$edge->src} || $inuse {$edge->dst})) {
	    $inuse{$edge->src} = 1;
	    $inuse{$edge->dst} = 1;
	    push @thisrun,$edge;
	    @{$todo_ref}[$i] = undef;
	}
    }

    # figure out the tasks for this particular host.
    foreach my $edge (@thisrun) {
	if($hostname eq $edge->src || $hostname eq $edge->dst ) {
	    $task = $edge;
	}
    }

    # each machine should reduce the todo list the same order due to
    # alphabetic sorting of info from the ns file.
    # only thing left to do is return this machines' assignment for processing.
    return $task; # or undef if no jobs left for this host.
}


# returns two edges at a time, reserving two nodes.
sub get_twoway_assign {
    my ($todo_ref) = @_;
    my $task = undef;
    my $other_task = undef;
    my @thisrun;

    # build a fresh hash to see which nodes are in use.
    my %inuse;
    foreach (@hosts) {
	$inuse{$_}=0;
    }

    for(my $i=0;$i<@{$todo_ref};$i++) {
	my $edge = @{$todo_ref}[$i];
	if(defined($edge) && !($inuse{$edge->src} || $inuse {$edge->dst})) {
	    $inuse{$edge->src} = 1;
	    $inuse{$edge->dst} = 1;
	    push @thisrun, $edge;
	    @{$todo_ref}[$i]=undef;

	    # get the other side
	    for(my $j=$i;$j<@{$todo_ref};$j++) {
		my $otheredge = @{$todo_ref}[$j];
		if(defined($otheredge)
		   && $edge->src eq  $otheredge->dst
		   && $edge->dst eq $otheredge->src) {
		    push @thisrun,$otheredge;
		    @{$todo_ref}[$j] = undef;
		}
	    }
	    
	}
    }


    # figure out the tasks for this particular host.
    foreach my $edge (@thisrun) {
	if($hostname eq $edge->src || $hostname eq $edge->dst) {
	    $task = $edge;
	}
    }
    if(defined($task)) {
	foreach my $edge (@thisrun) {
	    if($task->dst eq $edge->src && $task->src eq $edge->dst) {
		$other_task = $edge;
	    }
	}
    }

    return ($task,$other_task); # or undef if no jobs left for this machine.


}

sub has_elems {
    my ($todo_ref) = @_;
    foreach (@{$todo_ref}) {
	if(defined($_)) {
	    return 1;
	}
    }
    return 0;
}


sub round {
    my($number) = shift;
    return int($number + .5);
}

# wait for all procs in the list argument to exit
sub wait_all {
    my ($list_ref) = @_;
    foreach my $pid ( @{$list_ref}) {
	waitpid($pid,0);
    }
}

# process cmd line
sub proc_cmd {
    my %options=();

    # important arguments come from events.
    
    foreach my $arg (@ARGV) {
	if($arg =~ /STOPAT=(\d)/) {
	    $stopat=$1;
	}
	if($arg =~ /STARTAT=(\d)/) {
	    $startat=$1;
	}
	if($arg =~ /TEST=(\d)/) {
	    $stopat=$1;
	    $startat=$1;
	}

	# development options
	if($arg =~ /SCRIPT=(\S+)/) {
	    $ns_file = $1;
	}
	if($arg =~ /DEBUG=(\d)/) {
	    $debug_level=$1;
	}

    }
    &debug( "got arguments: @ARGV\n");
}

# send the event indicating that the test has completed.
sub send_done {
    if($hostname eq $synserv) {
	&my_system(PATH_LTEVENT,"-s",$event_server,"-e","$proj_id/$exp_id","-x",EVENT_STOP, "-k", PATH_KEYFILE);
    }
}

# cleanup any child procs.
sub cleanup {
    &debug("Cleaning up @kill_list\n");
    kill 9, @kill_list;
}

sub dotest {
    my $level = shift @_;
    if($level >= $startat && $level <= $stopat) {
	return 1;
    } else {
	return 0;
    }
}

# an alternative to backticks to pass taint mode.
sub my_tick {
    # first arg has to be a file, so at least check that here.
    my $fname = &check_filename(shift @_);

    my @results;
    open(FROM, "-|") or exec $fname, @_;
    while( <FROM>) {
	push @results,$_;
    };
    close FROM;
    return @results;
}

# reads/returns contents of file.
sub read_file {
    my @results;
    my $fname = &check_filename($_[0]);
    open FILE, $fname || die &fatal ("Could not open $fname");
    while(<FILE>) {
	chomp;
	push @results, $_;
    };
    close FILE;
    return @results;
	
}


# purpose: because built-in system does not send SIGINT to child processes,
# interrupting link test (in development) causes background proceses.
# using a lower-level implementation enables sending
# SIGINT to children via the kill_list. Use my_system instead of system
# for longer-running tasks for which output is redirected to null.
#
# @param: accepts a list of arguments for exec.
sub my_system {
    &check_filename($_[0]);

    foreach my $param (@_) {
	&debug($param . " ");
    }
    &debug("\n");
    if(my $pid =fork) {
	push @kill_list, $pid;
	waitpid($pid,0);
	pop(@kill_list);
    } else {
	if($debug_level < DEBUG_ALL) {
	    open(STDOUT, "/dev/null") ;
	    open(STDERR, $linktest_path . "/" . $hostname . SUFFIX_ERROR) ;
	}
	exec(@_);
    }
}
# permutation of my_system to start but not wait for child procs.
sub my_system_initonly {
    &check_filename($_[0]);

    if(my $pid =fork) {
	push @kill_list, $pid;
    } else {
	if($debug_level < DEBUG_ALL) {
	    open(STDOUT, "/dev/null") ;
	    open(STDERR, $linktest_path . "/" . $hostname . SUFFIX_ERROR) ;
	}
	exec(@_);
    }
}

sub check_filename {
    my $fname = shift @_;
    
    # taint check: /something/something.out
    if($fname =~ /^(\/?(?:[\/\w-]*(?:\.\w+)?)*)$/) {
	return "$1";
    } else {
	die &fatal("Possible taint detected: $fname");
    }

}

sub write_file{
    my ($fname,@list) = @_;
    my $ut_fname = &check_filename($fname);
    open FILE,">$ut_fname"  || die &fatal("could not open $ut_fname for writing");
    foreach (@list) {
	print FILE $_;
    }
    close FILE;

}


sub do_unlink {
    my $ut_fname = &check_filename(shift @_);

    if( -e $ut_fname) {
	&debug("unlink $ut_fname\n");
	unlink $ut_fname ||  die &fatal ("Could not delete $ut_fname");
    }
}

# purpose: log to a proprietary location for future improvement.
# save only randomly so that it doesn't hit the fs too bad.
sub log {
    return unless (rand(1) < LOG_CHANCE);
    my $msg = shift @_;
    &debug($msg);
    &append_file($log_file,$msg);
}

sub append_file {
    my $fname = &check_filename(shift @_);
    open FILE,">>$fname" || die &fatal ("Could not append to $fname");
    print FILE "@_";
    close FILE;
}
