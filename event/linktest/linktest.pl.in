#!/usr/bin/perl -w
#
# Linktest test script.
#
# set $ENV{TEST_NS_SCRIPT} to override default NS file location (for testing)
#
# @author: davidand
# @created: 10/13/03
use strict;
use Class::Struct;
use Getopt::Std;
use constant ERROR_LOG => "/tmp/linktest.log";
use constant RUDE_LOG  => "/tmp/rude.log";
use constant CRUDE_DAT => "/tmp/crude.dat"; # crude binary 
use constant CRUDE_DEC => "/tmp/crude.dec"; # decoded crude data
use constant RUDE_CFG  => "/tmp/rude.cfg";
use constant PATHRATE_DAT => "/tmp/pathrate.dat";
use constant SEND_RATE => 400; # rude sends 1 more than specified here.
use constant PACK_COUNT => 401;
#use constant HI_BW => 90000000; # pathrate test only accurate 1-90 Mbps
#use constant LO_BW =>  1000000;
use constant BSD => "FreeBSD";
use constant LAT_TOL => 0.71; # units of ms
use constant DEBUG => 1;

##############################################################################
# Globals
##############################################################################

# see init() for initialization of globals
my $ns_file;    # operative ns file
my $synserv;    # node having synch server (from tb-set-synch)
my $rtproto;    # routing protocol
my $hostname; # this host
my $eid; # experiment id
my $pid; # project id
my $gid; # group id
my $platform; #results of uname
my $testlevel=99; #default all tests

my @verts; # verts: list of text strings containing host names.
           # sorted alphabetically
my @edges; # edges: list of edge structs.
           # sorted alphabetically by src . dst

# struct for representing an edge
struct ( edge => {
    src => '$',
    dst => '$',
    bw  => '$',
    delay => '$',
    loss => '$'
});


# experiment path (ie, tbdata) set by init.
my $expt_path;

# log path (ie tbdata/linktest) set by init.
my $log_path;

# full path to custom NS build. 
# TODO: this should get a configure variable.
# NOTE: this is platform and linktest specific!
my $ns_cmd = "ns"; 

# full path to custom tb_compat.tcl. # TODO: this should be a configure variable.L
my $lt_path = "/users/davidand/testbed/event/linktest";

##############################################################################
# Main control
##############################################################################

&init;

my %options=();
getopts("f:cl:",\%options);

# usage: f=filename, c= count synchs and exit, l=test level 1-3

# if there is an arg, just count steps and return.
# this was a quick hack to survey number of synch steps on production files.
# figure out which file to use
# get the nsfile path 
if(defined $options{f}){
    $ns_file = $options{f};
    die "could not find $ns_file" unless -e $ns_file;
} else {

    # TODO: support groups!
    # if they modified, use the modify; else use the default.
    my $modname = "/proj/$pid/exp/$eid/tbdata/" . $eid . "-modify.ns";
    if (-e $modname ) {
	$ns_file = $modname;
    } else {
	$ns_file = "/proj/$pid/exp/$eid/tbdata/$eid.ns";
    }
}

# init topology
&get_topo;

if(defined $options{c}){
    &debug_top();
    &count_steps();
    exit(0);
}

if(defined $options{l}) {
    if($options{l}=~/(\d)/){
       $testlevel=$1;
    }
}
    
# is there a synch server? if not that's a problem (unless have a default)
die "no synch server defined in: $ns_file\n" unless defined($synserv);

#&debug_top;

    if($testlevel >= 1) {

	&debug("stat_rt_test\n");
	&stat_rt_test if defined($rtproto) && $rtproto eq "Static";

	&debug("onehop_test\n");
	&onehop_test;
    }

    if ($testlevel >=2) {
	&debug("ping_latency_test\n");
	&ping_latency_test;
    }

    if ($testlevel >=3) {
	&debug("stream_test\n");
	&stream_test; 
    }

    if( $testlevel >=4) {
	&debug("bw_test\n");
	&bw_test if $testlevel >=3;
    }
&debug("all done\n");


##############################################################################
# Test procedures
##############################################################################


# Static routing test
# 
# Attempt to reach all nodes with default TTL
sub stat_rt_test {
    # fork processes to run the pings in parallel.
    foreach my $dst (@verts) {
	if(!($dst eq $hostname) ) {
	    &debug("stat_rt_test: ping $dst\n");
	    my $pid = fork();
	    if(!$pid) {
		if(!&ping_node($dst,0)) {
		    &error("could not reach $dst");
		}
		exit;
	    }
	}
    }
    wait;
}


# direct link test
#
# Attempt to reach linked nodes with TTL=1
sub onehop_test {
    # fork processes to run the pings in parallel.
    foreach my $edge (@edges) {
	if($edge->src eq $hostname ) {
	    my $pid = fork();
	    if(!$pid) {
		if(!&ping_node($edge->dst,1)) {
		    &error("could not reach " . $edge->dst . " directly");
		}
		exit;
	    }
	}
    }
    wait;
}
 
# stream test
#
# check loss and possibly latency on non-BSD.
#
# note: it's possible to get a more precise read on the network if
# both end nodes are linux (using owd and ntp) but given that it may 
# be a mix, for now just use the ping test. stream test still useful
# for loss.
sub stream_test {
    # repeatedly:
    #   get test assignments.
    #   start crude
    #   run the stream
    #   stop crude
    #   analyze results for latency and loss

    my @edge_copy = @edges;

    # all nodes will execute the same reductions on the edge list
    # on their own so that the number of barriers is the same.
    while(&has_elems(\@edge_copy)) {
	my $edge = &get_assign(\@edge_copy);
	if(defined($edge)) {
	    
	    # unique barrier for this test.
	    my $barrier_name = $edge->src;

	    # determine if this machine is the source or the dest.
	    if($hostname eq $edge->src
	       ) {
		# wait for crude startup
		&barrier_name($barrier_name,2);
		# generate config file
		open FCFG,">" . RUDE_CFG || die ("couldn't open " . RUDE_CFG);
		print FCFG "START NOW\n";
		print FCFG "0000 1 ON 3001 " . $edge->dst . ":10001 CONSTANT " . SEND_RATE . " 20\n";
		print FCFG "1000 1 OFF\n";
		close FCFG;
		# run rude
		if(DEBUG) {
		    &debug( "rude flow to " . $edge->dst . "\n");
		    system "rude -s" . RUDE_CFG ;
		} else {
		    system "rude -s" . RUDE_CFG . " 1>" . RUDE_LOG . " 2>/dev/null";
		}
		&barrier_name($barrier_name,2);

	    } elsif ($hostname eq $edge->dst) {
		# start up crude
		my $crude_pid = fork();
		if(!$crude_pid) {
		    unlink CRUDE_DAT if -e CRUDE_DAT;
		    open(STDOUT, ">/dev/null") ; # redirct output to null
		    exec "crude -l " . CRUDE_DAT;
		}
		&barrier_name($barrier_name,2);
		# test occurs
		&barrier_name($barrier_name,2);
		system "kill -9 $crude_pid";
		# analyze log for loss.
		&analyze_stream($edge,0);
	    }
	}
	# all nodes wait for the sub-syncs to complete
	&barrier();
    }
}

sub ping_latency_test {
    my @edge_copy = @edges;

    # all nodes will execute the same reductions on the edge list
    # on their own so that the number of barriers is the same.
    while(&has_elems(\@edge_copy)) {

	my ($edge,$other_edge) = &get_twoway_assign(\@edge_copy);
	if(defined($edge) && defined($other_edge)) {

	    # do a RTT test for the link and see if it adds up.
	    if($hostname eq $edge->src ) {
		my $cmd;

		# set deadline to prevent long waits
		if($platform eq BSD) {
		    $cmd = "sudo ping -c " . PACK_COUNT . " -q  -i " . (1 / SEND_RATE) . " -t 1 -m 1 " . $edge->dst ;
		} else {
		    $cmd = "sudo ping -c " . PACK_COUNT . " -q  -i " . (1 / SEND_RATE) . " -w 1 -t 1 " . $edge->dst ;
		}
		my @results = `$cmd`;
		foreach my $result (@results) {
		    # find the results line we care about
		    if($result =~ /\/(\d+\.\d+)\//) {
			my $mean = $1;
			my $expected = $edge->delay + $other_edge->delay;
			$expected *= 1000 ; # units of ms
			my $bestfit = $expected + (-0.10888 - 0.00236 * $expected)  ;
			my $diff = abs($bestfit - $mean);
			&debug("latency (ping): " . $edge->src . " to " . $edge->dst . " $mean expected $bestfit $diff\n");
			if($diff>LAT_TOL) {
			    &error("Latency test outside of best fit line by: $diff\n");
			}

		    }
		}
	    }

	}
    }
}


sub bw_test {
    
    # start pathrate_snd in interactive mode
    # repeatedly:
    #   get test assignments
    #   run pathrate_rcv
    #   analyze log results 

    my @edge_copy;
    my $snd_pid = undef;

    # assume BW test will be needed.
    $snd_pid = fork();
    if(!$snd_pid) {
	open(STDOUT, ">/dev/null"); # redirct output to null
	exec "pathrate_snd -i";
    }

    # wait for sender ready.
    sleep(2);
    &barrier();

    @edge_copy = @edges;

    # all nodes will execute the same reductions on the edge list
    # on their own so that the number of barriers is the same.
    while(&has_elems(\@edge_copy)) {
#	my $edge = &get_assign(\@edge_copy);

	my ($edge,$other_edge) = &get_twoway_assign(\@edge_copy);
	if(defined($edge) && defined($other_edge)) {

	    &debug("bw: $hostname: edge: " . $edge->src . "\t" . $edge->dst . "\n");
	    &debug("bw: $hostname: other_edge: " . $other_edge->src . "\t" . $other_edge->dst . "\n\n");

	    if($hostname eq $edge->src) {
		my $cmd = "pathrate_rcv -Q -s " . $edge->dst . " -q -O "
		    . PATHRATE_DAT;
		&debug("$cmd");
		system "$cmd";
		&analyze_bw($edge);
	    } elsif($hostname eq $other_edge->src) {
		my $cmd = "pathrate_rcv -Q -s " . $other_edge->dst . " -q -O "
		    . PATHRATE_DAT;
		&debug("$cmd");
		system "$cmd";
		&analyze_bw($other_edge);
	    }
	}
	&barrier();
    }

    system "kill -9 $snd_pid";

}


##############################################################################
# Utility methods
##############################################################################

# invoke ns and parse the representation into @verts and @edges
sub get_topo {
    # make sure we execute in the linktest directory (to access tb_compat.tcl)

    # in the experiment directory, execute the ns script with my hacked tb_compat.tcl
    chdir($lt_path);
    
    die "ns file not defined\n" unless defined ($ns_file);
    die "could not find NS script: $ns_file\n" unless -e $ns_file;

    my @ns_output = `$ns_cmd $ns_file`;
    die "no ns output!" unless @ns_output;
    foreach my $line (@ns_output) {
	chomp ($line);

	# load the output from ns.
	# the file format is simple:
	# expr := h <node name>
	#      || l <src node> <dst node> <bw (Mb/s)> <latency (s)> <loss (%)>
	if( $line =~ /^h (\S+)/ ) {
	    push @verts, $1
	} elsif ( $line =~ /^l (\S+)\s+(\S+)\s+(\d+)\s+(\d\.\d+)\s+(\d\.\d+)/) {
	    my $newEdge = new edge;
	    $newEdge->src($1);
	    $newEdge->dst($2);
	    $newEdge->bw($3);
	    $newEdge->delay($4);
	    $newEdge->loss($5);
	    push @edges, $newEdge;
	} elsif ($line =~ /^y (\S+)/) {
	    $synserv = $1;

	# currently recognize only Static routing
	} elsif ($line =~ /^r Static/i) {
	    $rtproto = "Static";
	}
    }

    # maintain sort order.
    @verts = sort { $a cmp $b } @verts;
    @edges = sort { $a->src . $a->dst cmp $b->src . $b->dst } @edges;

}


# prints out the topology read in from the NS file
sub debug_top {
#    &debug("host: $hostname\n");
    &debug("ns script: $ns_file\n");
    &debug("nodes:\n");
    foreach my $vert (@verts) {
	&debug( " " . $vert . "\n");
    }
    &debug("links:\n");
    foreach my $edge (@edges) {
	&debug( " " . $edge->src . " " . $edge->dst . " " . $edge->bw
		. " " . $edge->delay . " " . $edge->loss . "\n"
		);
    }
    &debug("synch server: $synserv\n");
    &debug("routing protocol: $rtproto\n") if defined($rtproto);
}

# TODO: update to log to expt problem directory.
sub error {
    print STDERR "ERROR: $_[0]\n";
    print STDERR "  Details: ";
    system "cat " . ERROR_LOG;
    print STDERR "\n";
}

# synch all nodes
sub barrier {
    die "wrong number of args!" if @_;
    my $name = "allnodes";
    my $count = @verts - 1;
    my $cmd;
    if($hostname eq $synserv) {
	$cmd = "emulab-sync -n $name -i $count";
    } else {
	$cmd = "emulab-sync -n $name";
    }
    system $cmd;

}

# ensure the right node puts in the count.
# @param: the name of the "master" sync command.
# @param: the number of nodes to synch.
sub barrier_name {
    die "wrong number of args" unless @_ == 2;
    my ($name, $count) = @_;
    $count -= 1;
    my $cmd;
    if($hostname eq $name) {
	$cmd = "emulab-sync -n $name -i $count";
    } else {
	$cmd = "emulab-sync -n $name";
    }
    &debug("cmd: $cmd\n");
    system $cmd;
}

sub debug {
    print "@_"; 
}

# initialize globals
sub init {

    # get the experiment info
    my $nick = `cat @CLIENT_VARDIR@/boot/nickname`;
    ($hostname, $eid, $pid) = split /\./, $nick;
    chomp $hostname;
    chomp $eid;
    chomp $pid;
    $gid = $pid; # temporarily ignoring groups

    # get the experiment path and log path
    $expt_path = "/proj/$pid/exp/$eid/tbdata";
    $log_path = "/proj/$pid/exp/$eid/tbdata/linktest";

    my @results = `uname`;
    $platform = $results[0];
    chomp($platform);

}    

# pings a node. 
# @param[0] := host to ping
# @param[1] := ttl, 0 for default
# @return: # of replies
sub ping_node {
    my ($host,$ttl) = @_;

    # set deadline to prevent long waits
    my $cmd;
    if($ttl) {
	if($platform eq BSD) {
	    $cmd = "sudo ping -c 10 -q -i 0.1 -t 1 -m $ttl $host 2> " . ERROR_LOG;
	} else {
	    $cmd = "sudo ping -c 10 -q -i 0.1 -w 1 -t $ttl $host 2> " . ERROR_LOG;
	}
    } else {
	if($platform eq BSD) {
	    $cmd = "sudo ping -c 10 -q -i 0.1 -t 1 $host 2> " . ERROR_LOG;
	} else {
	    $cmd = "sudo ping -c 10 -q -i 0.1 -w 1 $host 2> " . ERROR_LOG;
	}
    }

    my @results = `$cmd`;
    foreach my $result (@results) {
	# find the results line we care about
	if($platform eq BSD && $result =~ /(\d+) packets received/) {
	    return $1;
	} elsif($result =~ /(\d+) received/) {
	    return $1;
	}
    }
    return 0;
}


# returns an edge for this node to work on. ensures that no other
# machine gets the same assignment at the same time.
sub get_assign {
    my ($todo_ref) = @_; # must maintain sorted order invariant
    my $task = undef;
    my @thisrun;

#    &debug("oneway assign:\n");
#    foreach my $edge (@{$todo_ref}) {
#	if(defined($edge)){
#	    &debug("\t" . $edge->src . "\t" . $edge->dst . "\n");
#	}
#    }

    # build a fresh hash to see which nodes are in use.
    my %inuse;
    foreach (@verts) {
	$inuse{$_}=0;
    }

    for(my $i=0;$i<@{$todo_ref};$i++) {
	my $edge = @{$todo_ref}[$i];
	if(defined($edge) && !($inuse{$edge->src} || $inuse {$edge->dst})) {
	    $inuse{$edge->src} = 1;
	    $inuse{$edge->dst} = 1;
	    push @thisrun,$edge;
	    @{$todo_ref}[$i] = undef;
	}
    }

#    &debug("thisrun:\n");
#    foreach my $edge (@thisrun) {
#	&debug("\t" . $edge->src . "\t" . $edge->dst . "\n");
#    }


    # figure out the tasks for this particular host.
    foreach my $edge (@thisrun) {
	if($hostname eq $edge->src || $hostname eq $edge->dst ) {
	    $task = $edge;
	}
    }

 #   &debug("$hostname:\n");
 #   if(defined($task)) {
#	&debug("\t" . $task->src . "\t" . $task->dst . "\n\n");
#    }

    # each machine should reduce the todo list the same way due to
    # alphabetic sorting of info from the ns file.
    # only thing left to do is return this machines' assignment for processing.
    return $task; # or undef if no jobs left for this machine.
}



# note, broken.
sub get_twoway_assign {

    my ($todo_ref) = @_; # must maintain sorted order invariant
    my $task = undef;
    my $other_task = undef;
    my @thisrun;

#    &debug("twoway assign:\n");
#    foreach my $edge (@{$todo_ref}) {
#	if(defined($edge)){
#	    &debug("\t" . $edge->src . "\t" . $edge->dst . "\n");
#	}
#    }

    # build a fresh hash to see which nodes are in use.
    my %inuse;
    foreach (@verts) {
	$inuse{$_}=0;
    }

    for(my $i=0;$i<@{$todo_ref};$i++) {
	my $edge = @{$todo_ref}[$i];
	if(defined($edge) && !($inuse{$edge->src} || $inuse {$edge->dst})) {
	    $inuse{$edge->src} = 1;
	    $inuse{$edge->dst} = 1;
	    push @thisrun, $edge;
	    @{$todo_ref}[$i]=undef;

	    # get the other side
	    for(my $j=$i;$j<@{$todo_ref};$j++) {
		my $otheredge = @{$todo_ref}[$j];
		if(defined($otheredge)
		   && $edge->src eq  $otheredge->dst
		   && $edge->dst eq $otheredge->src) {
		    push @thisrun,$otheredge;
		    @{$todo_ref}[$j] = undef;
		}
	    }
	    
	}
    }

#    &debug("thisrun:\n");
#    foreach my $edge (@thisrun) {
#	&debug("\t" . $edge->src . "\t" . $edge->dst . "\n");
#    }


    # figure out the tasks for this particular host.
    foreach my $edge (@thisrun) {
	if($hostname eq $edge->src || $hostname eq $edge->dst) {
	    $task = $edge;
	}
    }
    if(defined($task)) {
	foreach my $edge (@thisrun) {
	    if($task->dst eq $edge->src && $task->src eq $edge->dst) {
		$other_task = $edge;
	    }
	}
    }

#    &debug("$hostname:\n");
#    if(defined($task) && defined($other_task)) {
#	&debug("\t" . $task->src . "\t" . $task->dst . "\n" .
#	       "\t" . $other_task->src . "\t" . $other_task->dst . "\n\n");
#    }


    # each machine should reduce the todo list the same way due to
    # alphabetic sorting of info from the ns file.
    # only thing left to do is return this machines' assignment for processing.
    return ($task,$other_task); # or undef if no jobs left for this machine.


}

sub has_elems {
    my ($todo_ref) = @_;
    foreach (@{$todo_ref}) {
	if(defined($_)) {
	    return 1;
	}
    }
    return 0;
}


# PRE: stream test has been run and results are in CRUDE_DAT
# POST: reports errors if any to the log location.
# @param: the edge being analyzed
# @param: parameter to analyze.
#
#  due to accuracy problems with the one-way test on BSD, 
#  an alternate test is used on that platform.
#  $param==1 means loss and latency
#  $param==0 means just loss.
#
# note, runs on the dest.
sub analyze_stream {
    my ($edge, $param) = @_;
    my $Os ; # offset sender
    my $Or ; # offset receiver
    
    &debug("analyze stream\n");
    # decode the log.
    system "crude -d " . CRUDE_DAT . " > " . CRUDE_DEC;

    if($param) {
	# get clock offsets.
	# these don't work on vnodes.
	$Os = &get_offset($edge->src);
	$Os /= 1000; # convert to microseconds
	$Or = &get_offset($edge->dst);
	$Or /= 1000;
    }
    # scan the log. since it's just the mean, don't bother with a statistics
    # library, use an accumulator instead.
    my $count = 0;
    my $sum = 0;
    open FLOG,"" . CRUDE_DEC || die("could not open " . CRUDE_DEC);
    while(<FLOG>) {
	if(/Tx=(\d+\.\d+).*Rx=(\d+\.\d+)/) {
	    if($param) {
		my $Ts = $1;
		my $Tr = $2;
		
		my $owd = $Tr + $Or - ( $Ts + $Os);
		# convert to ms
		$owd *= 1000;
		
		# subtract transmit delay (queue and prop are 0)
		# L2 bit size of packets: 20 (UDP) 8 (IP) 18 (ETH) 20 (PAY) = 68B = 528b
		# need to think some more about this...
#	    my $Dt = (1 / ( $edge->bw * 1024/512 )) * 1000;
#	    $owd -=  $Dt;
		$sum += $owd;
	    }
	    $count++;
	}
    }
    close FLOG;
    if(!$count) {
	&error("no packets sent!");
	return;
    }
    if($param) {
	my $mean = ($sum / $count);
	&debug("mean latency: $mean\n");
	my $expected = $edge->delay * 1000; # units of ms

	# now the latency part using magic numbers.
	my $bestfit = $expected + (-0.10888 - 0.00236 * $expected );
	my $diff = abs($bestfit - $mean);
	if($diff>LAT_TOL) {
	    &error("Latency test outside of best fit line by: $diff\n");
	}
    }
    
    # loss part, always occurs.
    my $expected = &round(PACK_COUNT * $edge->loss);
    my $sd = sqrt( $expected * (1 - $edge->loss));
    my $actual = PACK_COUNT - $count;
    my $tol = &round((3 * $sd));
    &debug("loss: " . $edge->src . " to " . $edge->dst . " actual: $actual expected: $expected tolerance: $tol\n");
    if($actual > ($expected + $tol)
       || 
       $actual < ($expected - $tol)
       ) {
	&error("Loss test outside of acceptible loss ($count)\n");
    }

}

sub analyze_bw {
    my ($edge) = @_;
    my $lo = -1;
    my $hi = -1;

    open LOGF,"<" . PATHRATE_DAT || die "could not open: $!";
    while(<LOGF>) {
#	print $_;
	if (/^Final capacity estimate :\D+(\d+\.\d+|\d+)\D+(\d+\.\d+|\d+) Mbps/) {
	    $lo = $1;
	    $hi = $2;
	} elsif (/^Final capacity estimate :\D+(\d+\.\d+|\d+)\D+(\d+\.\d+|\d+) kbps/) {
	    $hi = $2 / 1000;
	    $lo = $1 / 1000;
	}
    }
    close LOGF;

    # note that margin of error is 3Mb with pathrate.
#    &debug($edge->bw . " lo $lo hi $hi\n");
    $lo -= 3; # units of mb
    $hi += 3;
    &debug("bandwidth: " . $edge->src . " to " . $edge->dst . " $lo Mb to $hi Mb\texpected: " . ($edge->bw / 1000000)
	   . " Mb\n" );
    if($edge->bw > ($hi * 1000000)
       || 
       $edge->bw < ($lo * 1000000)) {
	&error("Bandwidth test outside of acceptible range ($lo Mb  $hi Mb)");
    }

}

# get ntpq offset of the specified host
sub get_offset {
    my ($host) = @_;
    my @result;
    if($platform eq BSD) {
	@result = `ntpq -c rl $host | grep ^offset`;
    } else {
	@result = `/usr/sbin/ntpq -c rl $host | grep ^offset`;
    }
    if( $result[0] =~ /^offset=(-*\d+\.\d+)/) {
	return $1;
    }
    return 0;
}
sub round {
    my($number) = shift;
    return int($number + .5);
}

sub count_steps {
 
    my @edge_copy = @edges;
    my $count = 0;

    while(&has_elems(\@edge_copy)) {
	&get_assign(\@edge_copy);
	$count++;
    }   
    &debug("get_assign calls: $count\n");
    @edge_copy = @edges;
    $count = 0;

    while(&has_elems(\@edge_copy)) {
	&get_twoway_assign(\@edge_copy);
	$count++;
    }   
    &debug("get_twoway_assign calls: $count\n");
}

