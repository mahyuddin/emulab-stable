Index: configure
===================================================================
RCS file: /flux/CVS/emulab-rude/configure,v
retrieving revision 1.1.1.1
retrieving revision 1.2
diff -c -r1.1.1.1 -r1.2
*** configure	27 Jun 2006 17:50:14 -0000	1.1.1.1
--- configure	27 Jun 2006 18:26:14 -0000	1.2
***************
*** 2062,2068 ****
  ###################
  # Make it happen. #
  ###################
! CFLAGS="$CFLAGS -I../include"
  trap '' 1 2 15
  cat > confcache <<\EOF
  # This file is a shell script that caches the results of configure
--- 2062,2068 ----
  ###################
  # Make it happen. #
  ###################
! CFLAGS="$CFLAGS -I\$(srcdir)/../include -I../include"
  trap '' 1 2 15
  cat > confcache <<\EOF
  # This file is a shell script that caches the results of configure
Index: autoconf/configure.in
===================================================================
RCS file: /flux/CVS/emulab-rude/autoconf/configure.in,v
retrieving revision 1.1.1.1
retrieving revision 1.2
diff -c -r1.1.1.1 -r1.2
***************
*** 121,126 ****
  ###################
  # Make it happen. #
  ###################
! CFLAGS="$CFLAGS -I../include"
  AC_OUTPUT(Makefile:autoconf/Makefile.in rude/Makefile crude/Makefile, \
  	  echo timestamp > include/stamp.h)
--- 121,126 ----
  ###################
  # Make it happen. #
  ###################
! CFLAGS="$CFLAGS -I\$(srcdir)/../include -I../include"
  AC_OUTPUT(Makefile:autoconf/Makefile.in rude/Makefile crude/Makefile, \
  	  echo timestamp > include/stamp.h)
Index: crude/main.c
===================================================================
RCS file: /flux/CVS/emulab-rude/crude/main.c,v
retrieving revision 1.1.1.1
retrieving revision 1.2
diff -c -r1.1.1.1 -r1.2
*** crude/main.c	27 Jun 2006 17:50:15 -0000	1.1.1.1
--- crude/main.c	27 Jun 2006 18:22:10 -0000	1.2
***************
*** 294,302 ****
--- 294,306 ----
     */
    if((user_id == 0) && (priority > 0)){
      /* Try to lock the memory to avoid paging delays */
+ #ifdef HAVE_MUNLOCKALL
      if(mlockall(MCL_CURRENT | MCL_FUTURE) < 0){
        RUDEBUG1("crude: memory lock failed: %s\n", strerror(errno));
      }
+ #else
+     RUDEBUG1("crude: memory lock unsupported\n");
+ #endif
  
      /* Switch to Round-Robin-Real-Time Scheduling */
      p.sched_priority = priority;
***************
*** 346,353 ****
--- 350,359 ----
        RUDEBUG7("crude: program priority restored\n");
      }
  
+ #ifdef HAVE_MUNLOCKALL
      /* Release the locked memory */
      munlockall();
+ #endif
    }                                                                             
  
    if(ps_flag){ print_stats(); }
***************
*** 663,670 ****
  
      /* print average delay as sign and absolute value */
      if ( (sec < 0) || (usec < 0) ) {
!       sec  = llabs( sec );
!       usec = llabs( usec );
        printf("Delay: average = -%lld.%06llu   ", sec, usec);
      } else {
        printf("Delay: average = %lld.%06llu   ", sec, usec);
--- 669,676 ----
  
      /* print average delay as sign and absolute value */
      if ( (sec < 0) || (usec < 0) ) {
!       if (sec < 0) sec *= -1;
!       if (usec < 0) usec *= -1;
        printf("Delay: average = -%lld.%06llu   ", sec, usec);
      } else {
        printf("Delay: average = %lld.%06llu   ", sec, usec);
Index: include/rude.h
===================================================================
RCS file: /flux/CVS/emulab-rude/include/rude.h,v
retrieving revision 1.1.1.1
retrieving revision 1.2
diff -c -r1.1.1.1 -r1.2
*** include/rude.h	27 Jun 2006 17:50:15 -0000	1.1.1.1
--- include/rude.h	27 Jun 2006 18:22:18 -0000	1.2
***************
*** 24,29 ****
--- 24,30 ----
  #ifndef _RUDE_H
  #define _RUDE_H
  
+ #include <sys/types.h>
  #include <netinet/in.h>  /* for struct sockaddr_in */
  #include <sys/time.h>    /* for struct timeval     */
  
Index: rude/flow_txmit.c
===================================================================
RCS file: /flux/CVS/emulab-rude/rude/flow_txmit.c,v
retrieving revision 1.1.1.1
retrieving revision 1.3
diff -c -r1.1.1.1 -r1.3
*** rude/flow_txmit.c	27 Jun 2006 17:50:14 -0000	1.1.1.1
--- rude/flow_txmit.c	27 Jun 2006 18:28:48 -0000	1.3
***************
*** 43,58 ****
  extern struct udp_data *data;
  extern char            *buffer;
  
  
  /*
!  * wait_for_xmit(): Wait for certain period of time in busy-loop
   */
  __inline__ void wait_for_xmit(struct timeval *target, struct timeval *now)
  {
    while(1){
-     gettimeofday(now,NULL);
      if(timercmp(now,target,<)){
!       /* FIXME: check if the timegap is large => use [u | nano]sleep() */
        continue;
      }
      return;
--- 43,117 ----
  extern struct udp_data *data;
  extern char            *buffer;
  
+ static int usecpertick = 0;
  
  /*
!  * init_wait(): set the resolution of the clock.
!  * We use this in wait_for_xmit(), if the desired sleep time is at least
!  * twice the clock resolution, we sleep rather than spin.
!  * XXX this could be determined dynamically.
!  */
! void wait_init(int tickspersec)
! {
!   if (tickspersec < 1000000)
!     usecpertick = 1000000 / tickspersec;
! }
! 
! #ifdef WAITSTATS
! static unsigned int calls;
! static unsigned int toolong;
! static unsigned long long toolongby;
! #endif
! 
! void wait_finish(void)
! {
! #ifdef WAITSTATS
!   printf("%d calls, %d slept too long (by %dusec ave)\n",
! 	 calls, toolong, toolongby/toolong);
! #endif
! }
! 
! /*
!  * wait_for_xmit(): Wait for certain period of time
   */
  __inline__ void wait_for_xmit(struct timeval *target, struct timeval *now)
  {
+   gettimeofday(now,NULL);
+   if (usecpertick) {
+     struct timeval dtv;
+     int usec;
+ 
+     timersub(target,now,&dtv);
+     usec = dtv.tv_sec * 1000000 + dtv.tv_usec;
+     if (usec >= usecpertick*2) {
+       int res = usec % usecpertick;
+ 
+       /* empirical voodoo */
+       if (res == 0) res = 1;
+ 
+       usec -= res;
+       dtv.tv_sec = usec / 1000000;
+       dtv.tv_usec = usec % 1000000;
+       select(0,NULL,NULL,NULL,&dtv);
+       gettimeofday(now,NULL);
+ 
+ #ifdef WAITSTATS
+       /* XXX fernow stats */
+       calls++;
+       if (timercmp(now,target,>)) {
+         toolong++;
+         timersub(now,target,&dtv);
+         usec = dtv.tv_sec * 1000000 + dtv.tv_usec;
+         toolongby += usec;
+         return;
+       }
+ #endif
+     }
+   }
+ 
    while(1){
      if(timercmp(now,target,<)){
!       gettimeofday(now,NULL);
        continue;
      }
      return;
***************
*** 78,83 ****
--- 137,146 ----
    data->sequence_number = htonl(flow->sequence_nmbr);
    wait_for_xmit(&flow->next_tx, &now);
  
+   /* Emulab hack: this can happen for a final zero transmission */
+   if (p->rate == 0)
+     return;
+ 
    /* ...and fill in the rest of the data */
    data->tx_time_seconds  = htonl(now.tv_sec);
    data->tx_time_useconds = htonl(now.tv_usec);
Index: rude/main.c
===================================================================
RCS file: /flux/CVS/emulab-rude/rude/main.c,v
retrieving revision 1.1.1.1
retrieving revision 1.2
diff -c -r1.1.1.1 -r1.2
*** rude/main.c	27 Jun 2006 17:50:14 -0000	1.1.1.1
--- rude/main.c	27 Jun 2006 18:22:23 -0000	1.2
***************
*** 95,101 ****
      exit(1);
    }
  
!   while(((opt_ret=getopt(argc,argv,"s:P:hv")) != EOF) && (retval == 0)){
      switch(opt_ret){
      case 'v':
        if((optind == 2) && (argc == 2)){
--- 95,101 ----
      exit(1);
    }
  
!   while(((opt_ret=getopt(argc,argv,"s:P:hvC:")) != EOF) && (retval == 0)){
      switch(opt_ret){
      case 'v':
        if((optind == 2) && (argc == 2)){
***************
*** 147,152 ****
--- 147,156 ----
        }
        break;
  
+     case 'C':
+       wait_init(atoi(optarg));
+       break;
+ 
      default:
        usage(argv[0]);
        retval = -2;
***************
*** 204,212 ****
--- 208,220 ----
     */
    if((user_id == 0) && (priority > 0)){
      /* Try to lock the memory to avoid paging delays */
+ #ifdef HAVE_MUNLOCKALL
      if(mlockall(MCL_CURRENT | MCL_FUTURE) < 0){
        RUDEBUG1("rude: memory lock failed: %s\n", strerror(errno));
      }
+ #else
+     RUDEBUG1("rude: memory lock unsupported\n");
+ #endif
  
      /* Switch to Round-Robin-Real-Time Scheduling */
      p.sched_priority = priority;
***************
*** 242,249 ****
--- 250,259 ----
        RUDEBUG7("rude: program priority restored\n");
      }
  
+ #ifdef HAVE_MUNLOCKALL
      /* Release the locked memory */
      munlockall();
+ #endif
    }
  
   rude_exit1:
***************
*** 275,281 ****
--- 285,293 ----
      }
    }
  
+ #ifdef HAVE_MUNLOCKALL
    munlockall();
+ #endif
    clean_up();
    exit(ret_val);
  } /* main() */
***************
*** 414,419 ****
--- 426,432 ----
      }
      flow = flow->next;
    }
+   wait_finish();
    return;
  } /* print_results() */
  
Index: rude/parse.c
===================================================================
RCS file: /flux/CVS/emulab-rude/rude/parse.c,v
retrieving revision 1.1.1.1
retrieving revision 1.2
diff -c -r1.1.1.1 -r1.2
*** rude/parse.c	27 Jun 2006 17:50:14 -0000	1.1.1.1
--- rude/parse.c	27 Jun 2006 18:28:48 -0000	1.2
***************
*** 688,694 ****
--- 688,696 ----
        /* NEW in 0.50: Enable flow "stop" - ZERO transmission rate... */
        if(temp->params.cbr.rate == 0){
  	temp->next_tx = temp->flow_stop;
+ 	/* Emulab hack: make final zero transmission actually happen
  	temp->next_tx.tv_sec++;
+ 	*/
        }
        break;
      case(TRACE):
