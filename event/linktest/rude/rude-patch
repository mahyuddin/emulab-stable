diff -cr rude.orig/autoconf/configure.in rude/autoconf/configure.in
*** rude.orig/autoconf/configure.in	Thu Jun 13 06:15:20 2002
--- rude/autoconf/configure.in	Wed Apr 12 12:31:38 2006
***************
*** 121,126 ****
  ###################
  # Make it happen. #
  ###################
! CFLAGS="$CFLAGS -I../include"
  AC_OUTPUT(Makefile:autoconf/Makefile.in rude/Makefile crude/Makefile, \
  	  echo timestamp > include/stamp.h)
--- 121,126 ----
  ###################
  # Make it happen. #
  ###################
! CFLAGS="$CFLAGS -I\$(srcdir)/../include -I../include"
  AC_OUTPUT(Makefile:autoconf/Makefile.in rude/Makefile crude/Makefile, \
  	  echo timestamp > include/stamp.h)
diff -cr rude.orig/configure rude/configure
*** rude.orig/configure	Thu Jun 27 03:44:09 2002
--- rude/configure	Wed Apr 12 12:31:46 2006
***************
*** 2062,2068 ****
  ###################
  # Make it happen. #
  ###################
! CFLAGS="$CFLAGS -I../include"
  trap '' 1 2 15
  cat > confcache <<\EOF
  # This file is a shell script that caches the results of configure
--- 2062,2068 ----
  ###################
  # Make it happen. #
  ###################
! CFLAGS="$CFLAGS -I\$(srcdir)/../include -I../include"
  trap '' 1 2 15
  cat > confcache <<\EOF
  # This file is a shell script that caches the results of configure
diff -cr rude.orig/crude/main.c rude/crude/main.c
*** rude.orig/crude/main.c	Thu Jun 13 06:15:21 2002
--- rude/crude/main.c	Wed Apr 12 11:44:29 2006
***************
*** 294,302 ****
--- 294,306 ----
     */
    if((user_id == 0) && (priority > 0)){
      /* Try to lock the memory to avoid paging delays */
+ #ifdef HAVE_MUNLOCKALL
      if(mlockall(MCL_CURRENT | MCL_FUTURE) < 0){
        RUDEBUG1("crude: memory lock failed: %s\n", strerror(errno));
      }
+ #else
+     RUDEBUG1("crude: memory lock unsupported\n");
+ #endif
  
      /* Switch to Round-Robin-Real-Time Scheduling */
      p.sched_priority = priority;
***************
*** 346,353 ****
--- 350,359 ----
        RUDEBUG7("crude: program priority restored\n");
      }
  
+ #ifdef HAVE_MUNLOCKALL
      /* Release the locked memory */
      munlockall();
+ #endif
    }                                                                             
  
    if(ps_flag){ print_stats(); }
***************
*** 663,670 ****
  
      /* print average delay as sign and absolute value */
      if ( (sec < 0) || (usec < 0) ) {
!       sec  = llabs( sec );
!       usec = llabs( usec );
        printf("Delay: average = -%lld.%06llu   ", sec, usec);
      } else {
        printf("Delay: average = %lld.%06llu   ", sec, usec);
--- 669,676 ----
  
      /* print average delay as sign and absolute value */
      if ( (sec < 0) || (usec < 0) ) {
!       if (sec < 0) sec *= -1;
!       if (usec < 0) usec *= -1;
        printf("Delay: average = -%lld.%06llu   ", sec, usec);
      } else {
        printf("Delay: average = %lld.%06llu   ", sec, usec);
diff -cr rude.orig/include/rude.h rude/include/rude.h
*** rude.orig/include/rude.h	Mon Sep  2 08:28:01 2002
--- rude/include/rude.h	Wed Apr 12 10:03:36 2006
***************
*** 24,29 ****
--- 24,30 ----
  #ifndef _RUDE_H
  #define _RUDE_H
  
+ #include <sys/types.h>
  #include <netinet/in.h>  /* for struct sockaddr_in */
  #include <sys/time.h>    /* for struct timeval     */
  
diff -cr rude.orig/rude/flow_txmit.c rude/rude/flow_txmit.c
*** rude.orig/rude/flow_txmit.c	Thu Jun 13 06:15:21 2002
--- rude/rude/flow_txmit.c	Wed Apr 12 11:53:03 2006
***************
*** 43,58 ****
  extern struct udp_data *data;
  extern char            *buffer;
  
  
  /*
!  * wait_for_xmit(): Wait for certain period of time in busy-loop
   */
  __inline__ void wait_for_xmit(struct timeval *target, struct timeval *now)
  {
    while(1){
-     gettimeofday(now,NULL);
      if(timercmp(now,target,<)){
!       /* FIXME: check if the timegap is large => use [u | nano]sleep() */
        continue;
      }
      return;
--- 43,117 ----
  extern struct udp_data *data;
  extern char            *buffer;
  
+ static int usecpertick = 0;
  
  /*
!  * init_wait(): set the resolution of the clock.
!  * We use this in wait_for_xmit(), if the desired sleep time is at least
!  * twice the clock resolution, we sleep rather than spin.
!  * XXX this could be determined dynamically.
!  */
! void wait_init(int tickspersec)
! {
!   if (tickspersec < 1000000)
!     usecpertick = 1000000 / tickspersec;
! }
! 
! #ifdef WAITSTATS
! static unsigned int calls;
! static unsigned int toolong;
! static unsigned long long toolongby;
! #endif
! 
! void wait_finish(void)
! {
! #ifdef WAITSTATS
!   printf("%d calls, %d slept too long (by %dusec ave)\n",
! 	 calls, toolong, toolongby/toolong);
! #endif
! }
! 
! /*
!  * wait_for_xmit(): Wait for certain period of time
   */
  __inline__ void wait_for_xmit(struct timeval *target, struct timeval *now)
  {
+   gettimeofday(now,NULL);
+   if (usecpertick) {
+     struct timeval dtv;
+     int usec;
+ 
+     timersub(target,now,&dtv);
+     usec = dtv.tv_sec * 1000000 + dtv.tv_usec;
+     if (usec >= usecpertick*2) {
+       int res = usec % usecpertick;
+ 
+       /* empirical voodoo */
+       if (res == 0) res = 1;
+ 
+       usec -= res;
+       dtv.tv_sec = usec / 1000000;
+       dtv.tv_usec = usec % 1000000;
+       select(0,NULL,NULL,NULL,&dtv);
+       gettimeofday(now,NULL);
+ 
+ #ifdef WAITSTATS
+       /* XXX fernow stats */
+       calls++;
+       if (timercmp(now,target,>)) {
+         toolong++;
+         timersub(now,target,&dtv);
+         usec = dtv.tv_sec * 1000000 + dtv.tv_usec;
+         toolongby += usec;
+         return;
+       }
+ #endif
+     }
+   }
+ 
    while(1){
      if(timercmp(now,target,<)){
!       gettimeofday(now,NULL);
        continue;
      }
      return;
diff -cr rude.orig/rude/main.c rude/rude/main.c
*** rude.orig/rude/main.c	Thu Jun 13 06:15:21 2002
--- rude/rude/main.c	Wed Apr 12 11:37:37 2006
***************
*** 95,101 ****
      exit(1);
    }
  
!   while(((opt_ret=getopt(argc,argv,"s:P:hv")) != EOF) && (retval == 0)){
      switch(opt_ret){
      case 'v':
        if((optind == 2) && (argc == 2)){
--- 95,101 ----
      exit(1);
    }
  
!   while(((opt_ret=getopt(argc,argv,"s:P:hvC:")) != EOF) && (retval == 0)){
      switch(opt_ret){
      case 'v':
        if((optind == 2) && (argc == 2)){
***************
*** 147,152 ****
--- 147,156 ----
        }
        break;
  
+     case 'C':
+       wait_init(atoi(optarg));
+       break;
+ 
      default:
        usage(argv[0]);
        retval = -2;
***************
*** 204,212 ****
--- 208,220 ----
     */
    if((user_id == 0) && (priority > 0)){
      /* Try to lock the memory to avoid paging delays */
+ #ifdef HAVE_MUNLOCKALL
      if(mlockall(MCL_CURRENT | MCL_FUTURE) < 0){
        RUDEBUG1("rude: memory lock failed: %s\n", strerror(errno));
      }
+ #else
+     RUDEBUG1("rude: memory lock unsupported\n");
+ #endif
  
      /* Switch to Round-Robin-Real-Time Scheduling */
      p.sched_priority = priority;
***************
*** 242,249 ****
--- 250,259 ----
        RUDEBUG7("rude: program priority restored\n");
      }
  
+ #ifdef HAVE_MUNLOCKALL
      /* Release the locked memory */
      munlockall();
+ #endif
    }
  
   rude_exit1:
***************
*** 275,281 ****
--- 285,293 ----
      }
    }
  
+ #ifdef HAVE_MUNLOCKALL
    munlockall();
+ #endif
    clean_up();
    exit(ret_val);
  } /* main() */
***************
*** 414,419 ****
--- 426,432 ----
      }
      flow = flow->next;
    }
+   wait_finish();
    return;
  } /* print_results() */
  
