#!/usr/bin/perl -wT
#
# EMULAB-COPYRIGHT
# Copyright (c) 2000-2006 University of Utah and the Flux Group.
# All rights reserved.
#
use strict;
use Getopt::Std;
use English;
use POSIX;


#
# Wrapper for running the linktest daemon. This script is currently
# setup so it can run on either ops or from an experimental node.
#
sub usage()
{
    print "Usage: run_linktest.pl ".
	  "[-q] [-d level] [-t timeout] [-v] [-s server] [-p port] [-k keyfile] [-l level] [-o logfile] -e pid/eid\n".
	  "Use -q for quick termination mode, which skips the Bandwidth test\n".
          "Use -v for verbose feedback messages\n" .
	  "Use -t <time> to set a timeout in seconds\n";
	     
    exit(1);
}
my $optlist = "vqd:s:p:k:e:L:l:o:t:";
my $debug   = 0;
my $verbose = 0;
my $timeout = 0;
my $server;
my $keyfile;
my $port;
my $pid;
my $eid;
my $logfile;
my $child_pid;
my $startAt = 1; # default start level
my $stopAt = 4 ; # default stop level

# Local goo
my $TB          = "@prefix@";
my $TMCC	= "@CLIENT_BINDIR@/tmcc";
my $LTEVENT     = "@CLIENT_BINDIR@/ltevent";
my $LOGHOLE     = "$TB/bin/loghole";
my $LTEVENTOPS  = "$TB/libexec/ltevent";
my $STOPEVENT   = "STOP"; # XXX Left in here for backwards compat.
my $COMPLETEEVENT = "COMPLETE";
my $KILLEVENT   = "KILL";
my $REPORTEVENT   = "REPORT";

#
# This script should be run as a real person!
#
if (! $EUID) {
    die("*** $0:\n".
	"    This script should not be run as root!\n");
}

# un-taint path
$ENV{'PATH'} = '/bin:/usr/bin:/usr/local/bin';
delete @ENV{'IFS', 'CDPATH', 'ENV', 'BASH_ENV'};

$| = 1; #Turn off line buffering on output

#
# Make sure log files get created so project members can delete them!
#
umask(0002);

#
# Parse command arguments. Once we return from getopts, all that should be
# left are the required arguments.
#
my %options = ();
if (! getopts($optlist, \%options)) {
    print "error: cannot parse options\n";
    usage();
}
if (@ARGV) {
    print "error: extra arguments\n";
    usage();
}
if (defined($options{"d"})) {
    $debug = $options{"d"};
    if ($debug =~ /^([\w]+)$/) {
	$debug = $1;
    }
    else {
	die("*** $0:\n".
	    "    Bad data in debug: $debug\n");
    }
}
if (defined($options{"v"})) {
    $verbose = 1;
}
if (defined($options{"t"})) {
    $timeout = $options{"t"};
    if ($timeout =~ /^([\w]+)$/) {
	$timeout = $1;
    }
    else {
	die("*** $0:\n".
	    "    Bad data in timeout: $timeout\n");
    }
}
if (defined($options{"L"})) {
    $startAt = $options{"L"};
    if ($startAt =~ /^(\d)$/) {
	$startAt = $1;
    }
    else {
	die("*** $0:\n".
	    "    Bad data in start level: $startAt\n");
    }
}
if (defined($options{"l"})) {
    $stopAt = $options{"l"};
    if ($stopAt =~ /^(\d)$/) {
	$stopAt = $1;
    }
    else {
	die("*** $0:\n".
	    "    Bad data in level: $stopAt\n");
    }
}

if (defined($options{"q"})) {
    # ignore if via -l they are already in quick mode.
    if($stopAt > 3) { 
	$stopAt = 3; 
    }
}
if (defined($options{"s"})) {
    $server = $options{"s"};
    if ($server =~ /^([-\w\.]+)$/) {
	$server = $1;
    }
    else {
	die("*** $0:\n".
	    "    Bad data in server: $server\n");
    }
}
if (defined($options{"k"})) {
    $keyfile = $options{"k"};
    if ($keyfile =~ /^([-\w\.\/]+)$/) {
	$keyfile = $1;
    }
    else {
	die("*** $0:\n".
	    "    Bad data in keyfile: $keyfile\n");
    }
}
if (defined($options{"o"})) {
    $logfile = $options{"o"};
    if ($logfile =~ /^([-\w\.\/]+)$/) {
	$logfile = $1;
    }
    else {
	die("*** $0:\n".
	    "    Bad data in logfile: $logfile\n");
    }
}
if (defined($options{"p"})) {
    $port = $options{"p"};
    if ($port =~ /^(\d+)$/) {
	$port = $1;
    }
    else {
	die("*** $0:\n".
	    "    Bad data in port: $port\n");
    }
}
if (defined($options{"e"})) {
    ($pid,$eid) = split(/\//, $options{"e"});
}
else {
    usage();
}

#
# Untaint args.
#
if ($pid =~ /^([-\w]+)$/) {
    $pid = $1;
}
else {
    die("*** $0:\n".
	"    Bad data in pid: $pid\n");
}
if ($eid =~ /^([-\@\w]+)$/) {
    $eid = $1;
}
else {
    die("*** $0:\n".
	"    Bad data in eid: $eid\n");
}


#
# Default to the standard event server.
#
if (!defined($server)) {
    $server = "@EVENTSERVER@";
}

#
# These days, must use a keyfile!
#
if (!defined($keyfile)) {
    $keyfile = "/proj/$pid/exp/$eid/tbdata/eventkey";
}

my $linktest_path; # path to linktest data.
$linktest_path = "/proj/" . $pid . "/exp/" . $eid . "/tbdata/linktest";

# send the startup event.
my $args = starter();
# event arguments
$args .=  " -x START";
$args .= " STARTAT=$startAt STOPAT=$stopAt";
$args .= " DEBUG=$debug"
    if ($debug);

system($args);
if ($?) {
    die("*** $0:\n".
	"    Error running '$args'\n");
}

print "Starting linktest at " . &TBTimeStamp() . "\n";
print "Quick termination requested.\n"
    if (defined($options{"q"}));
print "Debug mode requested.\n"
    if ($debug);

sub handler($)
{
    my ($signame) = @_;

    $SIG{INT}  = 'IGNORE';
    $SIG{TERM} = 'IGNORE';
    $SIG{HUP}  = 'IGNORE';

    sleep(2);
    &kill_linktest_run;

    if (defined($child_pid)) {
	kill('TERM', $child_pid);
	waitpid($child_pid, 0);
	undef($child_pid);
    }

    if ($signame eq 'ALRM') {
	print "*** Linktest timer has expired, aborting the run.\n";
	&analyze(1);
    }
    else {
	print "*** Linktest has been aborted\n";
	&run_loghole;
    }
    exit(1);
}

#
# Now that linktest has started, wait for events to be reported
# by ltevent. It will print out the event followed by args,
# which are informational. The events sent are KILL, STOP, COMPLETE and REPORT.
#
$args = starter();
$args .= " -w";
if (($child_pid = fork())) {
    my $exitval;

    #
    # Install signal handlers to wait for a kill or a timeout.
    # If the process is killed, kill Linktest!
    #
    $SIG{INT}  = \&handler;
    $SIG{TERM} = \&handler;
    $SIG{HUP}  = \&handler;
    
    #
    # Set timeout behavior if requested.
    #
    if ($timeout) {
	$SIG{ALRM} = \&handler;
	alarm($timeout);
    }
    waitpid($child_pid, 0);
    $exitval = $?;
    alarm 0;
    if ($exitval) {
	&run_loghole;
	
	exit($exitval >> 8);
    }
    exit(&analyze(0));
}
else {
    my $ltpid;
    my $exitval = 0;

    #
    # Open child process to read in the output from ltevent,
    # and just print out the return values for feedback.
    #
    $SIG{TERM} = sub {
	if (defined($ltpid)) {
	    kill('TERM', $ltpid);
	    waitpid($ltpid, 0);
	    exit(0);
	}
    };

    $ltpid = open(LTC, "$args |");
    if (! $ltpid) {
	die("*** $0:\n".
	    "    Error running '$args'\n");
    }
    while(<LTC>) {
	chomp;
	if(/(\w+)\s?(.*)/) {
	    my $eventtype = $1;
	    my $eventargs = $2;
	    if (($eventtype eq $STOPEVENT) ||
		($eventtype eq $COMPLETEEVENT)) {
		print "Linktest completed at " . &TBTimeStamp() . "\n"
		    if($verbose);
		last;
	    }
	    elsif ($eventtype eq $KILLEVENT) {
		print("Linktest has been cancelled due to a timeout ".
		      "or unrecoverable error.\n");
		$exitval = 1;
		last;
	    } else {
		#
		# Print out report messages if in verbose mode.
		#
		print $eventargs . "\n"
		    if ($verbose);
	    }
	} else {
	    # parse error, exit.
	    print "error parsing: " . $_ . "\n";
	    $exitval = -1;
	    last;
	}
    }
    kill('TERM', $ltpid);
    close(LTC);
    exit($exitval);
}

#
# Spits out the results from the Linktest path,
# with a return code that indicates whether errors were found
# by Linktest on the nodes.
# 
sub analyze($) {
    my ($timedout) = @_;    
    
    my @dir_contents;
    opendir(DIR, $linktest_path) ||
	die("*** $0:\n".
	    "    Cannot open $linktest_path\n");
    @dir_contents = grep(/\.fatal$|\.error$/, readdir(DIR));
    closedir(DIR);

    unlink($logfile)
	if (defined($logfile));

    return 0
	if (! (scalar(@dir_contents) || $timedout));

    &run_loghole
	if (! $timedout);

    if (!defined($logfile)) {
	print "*************************************************************";
	print "****\n";
	print "***************** Linktest Error Reports ********************";
	print "****\n\n";
    }

    if ($timedout) && defined($logfile)) {
	my $msg = "Linktest timer expired, run was aborted\n".
	          "Gathering results generated before the timer expired\n".
		  "\n";

	system("echo '$msg' > $logfile");
    }

    foreach my $file (@dir_contents) {
	# Hmm, need to taint check the filenames. Ick.
	if ($file =~ /^([-\w\.\/]+)$/) {
	    $file = $1;
	}
	else {
	    die("*** $0:\n".
		"    Bad data in filename: $file\n");
	}
	if (defined($logfile)) {
	    open LOG_FILE, ">>$logfile" || 
		die "Could not open $logfile for append: $!";

	    open NODE_TRACE, "$linktest_path/$file" || 
		die "Could not open $file for read: $!";
	    while(<NODE_TRACE>) {
		print LOG_FILE $_;
	    }
	    close NODE_TRACE;
	    close LOG_FILE;
	} else {
	    system("/bin/cat $linktest_path/$file");
	}
    }
    if (!defined($logfile)) {
	print "*************************************************************";
	print "****\n";
    }
    return scalar(@dir_contents);
}

# Initial part of command string to ltevent.
sub starter {
    my $cmd;

    if (-x $LTEVENTOPS) {
	$cmd = $LTEVENTOPS;
    }
    else {
	$cmd = $LTEVENT;
    }
    $cmd .= " -s $server -e $pid/$eid";
    $cmd .= " -p $port"
	if (defined($port));
    $cmd .= " -k $keyfile"
	if (defined($keyfile));
    
    return $cmd
}

# Sub to kill off linktest on the nodes.
sub kill_linktest_run {
    my $args = starter();
    $args .= " -x $KILLEVENT";
    system($args);
    if ($?) {
	die("*** $0:\n".
	    "    Error running '$args'\n");
    }
}

sub run_loghole {
    my $ltlogs = "/proj/$pid/exp/$eid/tbdata/ltlogs";

    print "Downloading logs...\n";

    system("rm -rf $ltlogs");
    system("mkdir -p $ltlogs");
    system("chmod 775 $ltlogs");
    system("$LOGHOLE -e $pid/$eid sync -n -l $ltlogs -r /var/emulab/logs ".
	   "> $ltlogs/loghole.out 2>&1");
}

sub TBTimeStamp {
    return POSIX::strftime("%H:%M:%S", localtime());
}
