#!/usr/bin/perl -wT
#
# EMULAB-COPYRIGHT
# Copyright (c) 2000-2004 University of Utah and the Flux Group.
# All rights reserved.
#
use strict;
use Getopt::Std;
use English;
use POSIX;


#
# Wrapper for running the linktest daemon. This script is currently
# setup so it can run on either boss (or ops via plasticwrap), or from
# an experimental node. Hence the odd paths and ltevent aux program,
# which is not really on boss. Also not use of tmcc to find the server. 
#
sub usage()
{
    print "Usage: run_linktest.pl ".
	  "[-q] [-d] [-t] [-v] [-s server] [-p port] [-k keyfile] [-l level] [-o logfile] -e pid/eid\n".
	  "Use -q for quick termination mode, which skips the Bandwidth test\n".
          "Use -v for verbose feedback messages\n" .
	  "Use -t <time> to set a timeout in seconds\n";
	     
    exit(1);
}
my $optlist = "vqd:s:p:k:e:l:o:t:";
my $debug   = 0;
my $verbose = 0;
my $timeout = 0;
my $server;
my $keyfile;
my $port;
my $pid;
my $eid;
my $logfile;
my $child_pid;
my $startAt = 1; # default start level
my $stopAt = 4 ; # default stop level

# Local goo
my $TB          = "@prefix@";
my $TMCC	= "@CLIENT_BINDIR@/tmcc";
my $LTEVENT     = "@CLIENT_BINDIR@/ltevent";
my $LTEVENTBOSS = "$TB/libexec/ltevent";
my $BOSSNODE    = "@BOSSNODE@";
my $STOPEVENT   = "STOP";
my $KILLEVENT   = "KILL";
my $REPORTEVENT   = "REPORT";

#
# This script should be run as a real person!
#
if (! $EUID) {
    die("*** $0:\n".
	"    This script should not be run as root!\n");
}

# un-taint path
$ENV{'PATH'} = '/bin:/usr/bin:/usr/local/bin';
delete @ENV{'IFS', 'CDPATH', 'ENV', 'BASH_ENV'};

$| = 1; #Turn off line buffering on output

#
# Parse command arguments. Once we return from getopts, all that should be
# left are the required arguments.
#
my %options = ();
if (! getopts($optlist, \%options)) {
    usage();
}
if (@ARGV) {
    usage();
}
if (defined($options{"d"})) {
    $debug = $options{"d"};
    if ($debug =~ /^([\w]+)$/) {
	$debug = $1;
    }
    else {
	die("*** $0:\n".
	    "    Bad data in debug: $debug\n");
    }
}
if (defined($options{"v"})) {
    $verbose = 1;
}
if (defined($options{"t"})) {
    $timeout = $options{"t"};
    if ($timeout =~ /^([\w]+)$/) {
	$timeout = $1;
    }
    else {
	die("*** $0:\n".
	    "    Bad data in timeout: $timeout\n");
    }
}
if (defined($options{"l"})) {
    $stopAt = $options{"l"};
    if ($stopAt =~ /^(\d)$/) {
	$stopAt = $1;
    }
    else {
	die("*** $0:\n".
	    "    Bad data in level: $stopAt\n");
    }
}

if (defined($options{"q"})) {
    # ignore if via -l they are already in quick mode.
    if($stopAt > 3) { 
	$stopAt = 3; 
    }
}
if (defined($options{"s"})) {
    $server = $options{"s"};
    if ($server =~ /^([-\w\.]+)$/) {
	$server = $1;
    }
    else {
	die("*** $0:\n".
	    "    Bad data in server: $server\n");
    }
}
if (defined($options{"k"})) {
    $keyfile = $options{"k"};
    if ($keyfile =~ /^([-\w\.\/]+)$/) {
	$keyfile = $1;
    }
    else {
	die("*** $0:\n".
	    "    Bad data in keyfile: $keyfile\n");
    }
}
if (defined($options{"o"})) {
    $logfile = $options{"o"};
    if ($logfile =~ /^([-\w\.\/]+)$/) {
	$logfile = $1;
    }
    else {
	die("*** $0:\n".
	    "    Bad data in logfile: $logfile\n");
    }
}
if (defined($options{"p"})) {
    $port = $options{"p"};
    if ($port =~ /^(\d+)$/) {
	$port = $1;
    }
    else {
	die("*** $0:\n".
	    "    Bad data in port: $port\n");
    }
}
if (defined($options{"e"})) {
    ($pid,$eid) = split(/\//, $options{"e"});
}
else {
    usage();
}

#
# Untaint args.
#
if ($pid =~ /^([-\w]+)$/) {
    $pid = $1;
}
else {
    die("*** $0:\n".
	"    Bad data in pid: $pid\n");
}
if ($eid =~ /^([-\@\w]+)$/) {
    $eid = $1;
}
else {
    die("*** $0:\n".
	"    Bad data in eid: $eid\n");
}


#
# Need to figure out the elvind server. Since this script runs on boss
# and on experimental nodes, do something gross!
#
if (!defined($server)) {
    if (-x $TMCC) {
	my $results = `$TMCC bossinfo`;
	if ($results =~ /^([\w\.]*)\s/) {
	    $server = $1; 
	}
	else {
	    die("*** $0:\n".
		"    Bad data in server: $results\n");
	}
    }
    else {
	# We can do this on boss/ops, but not on experimental node.
	$server = $BOSSNODE;
    }
}

#
# These days, must use a keyfile!
#
if (!defined($keyfile)) {
    $keyfile = "/proj/$pid/exp/$eid/tbdata/eventkey";
}

my $linktest_path; # path to linktest data.
$linktest_path = "/proj/" . $pid . "/exp/" . $eid . "/tbdata/linktest";

# send the startup event.
my $args = starter();
# event arguments
$args .=  " -x START";
$args .= " STARTAT=$startAt STOPAT=$stopAt";
$args .= " DEBUG=$debug"
    if ($debug);

system($args);
if ($?) {
    die("*** $0:\n".
	"    Error running '$args'\n");
}

print "Linktest in progress...\n";
print "Quick termination requested.\n"
    if (defined($options{"q"}));
print "Debug mode requested.\n"
    if ($debug);

sub handler($)
{
    my ($signame) = @_;

    $SIG{INT}  = 'IGNORE';
    $SIG{TERM} = 'IGNORE';

    sleep(2);
    &kill_linktest_run;

    if (defined($child_pid)) {
	kill('TERM', $child_pid);
	waitpid($child_pid, 0);
	undef($child_pid);
    }

    if ($signame eq 'ALRM') {
	print "Linktest timer has expired, aborting the run.\n"
	    if ($verbose);
    }
    else {
	print "Linktest KILL event has been sent, aborting the run.\n"
	    if ($verbose);
    }
    exit(&analyze);
}

#
# Now that linktest has started, wait for events to be reported
# by ltevent. It will print out the event followed by args,
# which are informational. The events sent are KILL, STOP and REPORT.
#
$args = starter();
$args .= " -w";
if (($child_pid = fork())) {

    #
    # Install signal handlers to wait for a kill or a timeout.
    # If the process is killed, kill Linktest!
    #
    $SIG{INT}  = \&handler;
    $SIG{TERM} = \&handler;
    
    #
    # Set timeout behavior if requested.
    #
    if ($timeout) {
	$SIG{ALRM} = \&handler;
	alarm($timeout);
    }
    waitpid($child_pid, 0);
    alarm 0;
    exit(&analyze());
}
else {
    my $ltpid;

    #
    # Open child process to read in the output from ltevent,
    # and just print out the return values for feedback.
    #
    $SIG{TERM} = sub {
	if (defined($ltpid)) {
	    kill('TERM', $ltpid);
	    waitpid($ltpid, 0);
	    exit(0);
	}
    };
    
    $ltpid = open(LTC, "$args |");
    if (! $ltpid) {
	die("*** $0:\n".
	    "    Error running '$args'\n");
    }
    while(<LTC>) {
	chomp;
	if(/(\w+)\s(.*)/) {
	    my $eventtype = $1;
	    my $eventargs = $2;
	    if ($eventtype eq $STOPEVENT) {
		print "Linktest completed normally.\n"
		    if($verbose);
		last;
	    }
	    elsif ($eventtype eq $KILLEVENT) {
		print("Linktest has been cancelled due to a timeout ".
		      "or unrecoverable error.\n")
		    if ($verbose);
		last;
	    } else {
		#
		# Print out report messages if in verbose mode.
		#
		print lc($eventargs) . "\n"
		    if ($verbose);
	    }
	} else {
	    # parse error, exit.
	    print "error parsing: " . $_ . "\n";
	    last;
	}
    }
    kill('TERM', $ltpid);
    close(LTC);
    exit;
}

#
# Spits out the results from the Linktest path,
# with a return code that indicates whether errors were found
# by Linktest on the nodes.
# 
sub analyze {
    my @dir_contents;
    opendir(DIR, $linktest_path) ||
	die("*** $0:\n".
	    "    Cannot open $linktest_path\n");
    @dir_contents = grep(/\.fatal$|\.error$/, readdir(DIR));
    closedir(DIR);

    foreach my $file (@dir_contents) {
	# Hmm, need to taint check the filenames. Ick.
	if ($file =~ /^([-\w\.\/]+)$/) {
	    $file = $1;
	}
	else {
	    die("*** $0:\n".
		"    Bad data in filename: $file\n");
	}
	if(defined($options{"o"})) {
	    open LOG_FILE, ">>$logfile" || 
		die "Could not open $logfile for append: $!";

	    open NODE_TRACE, "$linktest_path/$file" || 
		die "Could not open $file for read: $!";
	    while(<NODE_TRACE>) {
		print LOG_FILE $_;
	    }
	    close NODE_TRACE;
	    close LOG_FILE;
	} else {
	    system("/bin/cat $linktest_path/$file");
	}
    }
    return scalar(@dir_contents);
}

# Initial part of command string to ltevent.
sub starter {
    my $cmd;

    if (-x $LTEVENTBOSS) {
	$cmd = $LTEVENTBOSS;
    }
    else {
	$cmd = $LTEVENT;
    }
    $cmd .= " -s $server -e $pid/$eid";
    $cmd .= " -p $port"
	if (defined($port));
    $cmd .= " -k $keyfile"
	if (defined($keyfile));
    
    return $cmd
}

# Sub to kill off linktest on the nodes.
sub kill_linktest_run {
    my $args = starter();
    $args .= " -x $KILLEVENT";
    system($args);
    if ($?) {
	die("*** $0:\n".
	    "    Error running '$args'\n");
    }
}
