#!/usr/bin/perl
package TestBed::XMLRPC::Client::Experiment;
use SemiModern::Perl;
use Mouse;
use Data::Dumper;
use TestBed::XMLRPC::Client::NodeInfo;

extends 'TestBed::XMLRPC::Client';

has 'pid' => ( isa => 'Str', is => 'rw', default => sub { $TBConfig::DEFAULT_PID; } );
has 'gid' => ( isa => 'Str', is => 'rw', default => sub { $TBConfig::DEFAULT_GID || $TBConfig::DEFAULT_PID; } );
has 'eid' => ( isa => 'Str', is => 'rw', default => \&gen_random_eid);

#autoloaded/autogenerated/method_missings/etc batchexp swapexp endexp waitforactive getlist expinfo metadata modify

my $EID_INCR = 0;
sub gen_random_eid {
  my $self = shift;
  $EID_INCR++;
  my $eid = "RANDEID$EID_INCR";
  $self->eid($eid);
}

sub args {
  my $self = shift;
  my $pid = $self->pid;
  my $gid = $self->gid;
  my $eid = $self->eid;
  
  return { 'pid' => $pid, 'gid' => $gid, 'eid' => $eid, @_ };
}

sub retry_on_TIMEOUT(&$) {
  my ($sub, $message) = @_;
RETRY: 
  { 
    my $result = eval { $sub->(); };
    if ($@ && $@ =~ /SSL_SOCKET_TIMEOUT/) {
      warn "SSL_SOCKET_TIMEOUT after $TBConfig::XMLRPC_SERVER_TIMEOUT seconds in $message";
      redo RETRY;
    }
    $result;
  }
}

sub noemail        { @TBConfig::EXPERIMENT_OPS_PARAMS; }
sub echo           { shift->augment_output( 'str' => shift ); }
sub getlist_brief  { shift->augment( 'format' => 'brief'); }
sub getlist_full   { shift->augment( 'format' => 'full' ); }
sub batchexp_ns    { shift->augment_code( 'nsfilestr' => shift, 'noswapin' =>1, noemail, @_ ); }
sub modify_ns      { shift->augment_code( 'nsfilestr' => shift, noemail, @_ ); }
sub swapin         { shift->augment_func_code( 'swapexp', noemail, 'direction' => 'in' ); }
sub swapout        { shift->augment_func_code( 'swapexp', noemail, 'direction' => 'out' ); }
sub end            { shift->augment_func_code( 'endexp', noemail); }
sub nodeinfo       { parseNodeInfo(shift->augment_func_output('expinfo', 'show' => 'nodeinfo')); }
sub waitforactive  { my $e = shift; retry_on_TIMEOUT { $e->augment_func_code('waitforactive', @_) } 'waitforactive'; }
sub waitforswapped { my $e = shift; retry_on_TIMEOUT { $e->augment_func_code( 'statewait', 'state' => 'swapped' ) } 'waitforswapped'; }

sub startexp_ns { batchexp_ns(@_, 'batch' => 0); }
sub startexp_ns_wait { batchexp_ns_wait(@_, 'batch' => 0); }

sub create_and_get_metadata {
  my $self = shift;
  $self->startexp_ns_wait(shift);
  $self->metadata;
}

sub batchexp_ns_wait { shift->batchexp_ns(@_,'wait' => 1); }

use constant EXPERIMENT_NAME_ALREADY_TAKEN => 2;
sub ensure_active_ns {
  my $self = shift;
  my $rc = $self->startexp_ns_wait(@_);
  if ($rc && $rc != EXPERIMENT_NAME_ALREADY_TAKEN) { return $rc }
  $self->swapin_wait;
}

sub swapin_wait { 
  my $self = shift;
  $self->augment_func_code( 'swapexp', 'direction' => 'in',  'wait' => 1, noemail );
  $self->waitforactive;
}

sub swapout_wait { 
  my $self = shift;
  $self->augment_func_code( 'swapexp', 'direction' => 'out',  'wait' => 1, noemail );
  $self->waitforswapped
}

sub inject_sub {
  my ($fqname, $sub) = @_;
  no strict 'refs';
  *{ $fqname } = $sub;
}

sub gen_expinfo_funcs {
  my ($package) = caller();
  for my $funcname (qw(mapping linkinfo shaping) ) {
    my $sub = sub {
      shift->augment_func_output('expinfo', 'show' => $funcname );
    };
    inject_sub($package . '::' . $funcname, $sub);
  }
}

gen_expinfo_funcs();

=head1 NAME

TestBed::XMLRPC::Client::Experiment

=over 4

=item C<< $e->pid >>

experiment pid

=item C<< $e->gid >>

experiment gid

=item C<< $e->eid >>

experiment eid

=item C<< $e->batchexp >>

calls batchexp xmlrpc function

=item C<< $e->swapexp >>

calls swapexp xmlrpc function

=item C<< $e->endexp >>

calls endexp xmlrpc function

=item C<< $e->waitforactive >>

calls waitforactive xmlrpc function

=item C<< $e->getlist >>

calls getlist xmlrpc function to get a list of experiments

=item C<< $e->expinfo >>

calls expinfo xmlrpc cfunction

=item C<args>

B<INTERNAL>: internal method for inserting pid, gid, and eid arguments into a xmlrpc call

=item C<< $e->echo($msg) >>

echos $msg through the emulab xmlrpc server

=item C<< $e->getlist_brief() >>

returns the 'format' => 'brief' experiement list

=item C<< $e->getlist_full() >>

returns the 'format' => 'full' experiement list

=item C<< $e->batchexp_ns($nsfile_contents, @args) >>

batches experiment defined in $nsfile_contents

=item C<< $e->swapin >>

swaps the experiment in

=item C<< $e->swapout >>

swaps the experiment out

=item C<< $e->end >>

ends the experiment

=item C<< $e->nodeinfo >>

returns a list of node names in the experiment

=item C<< $e->waitsforactive >>

waits for the experiment to enter the active state

=item C<< $e->waitforswapped >>

waits for the experiment to enter the swapped state

=item C<< $e->startexp_ns($nsfile_contents, @args) >>

start experiment defined in $nsfile_contents

=item C<< $e->startexp_ns_wait($nsfile_contents, @args) >>

start experiment defined in $nsfile_contents
waits for it to become active

=item C<< $e->batchexp_ns_wait($nsfile_contents, @args) >>

batches experiment defined in $nsfile_contents
waits for it to become active

=item C<< $e->swapin_wait >>

swaps the experiment in, waits for the experiment to enter the active state

=item C<< $e->swapout_wait >>

swaps the experiment out, waits for the experiment to enter the swapped state

=item C<< inject_sub($fqname, $sub) >>

B<INTERNAL>: injects anonymous sub $sub into $fqname package

=item C<< $e->mapping >>

returns experiment node mapping

=item C<< $e->linkinfo >>

returns experiment linkinfo

=item C<< $e->shaping >>

returns experiment link shaping

=item C<< $e->create_and_get_metadata($ns) >>

creates the experiment and returns the create metadata
i.e. min and max nodes, as well as a bunch of other stuff

=item C<< $e->ensure_active_ns($ns) >>

creates the experiment if it doesn't already exist and ensures that the experiement is swapped in

=item C<< $e->gen_random_eid >>

hook for generating a random $eid if desired

=item C<< $e->modify_ns($ns) >>

modifies the current experiment with the give $ns file

=item C<< $e->noemail >>

B<INTERNAL>: generates the noemail attribute for xmlrpc calls if so configured in TBConfig

=item C<< gen_expinfo_funcs >>

B<INTERNAL>: generates expinfo subs 

=item C<< retry_on_TIMEOUT(&sub, $messag) >>

B<INTERNAL>: catches socket timeout exceptions and rexecutes &sub after printing $message

=back 

=cut

1;
