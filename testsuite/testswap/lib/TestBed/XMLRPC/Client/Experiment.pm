#!/usr/bin/perl
package TestBed::XMLRPC::Client::Experiment;
use SemiModern::Perl;
use Mouse;
use Data::Dumper;
use TestBed::XMLRPC::Client::NodeInfo;

extends 'TestBed::XMLRPC::Client';

has 'pid' => ( isa => 'Str', is => 'rw');
has 'gid' => ( isa => 'Str', is => 'rw');
has 'eid' => ( isa => 'Str', is => 'rw');

#autoloaded/autogenerated/method_missings/etc batchexp swapexp endexp waitforactive getlist expinfo

sub args {
  my $self = shift;
  my $args = { 'pid' => $self->pid, 'eid' => $self->eid };
  my $gid = $self->gid;
  $args->{'gid'} = $gid if $gid;
  return { %$args, @_ };
}

sub echo           { shift->augment_output( 'str' => shift ); }
sub getlist_brief  { shift->augment( 'format' => 'brief'); }
sub getlist_full   { shift->augment( 'format' => 'full' ); }
sub batchexp_ns    { shift->augment( 'nsfilestr' => shift, @_ ); }
sub swapin         { shift->augment_func_code( 'swapexp', 'direction' => 'in' ); }
sub swapout        { shift->augment_func_code( 'swapexp', 'direction' => 'out' ); }
sub end            { shift->augment_func_code( 'endexp' ); }
sub nodeinfo       { parseNodeInfo(shift->augment_func_output('expinfo', 'show' => 'nodeinfo')); }
sub waitforactive  {
  my $self = shift;
  $self->augment_code(@_) && die sprintf("wait for swapin %s failed", $self->eid);
}
sub waitforswapped { 
  my $self = shift;
  $self->augment_func_code( 'statewait', 'state' => 'swapped' )
     && die sprintf("wait for swapin %s failed", $self->eid);
}

sub startexp_ns { batchexp_ns(@_, 'batch' => 0); }
sub startexp_ns_wait { batchexp_ns_wait(@_, 'batch' => 0); }

sub batchexp_ns_wait { 
  my $self = shift;
  $self->batchexp_ns(@_);
  $self->waitforactive;
}
sub swapin_wait { 
  my $self = shift;
  $self->augment_func_code( 'swapexp', 'direction' => 'in',  'wait' => 1 );
  $self->waitforactive;
}
sub swapout_wait { 
  my $self = shift;
  $self->augment_func_code( 'swapexp', 'direction' => 'out',  'wait' => 1 );
  $self->waitforswapped
}

sub inject_sub {
  my ($fqname, $sub) = @_;
  no strict 'refs';
  *{ $fqname } = $sub;
}

sub gen_expinfo_funcs {
  my ($package) = caller();
  for my $funcname (qw(mapping linkinfo shaping) ) {
    my $sub = sub {
      shift->augment_func_output('expinfo', 'show' => $funcname );
    };
    inject_sub($package . '::' . $funcname, $sub);
  }
}

gen_expinfo_funcs();

=head1 NAME

TestBed::XMLRPC::Client::Experiment

=over 4

=item C<pid>

experiment pid

=item C<eid>

experiment eid

=item C<batchexp>

calls batchexp xmlrpc function

=item C<swapexp>

calls swapexp xmlrpc function

=item C<endexp>

calls endexp xmlrpc function

=item C<waitforactive>

calls waitforactive xmlrpc function

=item C<getlist>

calls getlist xmlrpc function

=item C<expinfo>

calls expinfo xmlrpc cfunction

=item C<args>

B<INTERNAL>: internal method for inserting pid and eid arguments into a xmlrpc call

=item C<< $e->echo($msg) >>

echos $msg through the emulab xmlrpc server

=item C<< $e->getlist_brief() >>

returns the 'format' => 'brief' experiement list

=item C<< $e->getlist_full() >>

returns the 'format' => 'full' experiement list

=item C<< $e->batchexp_ns($nsfile_contents, @args) >>

batches experiment defined in $nsfile_contents

=item C<< $e->swapin >>

swaps the experiment in

=item C<< $e->swapout >>

swaps the experiment out

=item C<< $e->end >>

ends the experiment

=item C<< $e->nodeinfo >>

returns a list of node names in the experiment

=item C<< $e->waitsforactive >>

waits for the experiment to enter the active state

=item C<< $e->waitforswapped >>

waits for the experiment to enter the swapped state

=item C<< $e->startexp_ns($nsfile_contents, @args) >>

start experiment defined in $nsfile_contents

=item C<< $e->startexp_ns_wait($nsfile_contents, @args) >>

start experiment defined in $nsfile_contents
waits for it to become active

=item C<< $e->batchexp_ns_wait($nsfile_contents, @args) >>

batches experiment defined in $nsfile_contents
waits for it to become active

=item C<< $e->swapin_wait >>

swaps the experiment in, waits for the experiment to enter the active state

=item C<< $e->swapout_wait >>

swaps the experiment out, waits for the experiment to enter the swapped state

=item C<< inject_sub($fqname, $sub) >>

B<INTERNAL>: injects anonymous sub $sub into $fqname package

=item C<< $e->mapping >>

returns experiment node mapping

=item C<< $e->linkinfo >>

returns experiment linkinfo

=item C<< $e->shaping >>

returns experiment link shaping

=back 

=cut

1;
