#!/usr/bin/perl
use lib 'lib';
use SemiModern::Perl;
use TBConfig;
use TestBed::TestSuite;
use TestBed::XMLRPC::Client::Pretty;
use Data::Dumper;
use Tools;
use TestBed::Wrap::tevc;

#$TBConfig::DEBUG_XML_CLIENT = 1;

$SIG{ __DIE__ } = sub {
  use Carp qw(longmess);
  say "Caught here " . __FILE__;
  sayd(@_);
  say "SAYD DONE";
  Carp::confess( "DIED IN SC\n", @_ );
};

my $ns = <<'NSEND';
source tb_compat.tcl

set ns [new Simulator]

set node1 [$ns node]
set node2 [$ns node]

set lan1 [$ns make-lan "$node1 $node2" 100Mb 0ms]
set link1 [$ns duplex-link $node1 $node2 100Mb 50ms DropTail]
$ns run
NSEND

sub usage {
say <<'END'
ShortCut
./sc CMD EID ARGS

  CMD = start
        swapin
        swapout
        end
        endall
        watch
        watchall
        ping
        tevc
        linktest
        single_node_tests
        ni    // nodeinfo expinfo
        li    // linkinfo expinfo
        fqnn  // list fully qualified node names
        im    // $e->info(aspect => 'mapping'))
        ip    // $e->info(aspect => 'physical'))
        it    // $e->info(aspect => 'traces'))
        il    // $e->info(aspect => 'links'))
        ex    execute arbitrary perl code
END
}

sub end_all_experiments {
  e->pretty_list;
  say "";
  if (Tools::yn_prompt("Are you sure you want to terminate all experiments?")) {
    my @experiment_names = experiments_hash_to_list(e->getlist_full);
    e(@{$_->[0]})->end for(@experiment_names);
    e(@{$_->[0]})->waitforended for(@experiment_names);
  }
}

sub watch {
  my $e = shift;
  my $result = "INIT";
  my $eid = $e->eid;
  while ($result) {
    my $result = $e->state;
    say Tools::prettytimestamp . " Watch $eid = $result";
    sleep(2);
  }
}

sub watchall {
  while (1) {
    say Tools::prettytimestamp;
    e->pretty_list;
    sleep(5);
  }
}

eval {
if (@ARGV) {
  $_ = shift;
  if (/endall/) { end_all_experiments; }
  elsif (/end/) { e($_)->end for(@ARGV); }
  elsif (/watchall/) { watchall; }
  else {
    my $e = e(shift);
    if (/--help/) { usage; } 
    elsif (/end/) { $e->end_wait; }
    elsif (/ping/ ) { $e->ping_test; }
    elsif (/swapin/) { $e->swapin_wait; }
    elsif (/swapout/) { $e->swapout_wait; }
    elsif (/start/) { $e->startexp_ns_wait($ns); }
    elsif (/tevc/) { $e->tevc(@ARGV); }
    elsif (/linktest/) { $e->linktest; }
    elsif (/single_node_tests/) { $e->single_node_tests; }
    elsif (/fqnn/) { say Dumper($e->fqnodenames) ;}
    elsif (/ni/) { say Dumper($e->nodeinfo) ;}
    elsif (/li/) { say Dumper($e->linkinfo) ;}
    elsif (/im/) { say Dumper($e->info(aspect => 'mapping')) ;}
    elsif (/ip/) { say Dumper($e->info(aspect => 'physical')) ;}
    elsif (/it/) { say Dumper($e->info(aspect => 'traces')) ;}
    elsif (/il/) { say Dumper($e->info(aspect => 'links')) ;}
    elsif ($_ eq 'syncs') { prun( map { my $n = $_; sub { $e->node('node1')->ssh->cmdoutput('/usr/testbed/bin/emulab-sync'); } } (1..shift)); }
    elsif (/watch/) { watch($e); }
    elsif ($_ eq'ex') { 
      say $ARGV[0];
      my $result = eval $ARGV[0];
      say $@ if $@;
      sayd($result);
    }
    else {
      my $cmdstring = "sayd(\$e->$_);"; 
      say $cmdstring;
      eval $cmdstring;
    }
  }
}
else {
  usage;
  e->pretty_list;
}
};
if ($@) {
  sayd($@);
}

# vim: ft=perl:
