#! /usr/bin/env python
#
# EMULAB-COPYRIGHT
# Copyright (c) 2005, 2006 University of Utah and the Flux Group.
# All rights reserved.
# 
# Permission to use, copy, modify and distribute this software is hereby
# granted provided that (1) source code retains these copyright, permission,
# and disclaimer notices, and (2) redistributions including binaries
# reproduce the notices in supporting documentation.
#
# THE UNIVERSITY OF UTAH ALLOWS FREE USE OF THIS SOFTWARE IN ITS "AS IS"
# CONDITION.  THE UNIVERSITY OF UTAH DISCLAIMS ANY LIABILITY OF ANY KIND
# FOR ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.
#
import sys
import getopt
import os, os.path

TBROOT = "@prefix@"
DOMAIN = "@OURDOMAIN@"
TBPATH = os.path.join(TBROOT, "lib")

if TBPATH not in sys.path:
    sys.path.append(TBPATH)
    pass

# We get this from the testbed library directory.
import xmpp

# Debugging output.
debug           = False
verbose         = False

# Error condition.
server_error    = 0
exitval         = 0

# The default admin user to connect as is tbops.
admin_user      = "testbed-ops"
admin_password  = "WeLovChat"
admin_resource  = "TestbedOps"
admin_jid       = ""

# Default server to jabber server
jabber_server   = "jabber." + DOMAIN
muc_server      = "conference." + DOMAIN

# The room we are operating on.
chatroom        = False
chatroom_jid    = "";

# Current ID we are looking for, and the one we have.
current_id      = False;
desired_id      = False;

# Stuff to hand to the muc server.
chatroom_fields = {
    "muc#owner_roomname"                : "",
    "muc#owner_roomdesc"                : "",
    "muc#owner_publicroom"              : "0",
    "muc#owner_persistentroom"          : "1",
    "privacy"                           : "1",
    "muc#owner_maxusers"                : "50",
    "muc#owner_moderatedroom"           : "0",
    "defaulttype"                       : "0",
    "privmsg"                           : "0",
    "muc#owner_inviteonly"              : "1",
    "muc#owner_allowinvites"            : "1",
    "legacy"                            : "0",
    "muc#owner_passwordprotectedroom"   : "1",
    "muc#owner_roomsecret"              : "foobar",
    "muc#owner_enablelogging"           : "0",
    "muc#owner_whois"                   : "anyone"
    }

##
# Print the usage statement to stdout.
#
def usage():
    print ("Usage: " + sys.argv[0] 
           + " [-d] [-s server] <room> <op> [params]")
    sys.exit(-1)

#
# Process program arguments.
# 
try:
    # Parse the options,
    opts, req_args =  getopt.getopt(sys.argv[1:],
                      "dhs:",
                      [ "help", "server="])
    # ... act on them appropriately, and
    for opt, val in opts:
        if opt in ("-h", "--help"):
            usage()
            pass
        elif opt in ("-s", "--server"):
	    jabber_server = val
            pass
        elif opt in ("-d", "--debug"):
	    debug = True
            pass
        pass
    pass
except getopt.error, e:
    print e.args[0]
    usage()
    sys.exit(2)
    pass

if len(req_args) < 2:
    usage()
    sys.exit(2)
    pass

# First argument is the room jid.
chatroom = req_args[0]
req_args = req_args[1:];

# We need these a lot.
chatroom_jid = chatroom + "@" + muc_server + "/" + admin_resource;
admin_jid    = admin_user + "@" + jabber_server + "/" + admin_resource

#
# These handlers are required by the xmpp library.
#
def HandlePresence(session, presence):
    global current_id, server_error

    if verbose:
        print str(presence)
        pass
    
    current_id = presence.getID()
    if presence.getType() == 'error':
        errmsg        = presence.getError()
        server_error  = presence.getErrorCode()
        raise xmpp.protocol.NodeProcessed
    pass

# This is for doing the RoomExists test below.
def HandleMessage(session, message):
    global current_id, server_error

    if verbose:
        print str(message)
        pass
    
    current_id = message.getID()
    if message.getType() == 'error':
        errmsg        = message.getError()
        server_error  = message.getErrorCode()
        raise xmpp.protocol.NodeProcessed
    pass

def HandleIQ(conn, iq_node):
    global current_id, desired_id
    
    if verbose:
        print str(iq_node)
        pass
    
    current_id = iq_node.getID()
    if current_id == desired_id:
        raise xmpp.protocol.NodeProcessed
    pass

def HandleIQ_Error(conn, iq_node):
    global current_id, server_error

    if verbose:
        print str(iq_node)
        pass
    
    errmsg       = iq_node.getError()
    current_id   = iq_node.getID()
    server_error = 1
    raise xmpp.protocol.NodeProcessed
    pass

#
# Try and connect.
#
def Connect():
    jid = xmpp.protocol.JID(admin_jid)
    dbg = []
    if debug:
        dbg = ['always',]
        pass
    
    cl  = xmpp.Client(jid.getDomain(), debug=dbg)
    cl.connect()
    cl.auth(jid.getNode(), admin_password, resource=admin_resource)
    cl.sendInitPresence(requestRoster=0)
    cl.Process(timeout=2)

    cl.RegisterHandler('presence', HandlePresence)
    cl.RegisterHandler('message', HandleMessage)
    cl.RegisterHandler('iq', HandleIQ, 'result')
    cl.RegisterHandler('iq', HandleIQ_Error, 'error')

    return cl

#
# Wait for response. Generic 10 second timeout, or if error. 
#
def SendAndWait(client, x):
    global current_id, desired_id, server_error

    server_error  = 0
    current_id    = False
    desired_id    = x.getID()
    
    # Send it and wait.
    client.send(x)
    waitcount = 10
    while (waitcount >= 0):
        client.Process(timeout=1)
        if current_id == desired_id:
            if server_error != 0:
                return -1
            return 0
        waitcount = waitcount - 1
        pass
    
    if waitcount < 0:
        print "Timed out talking to server";
        sys.exit(1);
        pass

    pass

#
# See if a room already exists.
# 
def RoomExists(client):
    global server_error
    
    #
    # Send a message to the room. If the room does not exist, we get
    # back an error 400. If the room does exists, we get back an error
    # 405 since we are not in the room, and thus are not allowed to send
    # messages to the room. Reverse engineering ... 
    #
    p = xmpp.Message(to = chatroom + "@" + muc_server);
    
    # Add an id, to look for.
    p.setID("exists")

    # Wait for response
    SendAndWait(client, p);

    # We should always get an error back
    if server_error == 0:
        print "RoomExists: Protocol error; no error returned.";
        sys.exit(1);
        pass

    if server_error == "400":
        return False
    elif server_error == "405":
        return True

    print "RoomExists: Protocol error; error " + server_error + " returned.";
    sys.exit(1);
    pass

#
# Create/Delete a romm
#
def DoChatRoom(client, args):
    global chatroom, admin_jid
    
    op = args[0]

    exists = RoomExists(client);
    
    #
    # Destroy the room.
    #
    if (op == "destroy"):
        if exists == False:
            print "Presence: Chatroom " + chatroom + " does not exist."
            return 0

        # Must enter the room to destroy it. How dumb is that!
        p = xmpp.Presence(to = chatroom_jid);
        p.setTag(xmpp.NS_MUC + ' x')
        p.setID("enter");
    
        if SendAndWait(client, p) < 0:
            print "Presence: Chatroom " + chatroom + " could not be entered"
            return -1
        
        client.Process(timeout=2)
        
        # Now send the magic destroy message.
        iq = xmpp.Iq(typ = 'set', queryNS = xmpp.protocol.NS_MUC_OWNER,
                     frm = admin_jid, to = chatroom + "@" + muc_server)

        # Add a destroy element to the query element. It is empty.
        item = iq.getTag('query').setTag('destroy')

        # Add an id, to look for.
        iq.setID("begone")

        # Send it and wait. Server either did it or failed.
        return SendAndWait(client, iq)
    
    if exists == True:
        print "Presence: Chatroom " + chatroom + " already exists."
        return 0
        
    #
    # Otherwise creating a room. Must have a password.
    #
    if len(args) != 3:
        usage()
        sys.exit(2)
        pass
    
    password = args[1]
    leader   = args[2]
    
    # Announce presence, which creates room.
    p = xmpp.Presence(to = chatroom_jid)
    p.setTag(xmpp.NS_MUC + ' x')
    p.setID("create");
    
    if SendAndWait(client, p) < 0:
        print "Presence: Chatroom " + chatroom + " could not be created."
        return -1

    #
    # This unlocks the room.
    #
    iq = xmpp.Iq(typ = 'set', queryNS = xmpp.protocol.NS_MUC_OWNER,
                 to = chatroom + "@" + muc_server)
    iq.setID("unlock")
    query = iq.getTag('query')
    query.setTag(xmpp.protocol.NS_DATA + ' x', attrs = {'type': 'submit'})
    
    if SendAndWait(client, iq) < 0:
        print "Chatroom " + chatroom + " could not be unlocked."
        return -1
    
    #
    # Now request a configuration form. We are going to ignore it, but we
    # need to request it in order to send one in.
    #
    iq = xmpp.Iq(typ = 'get', queryNS = xmpp.protocol.NS_MUC_OWNER,
                 to = chatroom + "@" + muc_server)
    iq.setID("getform")
    
    if SendAndWait(client, iq) < 0:
        print "Chatroom " + chatroom + " did not send a form back."
        return -1
    
    # Set up the rest of the room parameters from arguments.
    chatroom_fields["muc#owner_roomname"]   = chatroom
    chatroom_fields["muc#owner_roomdesc"]   = "This is an Emulab Chat Room"
    chatroom_fields["muc#owner_roomsecret"] = password
    
    #
    # Now build up a form to send in.
    #
    iq = xmpp.Iq(typ = 'set', queryNS = xmpp.protocol.NS_MUC_OWNER,
                 to = chatroom + "@" + muc_server)
    iq.setID("config")
    query = iq.getTag('query')
    x = query.setTag(xmpp.protocol.NS_DATA + ' x', attrs = {'type': 'submit'})
    
    for key, val in chatroom_fields.items():
        tag = x.addChild('field')
        tag.setAttr('var', key)
        tag.setTagData('value', val)
        pass
    
    if SendAndWait(client, iq) < 0:
        print "Chatroom " + chatroom + " did not not properly configure."
        return -1
    
    client.Process(timeout=1)

    # Now set the admin for the room.
    return DoMemberShip(client, [leader, "admin"])

#
# Add/Remove members from a room
#
def DoMemberShip(client, args):
    iq = xmpp.Iq(typ = 'set', queryNS = xmpp.NS_MUC_ADMIN,
                 to  = chatroom + "@" + muc_server)

    if RoomExists(client) == False:
        print "DoMemberShip: Chatroom " + chatroom + " does not exist."
        return -1

    # Must enter the room to mess with the lists. How dumb is that!
    p = xmpp.Presence(to = chatroom_jid);
    p.setTag(xmpp.NS_MUC + ' x')
    p.setID("enter");
    
    if SendAndWait(client, p) < 0:
        print "Presence: Chatroom " + chatroom + " could not be entered"
        return -1
        
    op = args[0]
    jid_str = args[1] + "@" + jabber_server + "/" + args[1]

    jid  = xmpp.protocol.JID(jid_str)
    item = iq.getTag('query').setTag('item')
    
    item.setAttr('jid', jid)

    if op == "add":
        item.setAttr('affiliation', 'member')
        pass
    elif op == "owner":
        item.setAttr('affiliation', 'owner')
        pass
    elif op == "admin":
        item.setAttr('affiliation', 'admin')
        pass
    else:
        item.setAttr('affiliation', 'none')
        pass

    iq.setID("config")
    
    if SendAndWait(client, iq) < 0:
            print "MemberShip: Could not change affiliation."
            return -1
    pass

#
# We can create/delete rooms and add/remove members of rooms.
#
if (req_args[0] == "create" or req_args[0] == "destroy" or
    req_args[0] == "reconfig"):
    client = Connect();
    exitval = DoChatRoom(client, req_args)
    pass
elif (req_args[0] == "add" or req_args[0] == "remove"):
    client = Connect();
    exitval = DoMemberShip(client, req_args)
    pass
else:
    usage()
    sys.exit(2)
    pass

client.Process(timeout=1)
client.disconnect();
sys.exit(exitval)
