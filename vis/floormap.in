#!/usr/bin/perl -w
#
# EMULAB-COPYRIGHT
# Copyright (c) 2000-2004 University of Utah and the Flux Group.
# All rights reserved.
#
use English;
use Getopt::Std;
use File::Basename;

#
# TODO: Deal with multiple buildings? Currently defaults to MEB! 
# 
sub usage {
    print STDERR "Usage: floormap [-t] [-o <prefix>] [-f <floor>] [<building>]";
    print STDERR "\nor\n";
    print STDERR "Usage: floormap [-t] [-o <prefix>] [-f <floor>] ";
    print STDERR "[-e <pid,eid>] [<building>]\n";
    exit(-1);
}
my $optlist  = "df:o:e:ta";
my $debug    = 0;
my $notitles = 0;
my $showany  = 0;	# When showing specific floor, showany is turned on.
my $mereuser = 1;
my $building;
my $floor;
my $image;
my $pid;
my $eid;
my @areamaps   = ();
my %baseimages = ();
my $prefix = "/tmp/floormap";

#
# Configure variables
#
my $TB		= "@prefix@";
my $WWWPAGE     = "@TBBASE@/shownode.php3";
my $ICONDIR     = "$TB/www";

# Load libraries.
use lib '@prefix@/lib';
use libdb;
use GD;

# Admin people get extra info
$mereuser = 0
    if (!TBAdmin($UID));

#
# Gather image data from DB.
#
my $query_result =
    DBQueryFatal("select b.building,b.title,f.floor,f.image_path ".
		 "   from buildings as b ".
		 "left join floorimages as f on f.building=b.building");

if (!$query_result->numrows) {
    die("*** $0:\n".
	"    There is no building/floor data in the DB!\n");
}

while (my ($building,$title,$floor,$image) = $query_result->fetchrow_array()) {
    if (!exists($baseimages{$building})) {
	$baseimages{$building} = {};
	$baseimages{$building}->{"title"}  = $title;
	$baseimages{$building}->{"floors"} = {};
    }
    $image = "$TB/www/$image"
	if (dirname($image) eq ".");

    if (! -e $image) {
	die("*** $0:\n".
	    "    $image does not exist!\n");
    }
    $baseimages{$building}->{"floors"}->{$floor} = $image;
}

# Ha.
my @floortags = ();
$floortags[1] = "1st floor";
$floortags[2] = "2nd floor";   
$floortags[3] = "3rd floor";
$floortags[4] = "4th floor";
$floortags[5] = "5th floor";
$floortags[6] = "6th floor";
$floortags[7] = "7th floor";
$floortags[8] = "8th floor";
$floortags[9] = "9th floor";

#
# Turn off line buffering on output
#
$| = 1;

# Debugging.
sub dprint($) {
    my ($msg) = @_;
    
    print STDERR $msg
	if ($debug);
}
sub dofloor($$);
sub writefiles($@);
sub adjustmap($$$);

#
# Parse command arguments. Once we return from getopts, all that should
# left are the required arguments.
#
%options = ();
if (! getopts($optlist, \%options)) {
    usage();
}
if (defined($options{"a"})) {
    $showany = 1;
}
if (defined($options{"d"})) {
    $debug = 1;
}
if (defined($options{"t"})) {
    $notitles = 1;
}
if (defined($options{"f"})) {
    $floor   = $options{"f"};
    $showany = 1;
}
if (defined($options{"o"})) {
    $prefix = $options{"o"};
}

if (defined($options{"e"})) {
    if ($options{"e"} =~ /([-\w]*),([-\w]*)/) {
	$pid = $1;
	$eid = $2;
    }
    else {
	die("*** $0:\n".
	    "    Invalid argument to -e option!\n");
    }

    #
    # Verify permission to view this experiment.
    #
    if ($UID && !TBAdmin($UID) &&
	! TBExptAccessCheck($UID, $pid, $eid, TB_EXPT_READINFO)) {
	die("*** $0:\n".
	    "    You do not have permission to view $pid/$eid!\n");
    }

    #
    # Optional building and floor (see above) for a specific experiment.
    #
    usage()
	if (@ARGV > 1);
    if (@ARGV) {
	$building = $ARGV[0];
    }
}
elsif (@ARGV == 1) {
    $building = $ARGV[0];
}

# Must specify a building with a floor.
if (defined($floor) && !defined($building)) {
    die("*** $0:\n".
	"    Must supply a building name!\n");
}

# Building must exist.
if (defined($building) && !exists($baseimages{$building})) {
    die("*** $0:\n".
	"    No such building: $building\n");
}

#
# If a floor specified, then do just that floor and spit it out.
#
if (defined($floor)) {
    if (!exists($baseimages{$building}->{"floors"}->{$floor})) {
	die("No such floor '$floor' in building: $building\n");
    }
    
    my ($floorimage, $areamap) = dofloor($building, $floor);
    $image    = $floorimage;
    @areamaps = ($areamap);
}
else {
    #
    # Need to find all the floors in this building and generate them all.
    #
    my @floors = ();

    if (defined($building)) {
	foreach my $floor (sort(keys(%{ $baseimages{$building}->{"floors"} }))) {
	    my ($floorimage, $areamap) = dofloor($building, $floor);

	    push(@floors, [ $floorimage, $areamap ])
		if (defined($floorimage));
	}
    }
    else {
	#
	# XXX We need to be fancier for multiple buildings at some point!
	# Not much of a worry right now.
	#
	foreach my $building (sort(keys(%baseimages))) {
	    my @floorlist = sort(keys(%{ $baseimages{$building}->{"floors"} }));
	    
	    foreach my $floor (@floorlist) {
		my ($floorimage, $areamap) = dofloor($building, $floor);

		push(@floors, [ $floorimage, $areamap ])
		    if (defined($floorimage));
	    }
	}
    }

    #
    # Now generate a superimage from all the base images. We just line
    # them up; nothing fancy at all.
    #
    my $total_y = 0;
    my $max_x   = 0;
    foreach my $ref (@floors) {
	my ($floorimage, $areamap) = @$ref;
	
	($x, $y) = $floorimage->getBounds();

	$total_y = $total_y + $y + 15;
	$max_x = $x
	    if ($x > $max_x);
    }
    #
    # Create a new image using the aggregate size.
    #
    $image = new GD::Image($max_x, $total_y, 1);

    #
    # Now copy the floor images into the superimage.
    #
    my $running_y = 0;
    foreach my $ref (@floors) {
	my ($floorimage, $areamap) = @$ref;
	
	($x, $y) = $floorimage->getBounds();
	$image->copy($floorimage,
		     0, $running_y,
		     0, 0, $x, $y);
	# Move all the map references down/over by adjusted amount.
	adjustmap($areamap, 0, $running_y);
	push(@areamaps, $areamap);
	
	$running_y += $y + 15;
    }
}
writefiles($image, @areamaps);
exit(0);

#
# Do a floor. Returns the image object and an "areamap". 
#
sub dofloor($$)
{
    my ($building, $floor) = @_;
    my $isnew = 0;

    #
    # Grab the nodes on this floor in this building. We want to know
    # their allocation status so we know what colors to use.
    #
    my $query_result =
	DBQueryFatal("select loc.*,r.pid,r.eid,r.vname ".
		     "  from location_info as loc ".
		     "left join reserved as r on r.node_id=loc.node_id ".
		     "where loc.floor='$floor' and loc.building='$building'");

    my $newnodes_result =	
	DBQueryFatal("select * from new_nodes ".
		     "where floor='$floor' and building='$building'");

    if ($mereuser) {
	if (!$query_result->numrows && !$showany) {
	    return (undef, undef);
	}
    }
    else {
	if (!$query_result->numrows && !$newnodes_result->numrows && !$showany) {
	    return (undef, undef);
	}
    }

    #
    # The area map is indexed by nodeid, and contains a list of the
    # x1,y1,x2,y2 (upper left, lower right) coordinates of the "hot"
    # area.  We have to wait till later to actually generate the map
    # cause the coords might need to be adjusted if creating a floor
    # as part of a building (and the floor image gets moved within a
    # bigger image).
    #
    # XXX We make no attempt to deal with overlapping icons (areamaps).
    # This will eventually lead to confusion and incorrect maps.
    # 
    my $areamap = {};

    #
    # Grab the base image for the floor.
    #
    if (! exists($baseimages{$building}->{"floors"}->{$floor})) {
	die("*** $0:\n".
	    "    No base image for $building:$floor!\n");
    }
    my $baseimage =
      GD::Image->newFromPng($baseimages{$building}->{"floors"}->{$floor}, 1) ||
	  die("*** $0:\n".
	      "    Could not get base ".
	      $baseimages{$building}->{"floors"}->{$floor}  ."!\n");

    #
    # Green dot means node is free or owned by pid/eid.
    # Red dot mean node is down.
    # Blue dot means node is allocated
    #
    my $black = $baseimage->colorAllocate(0,0,0);
    my $green = $baseimage->colorAllocate(0,250,0);
    my $red   = $baseimage->colorAllocate(250,0,0);
    my $blue  = $baseimage->colorAllocate(0,0,250);
    my $white = $baseimage->colorAllocate(255,255,255);
    my $gold  = $baseimage->colorAllocate(255,255,0);
    my $CY    = 10;
    my $CX    = 10;

    foreach my $isnew (0, 1) {
	my $table;
	
	if ($isnew) {
	    next
		if ($mereuser);
	    
	    $table = $newnodes_result;
	}
	else {
	    $table = $query_result;
	}
	
	while (my $rowref = $table->fetchrow_hashref()) {
	    my $nodeid = $rowref->{"node_id"};
	    my $x      = $rowref->{"loc_x"};
	    my $y      = $rowref->{"loc_y"};
	    my $rpid   = $rowref->{"pid"};
	    my $reid   = $rowref->{"eid"};
	    my $label  = $nodeid;
	    my $newid  = ($isnew ? $rowref->{"new_node_id"} : 0);
	    my ($x1,$y1,$x2,$y2);

	    if ($isnew) {
		$baseimage->filledArc($x, $y, $CX, $CY, 0, 360, $gold)
		}
	    elsif ((!defined($pid) && !(defined($rpid))) ||
		   (defined($pid) && defined($rpid) && $pid eq $rpid)) {
		# Without -e option, green means node is free.
		# With -e option, green means node belongs to experiment. 
		$baseimage->filledArc($x, $y, $CX, $CY, 0, 360, $green);
	    }
	    elsif ($rpid eq NODEDEAD_PID() and $reid eq NODEDEAD_EID()) {
		$baseimage->filledArc($x, $y, $CX, $CY, 0, 360, $red);
	    }
	    else {
		$baseimage->filledArc($x, $y, $CX, $CY, 0, 360, $blue);
	    }
	    $baseimage->string(gdTinyFont, $x - 7, $y + ($CY / 2),
			       $label, $black);

	    my $tmp = {};
	    $tmp->{"X1"} = $x - ($CX / 2);
	    $tmp->{"Y1"} = $y - ($CY / 2);
	    $tmp->{"X2"} = $x + ($CX / 2);
	    $tmp->{"Y2"} = $y + ($CY / 2);
	    $tmp->{"ISNEW"} = $newid;
	    $areamap->{$nodeid} = $tmp;
	}
    }

    if (!$notitles) {
	#
	# We wat to stick in a label for the floor. To do that we need to make
	# some white space at the top by expanding the image, and moving it down.
	# Okay, so it takes some steps to do that. 
	# 
	my ($x, $y) = $baseimage->getBounds();
	my $fullimage = new GD::Image($x, $y + 50, 1);
	$fullimage->copy($baseimage, 0, 50, 0, 0, $x, $y);
	$fullimage->filledRectangle(0, 0, $x, 50, $white);

	$fullimage->stringFT($black, "/usr/testbed/lib/arial.ttf",
			     25, 0, 10, 40,
			     $baseimages{$building}->{"title"} . " - " .
			     $floortags[$floor]);

	# Have to adjust the maps cause we just moved everything.
	adjustmap($areamap, 0, 50);
	$baseimage = $fullimage;
    }
    
    return ($baseimage, $areamap);
}

#
# Adjust map coordinates moving everything by x,y amount. This is used
# when building an image of multiple maps.
#
sub adjustmap($$$)
{
    my ($mapref, $x, $y) = @_;

    foreach my $nodeid (keys(%{ $mapref })) {
	$mapref->{$nodeid}->{"X1"} += $x;
	$mapref->{$nodeid}->{"Y1"} += $y;
	$mapref->{$nodeid}->{"X2"} += $x;
	$mapref->{$nodeid}->{"Y2"} += $y;
    }
}

#
# Take a list of the areamaps created in the above function, and dump them
# to the output file so that the web page can grab them.
#
sub writefiles($@)
{
    my ($image, @maps) = @_;

    # Image
    open(PNG, "> ${prefix}.png") ||
	die("*** $0:\n".
	    "    Could not open ${prefix}.png for writing!\n");
    print PNG $image->png();
    close(PNG);

    # Areamap.
    if (!open(MAP, "> ${prefix}.map")) {
	unlink("${prefix}.png");
	die("*** $0:\n".
	    "    Could not open ${prefix}.map for writing!\n");
    }
    print MAP "<MAP NAME=floormap>\n";

    foreach my $mapref (@maps) {
	my %map = %{ $mapref };
	
	foreach my $nodeid (keys(%map)) {
	    my $x1 = $map{$nodeid}->{"X1"};
	    my $y1 = $map{$nodeid}->{"Y1"};
	    my $x2 = $map{$nodeid}->{"X2"};
	    my $y2 = $map{$nodeid}->{"Y2"};
	    my $isnew = $map{$nodeid}->{"ISNEW"};
	    my $link  = ($isnew ?
			 "newnode_edit.php3?id=${isnew}" :
			 "shownode.php3?node_id=${nodeid}");

	    print MAP "<AREA SHAPE=RECT COORDS=\"$x1,$y1,$x2,$y2\" ".
		"HREF=\"${link}\">\n\n";
	}
    }
    print MAP "</MAP>\n";
    close(MAP);
}
