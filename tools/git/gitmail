#!/usr/bin/perl -w
#
# EMULAB-COPYRIGHT
# Copyright (c) 2009-2010 University of Utah and the Flux Group.
# All rights reserved.
#
# To set this script up:
# 1) Copy or link it to .git/hooks/post-receive in your repository. Make sure
#    it's world-readable and executable.
# 2) Set configuration options by editng the values of variables directly
#    below
#       OR
#    Set the simple values with git options: run
#       git config --add hooks.gitmail.<optname> value
#       (for example:
#           git config --add hooks.gitmail.alwaysmail ricci@cs.utah.edu
# 3) Test it by running it with the -d and -t options, which will not send
#    mail and will give you a chance to make sure everything looks right
#
# TODO:
#    Users can add notifications for themselves
#

use strict;
use IPC::Open2;
use POSIX 'setsid';
use Getopt::Long;
sub get_config($$);
my $CONFIGBASE = "hooks.gitmail";

######################################################################
# Configuration Options
# Options that use get_config can be set using 'git config' - if not
# set, the second parameter is used as the default
######################################################################

#
# If debugging is enabled, prints a lot of messages and doesn't actually send
# mail.
#
my $debug = get_config("debug",undef);

#
# If set, just picks up the most recent commits instead of reading them from
# stdin. Note that this one doesn't look in the git config; that wouldn't
# make any sense.
#
my $testmode = undef;

#
# If set, try to hide trivial merges (i.e., ones with standard subject
# line and no body text). Ugly hack.
#
my $hide_trivial_merges = get_config("hidetrivialmerges",undef);

#
# Command-line options - have to do this before setting other options, since
# we want to be able to turn on debugging early
#
my %opt;
Getopt::Long::Configure("no_ignore_case");
if (!GetOptions(\%opt, 'd', 'h', 't', 'T=s', 'o=s@') || @ARGV || $opt{h}) {
    print STDERR "Usage: gitmail [-h|-d]\n";
    print STDERR "  -h     this message\n";
    print STDERR "  -d     enable debugging output and don't send mail\n";
    print STDERR "  -t     test mode - operate on last 3 commits to master\n";
    print STDERR "  -T br  like '-t', but use branch 'br' instead of master\n";
    print STDERR "  -o o=v give option o the value v (may be given multiple\n";
    print STDERR "         times)\n";
    exit 1;
}

my $testbranch = "master";
if ($opt{d}) { $debug    = 1; }
if ($opt{t}) { $testmode = 1; }
if ($opt{T}) { $testmode = 1; $testbranch = $opt{T} }

#
# Name of this repository - set it to a string to get it included in the
# mail subject line and the X-Git-Repo header
#
my $reponame = get_config("reponame",undef);

#
# Data structure mapping branch names and path names to email address. Each
# entry is a triple:
#    Branch name
#    File path
#    Mail address
# If *both* the branch and path match for a commit, mail will be sent to the
# associated address. The branch and paths are interpreted as perl regexps,
# with the special value 'undef' matching anything at all. Any of these may
# be array references: for the branch and path fields, if *any* of the
# elements in the array match, the field is considered to match. For the email
# address field, the mail will be sent to all addresses in the array.
#
# *NOTE* This are perl regexps, not shell globs! *NOTE*
# *NOTE* This can also be read from a file - see below *NOTE*
#
my @mailto = (
  # Branch              # Path             # Send mail to
# Examples
# [ undef,              undef,             'cvs-testbed@flux.utah.edu' ],
# [ undef,              'snmpit',         ['ricci@flux.utah.edu',
#                                          'sklower@vangogh.cs.berkeley.edu']],
# [ ['^ricci-',
#    '^test-'],         'assign/',         'ricci+assign@flux.utah.edu'],
# [ 'gitmail',          'tools/git',       'ricci+git@flux.utah.edu']
);

#
# If set, look in a file for the @mailto structure.  This file should be
# executable perl code that returns an array following the same format as the
# @mailto array below. For example, the file could contain:
# ( [ undef, undef, 'me@example.com'] )
#
# *NOTE* If this is set, overrides the @mailto setting above *NOTE*
#
my $mailconfigfile = get_config("mailconfigfile",undef);

#
# Default mail address - if none of the more specific regular expressions
# match, send to this address
#
my $defmail = get_config("defmail",undef);

#
# If set, *always* send mail to this address (even if one or more regexps
# match). ($defmail will still be used if no regexps match)
#
my $alwaysmail = get_config("alwaysmail",undef);

#
# If set to true, detach and run in background - the push doesn't return until
# the hook finishes, so doing this means the pusher doesn't have to wait for
# us to finish
# Note: Not well tested!
#
my $detach = get_config("detach",undef);

#
# If set to true, send a separate mail message for every single commit. If
# false, pushes of multiple commits along a branch get included in the same
# mail.
#
my $separate_mail = get_config("separatemail",undef);

#
# If set, these arguments will be passed *in addition* to the regular arguments
# to 'git show' to produce descriptions of commits
#
my $showcommit_extra = get_config("showcommitextra",undef);

#
# If set, check all commit objects to see if they exist in the repository
# at the specified path.  If a commit object exists in this repository,
# do not include its log in the email message.
# Note: This should point at the .git directory - for a 'bare' repository,
# this is just the path the repository. For a 'reglar' repository, this is the
# .git/ directory *inside* the repositry.
#
my $exclude_repo = get_config("excluderepo",undef);

######################################################################
# Constants
######################################################################

#
# Programs we use
#
my $GIT = "git";
my $SENDMAIL = get_config("sendmail","sendmail");

#
# Magic 'hash' that indicates an empty or non-existant rev
#
my $EMPTYREV = "0"x40;

#
# Types of changes
#
my $CT_CREATE = "create";
my $CT_UPDATE = "update";
my $CT_DELETE = "delete";
my $CT_REWIND = "rewind";
my $CT_REBASE = "rebase";

#
# Tired of typing this and getting it wrong
#
my $STDERRNULL = " 2> /dev/null";

######################################################################
# Function Prototypes
######################################################################
sub change_type($$$);
sub ref_type($);
sub rev_type($);
sub revparse($);
sub changed_files(@);
sub get_mail_addresses($@);
sub get_merge_base($$);
sub uniq(@);
sub flatten_arrayref($);
sub commit_mail($\@$@);
sub get_commits($$$);
sub send_mail($$@);
sub short_refname($);
sub debug(@);
sub object_exists($$);
sub filter_out_objects_in_repo($@);

######################################################################
# Main Body
######################################################################

debug("starting");

#
# Read from the mail config file, if requested. We do this before detaching
# so that we can report an error if one occurs.
#
if ($mailconfigfile) {
    #
    # We open the file, read the contents, then eval them. If we didn't get any
    # errors, the result becomes the new contents of the @mailto array
    #
    if (!open(MCF,"<$mailconfigfile")) {
        warn "gitmail: Unable to open config file $mailconfigfile - $!\n";
    } else {
        my @mailcode = <MCF>;
        close MCF;

        #
        # Have to turn array back into a single string before we can call
        # eval on it. Put the result in a temp. variable so that we don't
        # overwrite @mailto if there is an error
        #
        my @mailconfig = eval join("\n",@mailcode);

        #
        # If there were any errors in the eval, they will be found in the magic
        # variable $@ - however, they will also have been printed to stderr, so
        # don't print again
        #
        if ($@) {
            warn "gitmail: Error in $mailconfigfile: $@\n";
        } else {
            @mailto = @mailconfig;
        }
    }
}

#
# Get the actual references
#
my @reflines;
if ($testmode) {
    my $fullref = `git rev-parse --symbolic-full-name $testbranch`;
    if (!$fullref) {
	    exit(1);
    }
    my $newrev = `git rev-parse $fullref $STDERRNULL`;
    chomp $newrev;

    #
    # Provide a simple way to grab some commits - the three most recent ones
    #
    @reflines = ("$newrev~2 $newrev $fullref");
} else {
    #
    # Get all of the references that are being pushed from stdin - we do this in
    # one slurp so that we can detach below
    #
    @reflines = <STDIN>;
    debug("finished reading stdin");
}

#
# Detach?
#
if ($detach && !$debug) {
    # Stolen from perlipc manpage
    chdir '/'               or die "Can't chdir to /: $!";
    open STDIN, '/dev/null' or die "Can't read /dev/null: $!";
    open STDOUT, '>/dev/null'
                            or die "Can't write to /dev/null: $!";
    defined(my $pid = fork) or die "Can't fork: $!";
    exit if $pid;
    setsid                  or die "Can't start a new session: $!";
    open STDERR, '>&STDOUT' or die "Can't dup stdout: $!";
}

#
# Loop over all of the references we got on stdin
#
foreach my $refline (@reflines) {
    my @commits;
    my @changed_files;

    chomp $refline;
    debug("Read line '$refline'");

    #
    # Each line we get on stdin gives us an old revision, a new revision, and
    # a reference (such as the branch name). It's our job to figure out what
    # happened in the middle
    #
    my ($oldrev, $newrev, $refname) = split(/\s+/, $refline);
    my $ref_type = ref_type($refname);

    #
    # Use rev-parse so that fancy symbolic names, etc. can be used
    # Note: revparse can die if the name given is bogus
    #
    $oldrev = revparse($oldrev);
    $newrev = revparse($newrev);

    #
    # Figure out what type of change occured (update, creation, deletion, etc.)
    # and what type of objects (commit, tree, etc.) we got
    #
    my $ct = change_type($oldrev,$newrev,$ref_type);
    my $old_type = rev_type($oldrev);
    my $new_type = rev_type($newrev);

    debug("Change type: $ct ($old_type,$new_type)");

    #
    # For now, only handle commit objects.  Tag objects require extra work.
    #
    if ($new_type && $new_type ne "commit") {
        debug("Skipping non-commit");
        next;
    }

    #
    # Figure out which commits we're interested in based on reference type
    # and change type.
    #
    if ($ref_type eq 'tag') {
	if ($ct eq $CT_DELETE) {
	    # We want to know where the tag used to point before deletion
	    push @commits, $oldrev;
	} else {
	    # Tags only have delete, create, and update.  Rewind and rebase
	    # don't make sense in tag context.
	    #
	    # We only care about the new value of the tag here.
	    push @commits, $newrev;
	}
    } elsif ($ref_type eq 'branch') {
	if ($ct eq $CT_DELETE) {
	    # We want to know where the branch used to point before deletion
	    push @commits, $oldrev;
	} elsif ($ct eq $CT_REWIND) {
	    # There's no new history to show, but we still want to see where
	    # the branch now points.
	    push @commits, $newrev;
	} else {
	    @commits = get_commits($oldrev,$newrev,$refname);
	    # We only want to see *new* commits, which means that commits already
	    # in the main repository need to be excluded too.
	    if (defined $exclude_repo) {
		@commits = filter_out_objects_in_repo($exclude_repo, @commits);
	    }
	}
    }

    next unless (@commits);
    debug("commits are: ", join(" ",@commits));

    @changed_files = changed_files(@commits);
    debug("Changed files: ", join(",",@changed_files));

    #
    # Based on the list of files, figure out who to mail
    #
    my @mailaddrs = get_mail_addresses($refname,@changed_files);
    debug("Mailing to: ", join(",",@mailaddrs));

    #
    # Send off the mail!
    #
    if (@mailaddrs) {
        print "Sending email notification to ", join(",",@mailaddrs), "\n";
        commit_mail($ct,@commits,$refname,@mailaddrs);
    }
}

debug("finishing");

######################################################################
# Functions
######################################################################

#
# Does this change represent the creation, deletion, or update of an object?
# Takes old and new revs
#
sub change_type($$$) {
    my ($oldrev, $newrev, $ref_type) = @_;

    #
    # We can detect creates and deletes by looking for a special 'null'
    # revision
    #
    if ($oldrev eq $EMPTYREV) {
        return $CT_CREATE;
    } elsif ($newrev eq $EMPTYREV) {
        return $CT_DELETE;
    } elsif ($ref_type eq 'tag') {
	    return $CT_UPDATE;
    } else {
	my $merge_base = get_merge_base($oldrev,$newrev);
	my $oldrev = revparse($oldrev);
	my $newrev = revparse($newrev);
	if ($merge_base eq $oldrev) {
	    return $CT_UPDATE;
	} elsif ($merge_base eq $newrev) {
	    return $CT_REWIND;
	} else {
	    return $CT_REBASE;
	}
    }
}

#
# Find out what type an object has
#
sub rev_type($) {
    my ($rev) = @_;
    my $rev_type = `git cat-file -t '$rev' $STDERRNULL`;
    chomp $rev_type;
    return $rev_type;
}

#
# Find out what type of reference this is
#
sub ref_type($) {
    my ($ref) = @_;
    my $type;
    if ($ref =~ m#^refs/heads/#) {
	    $type = 'branch';
    } elsif ($ref =~ m#^refs/tags/#) {
	    $type = 'tag';
    }
    return $type;
}

#
# Parse (possibly) symbolic revision name into hash
# Note: Dies if the revision name is bogus!
#
sub revparse($) {
    my ($rev) = @_;
    open(RP,"$GIT rev-parse $rev $STDERRNULL |");
    my $parsedrev = <RP>;
    my $okay = close(RP);
    if (!$okay) {
        die "gitmail: $rev is not a valid revision\n";
    }
    chomp $parsedrev;
    return $parsedrev;
}

#
# Given a list of commit object hashes, return the list of files changed by
# all commits.
#
sub changed_files(@) {
    my %files;

    debug("running '$GIT diff-tree --stdin -r --name-only --no-commit-id' on '@_'");
    my $pid = open2(\*OUT, \*IN, "$GIT diff-tree --stdin -r --name-only --no-commit-id");

    print IN "$_\n" for (@_);
    close(IN);

    while (<OUT>) {
	    chomp;
	    $files{$_} = 1;
    }
    close(OUT);

    waitpid($pid, 0);
    my $rc = $? >> 8;
    if ($rc) {
	    die "'git diff-tree' exited with return code $rc\n";
    }

    return keys(%files);
}

#
# Given a refname and a list of filenames, return the set of email addresses
# the report should be sent to
#
sub get_mail_addresses($@) {
    my ($refname, @changedfiles) = @_;
    my @addrs;
    my $matched = 0;

    #
    # Note: we use flatten_arrayref so that either individual strings or array
    # references containing lists of addresses can be used
    #

    #
    # If there's an address we're always supposed to send to, include that now
    #
    if (defined($alwaysmail)) {
        push @addrs, flatten_arrayref($alwaysmail);
        debug("Used alwaysmail address $alwaysmail");
    }

    #
    # Find out if this is a branch, and of so, what it's name is. If it's not,
    # set the branch name to be empty, so that only empty regexps will match
    # it
    #
    my $branchname = "";
    if ($refname =~ /^refs\/heads\/(.*)/) {
       $branchname = $1;
    }

    #
    # Loop through each entry, making sure both branch and path match
    #
    ENTRY: foreach my $entry (@mailto) {
        my ($branches, $paths, $addresses) = @$entry;
        my @branches = flatten_arrayref($branches);
        my @paths = flatten_arrayref($paths);
        my @addresses = flatten_arrayref($addresses);

        #
        # If the branch doesn't match, go on to the next entry
        #
        my $branch_matched = 0;
        BRANCH: foreach my $branchRE (@branches) {
            if (!defined($branchRE)) {
                debug("Empty branch matched");
                $branch_matched = 1;
                last BRANCH;
            } elsif ($branchname =~ $branchRE) {
                debug("Matched branch regexp /$branchRE/");
                $branch_matched = 1;
                last BRANCH;
            }
        }

        if (!$branch_matched) {
            next ENTRY;
        }

        #
        # If the path doesn't match, go on to the next entry
        #
        my $paths_matched = 0;
        PATH: foreach my $regexp (@paths) {
            if (!defined($regexp)) {
                debug("  Empty path matched");
                $paths_matched = 1;
                last PATH;
            }
            # Have to check against every file in the changeset
            foreach my $file (@changedfiles) {
                if ($file =~ $regexp) {
                    debug("  Matched path regexp /$regexp/");
                    $paths_matched = 1;
                    last PATH;
                }
            }
        }

        if (!$paths_matched) {
            debug("  Path match failed");
            next ENTRY;
        }

        #
        # Great, made it through - we add all addresses, we'll weed out
        # duplicates later
        #
        debug("  Adding adddresses ", join(",",@addresses));
        $matched = 1;
        push @addrs, @addresses;
    }

    #
    # Fall back to default if no matches (note that an earlier match with an
    # empty list of addresses will cause this case to not be triggered - this
    # is intentional)
    #
    if (!$matched && defined($defmail)) {
        @addrs = flatten_arrayref($defmail);
        debug("Used default address $alwaysmail");
    }

    #
    # Pull out unique values to return
    #
    return uniq(@addrs);
}

#
# Return only the unique elements of the supplied list. Input does not have
# to be sorted, sort order of output is undefined.
#
sub uniq(@) {
    my %uniq;
    map { $uniq{$_} = 1 } @_;
    return keys %uniq;
}

#
# If the parameter is a scalar, just return a one-element array containing the
# scalar. If it's a reference to an array, return the array referenced.
#
sub flatten_arrayref($) {
    my ($ref) = @_;
    if (ref($ref) eq "ARRAY") {
        return @$ref;
    } else {
        return ($ref);
    }
}

#
# Send mail about a regular update commit
#
sub commit_mail($\@$@) {
    my ($ct,$commits,$refname,@mailaddrs) = @_;

    #
    # Construct the subject line. For now, we just say what repo (if defined)
    # and what branch/tag it happened on
    #
    my $subject = "git commit: ";
    my $ref_type;
    if (defined($reponame)) {
        $subject .= "[$reponame] ";
    }

    $ref_type = ref_type($refname);

    $subject .= $ref_type . ' ' . short_refname($refname);

    my $what_happened;
    if ($ct eq $CT_UPDATE) {
        $what_happened .= 'updated';
    } elsif ($ct eq $CT_REWIND) {
        $what_happened .= 'rewound';
    } elsif ($ct eq $CT_REBASE) {
        $what_happened .= 'rebased';
    } elsif ($ct eq $CT_CREATE) {
        $what_happened .= 'created';
    } elsif ($ct eq $CT_DELETE) {
        $what_happened .= 'deleted';
    }

    $subject .= ' ' . $what_happened;
    my $actionstring = ucfirst($ref_type) . ' ' . short_refname($refname) .
                       " has been $what_happened";

    if ($ct eq $CT_REBASE) {
        $actionstring .= ".  The following commits are new or have been modified:";
    } elsif ($ct eq $CT_REWIND) {
        $actionstring .= "  to point to the following commit:";
    } elsif ($ct eq $CT_DELETE) {
	$actionstring .= ".  It previously pointed to the following commit:";
    }

    $actionstring .= "\n\n";

    my @fullbody;
    foreach my $rev (@$commits) {
        #
        # Just use regular git show command, with purty +/- summary at the
        # bottom (formatted to be narrow enough for email)
        #
        my $showcommand = "$GIT show --numstat --shortstat ";
        if (defined($showcommit_extra)) {
            $showcommand .= "$showcommit_extra ";
        }
        $showcommand .= "'$rev'";
        debug("running '$showcommand'");
        my @body = `$showcommand`;
        
        if ($hide_trivial_merges) {
	        my $is_merge = 0;
	        my $body_lines = 0;
	        my $subject;
	        for (@body) {
		        $is_merge = 1 if (/^Merge:/);
			if (/^ /) {
				if (not defined $subject) {
					$subject = $_;
				} else {
					$body_lines++;
				}
			}
		}
		
		if ($is_merge && $body_lines == 0 &&
		    $subject =~ /^ +Merge (?:remote )?branch '[^']+'(?: of .*)?$/){
			next;
		}
			
	}

        if ($separate_mail) {
            # Send this message by itself
            send_mail($subject,$actionstring . join("",@body),@mailaddrs);
        } else {
            push @fullbody,\@body;
        }
    }

    #
    # Send all the changes together in one message
    #
    if (!$separate_mail && @fullbody) {
        send_mail($subject,
            $actionstring . join("\n" . "-"x72 . "\n\n",
                                 map { join "",@$_} @fullbody),
            @mailaddrs);
    }
}

#
# Given two revisions, get a list of the commits that occured between them
# TODO: Consider leaving out already-reachable commits like the contrib script
#       does, or at least making it an option
#
sub get_commits($$$) {
    my ($oldrev,$newrev,$refname) = @_;
    my $ct = change_type($oldrev,$newrev, ref_type($refname));

    #
    # If this is an update, we can just ask git for the revisions between the
    # two revisions we were given.
    #
    if ($ct eq $CT_UPDATE) {
	my $revstring = "$oldrev..$newrev";

	debug("running '$GIT rev-list --reverse --date-order '$revstring'");
	my @revs = `$GIT rev-list --reverse --date-order '$revstring'`;
	chomp @revs;
        return @revs;
    } elsif ($ct eq $CT_REBASE) {
        debug("running '$GIT cherry '$oldrev' '$newrev'");
	# Only return revs prefixed with a '+' since commits prefixed with a
	# '-' are already in the repository with a different commit hash.
	#
	# The '-' commits are the same as their non-rebased counterparts, except
	# their ancestry is different.  For the email messages, we don't care
	# about these since we should have seen the original commits already.
	#
	# The '+' commits are either new or are rebased commits whose *content*
	# has changed.  We definitely want to see these.  Note that this only
	# applies to the content of the commit, not the commit message.
	my @revs;
	my @all_revs;
	for (`$GIT cherry '$oldrev' '$newrev'`) {
		debug($_);
		chomp;
		@_ = split /\s+/, $_;
		unshift @revs, $_[1] if ($_[0] eq '+');
		unshift @all_revs, $_[1];
	}

	# If cherry finds that all of the commits are already present,
	# report 'em all anyway.  We still need to know that the rebase
	# happened, and reporting just the head doesn't make any sense.
	@revs = @all_revs if (!@revs);
        return @revs;
    } elsif ($ct eq $CT_CREATE) {
        #
        # If it's a create, we have to be a bit more fancy: we look for all
        # commits reachable from the new branch, but *not* reachable from any
        # other branch (otherwise, we get all of the history back to the dawn
        # of time). I stole this magic from the contrib post-receive-email hook
        # from the git distro.
        #

        #
        # Get the list of all other branch heads
        #
        my @other_branches = `$GIT for-each-ref --format='%(refname)' refs/heads/ | grep -F -v $refname`;
        chomp @other_branches;

        my $other_branches = join(" ",@other_branches);
        debug("other branches are: '$other_branches'");

        #
        # Get a list of commits that are reachable from this branch, and no
        # others.
        #
        debug("running '$GIT rev-parse --not $other_branches | $GIT rev-list --pretty --stdin $newrev'");
        my @commits = `$GIT rev-parse --not $other_branches | $GIT rev-list --reverse --date-order --stdin $newrev`;

        # We always want to be notified when a branch is created, so if there are no commits reachable
        # from only this branch just report on the head of the branch.
        push @commits, $newrev if (!@commits);

        debug("commits are @commits");

        chomp @commits;
        return @commits;
    }

    #
    # The following magic is from the contrib post-receive hook, and it tries
    # to avoid sending the same commit in mail twice, by excluding commits that
    # are reachable from other branches
    #
    #my @other_branches = `$GIT for-each-ref --format='%(refname)' refs/heads/ | grep -F -v $refname`;
    #chomp @other_branches;
    #my $other_branches = join(" ",@other_branches);
    #if ($debug) {
    #    print "other_branches magic: '$other_branches'\n";
    #}
    #my $rev_parse = `$GIT rev-parse --not $other_branches`;
    #if ($debug) {
    #    print "rev_parse magic: \n" . $rev_parse;
    #}
    #my @commits = `$GIT rev-parse --not $other_branches | $GIT rev-list --pretty --stdin $revspec`;

}

#
# Send out some mail (or not, if in debug mode)
#
sub send_mail($$@) {
    my ($subject, $body, @to) = @_;

    if ($debug) {
           open(MAIL,">&STDERR");
           print MAIL "\n\n";
    } else {
           # sendmail args:
           # -oem causes errors in mail to be "mailed back"
           # -odb deliver mail in background
           # -t causes sendmail to look in the message for 'To:' 'Cc:' and
           #    'Bcc:' lines
           open(MAIL, "| $SENDMAIL -odb -oem -t");
    }

    print MAIL "To: " . join(", ",@to) . "\n";
    print MAIL "Subject: $subject\n";

    #
    # Add an X-Git-Repo header to help people procmail
    # TODO: Add branch too!
    #
    if (defined($reponame)) {
        print MAIL "X-Git-Repo: $reponame\n";
    }

    #
    # Marks end of headers
    #
    print MAIL "\n";

    print MAIL $body;

}

#
# Given a full refname, pull off the last part for pretty printing
#
sub short_refname($) {
    my ($ref) = @_;
    my $refname = `git rev-parse --abbrev-ref $ref $STDERRNULL`;
    chomp $refname;

    # Fall back to full name if rev-parse fails for some reason
    $refname = $ref if (!$refname);
    debug("got short refname \"$refname\"");


    # If the ref didn't get shortened, it may be because it was deleted.  Just
    # chop off 'refs/heads' or 'refs/tags' and return the rest.
    if ($refname =~ m#^refs/(?:heads|tags)/(.*)#) {
	    $refname = $1;
    }

    return $refname;
}

#
# Print only if in debug mode
#
sub debug(@) {
    if ($debug) {
        print STDERR "*** gitmail: ", @_, "\n";
    }
}

#
# Return either the config value associated with the repo or the second
# argument, which supplies the default.
#
sub get_config($$) {
    my ($var,$default) = @_;

    #
    # Allow the user to override on command line
    #
    if ($opt{o}) {
        foreach my $pair (@{$opt{o}}) {
            my ($name,$value) = split /=/, $pair;
            if ($name eq $var) {
                debug("Using config value $value for $name from command line");
                return $value;
            }
        }
    }

    my $value = `git config $CONFIGBASE.$var`;
    chomp $value;
    if ($value ne "") {
        debug("Got $value from git config for $var");
        return $value;
    } else {
        debug("Using " , defined($default)?$default : "(undef)" , " for $var");
        return $default;
    }
}

#
# Returns the merge base (i.e., common ancestor) of
# the two supplied revisions.
#
sub get_merge_base($$)
{
	my ($rev_a, $rev_b) = @_;
	my $mb = `git merge-base '$rev_a' '$rev_b'`;
	chomp $mb;

	return $mb
}

#
# Returns 1 if the given object (identified by hash) exists in the given
# repository (identified by path); 0 if it does not .
#
sub object_exists($$) {
    my ($obj, $repo) = @_;

    #
    # 'cat-file -e' is like 'test -e', and don't be fooled by the name, it
    # works on non-files too
    #
    debug("running $GIT --git-dir='$repo' cat-file -e $obj");
    my $rv = system "$GIT --git-dir='$repo' cat-file -e $obj";
    if ($rv) {
        return 0;
    } else {
        return 1;
    }
}

#
# Return a list of all objects from the input list that do *not* exist in
# the given repo
#
sub filter_out_objects_in_repo($@) {
    my $repo = shift @_;
    return grep { !object_exists($_,$repo)} @_;
}
