#!/usr/bin/perl -w
#
# EMULAB-COPYRIGHT
# Copyright (c) 2000-2004 University of Utah and the Flux Group.
# All rights reserved.
#
use English;
use Getopt::Std;

#
# Emulab NFS mount command, called by rc.mounts .  
#
# Args are the remote and local mount points, for example:
#    emount fs.emulab.net:/q/proj/testbed /proj/testbed
#
# One arg is just the username, with the rest defaulted in for convenience.
#    emount russ
# is equivalent to:
#    emount fs.emulab.net:/users/russ /users/russ
#
# With no args, reports the current mounts with "net use".
#
# Since this is Windows, mounts go through drive letters, like this:
#    S:       \\fs.emulab.net\share              # Share
#    P:       \\fs.emulab.net\q\proj\testbed     # Project 
#    Q:       \\fs.emulab.net\groups\testbed\TG1 # Group
#    H:       \\fs.emulab.net\users\fish         # Creator
#    I:       \\fs.emulab.net\users\mike         # Swapper
#
# Creator/swapper information comes from tmcc via TMCREATOR()/TMSWAPPER() files.
# Any other user mounts require specifying the drive letter with the -d option.
# 
# The Services For Unix (SFU 3.5) NFS client commands are used underneath,
# and CygWin symlinks are made to point to the /cygdrive/driveletter mount,
# completing the Unix-like illusion.

sub usage()
{
    print "Usage: emount [-v] [-d driveletter:] remotehost:path localpath\n";
    print "   or: emount [-v] [-d driveletter:] username\n";
    print "   or: emount\n";
    exit(1);
}
my $optlist     = "vd:";
my $verbose     = 0;
my $driveletter = "";
my $remote      = "";
my $local       = "";
my $username    = "";

# Drag in path stuff so we can find emulab stuff.
BEGIN { require "/etc/emulab/paths.pm"; import emulabpaths; }

#
# Turn off line buffering on output
#
$| = 1;

#
# Load the OS independent support library. It will load the OS dependent
# library and initialize itself. 
# 
use libsetup;
use liblocsetup;

#
# Parse command arguments. Once we return from getopts, all that should be
# left are the positional arguments.
#
%options = ();
if (! getopts($optlist, \%options)) {
    usage();
}
if (defined($options{"v"})) {
    $verbose = 1;
}
if (defined($options{"d"})) {
    $driveletter = $options{"d"};
}
if (@ARGV == 0 ) {
    system("$NET use");
    exit(0);
}
elsif (@ARGV == 1) {
    $username = $ARGV[0];
    $local = "/users/$username";
    $remote = "fs.emulab.net:$local";
}
elsif (@ARGV == 2) {
    $remote = $ARGV[0];
    $local = $ARGV[1];
}
else {
    usage();
}

my $cmd;

# Infer the drive letter from what's being mounted.
my($project, $group, $user);
$driveletter = "S:"
    if (!$driveletter && $remote =~ m|:/share$|);
$driveletter = "P:"
    if (!$driveletter && (($project) = ($remote =~ m|:/q/proj/([-[:alnum:]]+)$|)) );
$driveletter = "Q:"
    if (!$driveletter && (($project, $group) = 
	($remote =~ m|:/q/proj/([-[:alnum:]]+)/([-[:alnum:]]+)$|)) );
if (!$driveletter && (($user) = ($remote =~ m|:/users/([-[:alnum:]]+)|))) {
    my $tmcreator = TMCREATOR();
    my $tmswapper = TMSWAPPER();
    my $creator = `cat $tmcreator`;
    my $swapper = `cat $tmswapper`;
    $creator =~ s/\n//;
    $swapper =~ s/\n//;
    ##print "user '$user', creator '$creator', swapper '$swapper'\n";

    $driveletter = "H:"
	if ($user eq $creator);
    $driveletter = "I:"
	if (!$driveletter && $user eq $swapper);
}
print "Using drive letter $driveletter\n"
    if ($verbose && $driveletter);

if (!$driveletter) {
    print STDERR "emount: Must specify a drive letter.\n";
    exit(1);
}

# Make sure that mount persistence is off.
os_noisycmd("$NET use /persistent:no", 0);

# Mount onto a drive letter using the Services For Unix NFS client.
print "Mounting remote directory '$remote' on drive letter '$driveletter'.\n"
    if ($verbose);
$cmd = "$SFCMOUNT $remote $driveletter";
if (os_noisycmd($cmd, $verbose) != 0) {
    print STDERR "emount: Failed SFU mount, $cmd.\n";
    exit(1);
}
    
# Make the CygWin symlink from the local path to the driveletter automount point.
my $localdir = $local;
$localdir =~ s|(.*)/.*|$1|;
my $cygdrive = "/cygdrive/" . lc(substr($driveletter, 0, 1));
if (length($localdir) && ! -e $localdir) {
    print "Making CygWin '$localdir' directory to contain symlinks.\n"
	if ($verbose);
    if (! os_mkdir($localdir, "0777")) { # Writable so anybody can make symlinks.
	print STDERR "emount: Failed CygWin mkdir, $cmd.\n";
	exit(1);
    }
}
if (-e $local) {
    print "Removing previous CygWin symlink '$local'.\n"
	if ($verbose);
    $cmd = "$CHOWN `id -un` $local";
    if (system($cmd) != 0) {
	print STDERR "emount: Failed to take ownership of symlink, $cmd.\n";
    }
    $cmd = "$RM -f $local";
    if (system($cmd) != 0) {
	print STDERR "emount: Failed to remove previous CygWin symlink, $cmd.\n";
	exit(1);
    }
}
print "Making CygWin symlink '$local' to '$cygdrive'.\n"
    if ($verbose);
$cmd = "$LN -f -s $cygdrive $local";
if (system($cmd) != 0) {
    print STDERR "emount: Failed CygWin symlink, $cmd.\n";
    exit(1);
}

exit(0);

