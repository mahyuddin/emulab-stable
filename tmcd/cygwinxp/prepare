#!/usr/bin/perl -w
#
# EMULAB-COPYRIGHT
# Copyright (c) 2000-2005 University of Utah and the Flux Group.
# All rights reserved.
#
use English;
require 'ctime.pl';

#
# Prepare the node for cutting a new image.  Should be run just prior.
#
# Note: No /etc/dumpdates support on CygWin, and no /etc/fstab or /var/account either.
my @DBFILES     = ();
my @VARDIRS	= ("logs", "db", "jails", "boot", "lock", "lib/dhcp");
my $LOGDIR      = "/var/log";
my $RUNDIR      = "/var/run";
my $SOURCES     = "/home/root/flux/testbed";
my $OBJS        = "/home/root/flux/obj-real";
my $HISTORY     = "/home/root/.bash_history";
my $MAILFILE    = "/var/spool/mail/root";
my $NTPDRIFT    = "/etc/ntp/drift";

#
# Dead wood in $BINDIR
# If you remove/move a script, list it here so that it goes away when the
# image is remade.
#
my @DEADFILES	= ("rc.agents", "rc.delayagent", "rc.delta", "rc.healthd",
		   "rc.injail", "rc.ipod", "rc.mfs", "rc.progagent",
		   "rc.setup", "rc.slothd", "rc.testbed",
		   "batchcmddone", "bootsetup", "install-tarfile",
		   "jailsetup", "update_delays", "rc/rc.linux",
		   "sethostname", # replaced by sethostname.dhclient on linux
		   "startssh", "stopssh", "rc/rc.cygwinxp-user"
		   );

# Drag in path stuff so we can find emulab stuff.
BEGIN { require "/etc/emulab/paths.pm"; import emulabpaths; }

# Only root.
if ($EUID != 0) {
    die("*** $0:\n".
	"    Must be root to run this script!\n");
}

#
# Need the current root password to re-define the Emulab services to match.
#
use Term::ReadKey;
my $rootpwd = "";
while ($rootpwd eq "") {
    print "Enter the root password: ";
    ReadMode 'noecho';
    $rootpwd = ReadLine 0;
    chomp $rootpwd;
    ReadMode 'normal';
    print "\n";
}
my $rootpwd2 = "";
while ($rootpwd2 eq "" || $rootpwd ne $rootpwd2) {
    print "Didn't match, try again.\n"
	if $rootpwd2 ne "" && $rootpwd ne $rootpwd2;
    print "Re-enter the root password: ";
    ReadMode 'noecho';
    $rootpwd2 = ReadLine 0;
    chomp $rootpwd2;
    ReadMode 'normal';
    print "\n";
}

#
# Windows stores the password as part of the definition of services that run
# as a real user, such as root, rather than as SYSTEM.  Redefine them with the
# current password.  Otherwise, Windows will refuse to start them up at reboot.
#
print "\nRedefining EmulabShutdown.\n";
# Have to remove a service before you can redefine it.
system("cygrunsrv -R EmulabShutdown");
system("cygrunsrv -I EmulabShutdown -u root -w \"$rootpwd\"" .
       " -p /cygdrive/c/cygwin/bin/bash" .
       " --shutdown --type manual" .
       " -a \"--norc --noprofile -c '/usr/local/etc/emulab/tbshutdown'\"");
system("cygrunsrv -VQ EmulabShutdown");
print "\nRedefining EmulabStartup.\n";
my $firstboot = "/usr/local/etc/emulab/rc/rc.firstboot";
my $bootsetup = "/usr/local/etc/emulab/rc/rc.bootsetup";
my $progrun = "cygrunsrv -S ProgAgent";
my $bootlog = "/var/log/bootsetup.log";
system("cygrunsrv -R EmulabStartup");
system("cygrunsrv -I EmulabStartup -u root -w \"$rootpwd\"" .
       " --dep DHCP --dep elvinsvc.exe --dep W32Time" .
       " -p /cygdrive/c/cygwin/bin/bash" .
       " -a \"--norc --noprofile -c " .
       "      '( $firstboot; $bootsetup; $progrun ) >& $bootlog'\"");
system("cygrunsrv -VQ EmulabStartup");

#
# Turn off line buffering on output
#
$| = 1;

#
# Load the OS independent support library. It will load the OS dependent
# library and initialize itself. 
# 
use libsetup;

# Capture the node name before cleaning out the config files.
my $vname = "";
if (open(NICK, TMNICKNAME)) {
    $vname = <NICK>;
    chomp $vname;
    $vname =~ s/\..*//;
    close(NICK);
}

#
# First clean up the node as it would be if free.
#
cleanup_node(1);

print "Running $BINDIR/rc/rc.config to clean up ...\n";
system("$BINDIR/rc/rc.config reset");

print "Removing old DB files ...\n";
foreach my $dbfile (@DBFILES) {
    if (-e $dbfile) {
	unlink($dbfile) or
	    die("Could not unlink $dbfile");
    }
}

# Stop anything holding a logfile open which we will want to remove below.
print "Stopping the watchdog ...\n";
system("$BINDIR/watchdog stop");

print "Stopping the program-agent ...\n";
system("$BINDIR/rc/rc.progagent shutdown");

print "Stopping emulab-syncd ...\n";
system("$BINDIR/rc/rc.syncserver shutdown");

print "Stopping slothd ...\n";
system("$BINDIR/rc/rc.slothd stop");
my $pidfile = "/var/run/slothd.pid";
unlink($pidfile) or
    warn("Could not unlink $pidfile");

print "Stopping evproxy ...\n";
system("killall evproxy");
$pidfile = "/var/run/evproxy.pid";
unlink($pidfile) or
    warn("Could not unlink $pidfile");

# Logfiles.
print "Cleaning logfiles ...\n";
opendir(LOG,$LOGDIR) or
    die("Could not open directory $LOGDIR: $!");

while ($dirent = readdir(LOG)) {
    my $file = $LOGDIR . "/" . $dirent;
    if (-f $file) {
        if (($file =~ /\.\d$/) || ($file =~ /\.\d\.gz$/)) {
            # Remove archived logfiles
            unlink($file) or
                die("Could not unlink $file: $!");
        } elsif (-s $file) {
            # Truncate other logfiles - many do not get re-created
            truncate($file,0) or
		system("chown root $file") and system("chmod 666 $file") 
		    and truncate($file,0) or
			warn("Could not truncate $file: $!");
        }
    }
}
closedir(LOG);

print "Removing root's history ...\n";
if (-f $HISTORY) {
    unlink($HISTORY) or
        die("Could not unlink $HISTORY: $!");
}

print "Removing root's mailfile ...\n";
if (-f $MAILFILE) {
    unlink($MAILFILE) or
        die("Could not unlink $MAILFILE: $!");
}

#
# Just removing the drift file gives an error, so set it to zero instead.
# Watchdog never sends zero drift files to the DB so we lose nothing.
#
print "Resetting drift in $NTPDRIFT ...\n";
if (-f $NTPDRIFT) {
    open(DRIFT, ">$NTPDRIFT") or
	die("Could not open $NTPDRIFT: $!");
    print DRIFT "0\n";
    close(DRIFT);
}

print "Clearing out testbed sources $SOURCES...\n";
system("rm -rf $SOURCES");

print "Clearing out testbed sources $OBJS...\n";
system("rm -rf $OBJS");

print "Clearing out $RUNDIR ...\n";
system("rm -rf $RUNDIR/*.pid");

print "Clearing out /tmp ...\n";
system("chmod -Rf 777 /tmp/* /tmp/.??* >& /dev/null");
system("chown -Rf root /tmp >& /dev/null");
system("rm -rf /tmp/* /tmp/.??*");

print "Cleaning out /local/logs ...\n";
system("chown -R root /local/logs");
system("rm -rf /local/logs/* /local/logs/.??*");

print "Cleaning out Windows logs ...\n";
system("chown root C:/windows/{iis6,setupapi}.log");
system("rm -f C:/windows/{iis6,setupapi}.log");

print "Clearing out C:/TEMP ...\n";
system("chown -R root C:/TEMP");
system("rm -rf C:/TEMP/* C:/TEMP/.??*");

print "Clearing out directories in $VARDIR ...\n";
foreach my $dir (@VARDIRS) {
    if (-d "$VARDIR/$dir") {
	system("rm -rf $VARDIR/$dir/*");
    }
}

print "Clearing out old Emulab scripts and binaries in $BINDIR ...\n";
foreach my $file (@DEADFILES) {
    if (-f "$BINDIR/$file") {
	unlink("$BINDIR/$file") or
	    warn("*** could not remove $BINDIR/$file\n");
    }
}

print "Removing backup files in /etc\n";

opendir(ETC,"/etc") or
    die ("Couldn't open /etc: $!");

while ($dirent = readdir(ETC)) {
    my $file = "/etc/" . $dirent;
    if (-f $file) {
	if (($file =~ /~$/) || ($file =~ /-$/)) {
	    unlink($file) or
		die ("Couldn't unlink $file: $!");
	}
    }
}
closedir(ETC);

print "Updating /etc/motd.\n";
if (open(MOTD, ">/etc/motd")) {
    open(UNAME, "uname -sr |");
    my $uname = <UNAME>;
    chomp $uname;
    close(UNAME);
    printf MOTD "%s, Windows-XP + %s, %s\n", $vname, $uname, scalar(localtime());
    print MOTD "\n\nWelcome to Windows in Emulab!\n\n";
    close(MOTD);
}
else {
    warn("Could not open /etc/motd!\n");
}

print "Cleaning out sp2 & Windows Update dirs.\n";
system("du -sm C:/WINDOWS/\\\$*");
system("rm -rf C:/WINDOWS/\\\$*");
system("du -sm C:/WINDOWS/ServicePackFiles/i386");
system("rm -rf C:/WINDOWS/ServicePackFiles/i386");
system("du -sm C:/WINDOWS/SoftwareDistribution/Download");
system("rm -rf C:/WINDOWS/SoftwareDistribution/Download/*");

print "Re-enable all network interfaces.\n";
system("devcon enable =net 'PCI*'");
