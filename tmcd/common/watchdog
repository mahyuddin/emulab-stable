#!/usr/bin/perl -w
#
# EMULAB-COPYRIGHT
# Copyright (c) 2000-2004 University of Utah and the Flux Group.
# All rights reserved.
#
use Getopt::Std;
use English;
use Errno;
use POSIX qw(strftime);

#
# The Emulab watchdog. Currently, not really much of a watchdog. Simply
# contacts tmcd to find out if it needs to do an update.
#
sub usage()
{
    print "Usage: watchdog [-dv] [start | stop]\n";
    exit(1);
}
my $optlist = "Fdv";

#
# Turn off line buffering on output
#
$| = 1;

# Drag in path stuff so we can find emulab stuff.
BEGIN { require "/etc/emulab/paths.pm"; import emulabpaths; }

#
# Load the OS independent support library. It will load the OS dependent
# library and initialize itself. 
# 
use libsetup;
use libtmcc;

# XXX should be in libsetup
my $svcslice    = "utah_elab_svc";
sub PLABSVC() {
    return (PLAB() &&
	(defined($ENV{'USER'}) && ($ENV{'USER'} eq $svcslice) ||
	 defined($ENV{'SUDO_USER'}) && ($ENV{'SUDO_USER'} eq $svcslice)));
}

# Locals
my $action	= "start";
my $logname	= "$LOGDIR/emulab-watchdog.log";
my $pidfile	= "/var/run/emulab-watchdog.pid";
my $rusagebin	= "$BINDIR/plabrusage";
my $debug	= 0;
my $verbose     = 0;
my $updatefailed= 0;
my $driftfile;
my $lastdrift;
my $rusagestr;
my $curtime;

# tmcc retries
my $trytcp = 0;
my $maxretries  = 3;
my %retry;

# XXX testing
my $fakeit;
my %faketimes;

#
# Default interval values in seconds.
# Compatible with old, static watchdog.
#
my %iv = (
    check   => 0,
    isalive => ((REMOTE() == 1) ? (PLAB() ? 600 : 60) : (JAILED() ? 600 : 180)),
    drift   => (60 * 60 * 12),
    cvsup   => (60 * 60 * 12),
    rusage  => 0,
);

my %funcs = (
    check   => \&setintervals,
    isalive => \&sendisalive,
    drift   => \&ntpdrift,
    cvsup   => \&runcvsup,
    rusage  => \&sendrusage,
);

#
# Forward declarations for prototype checking
#
sub setintervals($);
sub sendisalive($);
sub ntpdrift($);
sub runcvsup($);
sub sendrusage($);
sub logmsg($);

#
# Parse command arguments. Once we return from getopts, all that should be
# left are the required arguments.
#
%options = ();
if (! getopts($optlist, \%options)) {
    usage();
}
if (defined($options{"d"})) {
    $debug = 1;
}
if (defined($options{"v"})) {
    $verbose = 1;
}
if (defined($options{"F"})) {
    $fakeit = 1;
}
if (@ARGV) {
    $action = $ARGV[0];

    if (@ARGV != 1 || ($action ne "start" && $action ne "stop")) {
	usage();
    }
}

#
# Must be root.
# 
if ($UID != 0) {
    die("*** $0:\n".
	"    Must be root to run this script!\n");
}

#
# For stop, look to see if the pid file exists. If so, kill it and exit.
#
if ($action eq "stop") {
    if (! -e $pidfile) {
	exit(0);
    }
    system("kill `cat $pidfile`");
    sleep(1);
    exit($? >> 8);
}

#
# Put this into the background and log its output. We *must* do this cause
# we do not want to halt the boot if the testbed is down!
# 
if (!$debug && TBBackGround($logname)) {
    #
    # Parent exits normally
    #
    select(undef, undef, undef, 0.25);
    exit(0);
}

#
# Write our pid into the pid file so we can be killed later. We must
# do this first so that we can be killed before we change the sig
# handlers.
#
system("echo '$PID' > $pidfile") == 0
    or die("Could not create $pidfile!");

#
# Setup a handler to catch TERM, and kill our process group.
#
my $pgrp = getpgrp(0);

sub handler () {
    $SIG{TERM} = 'IGNORE';
    $SIG{INT} = 'IGNORE';
    kill('TERM', -$pgrp);
    unlink($pidfile);
    sleep(5);
    exit(0);
}
$SIG{TERM} = \&handler;
$SIG{INT}  = \&handler;

#
# If jailed, get our jailname. 
#
if (JAILED() || PLAB()) {
    my $vnodeid = libsetup_getvnodeid();
    # Tell the tmcc library. Note that its actually been done via libsetup
    # but I duplicate it here to make it explicit.
    configtmcc("subnode", $vnodeid);
}

#
# XXX plab UDP calls sometimes fail with EINVAL when reading a reply,
#     combat this by forcing the last retry of a failing call to use TCP
#     in the plab service slice.  Maybe we should do this for all plab
#     slices...
# XXX ok, really bad idea.  This just causes all our tmcd processes to
#     get hung with open connections to flaky plab machines
#
#$trytcp = 1 if (PLABSVC());

#
# For sending back ntpdrift.
# 
if (-e "/etc/ntp.drift") {
    $driftfile = "/etc/ntp.drift";
} elsif (-e "/etc/ntp/drift") {
    $driftfile = "/etc/ntp/drift";
}

#
# Initial drift value, we only update if it changes
#
if (defined($driftfile)) {
    $lastdrift = `cat $driftfile`;
    chomp($lastdrift);
}

#
# Retry state for failed tmcc calls
#
$retry{check} = 0;
$retry{isalive} = 0;
$retry{drift} = 0;
$retry{rusage} = 0;

$curtime = time();
if ($fakeit) {
    logmsg("Faking it\n");
} else {
    logmsg("Dogging it\n");
}

#
# Set our initial interval values.
# This will queue the interval check.
#
my $firsttime = 1;
setintervals($curtime);
$firsttime = 0;

#
# Loop, sleeping and then processing events
# 
while (1) {
    my ($nexttime, $event);

    $curtime = time();

    qhead($nexttime, $event) == 0 or
	die("All timeouts disabled at $date!");

    while ($curtime >= $nexttime) {
	qpop($nexttime, $event);
	&$event($curtime);
	qhead($nexttime, $event) == 0 or
	    die("All timeouts disabled at $date!");
	$curtime = time();
    }

    sleep($nexttime - $curtime);
}

exit(0);

sub sendisalive($)
{
    my ($curtime) = @_;
    
    if ($fakeit) {
	my $delta = $curtime - $faketimes{isalive};
	$faketimes{isalive} = $curtime;
	logmsg("sendisalive at +$delta\n");
	qinsert($curtime + $iv{isalive}, \&sendisalive) if ($iv{isalive});
	return;
    }

    if ($verbose) {
	if ($retry{isalive} == 0) {
	    logmsg("isalive: sending\n");
	} else {
	    logmsg("isalive: resending, retry=$retry{isalive}\n");
	}
    }

    my %tmccargs = ();
    $tmccargs{timeout} = 3;
    $tmccargs{useudp} = 1
	if (!$trytcp || $retry{isalive} != $maxretries);

    my @tmccresults;
    if (tmcc(TMCCCMD_ISALIVE, undef, \@tmccresults, %tmccargs) != 0 ||
	scalar(@tmccresults) == 0) {
	#
	# Failed, schedule a retry using a backoff.
	#
	if ($retry{isalive} < $maxretries) {
	    my $nexttime = time() + (1 << $retry{isalive});
	    qinsert($nexttime, \&sendisalive);
	    $retry{isalive}++;
	    logmsg("isalive: failed ($?), retry $retry{isalive}\n");
	    return;
	}
	#
	# Failed miserably, just whine and reschedule at the normal time.
	#
	logmsg("isalive: failed ($?) after $maxretries attempts\n");
    } else {
	#
	# Success.  The format of the response is rather simple right now.
	# Note: if the update failed last time, run it no matter what.
	#
	logmsg("isalive: succeeded after $retry{isalive} retries\n")
	    if ($retry{isalive});
	if ($updatefailed ||
	    $tmccresults[0] =~ /^UPDATE=1$/) {
	    logmsg("isalive: running an account update\n");
	    system("$BINDIR/update -i -l");
	    $updatefailed = $?;
	    logmsg("isalive: update done\n");
	}
    }

    #
    # Set up for another interval.
    # Since the tmcc call and update can take awhile, we update curtime
    #
    $retry{isalive} = 0;
    $curtime = time();
    qinsert($curtime + $iv{isalive}, \&sendisalive)
	if ($iv{isalive});
}

sub setintervals($)
{
    my ($curtime) = @_;
    my $report = 0;

    if ($fakeit) {
	$iv{check} = 7;
	$iv{isalive} = 3;
	$iv{drift} = 9;
	$iv{cvsup} = 21;
	$iv{rusage} = 15;

	my $delta = $curtime - $faketimes{check};
	$faketimes{check} = $curtime;

	logmsg("setintervals at +$delta\n");
	qinsert($curtime + $iv{check}, \&setintervals) if ($iv{check});
	return;
    }

    if ($verbose) {
	if ($retry{check} == 0) {
	    logmsg("setintervals: fetching intervals\n");
	} else {
	    logmsg("setintervals: refetching intervals, retry=$retry{check}\n");
	}
    }

    # XXX fake an argument to force request to TMCD and avoid the cache
    my $arg = "foo";

    my %tmccargs = ();
    $tmccargs{timeout} = 3;
    $tmccargs{useudp} = 1
	if (!$trytcp || $retry{check} != $maxretries);

    my @tmccresults;
    if (tmcc(TMCCCMD_WATCHDOGINFO, $arg, \@tmccresults, %tmccargs) != 0 ||
	scalar(@tmccresults) == 0) {
	#
	# Failed, schedule a retry using a backoff.
	#
	if ($retry{check} < $maxretries) {
	    my $nexttime = time() + (1 << $retry{check});
	    qinsert($nexttime, \&setintervals);
	    $retry{check}++;
	    logmsg("setintervals: failed ($?), retry $retry{check}\n");
	    return;
	}
	#
	# Failed miserably, just whine and reschedule at the normal time.
	#
	logmsg("setintervals: failed ($?) after $maxretries attempts, ".
	       "using current values\n");
	$report = 1;
    } else {
	#
	# Success.
	#
	logmsg("setintervals: succeeded after $retry{check} retries\n")
	    if ($retry{check});

	my %oiv;
	$oiv{check} = $iv{check};
	$oiv{isalive} = $iv{isalive};
	$oiv{drift} = $iv{drift};
	$oiv{cvsup} = $iv{cvsup};
	$oiv{rusage} = $iv{rusage};

	if ($tmccresults[0] =~
	    /INTERVAL=(-?\d+) ISALIVE=(-?\d+) NTPDRIFT=(-?\d+) CVSUP=(-?\d+) RUSAGE=(-?\d+)/) {
	    $iv{check} = $1
		if ($1 >= 0);
	    $iv{isalive} = $2
		if ($2 >= 0);
	    $iv{drift} = $3
		if ($3 >= 0);
	    $iv{cvsup} = $4
		if ($4 >= 0);
	    $iv{rusage} = $5
		if ($5 >= 0);
	}

	#
	# MFS nodes only report isalive
	#
	if (MFS()) {
	    $iv{drift} = 0;
	    $iv{cvsup} = 0;
	    $iv{rusage} = 0;
	}

	foreach my $key (keys %iv) {
	    if ($firsttime || $iv{$key} != $oiv{$key}) {
		$report = 1;

		#
		# Special handling of ourselves:
		# warn if future checks are disabled.
		#
		if ($key eq "check") {
		    if ($iv{$key} == 0) {
			logmsg("setintervals: ".
			       "WARNING interval checks disabled!\n");
		    } else {
			logmsg("setintervals: scheduling $key\n");
		    }
		    next;
		}

		if ($iv{$key} == 0) {
		    logmsg("setintervals: descheduling $key\n");
		    qdelete($funcs{$key});
		} elsif ($firsttime || $oiv{$key} == 0) {
		    logmsg("setintervals: scheduling $key\n");
		    #
		    # XXX special firsttime hack
		    # isalive and rusage must report immediately
		    #
		    if ($firsttime &&
			($key eq "isalive" || $key eq "rusage")) {
			qinsert($curtime, $funcs{$key});
		    } else {
			qinsert($curtime + $iv{$key}, $funcs{$key});
		    }
		} else {
		    #
		    # To reschedule an already existing event,
		    # we recompute when it was last scheduled and
		    # add the new interval to that.  If the result
		    # is before the current time, we set it to the
		    # current time so it will trigger immediately.
		    #
		    my $ntime = qfind($funcs{$key});
		    if (defined($ntime)) {
			$ntime -= $oiv{$key};
			$ntime += $iv{$key};
			$ntime = $curtime
			    if ($ntime < $curtime);
		    } else {
			$ntime = $curtime;
		    }
		    logmsg("setintervals: rescheduling $key at $ntime ".
			   "(now=$curtime)\n");
		    qinsert($ntime, $funcs{$key});
		}
	    }
	}
    }
	
    if ($report) {
	logmsg("setintervals: check=$iv{check}, isalive=$iv{isalive}, ".
	       "drift=$iv{drift}, cvsup=$iv{cvsup}, rusage=$iv{rusage}\n");
    }

    #
    # Set up for another interval.
    # Since the tmcc call can take awhile, we update curtime
    #
    $retry{check} = 0;
    $curtime = time();
    qinsert($curtime + $iv{check}, \&setintervals)
	if ($iv{check});
}

sub ntpdrift($)
{
    my ($curtime) = @_;
    
    if ($fakeit) {
	my $delta = $curtime - $faketimes{drift};
	$faketimes{drift} = $curtime;
	logmsg("ntpdrift at +$delta\n");
	qinsert($curtime + $iv{drift}, \&ntpdrift) if ($iv{drift});
	return;
    }

    logmsg("ntpdrift: reporting NTP drift\n")
	if ($verbose);

    my $drift = `cat $driftfile`;
    chomp($drift);
    
    if ($drift ne $lastdrift && $drift =~ /^([-\d\.]*)$/) {
	logmsg("ntpdrift: updating NTP drift from $lastdrift to $drift\n");

	# Server also checks the value for sanity.
	tmcc(TMCCCMD_NTPDRIFT, $1, undef, ("timeout" => 3));
	$lastdrift = $drift;
    }

    qinsert($curtime + $iv{drift}, \&ntpdrift)
	if ($iv{drift});
}

#
# Do a cvsup to get updated software.
# XXX fork this off?
#
sub runcvsup($)
{
    my ($curtime) = @_;
    
    if ($fakeit) {
	my $delta = $curtime - $faketimes{cvsup};
	$faketimes{cvsup} = $curtime;
	logmsg("runcvsup at +$delta\n");
	qinsert($curtime + $iv{cvsup}, \&runcvsup) if ($iv{cvsup});
	return;
    }

    logmsg("runcvsup: checking for software updates\n");

    system("$BINDIR/runcvsup.sh");

    logmsg("runcvsup: software updates done\n");

    # cvsup can take awhile so update curtime
    $curtime = time();

    qinsert($curtime + $iv{cvsup}, \&runcvsup)
	if ($iv{cvsup});
}

sub sendrusage($)
{
    my ($curtime) = @_;
    
    if ($fakeit) {
	my $delta = $curtime - $faketimes{rusage};
	$faketimes{rusage} = $curtime;
	logmsg("sendrusage at +$delta\n");
	qinsert($curtime + $iv{rusage}, \&sendrusage) if ($iv{rusage});
	return;
    }

    if ($verbose) {
	if ($retry{rusage} == 0) {
	    logmsg("rusage: sending\n");
	} else {
	    logmsg("rusage: resending, retry=$retry{rusage}\n");
	}
    }

    #
    # Collect the stats
    #
    if ($retry{rusage} == 0) {
	if (! -x $rusagebin) {
	    logmsg("rusage: no $rusagebin\n");
	    goto resched;
	}
	$rusagestr = `$rusagebin 2>>$LOGDIR/emulab-rusage.log`;
	if ($?) {
	    logmsg("rusage: $rusagebin failed ($?)\n");
	    goto resched;
	}
	chomp $rusagestr;
	if ($rusagestr !~ /LA1=[\d\.]+ LA5=[\d\.]+ LA15=[\d\.]+ DUSED=[\d\.]+/) {
	    logmsg("rusage: $rusagebin returns gobbledy-gook: $rusagestr\n");
	    goto resched;
	}
    }
    logmsg("rusage: sending: $rusagestr\n")
	if ($verbose);

    my %tmccargs = ();
    $tmccargs{timeout} = 3;
    $tmccargs{useudp} = 1
	if (!$trytcp || $retry{rusage} != $maxretries);

    my @tmccresults;
    if (tmcc(TMCCCMD_RUSAGE, $rusagestr, \@tmccresults, %tmccargs) != 0 ||
	scalar(@tmccresults) == 0) {
	#
	# Failed, schedule a retry using a backoff.
	#
	if ($retry{rusage} < $maxretries) {
	    my $nexttime = time() + (1 << $retry{rusage});
	    qinsert($nexttime, \&sendrusage);
	    $retry{rusage}++;
	    logmsg("rusage: failed ($?), retry $retry{rusage}\n");
	    return;
	}
	#
	# Failed miserably, just whine and reschedule at the normal time.
	#
	logmsg("rusage: failed ($?) after $maxretries attempts\n");
    } else {
	#
	# Success.  The format of the response is rather simple right now.
	# Note: if the update failed last time, run it no matter what.
	#
	logmsg("rusage: succeeded after $retry{rusage} retries\n")
	    if ($retry{rusage});
	if ($updatefailed ||
	    $tmccresults[0] =~ /^UPDATE=1$/) {
	    logmsg("rusage: running an account update\n");
	    system("$BINDIR/update -i -l");
	    $updatefailed = $?;
	    logmsg("rusage: update done\n");
	}
    }

resched:
    #
    # Set up for another interval.
    # Since the tmcc call and update can take awhile, we update curtime
    #
    $retry{rusage} = 0;
    $curtime = time();
    qinsert($curtime + $iv{rusage}, \&sendrusage)
	if ($iv{rusage});
}

sub logmsg($)
{
    my ($msg) = @_;

    print strftime("%b %e %H:%M:%S", localtime)." watchdog[$$]: $msg";
}

#
# The following are lifted from stated's TimeoutQueue package
# Replicated to avoid excess dependencies
#

@q = (); # The queue
%i = (); # The index

#
# qinsert($timeout,$obj) - returns 0
#   Insert an object.  Object must not already be in the list.
#
sub qinsert {
    my ($timeout, $obj) = @_;
    if (defined($i{$obj})) {
	# Already in there... take it out
	qdelete($obj);
    }
    my $loc = qsearch($timeout,0);
    my @l = ($timeout,$obj);
    splice(@q,$loc,0,\@l);
    $i{$obj} = $timeout;
    return 0;
}

#
# qdelete($obj)		 - returns 0, or 1 if not found
#   Delete an object
#
sub qdelete {
    my ($obj) = @_;
    if (!defined($i{$obj})) {
	return 1;
    }
    my $timeout = $i{$obj};
    my $n=qsearch($timeout,1);
    my $end = @q+0;
    while (1) {
	$o = ${$q[$n]}[1];
	if ($o eq $obj) {
	    splice(@q,$n,1);
	    last;
	}
	$n++;
	if ($n > $end) { return 1;}
    }
    delete $i{$obj};
    return 0;
}

#
# qhead(\$timeout,\$obj) - returns 0, or 1 if not found
#   Look at the head item
#
sub qhead {
    if (@q+0 == 0) { $_[0]=undef; $_[1]=undef; return 1; }
    $_[0] = ${$q[0]}[0];
    $_[1] = ${$q[0]}[1];
    return 0;
}

#
# qpop(\$timeout,\$obj)	 - returns 0, or 1 if empty
#   Remove and return the head item
#
sub qpop {
    if (@q+0 == 0) { $_[0]=undef; $_[1]=undef; return 1; }
    $_[0] = ${$q[0]}[0];
    $_[1] = ${$q[0]}[1];
    shift(@q);
    delete $i{$_[1]};
    return 0;
}

#
# qfind($obj)		 - returns timeout, or undef if not found
#   Find the timeout for an item
#
sub qfind {
    my ($obj) = @_;
    return $i{$obj};
}

#
# qsearch($timeout,$first) - returns index
#   Find the index in @q where ($first ? $timout starts : $timeout ends)
#
sub qsearch {
    my ($timeout,$first) = @_;
    return qbinsearch($timeout,0,@q+0,$first);
}

#
# qbinsearch($timeout,$min,$max,$first) - returns index
#   Find the index in @q where ($first ? $timout starts : $timeout ends)
#
sub qbinsearch {
    my ($timeout,$min,$max,$first) = @_;
    # Implement a binary search
    my $len = $max - $min;
    my $mid = $min + int($len/2);
    if ($len < 1) { return $mid; }
    my $val = ${$q[$mid]}[0];
    if ($first) {
	if ($val >= $timeout) { return qbinsearch($timeout,$min,$mid,$first); }
	else { return qbinsearch($timeout,$mid+1,$max,$first); }
    } else {
	if ($val > $timeout) { return qbinsearch($timeout,$min,$mid,$first); }
	else { return qbinsearch($timeout,$mid+1,$max,$first); }
    }
}
