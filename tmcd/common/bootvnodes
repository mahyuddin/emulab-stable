#!/usr/bin/perl -wT
#
# EMULAB-COPYRIGHT
# Copyright (c) 2000-2003 University of Utah and the Flux Group.
# All rights reserved.
#
use Getopt::Std;
use English;
use Errno;
use POSIX qw(strftime);

#
# Startup vnodes, if there are any!
#
# NB: This script should not be run in foreground mode on a remote node
# when booting; if boss is down the boot will hang. On local nodes, its
# okay to hang.
#
sub usage()
{
    print "Usage: bootvnodes [-d] [-f] [-k | -h]\n";
    exit(1);
}
my $optlist = "kdfh";

#
# Turn off line buffering on output
#
$| = 1;

# Drag in path stuff so we can find emulab stuff.
BEGIN { require "/etc/emulab/paths.pm"; import emulabpaths; }

#
# Load the OS independent support library. It will load the OS dependent
# library and initialize itself. 
# 
use libsetup;

# Locals
my $logname = "$LOGDIR/bootvnodes.debug";
my $vndir   = "/var/emulab/jails";
my $debug   = 0;
my $daemon  = 1;
my $killit  = 0;
my $haltit  = 0;

#
# Forward declarations for prototype checking
#
sub bootvnodes();

#
# Parse command arguments. Once we return from getopts, all that should be
# left are the required arguments.
#
%options = ();
if (! getopts($optlist, \%options)) {
    usage();
}
if (defined($options{"d"})) {
    $debug  = 1;
}
if (defined($options{"f"})) {
    $daemon = 0;
}
if (defined($options{"k"})) {
    $killit = 1;
}
if (defined($options{"h"})) {
    $haltit = 1;
}
if (@ARGV) {
    usage();
}

#
# Must be root.
# 
if ($UID != 0) {
    die("*** $0:\n".
	"    Must be root to run this script!\n");
}

#
# XXX
# Do not run the vnode startup on Linux nodes yet.
#
my $sysname = `uname -s`;
chomp($sysname);
if ($sysname eq "Linux") {
    exit(0);
}

#
# Put this into the background and log its output. We *must* do this cause
# we do not want to halt the boot if the testbed is down!
# 
if ($daemon && TBBackGround($logname)) {
    #
    # Parent exits normally
    #
    exit(0);
}

if ($killit | $haltit) {
    my $opt = ($haltit ? "-h" : "-k");
    my $act = ($haltit ? "Halting" : "Killing");
    
    print "$act vnodes ... please be patient ...\n";

    opendir(DIR, "/var/emulab/jails") or
	die("Cannot opendir /var/emulab/jails: $!\n");
    my @files = readdir(DIR);
    closedir(DIR);

    foreach my $file (@files) {
	if ($file ne "." && $file ne ".." &&
	    $file =~ /^([-\w]*)$/) {

	    print "$act vnode $1 ...\n";
	    system("vnodesetup $opt $1");
	}
    }
    exit(0);
}

my %curvnodelist;
my @vnodes;

#
# Get the current set of vnodes that are supposed to be running on
# this node.
#
my $TM = OPENTMCC(TMCCCMD_VNODELIST);
while (<$TM>) {
    if ($_ =~ /^VNODEID=([-\w]+) JAILED=(\d)$/) {
	$curvnodelist{$1} = $2;
    }
    else {
	print "Skipping bad vnodeid: '$_'\n";
    }
}
CLOSETMCC($TM);

@vnodes = keys(%curvnodelist);
if (! @vnodes) {
    print "No vnodes. Exiting gracefully ...\n";
    exit(0);
}
print "Vnodelist is @vnodes.\n";

#
# If booting with vnodes, then see about creating the extra FS.
# This will fail if it already exists. Keep going on any failure though.
#
if (!REMOTE()) {
    system("mkextrafs.pl $vndir");
}

#
# Make sure enough vn devices exist
#
for (my $i = 0; $i < scalar(@vnodes); $i++) {
    my $dev = "vn${i}";
    if (! -e "/dev/${dev}c") {
        system("(cd /dev; ./MAKEDEV $dev)");
    }
}

foreach my $vnode (keys(%curvnodelist)) {
    my $jailflag = "";
    if ($curvnodelist{$vnode}) {
	$jailflag = "-j";
    }
    print "Setting up vnode $vnode ...\n";
    # This will not return until the vnode is fully running.
    system("vnodesetup -b $jailflag $vnode");
    sleep(1);
}
exit(0);
