#!/usr/bin/perl -wT
#
# EMULAB-COPYRIGHT
# Copyright (c) 2000-2003 University of Utah and the Flux Group.
# All rights reserved.
#
use Getopt::Std;
use English;
use Fcntl ':flock';
use POSIX qw(strftime);

#
# Update the system with new accounts/mounts/etc. Use -i for immediate
# (no waiting if it cannot get the lock).
#
sub usage()
{
    print "Usage: update [-i] [-a] [-m] [-h] [-l]\n";
    exit(1);
}
my $optlist   = "imalh";
my $batchmode = 1;
my $doall     = 0;
my $accounts  = 0;
my $mounts    = 0;
my $hostsfile = 0;
my $immediate = 0;

# Drag in path stuff so we can find emulab stuff.
BEGIN { require "/etc/emulab/paths.pm"; import emulabpaths; }

#
# Load the OS independent support library. It will load the OS dependent
# library and initialize itself. 
# 
use libsetup;

#
# Turn off line buffering on output
#
$| = 1;

#
# Must either be setuid root (widearea), or it must run as root.
# 
if ($UID && $EUID) {
    if ($UID) {
	die("*** $0:\n".
	    "    Must be run as root!\n");
    }
    else {
	die("*** $0:\n".
	    "    Must be setuid root! Maybe not installed properly?\n");
    }
}

#
# If not invoked as real root, then must be invoked as emulabman.
#
if ($UID) {
    my ($pwname) = getpwuid($UID) or
	die("*** $0:\n".
	    "    $UID is not in the password file!\n");

    if ($pwname ne "emulabman") {
	die("*** $0:\n".
	    "    You do not have permission to run this script!\n");
    }

    #
    # But must run as real root!
    #
    $UID = 0;
}

#
# Parse command arguments. Once we return from getopts, all that should be
# left are the required arguments.
#
%options = ();
if (! getopts($optlist, \%options)) {
    usage();
}
if (defined($options{"i"})) {
    $batchmode = 0;
    $immediate = 1;
}
if (defined($options{"a"})) {
    $doall = 1;
}
if (defined($options{"l"})) {
    $accounts = 1;
}
if (defined($options{"m"})) {
    $mounts = 1;
}
if (defined($options{"h"})) {
    $hostsfile = 1;
}
if (@ARGV) {
    usage();
}
# Backwards compat; no options means mounts and accounts.
if (!$mounts && !$accounts && !$hostsfile) {
    $mounts = $accounts = 1;
}

#
# Local config.
#
my $lockfile  = "$LOCKDIR/node_update_lockfile";

#
# Reuse the same log file so we can track errors.
#
my $logname   = "$LOGDIR/account_update.debug";

#
# Put this into the background so that the ssh can return immediately.
# 
if ($batchmode && TBBackGround($logname)) {
    #
    # Parent exits normally
    #
    exit(0);
}

if ($batchmode) {
    my $date = POSIX::strftime("20%y/%m/%d %H:%M:%S", localtime());

    print "------------------------------------------------------------\n";
    print "$date\n";
    print "------------------------------------------------------------\n";
}

#
# We do not want multiple invocations of this script running concurrently!
# Use a lock file to serialze.
#
open(LOCK, ">>$lockfile") ||
    die("Could not open $lockfile\n");

my $count = 0;
while (flock(LOCK, LOCK_EX|LOCK_NB) == 0) {
    if ($immediate) {
	print "Another update in progress. Exiting ...\n";
	close(LOCK);
	exit(1);
    }
    print "Another update in progress. Waiting a moment ...\n";
   
    if ($count++ > 20) {
	die("Could not get the lock after a long time!\n");
    }
    sleep(5);
}

#
# When doing an update do not block forever. If no progress in 30 seconds
# just quit and try again later. For REMOTE() nodes, this is essential
# to avoid blocking at boot time.
#
$tmcctimeout = 30;

#
# Order matters!
#
if (($mounts || $doall) && !JAILED() && !PLAB()) {
    print "Updating project and home directories ... \n";

    if (domounts()) {
	die("*** $0:\n".
	    "    Failed to update mountpoints!\n");
    }
}

if (($hostsfile || $doall) && (!REMOTE() || PLAB())) {
    # Yes, the || PLAB() is intentional, since hostnames work on Plab
    print "Updating Testbed hostnames configuration ... \n";

    if (dohostnames()) {
	die("*** $0:\n".
	    "    Failed to update hosts file!\n");
    }
}

if ($accounts || $doall) {
    print "Updating groups and accounts ... \n";

    if (doaccounts()) {
	die("*** $0:\n".
	    "    Failed to update groups and accounts!\n");
    }
}

close(LOCK);
exit(0);
