#!/usr/bin/perl -wT
#
# EMULAB-COPYRIGHT
# Copyright (c) 2000-2002 University of Utah and the Flux Group.
# All rights reserved.
#
use Getopt::Std;
use English;
use Fcntl ':flock';
use POSIX qw(strftime);

#
# Update the system with new accounts/mounts/etc. Use -i for immediate
# (no waiting if it cannot get the lock).
#
sub usage()
{
    print "Usage: update [-i]\n";
    exit(1);
}
my $optlist   = "i";
my $batchmode = 1;
my $immediate = 0;

# Drag in path stuff so we can find emulab stuff.
BEGIN { require "/etc/emulab/paths.pm"; import emulabpaths; }

#
# Load the OS independent support library. It will load the OS dependent
# library and initialize itself. 
# 
use libsetup;

#
# Turn off line buffering on output
#
$| = 1;

#
# Must be setuid root.
# 
if ($EUID != 0) {
    die("*** $0:\n".
	"    Must be root! Maybe not installed properly?\n");
}

#
# Parse command arguments. Once we return from getopts, all that should be
# left are the required arguments.
#
%options = ();
if (! getopts($optlist, \%options)) {
    usage();
}
if (defined($options{"i"})) {
    $batchmode = 0;
    $immediate = 1;
}
if (@ARGV) {
    usage();
}

#
# If not invoked as real root, then must be invoked as emulabman.
#
if ($UID) {
    my ($pwname) = getpwuid($UID) or
	die("*** $0:\n".
	    "    $UID is not in the password file!\n");

    if ($pwname ne "emulabman") {
	die("*** $0:\n".
	    "    You do not have permission to run this script!\n");
    }

    #
    # But must run as real root!
    #
    $UID = 0;
}

#
# Local config.
#
my $lockfile  = "$LOCKDIR/node_update_lockfile";

#
# Reuse the same log file so we can track errors.
#
my $logname   = "$LOGDIR/account_update.debug";

#
# Put this into the background so that the ssh can return immediately.
# 
if ($batchmode && TBBackGround($logname)) {
    #
    # Parent exits normally
    #
    exit(0);
}

if ($batchmode) {
    my $date = POSIX::strftime("20%y/%m/%d %H:%M:%S", localtime());

    print "------------------------------------------------------------\n";
    print "$date\n";
    print "------------------------------------------------------------\n";
}

#
# We do not want multiple invocations of this script running concurrently!
# Use a lock file to serialze.
#
open(LOCK, ">>$lockfile") ||
    die("Could not open $lockfile\n");

my $count = 0;
while (flock(LOCK, LOCK_EX|LOCK_NB) == 0) {
    if ($immediate) {
	print "Another update in progress. Exiting ...\n";
	close(LOCK);
	exit(1);
    }
    print "Another update in progress. Waiting a moment ...\n";
   
    if ($count++ > 20) {
	die("Could not get the lock after a long time!\n");
    }
    sleep(5);
}

my $failed = nodeupdate();

close(LOCK);
exit($failed);
