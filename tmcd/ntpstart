#!/usr/bin/perl -w
#
# EMULAB-COPYRIGHT
# Copyright (c) 2000-2002 University of Utah and the Flux Group.
# All rights reserved.
#
use English;

#
# Fire up ntp from /etc/rc. This is a strict wrapper so it should be
# invoked from /etc/rc.conf as such:
#
#	xntpd_program="/usr/local/etc/emulab/ntpstart"
#	xntpd_flags="/usr/sbin/ntpd -p /var/run/ntpd.pid"
#
# which is to say that this program passes it entire argument list to
# off to the shell once it sets up the config file. We fire off ntp
# no matter what happens though.
#

#
# Untaint path
#
$ENV{'PATH'} = '/bin:/sbin:/usr/bin:/usr/local/bin:/etc/testbed';
delete @ENV{'IFS', 'CDPATH', 'ENV', 'BASH_ENV'};

#
# Turn off line buffering on output
#
$| = 1;

#
# Load the OS independent support library. It will load the OS dependent
# library and initialize itself. 
# 
use lib "/usr/local/etc/emulab";
use libsetup;

# Locals
my @ntpinfo	= ();
my $useold	= 1;
my $newfile     = "/tmp/ntp.conf.new";
my $ntpfile     = "/etc/ntp.conf";
my $driftfile   = "/etc/ntp.drift";
my $pidfile	= "/var/run/ntpd.pid";
my $debug       = 0;

#
# Since this is a wrapper, we have to try to start ntp no matter what.
#
sub ntpstart () {
    if ($debug) {
	print "@ARGV\n";
	return 0;
    }
    system("@ARGV");
    return ($? >> 8);
}

#
# Ask for setup. If none then we are done. If provided with a drift value
# but no servers/peers, then need to leave the config alone and just
# replace the drift file.
# 
my $TM = OPENTMCC("ntpinfo");
while (<$TM>) {
    chomp();
    if ($_ =~ /^PEER=.*$/ ||
	$_ =~ /^SERVER=.*$/) {
	$useold = 0;
    }
    push(@ntpinfo, $_);
}
CLOSETMCC($TM);
if (! @ntpinfo) {
    exit(ntpstart());
}

#
# We are going to copy the old file to a new file, munging it as we go.
# Note that if the server did not provide any servers or peers, we want
# to use whatever is in the original file, but we still have to read it
# to find the name of the driftfile. So, just make a copy and throw it
# away later if it turns out we do not need a new version.
#
open(NEW, "> $newfile")
    or fatal("Could not open $newfile: $!");
open(NTP, "< $ntpfile")
    or fatal("Could not open $ntpfile: $!");

while (<NTP>) {
    chomp();
    SWITCH1: {
	/^peer.*$/ && do {
	    last SWITCH1;
	};
	/^server.*$/ && do {
	    last SWITCH1;
	};
	/^driftfile[\s]*(\/.*)$/ && do {
	    $driftfile = $1;
	};
	print NEW "$_\n";
    }
}

#
# Okay, now tack on the servers and peers to the new file. The drift
# goes into the driftfile. 
# 
foreach my $line (@ntpinfo) {
    $_ = $line;

    SWITCH1: {
	/^PEER=(.*)$/ && do {
	    print NEW "peer $1\n";
	    last SWITCH1;
	};
	/^SERVER=(.*)$/ && do {
	    print NEW "server $1\n";
	    last SWITCH1;
	};
	/^DRIFT=(.*)$/ && do {
	    open(DRIFT, "> $driftfile");
	    print DRIFT "$1\n";
	    close(DRIFT);
	    last SWITCH1;
	};
    }
}

close(NTP)
    or fatal("Could not close $ntpfile: $!");
close(NEW)
    or fatal("Could not close $newfile: $!");

#
# If it turns out we want to use the old file (no servers/peers provided)
# then start ntp and exit. The new file is thrown away ...
#
if ($useold) {
    exit(ntpstart());
}

#
# Okay, back up the old file and replace it with the new file!
#
system("cp -fp $ntpfile $ntpfile.old");
if ($?) {
    fatal("Could not backup $ntpfile to $ntpfile.old\n");
}
system("cp -fp $newfile $ntpfile");
if ($?) {
    fatal("Could not replace $ntpfile with $newfile\n");
}
exit(ntpstart());

#
# Print error and exit, but must start ntp anyway!
#
sub fatal($)
{
    my ($msg) = @_;

    print STDERR "*** $0:\n" .
	         "    $msg\n";
    exit(ntpstart());
}

