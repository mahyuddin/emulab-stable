#!/bin/sh
#
# EMULAB-COPYRIGHT
# Copyright (c) 2000-2005 University of Utah and the Flux Group.
# All rights reserved.
#

if [ -r /etc/emulab/paths.sh ]; then
	. /etc/emulab/paths.sh
else
	BINDIR=/etc/testbed
	BOOTDIR=/var/emulab/boot
fi

disk="ad0"

case $# in
1)
	part=$1
	;;
2)
	part=$1
	disk=$2
	;;
*)
	echo "Usage: $0 partition [disk]"
	exit 1
esac

dofreebsd() {
	#
	# ARGH!  FreeBSD 5, which primarily uses UFS2, internally converts
	# UFS1 filesystems to an updated, UFS2 compatible form.  However,
	# some of the converted fields leak back to disk when the filesystem
	# is unmounted, creating the potential for corruption in the following
	# scenerio:
	#
	# 1. mount, update, and unmount a UFS1 FS under FBSD5
	# 2. mount, update, and unmount the FS under FBSD4
	# 3. go back and access the FS under FBSD5
	#
	# #2 will update the old version of the csum structure.  At step
	# #3, the mount will see some of the leaked info from the unmount
	# in #1 and determine that it has already "upgraded" this FS and
	# thus doesn't need to copy the old csum into the new one.  The
	# result is that it will use stale csum info.
	#
	# In theory we could encounter this problem when we slicefix
	# a newly loaded FBSD image (#1), boot up and update stuff on
	# the image (#2), and then create a new image with imagezip
	# (#3, as imagezip uses the FBSD5 filesystem logic).
	#
	# How do we deal with this?  What we will have to do is either
	# fix the FBSD5 filesystem code or we will have to run a little
	# hack after the slicefix unmount to undo the damage that FBSD5
	# does.  Currently I have not done either.  Instead we avoid the
	# problem as follows.  Before making any change to the FS with
	# slicefix, we first RO-mount the FS to see if anything needs to
	# be done.  If not, we just leave it alone.  Since I currently
	# create all new images on machines with "ad" disks and that is
	# what the default fstab contains for its root device, we avoid
	# making any mods with slicefix and thus avoid #1 above.
	#
	# This is clearly not a solution.
	#
	version=`uname -v | sed -e 's/FreeBSD \([0-9]\).*/\1/'`

	# see if there is a root ('a') partition on this BSD slice
	`disklabel ${disk}s${part} 2>&1 | grep -s -E '^[ ]+a:' >/dev/null` || {
		return 1
	}

	rootdev=/dev/${disk}s${part}a
	echo "fixing FreeBSD root partition ${disk}s${part}a"
	fsck -p $rootdev || {
		echo "Fsck of $rootdev failed"
		return 1
	}
	mount -o ro $rootdev /mnt || {
		echo "RO-mount of $rootdev failed"
		return 1
	}

	# If our disk appears anywhere in fstab, assume we are good to go
	if `grep "^/dev/${disk}s" /mnt/etc/fstab >/dev/null 2>&1`; then
		umount $rootdev
		return 0
	fi

	# We need to change something, remount RW and change it
	umount $rootdev
	mount $rootdev /mnt || {
		echo "Mount of $rootdev failed"
		return 1
	}
	sed -E -i .orig -e "s;^/dev/[a-zA-Z]+[0-9]+s[0-9]+;/dev/${disk}s${part};" /mnt/etc/fstab || {
		echo "Failed to update /etc/fstab"
		umount $rootdev
		return 1
	}
	sed -E -i .orig -e "s;^/dev/[a-zA-Z]+[0-9]+s[0-9]+;/dev/${disk}s${part};" /mnt/etc/dumpdates || {
		echo "Failed to update /etc/dumpdates"
		umount $rootdev
		return 1
	}
	umount $rootdev

	# XXX need to fixup FS, see big comment above
	if [ "x$version" = "x5" ]; then
		echo "WARNING: FBSD5 may have modified the UFS1 root FS"
	fi

	return 0
}

#
# echo the name of the kernel that lilo will boot by default
#
lilogetkernel() {
    _lconf=$1
    _re='[a-zA-Z][-_\.a-zA-Z0-9]*'

    # see if there is a default= line and prefer that
    linux=`grep -E "default=$_re" $_lconf | sed -e "s/default=\($_re\).*/\1/"`

    # no explicit default, use first kernel listed
    if [ "x${linux}" = x ]; then
	linux=`grep -E "label=$_re" $_lconf | head -1 | \
		sed -e "s/label=\($_re\).*/\1/"`
    fi

    # still no hit, just use 'linux'
    linux=${linux:-'linux'}

    echo $linux
}

dolinux() {
	# figure out the linux device name
	dunit=`echo $disk | sed -e 's/..\([0-7]\)/\1/'`
	case $disk in
	# IDE
	ad[0-3])
		dtype="hd"
		d=`echo $dunit | sed -e 'y/0123/048c/'`
		lrootdev="3${d}${part}"
		;;
	# SATA
	ad[4-7])
		dtype="sd"
		dunit=`expr $dunit - 4`
		lrootdev="8${dunit}${part}"
		;;
	# SCSI
	da[0-7])
		dtype="sd"
		lrootdev="8${dunit}${part}"
		;;
	# Megaraid
	amrd[0-7])
		dunit=`echo $disk | sed -e 's/amrd\([0-7]\)/\1/'`
		dtype="sd"
		lrootdev="8${dunit}${part}"
		;;
	*)
		echo "slicefix: linux: unknown disk $disk"
		return 1
		;;
	esac
	dunit=`echo $dunit | sed -e 'y/01234567/abcdefgh/'`;
	ldisk=$dtype$dunit

	# attempt to mount filesystem   
	rootdev=/dev/${disk}s${part}
	mount -t ext2fs $rootdev /mnt || {
		echo "EXT2FS mount of $rootdev failed"
		return 1
	}

	# change the swap devices in fstab
	sed -i .orig -e "s;^/dev/[hs]d.\([0-7]\);/dev/${ldisk}\1;" /mnt/etc/fstab || {
		echo "Failed to update /etc/fstab"
		umount $rootdev
		return 1
	}

	#
	# If using lilo, update lilo.conf and set indicator to tell Emulab
	# to rerun lilo.
	#
	linux=
	lconf=/mnt/etc/lilo.conf
	if [ -r $lconf ]; then
	    sed -i .orig -e "s;\([br]oot=/dev\)/[hs]d.\([0-7]\);\1/${ldisk}\2;" $lconf || {
		    echo "Failed to update /etc/lilo.conf"
		    umount $rootdev
		    return 1
	    }

	    # XXX note the hardwired path, cannot use BOOTDIR as it is
	    # different in frisbee MFS.  This also assumes Linux partition
	    # is one big filesystem.
	    cp /dev/null /mnt/var/emulab/boot/runlilo

	    # grab the default linux kernel to boot
	    linux=`lilogetkernel $lconf`
	fi

	umount $rootdev

	if [ "x${linux}" != x ]; then
	    # setup one time lilo command line, must be done after unmount
	    $BINDIR/groklilo -c "$linux root=$lrootdev" $part /dev/$disk || {
		echo "Failed to set LILO command line"
		return 1
	    }
	fi

	return 0
}

fixone() {
    echo "*** ${disk}s${part}:"
    ptype=`fdisk -${part} ${disk} | grep sysid | sed 's/^sysid \([0-9][0-9]*\).*/\1/'`
    ptype=${ptype:-0}

    case $ptype in
    165)
	dofreebsd
	return $?
	;;
    131)
	dolinux
	return $?
	;;
    0)
	echo "unused"
	;;
    *)
	echo "ignoring partition type $ptype"
	;;
    esac
    return 0
}

case $part in
0)
    part=1; fixone
    part=2; fixone
    part=3; fixone
    part=4; fixone

    # when fixing all partitions, do not fail on an error
    if [ $? -ne 0 ]; then
    	echo "WARNING: failed to fix one or more partitions, BEWARE!"
    fi

    # for the CD boot, we need to intialize the magic boot block
    if [ -e /cdrom.inf -a -x $BINDIR/tbbootconfig ]; then
	$BINDIR/tbbootconfig -f -c 1 -k 0 -m 1 /dev/${disk}
    fi
    ;;
1|2|3|4)
    fixone
    ;;
*)
    echo "bad partition: $part"
    false
    ;;
esac

exit $?
