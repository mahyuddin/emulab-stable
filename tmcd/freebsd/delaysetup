#!/usr/bin/perl -w
#
# EMULAB-COPYRIGHT
# Copyright (c) 2000-2006 University of Utah and the Flux Group.
# All rights reserved.
#
use English;
use Getopt::Std;

#
# Setup/Update the system with new delays. Use -i for install mode, which
# means to run the scripts so that the delays are installed. Use -u for
# uninstall mode, which really only makes sense when used in conjunction
# with -j. On a real delay node, no real need to do an uninstall; an install
# flushes the current rules for the entire node. 
#
sub usage()
{
    print "Usage: delaysetup [-i | -u] [-j <vnodeid>]\n";
    exit(1);
}
my $optlist	= "iuj:";
my $install	= 0;
my $uninstall	= 0;
my $vnodeid;

# Drag in path stuff so we can find emulab stuff.
BEGIN { require "/etc/emulab/paths.pm"; import emulabpaths; }

#
# Turn off line buffering on output
#
$| = 1;

#
# Load the OS independent support library. It will load the OS dependent
# library and initialize itself.
#
use libsetup;
use libtmcc;

#
# Must be root.
#
if ($EUID) {
    die("*** $0:\n".
	"    Must be run as root!\n");
}

#
# Parse command arguments. Once we return from getopts, all that should be
# left are the required arguments.
#
%options = ();
if (! getopts($optlist, \%options)) {
    usage();
}
if (defined($options{"i"})) {
    $install = 1;
}
if (defined($options{"u"})) {
    $uninstall = 1;
}
if (defined($options{"j"})) {
    $vnodeid = $options{"j"};
    libsetup_setvnodeid($vnodeid);
    # Tell tmcc library, although thats already been done with previous call.
    configtmcc("subnode", $vnodeid);
}
if (@ARGV) {
    usage();
}
sub checkkernel($);

$FBSD_VERSION = `uname -v`;

if ($FBSD_VERSION =~ /FreeBSD ([0-9]).*/) {
    $FBSD_VERSION = int($1);
}
else {
    die("*** $0:\n".
	"    Cannot determine version\n");
}

#
# Delay node configuration goop.
#
my $KERNEL100	= "/kernel.100HZ";
my $KERNEL1000  = "/kernel.1000HZ";
my $KERNEL10000 = "/kernel.10000HZ";
my $KERNELDELAY = "/kernel.delay";	# New images. Linked to kernel.10000HZ
my $KERNELJAIL  = "/kernel.jail";	# Specific to jails (with linkdelays).
my $KERNELLDELAY= "/kernel.linkdelay";	# Link delay kernel.

# This should never happen!
if (REMOTE() || MFS()) {
    print "Skipping delay configuration on remote/MFS node!\n";
    exit(0);
}

print "Checking Testbed delay configuration ... \n";

# Uninstall just looks for the files, runs them, and exits.
if ($uninstall) {
    system(TMDELAY . " disable")
	if (-e TMDELAY);

    system(TMLINKDELAY . " disable")
	if (-e TMLINKDELAY);
    exit(0);
}

#
# Update the delays configuration. Also run the the commands to make
# the changes. Since a node cannot be doing delays and linkdelays at the
# same time, try each and exit.
#
DelaySetup();
if (-e TMDELAY) {
    system(TMDELAY . " enable")
	if ($install);
    exit(0);
}

LinkDelaySetup();
if (-e TMLINKDELAY) {
    system(TMLINKDELAY . " enable")
	if ($install);
    exit(0);
}
exit(0);

#
# This sets up delays on a delay node.
#
sub DelaySetup
{
    my @delays;
    my $checkreplace = 0;
    my $kernel;

    # Lets clean out old instructions.
    unlink TMDELAY;
    unlink TMDELMAP;

    if (tmcc(TMCCCMD_DELAY, undef, \@delays) < 0) {
	warn("*** WARNING: Could not get delays from server!\n");
	return -1;
    }

    if (@delays) {
	my $count    = 69;
	my $mindelay = 10000;

	open(MAP, ">" . TMDELMAP)
	    or die("Could not open " . TMDELMAP . ": $!");

	open(DEL, ">" . TMDELAY)
	    or die("Could not open " . TMDELAY . ": $!");

	print DEL "#!/bin/sh\n";
	# Turn these off before setting bridge_cfg.
	if ($FBSD_VERSION <= 4) {
	    print DEL "sysctl -w net.link.ether.bridge=0\n";
	    print DEL "sysctl -w net.link.ether.bridge_ipfw=0\n";
	    print DEL "sysctl -w net.link.ether.bridge_cfg=";
	}
	else {
	    print DEL "sysctl -w net.link.ether.bridge.enable=0\n";
	    print DEL "sysctl -w net.link.ether.bridge.ipfw=0\n";
	    print DEL "sysctl -w net.link.ether.bridge.config=";
	}

	foreach $delay (@delays) {
	    $delay =~ /DELAY INT0=([\d\w]+) INT1=([\d\w]+) /;
	    my $iface1 = findiface($1);
	    my $iface2 = findiface($2);

	    print DEL "$iface1:$count,$iface2:$count,";
	    $count++;
	}
	print DEL "\n";
	# Now turn them back on.
	if ($FBSD_VERSION <= 4) {
	    print DEL "sysctl -w net.link.ether.bridge=1\n";
	    print DEL "sysctl -w net.link.ether.bridge_ipfw=1\n";
	}
	else {
	    print DEL "sysctl -w net.link.ether.bridge.enable=1\n";
	    print DEL "sysctl -w net.link.ether.bridge.ipfw=1\n";
	}
	print DEL "ipfw -f flush\n";

 	#
 	# If we are in a new-style image that uses a polling-based kernel
 	# turn on polling.
 	#
 	if (-e $KERNELDELAY) {
 	    print DEL "sysctl -w kern.polling.enable=1\n";
 	}

	foreach $delay (@delays) {
	    my $pat  = q(DELAY INT0=([\d\w]+) INT1=([\d\w]+) );
	    $pat .= q(PIPE0=(\d+) DELAY0=([\d\.]+) BW0=(\d+) PLR0=([\d\.]+) );
	    $pat .= q(PIPE1=(\d+) DELAY1=([\d\.]+) BW1=(\d+) PLR1=([\d\.]+) );
	    $pat .= q(LINKNAME=([-\d\w]+) );
	    $pat .= q(RED0=(\d) RED1=(\d) );
	    $pat .= q(LIMIT0=(\d+) );
	    $pat .= q(MAXTHRESH0=(\d+) MINTHRESH0=(\d+) WEIGHT0=([\d\.]+) );
	    $pat .= q(LINTERM0=(\d+) QINBYTES0=(\d+) BYTES0=(\d+) );
	    $pat .= q(MEANPSIZE0=(\d+) WAIT0=(\d+) SETBIT0=(\d+) );
	    $pat .= q(DROPTAIL0=(\d+) GENTLE0=(\d+) );
	    $pat .= q(LIMIT1=(\d+) );
	    $pat .= q(MAXTHRESH1=(\d+) MINTHRESH1=(\d+) WEIGHT1=([\d\.]+) );
	    $pat .= q(LINTERM1=(\d+) QINBYTES1=(\d+) BYTES1=(\d+) );
	    $pat .= q(MEANPSIZE1=(\d+) WAIT1=(\d+) SETBIT1=(\d+) );
	    $pat .= q(DROPTAIL1=(\d+) GENTLE1=(\d+) );
	    $pat .= q(VNODE0=([-\d\w]+) VNODE1=([-\d\w]+) );
	    $pat .= q(NOSHAPING=(\d+));

	    $delay =~ /$pat/;

	    #
	    # tmcd returns the interfaces as MAC addrs.
	    #
	    my $iface1 = findiface($1);
	    my $iface2 = findiface($2);
	    my $p1        = $3;
	    my $delay1    = $4;
	    my $bandw1    = $5;
	    my $plr1      = $6;
	    my $p2        = $7;
	    my $delay2    = $8;
	    my $bandw2    = $9;
	    my $plr2      = $10;
	    my $linkname  = $11;
	    my $red1      = $12;
	    my $red2      = $13;

	    #
	    # Only a few of these NS RED params make sense for dummynet,
	    # but they all come through; someday they might be used.
	    #
	    my $limit1     = $14;
	    my $maxthresh1 = $15;
	    my $minthresh1 = $16;
	    my $weight1    = $17;
	    my $linterm1   = $18;
	    my $qinbytes1  = $19;
	    my $bytes1     = $20;
	    my $meanpsize1 = $21;
	    my $wait1      = $22;
	    my $setbit1    = $23;
	    my $droptail1  = $24;
	    my $gentle1    = $25;
	    my $limit2     = $26;
	    my $maxthresh2 = $27;
	    my $minthresh2 = $28;
	    my $weight2    = $29;
	    my $linterm2   = $30;
	    my $qinbytes2  = $31;
	    my $bytes2     = $32;
	    my $meanpsize2 = $33;
	    my $wait2      = $34;
	    my $setbit2    = $35;
	    my $droptail2  = $36;
	    my $gentle2    = $37;
	    my $vnode0     = $38;
	    my $vnode1     = $39;
	    my $noshaping  = $40;

	    #
	    # Noshaping. All we wanted was to set up the bridge (above).
	    # We do not want to actually delay the packets via a pipe,
	    # and we do not want a queuing!
	    #
	    next
		if ($noshaping);

	    #
	    # Delays are floating point numbers (unit is ms). ipfw does not
	    # support floats, so apply a cheesy rounding function to convert
            # to an integer (since perl does not have a builtin way to
	    # properly round a floating point number to an integer).
	    #
	    $delay1 = int($delay1 + 0.5);
	    $delay2 = int($delay2 + 0.5);

	    #
	    # Qsizes are in slots or packets. My perusal of the 4.3 code
	    # shows the limits are 50 < slots <= 100 or 0 <= bytes <= 1MB.
	    #
	    my $queue1 = "";
	    my $queue2 = "";
	    if ($qinbytes1) {
		if ($limit1 <= 0 || $limit1 > (1024 * 1024)) {
		    print "Q limit $limit1 for pipe $p1 is bogus.\n";
		}
		else {
		    $queue1 = "queue ${limit1}bytes";
		}
	    }
	    elsif ($limit1 != 0) {
		if ($limit1 < 0 || $limit1 > 100) {
		    print "Q limit $limit1 for pipe $p1 is bogus.\n";
		}
		else {
		    $queue1 = "queue $limit1";
		}
	    }
	    if ($qinbytes2) {
		if ($limit2 <= 0 || $limit2 > (1024 * 1024)) {
		    print "Q limit $limit2 for pipe $p2 is bogus.\n";
		}
		else {
		    $queue2 = "queue ${limit2}bytes";
		}
	    }
	    elsif ($limit2 != 0) {
		if ($limit2 < 0 || $limit2 > 100) {
		    print "Q limit $limit2 for pipe $p2 is bogus.\n";
		}
		else {
		    $queue2 = "queue $limit2";
		}
	    }

	    #
	    # RED/GRED stuff
	    #
	    my $redparams1 = "";
	    my $redparams2 = "";
	    if ($red1) {
		if ($gentle1) {
		    $redparams1 = "gred ";
		}
		else {
		    $redparams1 = "red ";
		}
		my $max_p = 1 / $linterm1;
		$redparams1 .= "$weight1/$minthresh1/$maxthresh1/$max_p";
	    }
	    if ($red2) {
		if ($gentle2) {
		    $redparams2 = "gred ";
		}
		else {
		    $redparams2 = "red ";
		}
		my $max_p = 1 / $linterm2;
		$redparams2 .= "$weight2/$minthresh2/$maxthresh2/$max_p";
	    }

	    print DEL "ipfw add pipe $p1 ip from any to any in recv $iface1\n";
	    print DEL "ipfw add pipe $p2 ip from any to any in recv $iface2\n";
	    print DEL "ipfw pipe $p1 config delay ${delay1}ms ";
	    print DEL "bw ${bandw1}Kbit/s plr $plr1 $queue1 $redparams1\n";
	    print DEL "ipfw pipe $p2 config delay ${delay2}ms ";
	    print DEL "bw ${bandw2}Kbit/s plr $plr2 $queue2 $redparams2\n";

	    print STDOUT "  $iface1/$iface2 pipe $p1 config delay ";
	    print STDOUT "${delay1}ms bw ${bandw1}Kbit/s plr $plr1 ";
	    print STDOUT "$queue1 $redparams1\n";
	    print STDOUT "  $iface1/$iface2 pipe $p2 config delay ";
	    print STDOUT "${delay2}ms bw ${bandw2}Kbit/s plr $plr2 ";
	    print STDOUT "$queue2 $redparams2\n";

	    print MAP "$linkname duplex $vnode0 $vnode1 ".
		"$iface1 $iface2 $p1 $p2\n";
	}
	#
	# If a delay node, then lets report status and ready in so that batch
	# experiments do not become stuck.
	#
	printf DEL "%s %s 0\n", TMCC(), TMCCCMD_STARTSTAT();

	print DEL "echo \"Delay Configuration Complete\"\n";
	close(DEL);
	chmod(0755, TMDELAY);
	close(MAP);
	
	# Touch this file so that we globally know that the node is a delay
	# node. See routing setup. Need to avoid fastforwarding whenever we
	# have link delays.
	system("touch " . ISDELAYNODEPATH());

	#
	# Now do kernel configuration. All of the above work is wasted,
	# but such is life.
	#
 	if (-e $KERNELDELAY) {
 	    $kernel = $KERNELDELAY;
 	} else {
 	    $kernel = $KERNEL1000;
 	}
	$checkreplace = 1;
    }
    if ($checkreplace) {
	checkkernel($kernel);
    }
    return 0;
}

#
# This sets up linkdelays on an experimental node.
#
sub LinkDelaySetup
{
    my @delays;
    my @jails;
    my $kernel;
    my $checkreplace = 0;
    my $gotjails = (defined($vnodeid) ? 1 : 0);
    my $upcmds   = "";
    my $downcmds = "";

    # Lets clean out old instructions.
    unlink TMLINKDELAY;
    unlink TMDELMAP;

    #
    # We need to know if any jailed nodes. That changes which kernel
    # we want to boot. Temporary until the jail stuff is better tested.
    #
    if (!$gotjails) {
	if (tmcc(TMCCCMD_VNODELIST, undef, \@jails) < 0) {
	    warn("*** WARNING: Could not get jails from server!\n");
	    return -1;
	}
	foreach my $str (@jails) {
	    if ($str =~ /^VNODEID=([-\w]+) JAILED=(\d)$/) {
		if ($2) {
		    $gotjails++;
		}
	    }
	}
    }
    if ($gotjails) {
	$kernel = $KERNELJAIL;
	$checkreplace = 1;
    }

    # Get delay config.
    if (tmcc(TMCCCMD_LINKDELAYS, undef, \@delays) < 0) {
	warn("*** WARNING: Could not get link delays from server!\n");
	return -1;
    }

    if (@delays) {
	open(MAP, ">" . TMDELMAP)
	    or die("Could not open " . TMDELMAP . ": $!");

	open(DEL, ">" . TMLINKDELAY)
	    or die("Could not open " . TMLINKDELAY . ": $!");

	foreach $delay (@delays) {
	    my $pat = q(LINKDELAY IFACE=([\d\w]+) TYPE=(simplex|duplex) );
	    $pat .= q(LINKNAME=([-\d\w]+) VNODE=([-\d\w]+) );
	    $pat .= q(INET=([0-9.]*) MASK=([0-9.]*) );
	    $pat .= q(PIPE=(\d+) DELAY=([\d\.]+) BW=(\d+) PLR=([\d\.]+) );
	    $pat .= q(RPIPE=(\d+) RDELAY=([\d\.]+) RBW=(\d+) RPLR=([\d\.]+) );
	    $pat .= q(RED=(\d) LIMIT=(\d+) );
	    $pat .= q(MAXTHRESH=(\d+) MINTHRESH=(\d+) WEIGHT=([\d\.]+) );
	    $pat .= q(LINTERM=(\d+) QINBYTES=(\d+) BYTES=(\d+) );
	    $pat .= q(MEANPSIZE=(\d+) WAIT=(\d+) SETBIT=(\d+) );
	    $pat .= q(DROPTAIL=(\d+) GENTLE=(\d+));

	    $delay =~ /$pat/;

	    #
	    # tmcd returns the interfaces as MAC addrs.
	    #
	    my $iface     = findiface($1);
	    my $type      = $2;
	    my $linkname  = $3;
	    my $vnode     = $4;
	    my $inet      = $5;
	    my $mask      = $6;
	    my $pipeno    = $7;
	    my $delay     = $8;
	    my $bandw     = $9;
	    my $plr       = $10;
	    my $rpipeno   = $11;
	    my $rdelay    = $12;
	    my $rbandw    = $13;
	    my $rplr      = $14;
	    my $red       = $15;

	    #
	    # Only a few of these NS RED params make sense for dummynet,
	    # but they all come through; someday they might be used.
	    #
	    my $limit     = $16;
	    my $maxthresh = $17;
	    my $minthresh = $18;
	    my $weight    = $19;
	    my $linterm   = $20;
	    my $qinbytes  = $21;
	    my $bytes     = $22;
	    my $meanpsize = $23;
	    my $wait      = $24;
	    my $setbit    = $25;
	    my $droptail  = $26;
	    my $gentle    = $27;

	    #
	    # Delays are floating point numbers (unit is ms). ipfw does not
	    # support floats, so apply a cheesy rounding function to convert
            # to an integer (since perl does not have a builtin way to
	    # properly round a floating point number to an integer).
	    #
	    $delay  = int($delay + 0.5);
	    $rdelay = int($rdelay + 0.5);

	    #
	    # Qsizes are in slots or packets. My perusal of the 4.3 code
	    # shows the limits are 50 < slots <= 100 or 0 <= bytes <= 1MB.
	    #
	    my $queue = "";
	    if ($qinbytes) {
		if ($limit <= 0 || $limit > (1024 * 1024)) {
		    print "Q limit $limit for pipe $pipeno is bogus.\n";
		}
		else {
		    $queue = "queue ${limit}bytes";
		}
	    }
	    elsif ($limit != 0) {
		if ($limit < 0 || $limit > 100) {
		    print "Q limit $limit for pipe $pipeno is bogus.\n";
		}
		else {
		    $queue = "queue $limit";
		}
	    }

	    #
	    # RED/GRED stuff
	    #
	    my $redparams = "";
	    if ($red) {
		if ($gentle) {
		    $redparams = "gred ";
		}
		else {
		    $redparams = "red ";
		}
		my $max_p = 1 / $linterm;
		$redparams .= "$weight/$minthresh/$maxthresh/$max_p";
	    }

	    $upcmds .= "ifconfig $iface media 100baseTX mediaopt full-duplex";
	    $upcmds .= "\n";

	    $upcmds .= "ipfw add $pipeno pipe $pipeno ip from any to ".
		       "any out xmit $iface nexthop $inet:$mask\n";

	    $upcmds .= "ipfw pipe $pipeno config delay ${delay}ms " .
	               "bw ${bandw}Kbit/s plr $plr $queue $redparams\n";

	    $downcmds .= "ipfw pipe delete $pipeno\n";
	    $downcmds .= "ipfw delete $pipeno\n";

	    if ($type eq "duplex") {
		#
		# Want to force the reverse side to 1 queue slot to enforce
		# the proper bandwidth. Not ideal, especially since at 1000HZ
		# 1 queue slot is not enough. Make it 4 instead.
		#
		$upcmds .= "ipfw add $rpipeno pipe $rpipeno ip from any ".
		           "to any in recv $iface\n";

		$upcmds .= "ipfw pipe $rpipeno config delay ${rdelay}ms ".
		           "bw ${rbandw}Kbit/s plr $rplr queue 5\n";

		$downcmds .= "ipfw pipe delete $rpipeno\n";
		$downcmds .= "ipfw delete $rpipeno\n";
	    }

	    if ($type eq "duplex") {
		print MAP "$linkname duplex $vnode $vnode $iface $iface ".
		    "$pipeno $rpipeno\n";
	    }
	    else {
		print MAP "$linkname simplex $vnode $iface $pipeno\n";
	    }
	}
	close(MAP);

	print DEL "#!/bin/sh\n";
	print DEL "# auto-generated by libsetup.pm, DO NOT EDIT\n";
	# Main boot only.
	if (!defined($vnodeid)) {
	    print DEL "ipfw -f flush\n";
	}
	print DEL "if [ x\$1 = x ]; then action=enable; else action=\$1; fi\n";
	print DEL "case \"\$action\" in\n";
	print DEL "  enable)\n";
	print DEL "     $upcmds\n";
	# Turn off Flow-based IP (fast) forwarding since it causes packets
	# to bypass traffic shaping and ipfw. Stupid!
	print DEL "     sysctl -w net.inet.ip.fastforwarding=0\n";
	print DEL "     ;;\n";
	print DEL "  disable)\n";
	print DEL "     $downcmds\n";
	print DEL "     ;;\n";
	print DEL "esac\n";
	close(DEL);
	chmod(0755, TMLINKDELAY);

	# Touch this file so that we globally know that the node is a delay
	# node. See routing setup. Need to avoid fastforwarding whenever we
	# have link delays.
	system("touch " . ISDELAYNODEPATH());

	#
	# Now do kernel configuration. All of the above work is wasted,
	# but such is life.
	#
	if (!$gotjails) {
	    $kernel = $KERNELLDELAY;
	}
	$checkreplace = 1;
    }
    if ($checkreplace) {
	checkkernel($kernel);
    }
    return 0;
}

#
# Check kernel config, and reboot.
#
sub checkkernel($)
{
    my($kernel) = @_;

    print STDOUT "Making sure node is running $kernel ... \n";

    if (-e $kernel) {
	if (system("cmp -s /kernel $kernel") != 0) {
	    if (system("cp -f /kernel /kernel.save")) {
		print "Could not backup /kernel! Aborting kernel change\n";
	    }
	    elsif (! unlink("/kernel")) {
		print "Could not unlink /kernel! Aborting kernel change\n";
	    }
	    elsif (system("cp -f $kernel /kernel")) {
		print "Could not cp $kernel to /kernel!\n";
	    }
	    else {
		print "Copied $kernel to /kernel.\n";
		
		system("sync");
		system("reboot");
		#
		# Make sure that, even if the reboot command returns
		# before the node is totally down, this process doesn't
		# exit (otherwise, we would proceed with testbed setup)
		#
		sleep(10000);
	    }
	}
    }
    else {
	print "Kernel $kernel does not exist!\n";
    }
}
