#!/usr/bin/perl -wT
use Getopt::Std;
use English;
use Errno;
use POSIX qw(setsid);

#
# Setup a single virtual experiment.
#
sub usage()
{
    print "Usage: vnodesetup [-k] <vnodeid>\n".
	"Use the -k option to kill the virtual node.\n";
    exit(1);
}
my $optlist = "k";
my $killit  = 0;

#
# XXX deal with left over setups.
#     left over directories.
#     kill vtun log files.
# 

#
# Turn off line buffering on output
#
$| = 1;

#
# Untaint path
#
$ENV{'PATH'} = "/usr/local/etc/testbed:/bin:/sbin:/usr/bin:/usr/local/bin:" .
    "/usr/local/sbin";
delete @ENV{'IFS', 'CDPATH', 'ENV', 'BASH_ENV'};

#
# Load the OS independent support library. It will load the OS dependent
# library and initialize itself. 
# 
use lib "/usr/local/etc/testbed";
use libsetup;

#
# Forward declarations for prototype checking
#
sub killvnode();

#
# Parse command arguments. Once we return from getopts, all that should be
# left are the required arguments.
#
%options = ();
if (! getopts($optlist, \%options)) {
    usage();
}
if (defined($options{"k"})) {
    $killit = 1;
}
if (@ARGV != 1) {
    usage();
}
my $vnodeid = $ARGV[0];

if ($vnodeid =~ /^([\w]+)$/) {
    $vnodeid = $1;
}
else {
    die("Bad data in vnodeid: $vnodeid.");
}

#
# Hacky. All this path stuff is hacky.
# 
my $logname  = "/tmp/tbvnode-${vnodeid}.debug";
my $pidfile  = "/var/run/tbvnode-${vnodeid}.pid";
my $vnodedir = "/var/testbed/$vnodeid";

#
# If killing the virtual node, then kill the manager process. We use
# the negative signal number to send to the process group so that all
# stuff gets killed in one fell swoop.
#
if ($killit) {
    if (! -e $pidfile) {
	die("*** $0:\n".
	    "    No pid for $vnodeid manager!\n");
    }
    exit(killvnode());
}

#
# If the pidfile still exists, then something went wrong with a
# previous experiment (or teardown).
#
if (-e $pidfile) {
    print "Killing an already running vnode manager!\n";

    if (killvnode() == 0) {
	if (-e $pidfile) {
	    die("*** $0:\n".
		"    Not able to kill running vnode manager!\n");
	}
    }
    elsif ($!{ESRCH}) {
	#
	# If there was no such process, kill the pid file and go on.
	# 
	system("rm -f $pidfile");
	system("rm -rf $vnodedir");
    }
    else {
	die("*** $0:\n".
	    "    Not able to kill running vnode manager!\n");
    }
}

#
# Okay, lets and continue on so that ssh from Emulab exits right away.
# It will figure out we are okay via the ISUP. 
#
if (TBBackGround($logname)) {
    #
    # Parent exits normally
    #
    exit(0);
}

#
# Change our process group since we are a daemon. Not usually important,
# but we get called from the watchdog, and we do not want to be in
# its process group, or it will die when we get killed.
#
POSIX::setsid();

#
# Write our pid into the pid file so we can be killed later (when the
# experiment is torn down). We must do this first so that we can be
# killed before we change the sig handlers
#
open(PFILE, "> $pidfile")
    or die("Could not open $pidfile: $!");
print PFILE "$PID\n";
close(PFILE);

#
# Setup a handler to catch TERM, and kill our process group.
#
my $pgrp = getpgrp(0);

sub handler () {
    $SIG{TERM} = 'IGNORE';
    $SIG{INT} = 'IGNORE';
    print "Exiting\n";
    kill('TERM', -$pgrp);
    sleep(15);
    system("rm -rf $vnodedir");
    system("rm -f $pidfile");
    exit(0);
}
$SIG{TERM} = \&handler;
$SIG{INT}  = \&handler;

#
# Kill existing directory in case its still there.
# 
if (-e $vnodedir) {
    system("rm -rf $vnodedir");
}
mkdir($vnodedir, 0755) or
    die("*** $0:\n".
	"    Could not mkdir $vnodedir: $!\n");

#
# Inform the TMCD we are setting up. Use REBOOTED event for simplicity!
#
system("tmcc -n $vnodeid state REBOOTED");

#
# Invoke remotevnodesetup routine in the setup library. This will talk
# to tmcd and create the rc files.
#
if (!defined(remotenodevnodesetup($vnodeid, $vnodedir))) {
    #
    # Hmm, suddenly got free. 
    # 
    system("rm -f $pidfile");
    system("rm -rf $vnodedir");
    exit(0);
}

#
# Become real root so that route command works!
#
$UID = 0;

#
# Okay, now startup the scripts.
#
if (-e TMTUNNELCONFIG) {
    print "Starting Tunnels ...\n";
    TBForkCmd(TMTUNNELCONFIG);
}
sleep(5);

if (-e TMTRAFFICCONFIG) {
    print "Starting Traffic Generators ...\n";
    TBForkCmd(TMTRAFFICCONFIG);
}
sleep(1);

#
# Inform the TMCD we are ready.
#
system("tmcc -n $vnodeid state ISUP");

#
# Now we just sit and wait to be killed off by a signal sent to the
# process group. Everything should get killed. 
#
while (1) {
    sleep 5;
}

#
# Routine to kill a vnode manager by sending it a signal.
#
sub killvnode() {
    my $mpid = `cat $pidfile`;
    $mpid =~ s/\n//;
    # untaint
    if ($mpid =~ /^([-\@\w.]+)$/) {
	$mpid = $1;
    }
    else {
	die("*** $0:\n".
	    "    Bad data in pid: $mpid!\n");
    }
    if (kill('TERM', $mpid) == 0) {
	print"*** Could not kill(TERM) process $mpid: $!\n";
	return -1;
    }
    
    #
    # Wait for the pidfile to be removed. Do not wait too long though. 
    # 
    for (my $i = 0; $i < 30;) {
	sleep(5);
	if (! -e $pidfile) {
	    return 0;
	}
	$i += 5;
    }
    print "*** Not able to kill running vnode manager process $mpid!\n";
    return 0;
}

exit 0;
