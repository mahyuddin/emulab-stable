#!/bin/sh
#
# EMULAB-COPYRIGHT
# Copyright (c) 2000-2007 University of Utah and the Flux Group.
# All rights reserved.
#
# Optional flag argument says "do not reboot"
#

MBR_PATH=/etc/emulab

reboot=1
if [ $# -eq 1 -a "$1" = "-noreboot" ]; then
    reboot=0
fi

OS=`uname -s`

#
# Amount of memory in MB to leave for everyone else in the system.  If you
# get out-of-memory or vm_pager error while running frisbee, increase this.
#
RESIDMEM=32

if [ -r /etc/emulab/paths.sh ]; then
	. /etc/emulab/paths.sh
else
	BINDIR=/etc/testbed
	BOOTDIR=/etc/testbed
	ETCDIR=/etc/testbed
fi

# See if we can map drive names to BIOS numbers via EDD
if [ -x $BINDIR/get_edd_map.pl ]; then
	$BINDIR/get_edd_map.pl > $BOOTDIR/edd_map
fi


# Behave a little different on widearea nodes.
isrem=0
if [ -e $ETCDIR/isrem ]; then
    isrem=1
fi

get_value()
{
	local data="$1"
	local key="$2"

	echo $data | tr ' ' '\n' | sed -n "s/^$key=//p"
}

#
# Update the MBR of the given disk to the indicated "version."
#
# XXX this is somewhat of a hack right now.  We recognize two
# versions of the MBR:
#	v1 (partition 1 size 6281352)
#	v2 (partition 1 size 12305790)
# Currently we only install a new MBR if the existing one is the
# wrong size, just in case the user has customized the boot program.
#
install_mbr()
{
	local disk=$1
	local new_mbr_ver=$2
	local cur_mbr_ver=''

	if ! dd if=$disk of=/dev/null bs=512 count=1 2>/dev/null; then
			echo "WARNING: could not read from $disk, MBR not changed"
			return 255
	fi

	if [ "$OS" = Linux ]; then
		size=`echo -e 'u\np\nq' | fdisk $disk 2> /dev/null| \
			sed -n "s#^${disk}1 *. *[0-9]* *[0-9]* *\([0-9]*\).*\\$#\1#p"`
		size=`expr $size '*' 2`
	elif [ "$OS" = FreeBSD ]; then
		size=`fdisk -s ${disk##*/} 2>/dev/null | \
			sed -n -e 's/^ *1: *[0-9][0-9]* *\([0-9][0-9]*\).*$/\1/p'`
	fi

	case ${size}s in
		6281352s)
			cur_mbr_ver=1
			;;
		12305790s)
			cur_mbr_ver=2
			;;
		s)
			echo "Found no MBR on $disk, installing version $new_mbr_ver"
			;;
		*)
			echo "WARNING: custom MBR on $disk, not changed"
			return 0
			;;
	esac

	if [ "$cur_mbr_ver" = $new_mbr_ver ]; then
		return 0
	fi

	if ! [ -r $MBR_PATH/mbr{$new_mbr_ver}.dd ]; then
		echo "WARNING: cannot find MBR version $new_mbr_ver, not installed"
		return 255
	fi
	
	echo "Installing MBR version $new_mbr_ver ..."
	dd if=$MBR_PATH/mbr{$new_mbr_ver}.dd of=$disk bs=512 count=1

	# Linux won't re-read the partition table unless told to do so.
	# hdparm could be used for this, but it may not be installed.
	# fdisk tells the kernel to re-read the table after writing it
	# to disk, so we'll just use that.
	if [ $OS = Linux ]; then
		echo "Re-reading partition table ..."
		echo w | fdisk $disk > /dev/null 2>&1
	fi
}

#
# Function to zero all potential superblocks in the DOS partitions that
# could interfere with the OSes on the image being loaded.
#
# FreeBSD 4 or 5 goes out of its way to make this hard.  In FBSD4, we
# cannot overwrite the beginning of partitions that have a legit superblock.
# In FBSD5, DOS partitions that have a zero type cannot even be accessed.
# So we have to use the whole-disk special file using offsets extracted
# via fdisk.  This is unnecessary with Linux, but it's easier just to do it
# the same way on both OSs rather than have special-case code.
#
zap_superblocks()
{
	local disk=$1
	local offsets=''

	if [ $OS = Linux ]; then
		offsets=`echo -e 'u\np\nq' | fdisk $disk 2> /dev/null | \
			sed -n "s#^${disk}[0-9]* *. *[0-9]* *\([0-9]*\).*\\$#\1#p"`
	elif [ $OS = FreeBSD ]; then
		offsets=`fdisk -s ${disk##*/} 2>/dev/null | \
			sed -n -e 's/^[ 0-9]*: *\([0-9]*\).*$/\1/p'`
	fi

	if [ x"$offs" = x ]; then
		return 0
	fi

	echo -n "Invalidating old potential superblocks: "
	for off in $offsets; do
		echo -n "$off "
		dd if=/dev/zero of=$disk seek=$off bs=512 count=16 > /dev/null 2>&1
		if [ $? -ne 0 ]; then
			echo "WARNING: failed to invalidate $off"
		fi
	done
	echo ""

	return 0
}

get_buffer_sizes()
{
	local memargs
	local hostmem
	local bytes
	local datasegsz

	# set memory limits:
	#	allow $RESIDMEM MB for non-frisbee stuff
	#	split remaining memory (min of 2MB) between network/disk buffering
	#
	if [ $OS = FreeBSD ]; then
		hostmem=`sysctl -n hw.usermem`
		hostmem=`expr $hostmem / 1048576`
		if [ $hostmem -ge `expr $RESIDMEM + 2` ]; then
			hostmem=`expr $hostmem - $RESIDMEM`
			bytes=`expr $hostmem \* 1024`
			datasegsz=`ulimit -d`
			if [ $bytes -gt $datasegsz ]; then
			    bytes=$datasegsz
			    hostmem=`expr $bytes / 1024`
			    echo "WARNING: kernel limits buffering to $hostmem MB"
			fi
			ulimit -v $bytes

			## For GaTech we use more memory for disks since the disks are so slow
			#netmem=`expr $hostmem \* 1 / 3`
			#diskmem=`expr $hostmem \* 2 / 3`
			#memargs="-C $netmem -W $diskmem"

			# For Utah, we let the client split up the memory
			# (50/50, but no more chunk buffers than there are chunks in the image)
			memargs="-M $hostmem"
		fi
	fi

	echo $memargs
}

# FIXME shouldn't hard code "/images"
write_image()
{
	local address=$1
	local disk=$2
	local slice=$3
	local port=""
	local imagefile=""

	local protocol=${address%%://*}
	if [ $protocol = $address ]; then
		case $address in
			/*) protocol=file ;;
			*) protocol=frisbee ;;
		esac
	fi

	case $protocol in
		frisbee)
			port=${address##*:}
			if [ $port = $address ]; then
				echo "*** WARNING: no port specified for frisbee"
				return 255
			fi
			address=${address%%:*}
			;;
		http|https)
			server=${address%%/*}
			filename=${address#*/}

			if ! [ -d /images ]; then
				echo "Need to create or mount /images directory!"
				return 1
			fi

			if ! $BINDIR/mkextrafs.pl -f $disk /images; then
		    		echo "Could not create /images partition"
				return 1
			fi

			wget -nv -N -P /images \
				$protocol://$server/$filename
			rc=$?
			if [ $rc -eq 0 ]; then
				echo "wget succeeded getting the image"
			else
				echo "wget failed, status $rc"
				return 255
			fi
			imagefile=/images/${filename##*/}
			;;
		file)
			imagefile=/$address
			;;
		*)
			echo "*** WARNING: Unsupported protocol $protocol!"
			return 255
			;;
	esac

	$BINDIR/tmcc state RELOADING

	if [ $protocol = frisbee ]; then
		$BINDIR/frisbee -m $address -p $port -s $slice $FRISBEE_OPTS $disk
		rc=$?

		if [ $rc -ne 0 ]; then
			echo "Frisbee run failed, status $rc"
			return $rc
		fi

		echo "Frisbee run finished"
		rc=0
	else
		$BINDIR/imageunzip $IMAGEUNZIP_OPTS -s $slice $imagefile $disk
		rc=$?
	fi

	if mount | grep /images > /dev/null; then
		umount /images
	fi

	return $rc
}

$BINDIR/tmcc state RELOADSETUP

echo "Trying to get loadinfo data... "
time=30
while [ $time -gt 0 ]; do
	sleep 1
	LOADINFO=`$BINDIR/tmcc loadinfo`
	[ -n "$LOADINFO" ] && break
	time=$(( $time - 1 ))
done

if [ $time -eq 0 ]; then
	echo "*** Failed to get loadinfo data" 1>&2
	exit 2
fi

echo "Got loadinfo data"

BOSSINFO=`$BINDIR/tmcc bossinfo`
BOSSIP=${BOSSINFO##* }

# For testing purposes.
#BOSSINFO='boss.emulab.net 155.101.128.70'
#LOADINFO='ADDR=234.5.6.69:4444'

ADDRESS=`get_value "$LOADINFO" ADDR`
PARTOS=`get_value "$LOADINFO" PARTOS`
PARTITION=`get_value "$LOADINFO" PART`
PARTITION=${PARTITION:-'0'}
DISK=`get_value "$LOADINFO" DISK`
DISK=${DISK:-'ad0'}
ZFILL=`get_value "$LOADINFO" ZFILL`
ZFILL=${ZFILL:-'0'}
ACPI=`get_value "$LOADINFO" ACPI`
ASF=`get_value "$LOADINFO" ASF`
MBR=`get_value "$LOADINFO" MBRVERS`

FREEBSD_DISK=$DISK
# Convert from the FreeBSD device names to Linux device names
# if necessary.
if [ $OS = "Linux" ]; then
	case $DISK in
		[hs]d[a-z])
			;;
		*)
			DISK=`$BINDIR/freebsd_to_linux_disk $DISK 0` 
			DISK=${DISK%% *}
			;;
	esac

	# Try to map disks to BIOS drive numbers via EDD
	# The map is created now before we touch any disks
	# since we may need to use the MBR to determine
	# which disk is which.
	$BINDIR/get_edd_map > $BOOTDIR/edd_map 2>/dev/null
fi

FRISBEE_OPTS="-S $BOSSIP"

if [ -z "$ADDRESS" ]; then
	echo "Unable to get address for loading image"
	exit 1
fi

# FIXME shouldn't hardcode path
if [ -x /usr/sbin/ntpdate ]; then
	/usr/sbin/ntpdate -b $BOSSIP >/dev/null 2>&1
fi

if [ $PARTITION -ne 0 ]; then
	FRISBEE_OPTS="$FRISBEE_OPTS -s $PARTITION"
	case $PARTOS in
		FreeBSD) PTYPE=165 ;;
		OpenBSD) PTYPE=166 ;;
		Fedora|Linux)   PTYPE=131 ;;
	esac

	[ -n "$PTYPE" ] && FRISBEE_OPTS="$FRISBEE_OPTS -D $PTYPE"
fi

# Enable IPoD
if [ -r $BINDIR/rc.ipod ]; then
	. $BINDIR/rc.ipod
fi

FRISBEE_OPTS="$FRISBEE_OPTS `get_buffer_sizes`"

if [ -e $BOOTDIR/myip ]; then
	FRISBEE_OPTS="$FRISBEE_OPTS -i `cat $BOOTDIR/myip`"
fi
IMAGEUNZIP_OPTS="-o -O -W 32"

# ZFILL==1: use frisbee
# ZFILL==2: separate disk-wipe pass (not yet implemented)
if [ "$ZFILL" != "0" ]; then
	FRISBEE_OPTS="$FRISBEE_OPTS -z"
	IMAGEUNZIP_OPTS="$IMAGEUNZIP_OPTS -z"
fi

device=/dev/$DISK
if [ $PARTITION -ne 0 ]; then
	if [ $OS = Linux ]; then
		device=$device$PARTITION
	elif [ $OS = FreeBSD ]; then
		device=${device}s$PARTITION
	fi
fi

is_remote=0
[ -e $ETCDIR/isrem ] && is_remote=1

if [ $OS = FreeBSD ]; then
	# Make sure the necessary device files exist (only necessary on FreeBSD 4.x)
	# Note that we create partition files for all slices, not just slice 1,
	# for the benefit of the slicefix script.
	#
	if [ -x /dev/MAKEDEV -a ! -e /dev/$DISK ]; then
		(cd /dev; ./MAKEDEV $DISK ${DISK}s2a ${DISK}s3a ${DISK}s4a)
	fi 
fi

# For slice images, ensure that the MBR is the correct version
# and replace if not.
if [ "$PARTITION" != "0" ]; then
    install_mbr /dev/$DISK $MBR
    echo "Resizing final disk partition"
    growdisk -vW /dev/$DISK
fi

# If not zeroing the disk and we are loading a full disk image
# we need to ensure that we at least invalidate any old superblocks
# that might leak through (most likely in partition 4 which isn't
# touched by our current image).  We do this before running frisbee
# so that any legit filesystems loaded from the image work.

# Since we do it before frisbee, we are counting on the current
# MBR being the same as the MBR being layed down.  While not
# a reasonable assumption in general, it mostly works in our
# environment and at least won't hurt anything if not true.
if [ $is_remote -eq 0 -a $PARTITION -eq 0 -a $ZFILL -eq 0 ]; then
	zap_superblocks /dev/$DISK
fi

if [ $OS = FreeBSD ]; then
	# Make sure the write-cache is enabled on SCSI disks.  It makes a
	# huge difference.  We don't worry about data corruption in the
	# case of a crash, because we will just reload the disk again anyway
	# in that situation.
	#
	turncacheoff=0
	case $DISK in
	da*)
	    if [ -x $BINDIR/camwce ] && $BINDIR/camwce on $DISK; then
		turncacheoff=1;
	    fi
	    ;;
	esac
fi

write_image $ADDRESS /dev/$DISK $PARTITION
rc=$?
if [ $rc -ne 0 ]; then
	echo "Failed to write image to disk, status $rc"
	exit 1
fi

if [ $OS = FreeBSD ]; then
	# Turn the cache back off if we turned it on.
	# Is this sufficient to ensure the cache gets flushed?
	#
	if [ $turncacheoff -eq 1 ]; then
	    $BINDIR/camwce off $DISK
	fi
fi

# we resize the 4th partition after writing the image
# if we used a full disk image.  Otherwise, the resize
# happens before the image write in case we need the
# extra partition for an image fetched via HTTP.
if [ $PARTITION -eq 0 ]; then
    echo "Resizing final disk partition"
    growdisk -vW /dev/$DISK
fi

echo "Adjusting slice-related files"
export SLICEFIX_ACPI=$ACPI
export SLICEFIX_ASF=$ASF
$BINDIR/slicefix $PARTITION $FREEBSD_DISK
echo "Image load complete at `date`"

#
# If requested to reboot, do so.
#
# Note: there is a race condition with stated here.
# If we reboot immediately after sending RELOADDONE,
# it is possible that, under heavy server load, we will
# finish the reboot and reach the bootinfo stage before
# stated gets and processes our RELOADDONE.  So now we
# wait around after sending the RELOADDONE.  stated should
# force us to reboot when the transition takes place.
# For backward compatibility we use a new state: RELOADDONEV2.
# For paranoia we just wait around for awhile and then
# reboot anyway, just in case stated's reboot fails for
# some reason.
#
if [ $reboot -eq 1 ]; then
    $BINDIR/tmcc state RELOADDONEV2
    echo "Waiting for server to reboot us ..."
    if [ $isrem -eq 1 ]; then
	sleep 30
    else
	sleep 240
    fi
    echo "No response from server, rebooting myself ..."
    /sbin/reboot
    sleep 100
else
    $BINDIR/tmcc state RELOADDONE
fi

#echo "Failed to load disk, dropping to login prompt at `date`"
#exit 1
