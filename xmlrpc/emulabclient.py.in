#! /usr/bin/env python
#
# EMULAB-COPYRIGHT
# Copyright (c) 2004 University of Utah and the Flux Group.
# All rights reserved.
#
import sys
import socket
import os
import popen2
import getopt

MAXNSFILESIZE = (1024 * 512)

#
# This class defines a simple structure to return back to the caller.
# It includes the exit status of the command, and any output that it
# wants to send back. Why not return a tuple? Well, it appears that the
# python xmlrpc library requires that a singleton be returned from the
# server.
#
class ResponseBlock:
    def __init__(self, exitval, output):
        self.exitval = exitval
        self.output  = output
        return

#
# This class implements the client side of the XMLRPC interface to Emulab.
# We do not try to do any serious argument processing here, but just pass
# it all through to the server. This may not be ideal, but I do not want to
# do argument processing and checking in multiple places! This whole approach
# will need another look at some point, but the goal right now is to get
# something that looks like an RPC interface running quickly.
#
class emulabclient:
    #
    # Initialize the object. The server argument is intended to
    # make this class independent of how we talk to the server. It just needs
    # to export the same interface as the xmlrpclib ServerProxy class. 
    #
    def __init__(self, server, debug):
        self.VERSION = 0.1
        self.server  = server
        self.debug   = debug
        return

    ##
    # Echo a message, basically, prepend the host name to the parameter list.
    #
    # @param args The argument list to echo back.
    # @return The 'msg' value with this machine's name prepended.
    #
    def echo(self, *args):
        argdict = {};
        argdict["list"] = args
        response = self.server.echo(self.VERSION, argdict)
        print response["output"]
	return 0

    #
    # Start an experiment using batchexp. The wrinkle is that we have to
    # package up the NS file and pass it inline. 
    #
    def batchexp(self, *args):
        # The args are read-only, but I want a mutable version.
        arglist = [a for a in args];

	if len(arglist) == 0:
            print "batchexp: Must provide some arguments"
	    return -1

        #
        # Parse args. We do not try to do any checking, but rather just
        # convert them to functional arguments and place them into the
        # Dict that is passed along.
        #
        argdict = {};
        opt_args, req_args = getopt.getopt(arglist, "iE:g:e:p:S:L:a:l:fw")
        for opt, val in opt_args:
            if opt in ("-i"):
                argdict["batchmode"] = 0
                pass
            elif opt in ("-E"):
                argdict["description"] = val
                pass
            elif opt in ("-g"):
                argdict["gid"] = val
                pass
            elif opt in ("-e"):
                argdict["eid"] = val
                pass
            elif opt in ("-p"):
                argdict["pid"] = val
                pass
            elif opt in ("-S"):
                argdict["swapable"]      = 0
                argdict["noswap_reason"] = val
                pass
            elif opt in ("-L"):
                argdict["idleswap"]          = 0
                argdict["noidleswap_reason"] = val
                pass
            elif opt in ("-a"):
                argdict["autoswap"] = val
                pass
            elif opt in ("-l"):
                argdict["idleswap"] = val
                pass
            elif opt in ("-f"):
                argdict["frontend"] = 1
                pass
            elif opt in ("-w"):
                argdict["waitmode"] = 1
                pass
            pass

        if len(req_args) == 1:
            nsfilename = req_args[0]
            nsfilestr  = readnsfile(nsfilename, self.debug)

            # Watch for error reading NS file.
            if not nsfilestr:
                return -1

            if len(nsfilestr) > MAXNSFILESIZE:
                print "batchexp: NS file too big; server will reject it."
                return -1

            argdict["nsfilestr"] = nsfilestr
            pass

        response = self.server.batchexp(self.VERSION, argdict)
        if len(response["output"]):
            print response["output"]
            pass

        return response["exitval"]

    #
    # startexp is an alias for batchexp.
    #
    def startexp(self, *args):
        return self.batchexp(*args)

    #
    # swapexp. Also does swapmod. The wrinkle is that like above, we need to
    # pakcage up the NS file and pass it inline. The difference is that the
    # NS file is optional, dependent on the previous options; swapmod only.
    #
    def swapexp(self, *args):
        # The args are read-only, but I want a mutable version.
        arglist = [a for a in args];

	if len(arglist) == 0:
            print "swapexp: Must provide some arguments"
	    return -1

        #
        # Parse args. We do not try to do any checking, but rather just
        # convert them to functional arguments and place them into the
        # Dict that is passed along.
        #
        argdict = {};
        opt_args, req_args = getopt.getopt(arglist, "wres:")
        for opt, val in opt_args:
            if opt in ("-w"):
                argdict["waitmode"] = 1
                pass
            elif opt in ("-r"):
                argdict["reboot_nodes"] = 1
                pass
            elif opt in ("-e"):
                argdict["restart_eventsys"] = 1
                pass
            elif opt in ("-s"):
                argdict["swapop"] = val
                pass
            pass

        if len(req_args) < 2 or len(req_args) > 3:
            print "swapexp: Must provide pid and eid and an optiona NS file!"
	    return -1

        argdict["pid"] = req_args[0]
        argdict["eid"] = req_args[1]
            
        if len(req_args) == 3:
            nsfilename = req_args[2]
            nsfilestr  = readnsfile(nsfilename, self.debug)

            # Watch for error reading NS file.
            if not nsfilestr:
                return -1

            if len(nsfilestr) > MAXNSFILESIZE:
                print "batchexp: NS file too big; server will reject it."
                return -1

            argdict["nsfilestr"] = nsfilestr
            pass

        response = self.server.swapexp(self.VERSION, argdict)
        if len(response["output"]):
            print response["output"]
            pass

        return response["exitval"]

    #
    # endexp.
    #
    def endexp(self, *args):
        # The args are read-only, but I want a mutable version.
        arglist = [a for a in args];

	if len(arglist) == 0:
            print "endexp: Must provide some arguments"
	    return -1

        #
        # Parse args. We do not try to do any checking, but rather just
        # convert them to functional arguments and place them into the
        # Dict that is passed along.
        #
        argdict = {};
        opt_args, req_args = getopt.getopt(arglist, "w")
        for opt, val in opt_args:
            if opt in ("-w"):
                argdict["waitmode"] = 1
                pass
            pass

        if len(req_args) != 2:
            print "swapexp: Must provide pid and eid!"
	    return -1

        argdict["pid"] = req_args[0]
        argdict["eid"] = req_args[1]
            
        response = self.server.endexp(self.VERSION, argdict)
        if len(response["output"]):
            print response["output"]
            pass

        return response["exitval"]

    #
    # nscheck. Syntax check an NS file. The wrinkle is that like above, we
    # need to pakcage up the NS file and pass it inline.
    ##
    def nscheck(self, *args):
        # The args are read-only, but I want a mutable version.
        arglist = [a for a in args];

	if len(arglist) != 1:
            print "nscheck: Must provide an NS file!"
	    return -1

        argdict    = {};
        nsfilename = arglist[0]
        nsfilestr  = readnsfile(nsfilename, self.debug)

        # Watch for error reading NS file.
        if not nsfilestr:
            return -1

        if len(nsfilestr) > MAXNSFILESIZE:
            print "nscheck: NS file too big; server will reject it."
            return -1

        argdict["nsfilestr"] = nsfilestr

        response = self.server.nscheck(self.VERSION, argdict)
        if len(response["output"]):
            print response["output"]
            pass

        return response["exitval"]

    #
    # nscheck. Syntax check an NS file. The wrinkle is that like above, we
    # need to pakcage up the NS file and pass it inline.
    #
    def create_image(self, *args):
        # The args are read-only, but I want a mutable version.
        arglist = [a for a in args];

	if len(arglist) == 0:
            print "create_image: Must provide some arguments!"
	    return -1

        #
        # Parse args. We do not try to do any checking, but rather just
        # convert them to functional arguments and place them into the
        # Dict that is passed along.
        #
        argdict = {};
        opt_args, req_args = getopt.getopt(arglist, "p")
        for opt, val in opt_args:
            if opt in ("-p"):
                argdict["pid"] = val
                pass
            pass

        if len(req_args) != 2:
            print "create_image: Must provide imageid and nodeid!"
	    return -1

        argdict["imageid"] = req_args[0]
        argdict["nodeid"]  = req_args[1]
            
        response = self.server.create_image(self.VERSION, argdict)
        if len(response["output"]):
            print response["output"]
            pass

        return response["exitval"]

    pass

#
# Utility functions
#

#
# Read an nsfile and return a single string. 
#
def readnsfile(nsfilename, debug):
    nsfilestr  = ""
    try:
        fp = os.open(nsfilename, os.O_RDONLY)

        while True:
	    str = os.read(fp, 1024)

            if not str:
                break
            nsfilestr = nsfilestr + str
            pass

        os.close(fp)

    except:
        if debug:
            print "%s:%s" % (sys.exc_type, sys.exc_value)
            pass

        print "batchexp: Cannot read NS file '" + nsfilename + "'"
        return None
        pass

    return nsfilestr


