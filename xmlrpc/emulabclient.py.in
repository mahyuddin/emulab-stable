#! /usr/bin/env python
#
# EMULAB-COPYRIGHT
# Copyright (c) 2004 University of Utah and the Flux Group.
# All rights reserved.
#
import sys
import socket
import os
import popen2
import getopt
import string

MAXNSFILESIZE = (1024 * 512)

#
# This class defines a simple structure to return back to the caller.
# It includes the exit status of the command, and any output that it
# wants to send back. Why not return a tuple? Well, it appears that the
# python xmlrpc library requires that a singleton be returned from the
# server, and I do not want to depend on the "Fault" structure that XML
# defines for return values.
#
RESPONSE_SUCCESS        = 0
RESPONSE_BADARGS        = 1
RESPONSE_ERROR          = 2
RESPONSE_FORBIDDEN      = 3
RESPONSE_BADVERSION     = 4
RESPONSE_SERVERERROR    = 5
RESPONSE_TOOBIG         = 6

class ResponseBlock:
    def __init__(self, code, value=0, output=None):
        self.code     = code
        self.value    = value
        self.output   = output
        return

#
# This class implements the client side of the XMLRPC interface to Emulab.
# We do not try to do any serious argument processing here, but just pass
# it all through to the server.
#
# This is intended to serve as a demonstration of how to use the RPC
# interface, and to provide a test harness (via sshxmlrpc_client.py)
# for the server. 
#
class emulabclient:
    #
    # Initialize the object. The server argument is intended to
    # make this class independent of how we talk to the server. It just needs
    # to export the same interface as the xmlrpclib ServerProxy class. 
    #
    def __init__(self, server, debug):
        self.VERSION = 0.1
        self.server  = server
        self.debug   = debug
        return

    ##
    # Echo a message, basically, prepend the host name to the parameter list.
    #
    # @param args The argument list to echo back.
    # @return The 'msg' value with this machine's name prepended.
    #
    def echo(self, *args):
        argdict = {};
        argdict["list"] = args
        response = self.server.echo(self.VERSION, argdict)
        print response["output"]
	return 0

    #
    # Start an experiment using batchexp. The wrinkle is that we have to
    # package up the NS file and pass it inline. 
    #
    def batchexp(self, *args):
        # The args are read-only, but I want a mutable version.
        arglist = [a for a in args];

	if len(arglist) == 0:
            print "batchexp: Must provide some arguments"
	    return -1

        #
        # Parse args. We do not try to do any checking, but rather just
        # convert them to functional arguments and place them into the
        # Dict that is passed along.
        #
        argdict = {};
        opt_args, req_args = getopt.getopt(arglist, "iE:g:S:L:a:l:fw")
        for opt, val in opt_args:
            if opt in ("-i"):
                argdict["batchmode"] = 0
                pass
            elif opt in ("-E"):
                argdict["description"] = val
                pass
            elif opt in ("-g"):
                argdict["gid"] = val
                pass
            elif opt in ("-S"):
                argdict["swapable"]      = 0
                argdict["noswap_reason"] = val
                pass
            elif opt in ("-L"):
                argdict["idleswap"]          = 0
                argdict["noidleswap_reason"] = val
                pass
            elif opt in ("-a"):
                argdict["autoswap"] = val
                pass
            elif opt in ("-l"):
                argdict["idleswap"] = val
                pass
            elif opt in ("-f"):
                argdict["frontend"] = 1
                pass
            elif opt in ("-w"):
                argdict["waitmode"] = 1
                pass
            pass

        #
        # Next two args must be pid and eid. This differs from the batchexp
        # command line interface, but is consistent with swapexp and endexp.
        #
        if len(req_args) < 2 or len(req_args) > 3:
            print "batchexp: Must provide pid, eid, and optional NS file!"
            return -1
        
        argdict["pid"] = req_args[0]
        argdict["eid"] = req_args[1]

        # Optional NS file. 
        if len(req_args) == 3:
            nsfilename = req_args[2]
            nsfilestr  = readnsfile(nsfilename, self.debug)

            # Watch for error reading NS file.
            if not nsfilestr:
                return -1

            if len(nsfilestr) > MAXNSFILESIZE:
                print "batchexp: NS file too big; server will reject it."
                return -1

            argdict["nsfilestr"] = nsfilestr
            pass

        response = self.server.batchexp(self.VERSION, argdict)
        if len(response["output"]):
            print response["output"]
            pass

        if response["code"] != RESPONSE_SUCCESS:
            if response["value"]:
                return response["value"]
            else:
                return response["code"]
            pass
        return RESPONSE_SUCCESS

    #
    # startexp is an alias for batchexp.
    #
    def startexp(self, *args):
        return self.batchexp(*args)

    #
    # swapexp. Also does swapmod. The wrinkle is that like above, we need to
    # pakcage up the NS file and pass it inline. The difference is that the
    # NS file is optional, dependent on the previous options; swapmod only.
    #
    def swapexp(self, *args):
        # The args are read-only, but I want a mutable version.
        arglist = [a for a in args];

	if len(arglist) == 0:
            print "swapexp: Must provide some arguments"
	    return -1

        #
        # Parse args. We do not try to do any checking, but rather just
        # convert them to functional arguments and place them into the
        # Dict that is passed along.
        #
        argdict = {};
        opt_args, req_args = getopt.getopt(arglist, "wres:")
        for opt, val in opt_args:
            if opt in ("-w"):
                argdict["waitmode"] = 1
                pass
            elif opt in ("-r"):
                argdict["reboot_nodes"] = 1
                pass
            elif opt in ("-e"):
                argdict["restart_eventsys"] = 1
                pass
            elif opt in ("-s"):
                argdict["swapop"] = val
                pass
            pass

        if len(req_args) < 2 or len(req_args) > 3:
            print "swapexp: Must provide pid and eid and an optiona NS file!"
	    return -1

        argdict["pid"] = req_args[0]
        argdict["eid"] = req_args[1]
            
        if len(req_args) == 3:
            nsfilename = req_args[2]
            nsfilestr  = readnsfile(nsfilename, self.debug)

            # Watch for error reading NS file.
            if not nsfilestr:
                return -1

            if len(nsfilestr) > MAXNSFILESIZE:
                print "batchexp: NS file too big; server will reject it."
                return -1

            argdict["nsfilestr"] = nsfilestr
            pass

        response = self.server.swapexp(self.VERSION, argdict)
        if len(response["output"]):
            print response["output"]
            pass

        if response["code"] != RESPONSE_SUCCESS:
            if response["value"]:
                return response["value"]
            else:
                return response["code"]
            pass
        return RESPONSE_SUCCESS

    #
    # endexp.
    #
    def endexp(self, *args):
        # The args are read-only, but I want a mutable version.
        arglist = [a for a in args];

	if len(arglist) == 0:
            print "endexp: Must provide some arguments"
	    return -1

        #
        # Parse args. We do not try to do any checking, but rather just
        # convert them to functional arguments and place them into the
        # Dict that is passed along.
        #
        argdict = {};
        opt_args, req_args = getopt.getopt(arglist, "w")
        for opt, val in opt_args:
            if opt in ("-w"):
                argdict["waitmode"] = 1
                pass
            pass

        if len(req_args) != 2:
            print "swapexp: Must provide pid and eid!"
	    return -1

        argdict["pid"] = req_args[0]
        argdict["eid"] = req_args[1]
            
        response = self.server.endexp(self.VERSION, argdict)
        if len(response["output"]):
            print response["output"]
            pass

        if response["code"] != RESPONSE_SUCCESS:
            if response["value"]:
                return response["value"]
            else:
                return response["code"]
            pass
        return RESPONSE_SUCCESS

    #
    # nscheck. Syntax check an NS file. The wrinkle is that like above, we
    # need to pakcage up the NS file and pass it inline.
    ##
    def nscheck(self, *args):
        # The args are read-only, but I want a mutable version.
        arglist = [a for a in args];

	if len(arglist) != 1:
            print "nscheck: Must provide an NS file!"
	    return -1

        argdict    = {};
        nsfilename = arglist[0]
        nsfilestr  = readnsfile(nsfilename, self.debug)

        # Watch for error reading NS file.
        if not nsfilestr:
            return -1

        if len(nsfilestr) > MAXNSFILESIZE:
            print "nscheck: NS file too big; server will reject it."
            return -1

        argdict["nsfilestr"] = nsfilestr

        response = self.server.nscheck(self.VERSION, argdict)
        if len(response["output"]):
            print response["output"]
            pass

        if response["code"] != RESPONSE_SUCCESS:
            if response["value"]:
                return response["value"]
            else:
                return response["code"]
            pass
        return RESPONSE_SUCCESS

    #
    # create_image. Create a disk image from a node.
    #
    def create_image(self, *args):
        # The args are read-only, but I want a mutable version.
        arglist = [a for a in args];

	if len(arglist) == 0:
            print "create_image: Must provide some arguments!"
	    return -1

        #
        # Parse args. We do not try to do any checking, but rather just
        # convert them to functional arguments and place them into the
        # Dict that is passed along.
        #
        argdict = {};
        opt_args, req_args = getopt.getopt(arglist, "p")
        for opt, val in opt_args:
            if opt in ("-p"):
                argdict["pid"] = val
                pass
            pass

        if len(req_args) != 2:
            print "create_image: Must provide imageid and nodeid!"
	    return -1

        argdict["imageid"] = req_args[0]
        argdict["nodeid"]  = req_args[1]
            
        response = self.server.create_image(self.VERSION, argdict)
        if len(response["output"]):
            print response["output"]
            pass

        if response["code"] != RESPONSE_SUCCESS:
            if response["value"]:
                return response["value"]
            else:
                return response["code"]
            pass
        return RESPONSE_SUCCESS

    #
    # delay_config. Alter link characteristics. 
    #
    def delay_config(self, *args):
        # The args are read-only, but I want a mutable version.
        arglist = [a for a in args];

	if len(arglist) == 0:
            print "create_image: Must provide some arguments!"
	    return -1

        #
        # Parse args. We do not try to do any checking, but rather just
        # convert them to functional arguments and place them into the
        # Dict that is passed along.
        #
        argdict = {};
        opt_args, req_args = getopt.getopt(arglist, "ms:")
        for opt, val in opt_args:
            if opt in ("-m"):
                argdict["modify_exp"] = 1
                pass
            if opt in ("-s"):
                argdict["srcvnode"] = val
                pass
            pass

        if len(req_args) < 4:
            print "delay_config: Must provide pid, eid, link, param=value ...!"
	    return -1

        argdict["pid"]  = req_args.pop(0)
        argdict["eid"]  = req_args.pop(0)
        argdict["link"] = req_args.pop(0)

        #
        # The params are supplied as a separate dictionary. It is up to the
        # server to reject ones it does not like. 
        #
        params = {}
        for param in req_args:
            plist = string.split(param, "=")
            if len(plist) != 2:
                print "delay_config: Parameters are of the form: param=value!"
                return -1

            params[plist[0]] = plist[1]
            pass
        argdict["params"] = params
            
        response = self.server.delay_config(self.VERSION, argdict)

        if len(response["output"]):
            print response["output"]
            pass

        if response["code"] != RESPONSE_SUCCESS:
            if response["value"]:
                return response["value"]
            else:
                return response["code"]
            pass
        return RESPONSE_SUCCESS

    pass

#
# Utility functions
#

#
# Read an nsfile and return a single string. 
#
def readnsfile(nsfilename, debug):
    nsfilestr  = ""
    try:
        fp = os.open(nsfilename, os.O_RDONLY)

        while True:
	    str = os.read(fp, 1024)

            if not str:
                break
            nsfilestr = nsfilestr + str
            pass

        os.close(fp)

    except:
        if debug:
            print "%s:%s" % (sys.exc_type, sys.exc_value)
            pass

        print "batchexp: Cannot read NS file '" + nsfilename + "'"
        return None
        pass

    return nsfilestr


