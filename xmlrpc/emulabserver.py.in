#! /usr/bin/env python
#
# EMULAB-COPYRIGHT
# Copyright (c) 2004 University of Utah and the Flux Group.
# All rights reserved.
#
import sys
import socket
import os
import os.path
import stat
import popen2
import tempfile
import time
import re
import string
import pwd
import grp
import errno
import exceptions
import xmlrpclib
sys.path.append("@prefix@/lib")
from libdb        import *
from libtestbed   import SENDMAIL, TBOPS
from emulabclient import *

# Configure variables
TBDIR = "@prefix@"

# Version
VERSION = 0.1

# Well known directories
PROJROOT = "/proj"
GROUPROOT = "/groups"
SHAREROOT = "/share"
USERSROOT = "/users"

# List of directories exported to nodes via NFS.
NFS_EXPORTS = [
    PROJROOT,
    GROUPROOT,
    SHAREROOT,
    USERSROOT,
    ]

#
# XXX
# This mirrors db/xmlconvert. Be sure to keep this table in sync with that table.
#
virtual_tables = {
    "experiments"		: { "rows"  : None, 
                                    "tag"   : "experiment",
                                    "attrs" : [ ] },
    "virt_nodes"		: { "rows"  : None, 
                                    "tag"   : "nodes",
                                    "attrs" : [ "vname" ]},
    "virt_lans"                 : { "rows"  : None, 
                                    "tag"   : "lans",
                                    "attrs" : [ "vname" ]},
    "virt_lan_settings"         : { "rows"  : None, 
                                    "tag"   : "lan_settings",
                                    "attrs" : [ "vname", "capkey" ]},
    "virt_lan_member_settings"  : { "rows"  : None, 
                                    "tag"   : "lan_member_settings",
                                    "attrs" : [ "vname", "member", "capkey" ]},
    "virt_trafgens"		: { "rows"  : None, 
                                    "tag"   : "trafgens",
                                    "attrs" : [ "vname", "vnode" ]},
    "virt_agents"		: { "rows"  : None, 
                                    "tag"   : "agents",
                                    "attrs" : [ "vname", "vnode" ]},
    "virt_node_desires"         : { "rows"  : None, 
                                    "tag"   : "node_desires",
                                    "attrs" : [ "vname", "desire" ]},
    "virt_routes"		: { "rows"  : None, 
                                    "tag"   : "routes",
                                    "attrs" : [ "vname", "src", "dst" ]},
    "virt_vtypes"		: { "rows"  : None, 
                                    "tag"   : "vtypes",
                                    "attrs" : [ "name" ]},
    "virt_programs"		: { "rows"  : None, 
                                    "tag"   : "programs",
                                    "attrs" : [ "vname", "vnode" ]},
    "nseconfigs"		: { "rows"  : None, 
                                    "tag"   : "nseconfigs",
                                    "attrs" : [ "vname" ]},
    "eventlist"                 : { "rows"  : None, 
                                    "tag"   : "events",
                                    "attrs" : [ "vname" ]}
    }
    
# Base class for emulab specific exceptions.
class EmulabError(exceptions.Exception):
    pass

# Exception thrown when logins are not allowed.
class NoLoginsError(EmulabError):
    pass

# Exception thrown an unknown user tries to import this module.
class UnknownUserError(EmulabError):
    pass

# User info from the passwd file
UID = pwd.getpwuid(os.getuid())[0]
ISADMIN = 0

#
# Do a "one time" initialization of user data from the database.
#
def InitUser():
    global UID, ISADMIN
    
    userQuery = DBQueryFatal("SELECT admin FROM users AS u WHERE u.uid=%s",
                             (UID,))
    
    if len(userQuery) == 0:
        raise UnknownUserError, UID

    ISADMIN = userQuery[0][0]
    return

InitUser()

#
# Arguments to methods are passed as a Dictionary. This converts to a XML
# "struct" which in Perl/PHP/Ruby would be a hash. So, a client written in
# pretty much any language should be able to talk to this class.
#

#
# A helper function for checking required arguments.
#
def CheckRequiredArgs(argdict, arglist):
    # proj,group,exp are aliases for pid,gid,eid
    if (argdict.has_key("pid") and not argdict.has_key("proj")):
        argdict["proj"] = argdict["pid"]
        pass
    if (argdict.has_key("gid") and not argdict.has_key("group")):
        argdict["group"] = argdict["gid"]
        pass
    if (argdict.has_key("eid") and not argdict.has_key("exp")):
        argdict["exp"] = argdict["eid"]
        pass

    # Okay, now check.
    for arg in arglist:
        if not argdict.has_key(arg):
            return EmulabResponse(RESPONSE_BADARGS,
                                  output="Must supply '" + arg + "'")
        pass
    return None

#
# This class implements the server side of the XMLRPC interface to emulab as a
# whole.
#
class emulab:
    def __init__(self):
        self.VERSION = VERSION
        return

    #
    # Get the global 'notice' message that is usually printed under the menu
    # on the web site.
    #
    def message(self, version, argdict):
        if version != self.VERSION:
            return EmulabResponse(RESPONSE_BADVERSION,
                                  output="Client version mismatch!")

        msg = TBGetSiteVar("web/message")

        return EmulabResponse(RESPONSE_SUCCESS,
                              value=msg,
                              output=msg)

    #
    # Get the news items as a list of {subject,author,date,msgid} items for
    # dates between an option start and ending.
    #
    def news(self, version, argdict):
        if version != self.VERSION:
            return EmulabResponse(RESPONSE_BADVERSION,
                                  output="Client version mismatch!")

        # Process optional arguments.
        starting = None;
        if argdict.has_key("starting"):
            if not re.match("^[-:\w]*$", str(argdict["starting"])):
                return EmulabResponse(RESPONSE_BADARGS,
                                      output="Improperly formed 'starting'!")
            starting = sqldate(argdict["starting"])
            pass

        ending = None
        if argdict.has_key("ending"):
            if not re.match("^[-:\w]*$", str(argdict["ending"])):
                return EmulabResponse(RESPONSE_BADARGS,
                                      output="Improperly formed 'ending'!")
            ending = sqldate(argdict["ending"])
            pass

        # Construct the SQL date comparison
        if starting and ending:
            comparison = "BETWEEN %s and %s"
            sub = (starting, ending)
            pass
        elif starting:
            comparison = "> %s"
            sub = (starting,)
            pass
        elif ending:
            comparison = "< %s"
            sub = (ending,)
            pass
        else:
            comparison = ""
            sub = ()
            pass

        # Get the headlines and
        dbres = DBQueryFatal("SELECT subject,author,date,msgid FROM webnews "
                             "WHERE date "
                             + comparison
                             + " ORDER BY date DESC",
                             sub)

        # ... package them up
        result = []
        for res in dbres:
            tmp = {}
            tmp["subject"] = res[0]
            tmp["author"] = res[1]
            tmp["date"] = xmlrpclib.DateTime(
                time.strptime(res[2], "%Y-%m-%d %H:%M:%S"))
            tmp["msgid"] = res[3]
            result.append(tmp)
            pass

        return EmulabResponse(RESPONSE_SUCCESS,
                              value=result,
                              output=str(result))
    
    pass


#
# This class implements the server side of the XMLRPC interface to user
# specific information.
#
class user:
    def __init__(self):
        self.VERSION = VERSION
        return

    #
    # Get the number of nodes this user is has allocated.
    #
    def nodecount(self, version, argdict):
        if version != self.VERSION:
            return EmulabResponse(RESPONSE_BADVERSION,
                                  output="Client version mismatch!")

        try:
            checknologins()
            pass
        except NoLoginsError, e:
            return EmulabResponse(RESPONSE_REFUSED, output=str(e))

        res = DBQueryFatal(
            "SELECT a.node_id FROM nodes AS a "
            "left join reserved as b on a.node_id=b.node_id "
            "left join node_types as nt on a.type=nt.type "
            "left join experiments as e on b.pid=e.pid and "
            " b.eid=e.eid "
            "WHERE e.expt_head_uid=%s and e.pid!='emulab-ops' "
            "  and a.role='testnode' and nt.class = 'pc'",
            (UID,))

        return EmulabResponse(RESPONSE_SUCCESS,
                              value=len(res),
                              output=str(len(res)))

    #
    # Get the listing of projects/groups that this user is a member of and,
    # optionally, has the permission to perform some task.
    #
    def membership(self, version, argdict):
        if version != self.VERSION:
            return EmulabResponse(RESPONSE_BADVERSION,
                                  output="Client version mismatch!")

        try:
            checknologins()
            pass
        except NoLoginsError, e:
            return EmulabResponse(RESPONSE_REFUSED, output=str(e))

        permission = "readinfo"
        if argdict.has_key("permission"):
            permission = argdict["permission"]
            pass

        # Convert the permission to a SQL condition.
        if permission == "readinfo":
            trust_clause = "trust!='none'"
            pass
        elif permission == "makegroup":
            trust_clause = "trust='project_root'"
            pass
        elif permission == "createexpt":
            trust_clause = ("(trust='project_root' or trust='group_root' or "
                            " trust='local_root')")
            pass
        elif permission == "makeosid" or permission == "makeimageid":
            # XXX Handle admin
            trust_clause = ("(trust='project_root' or trust='group_root' or "
                            " trust='local_root')")
            pass
        else:
            return EmulabResponse(RESPONSE_BADARGS,
                                  output=("Bad permission value: "
                                          + permission))

        res = DBQueryFatal("SELECT distinct pid,gid FROM group_membership "
                           "WHERE uid=%s and "
                           + trust_clause
                           + " ORDER BY pid",
                           (UID,))

        result = {}
        for proj in res:
            if result.has_key(proj[0]):
                # Add group to existing project list
                tmp = result[proj[0]]
                tmp.append(proj[1])
                pass
            else:
                # Add new project to root list
                tmp = [proj[1],]
                result[proj[0]] = tmp
                pass
            pass

        return EmulabResponse(RESPONSE_SUCCESS,
                              value=result,
                              output=str(result))

    pass


#
# This class implements the server side of the XMLRPC interface to the emulab
# NFS exports.
#
class fs:
    def __init__(self):
        self.VERSION = VERSION
        return

    #
    # Check the accessibility of a path.
    #
    def access(self, version, argdict):
        if version != self.VERSION:
            return EmulabResponse(RESPONSE_BADVERSION,
                                  output="Client version mismatch!");

        try:
            checknologins()
            pass
        except NoLoginsError, e:
            return EmulabResponse(RESPONSE_REFUSED, output=str(e))

        argerror = CheckRequiredArgs(argdict, ("permission", "path"))
        if (argerror):
            return argerror

        try:
            path = nfspath(argdict["path"]) # Scrub the path
            
            permission = argdict["permission"]

            # Convert the permission to a python compatible value.
            if permission == "read" or permission == "r":
                accessmode = os.R_OK
                pass
            elif permission == "write" or permission == "w":
                accessmode = os.W_OK
                pass
            elif permission == "execute" or permission == "x":
                accessmode = os.X_OK
                pass
            elif permission == "exists" or permission == "e":
                accessmode = os.F_OK
                pass
            else:
                return EmulabResponse(RESPONSE_BADARGS,
                                      output=("Bad permission value: "
                                              + permission))
            
            res = os.access(path, accessmode)

            return EmulabResponse(RESPONSE_SUCCESS,
                                  value=res,
                                  output=str(res))
        except OSError, e:
            return EmulabResponse(RESPONSE_ERROR,
                                  value=e,
                                  output=(e.strerror + ": " + e.filename))

        # Never reached...
        assert False
        pass

    #
    # Get a directory listing for a given path.
    #
    def listdir(self, version, argdict):
        if version != self.VERSION:
            return EmulabResponse(RESPONSE_BADVERSION,
                                  output="Client version mismatch!")

        try:
            checknologins()
            pass
        except NoLoginsError, e:
            return EmulabResponse(RESPONSE_REFUSED, output=str(e))

        argerror = CheckRequiredArgs(argdict, ("path",))
        if (argerror):
            return argerror

        try:
            path = nfspath(argdict["path"]) # Scrub the path

            # Make sure the path is accessible,
            if not os.access(path, os.X_OK):
                raise OSError(errno.EPERM, "Path is not accessible", path)

            # ... get the directory listing, and
            res = os.listdir(path)

            # ... package it up into a platform independent from.
            result = []
            for entry in res:
                try:
                    st = os.stat(os.path.join(path, entry))
                    # The UID/GID will be meaningless to the other side,
                    # resolve them before sending it back.
                    try:
                        uname = pwd.getpwuid(st[stat.ST_UID])[0]
                        pass
                    except:
                        # Unknown UID, just send the number as a string
                        uname = str(st[stat.ST_UID])
                        pass
                    try:
                        gname = grp.getgrgid(st[stat.ST_GID])[0]
                        pass
                    except:
                        # Unknown GID, just send the number as a string
                        gname = str(st[stat.ST_GID])
                        pass
                    result.append((entry,
                                   filetype(st[stat.ST_MODE]),
                                   stat.S_IMODE(st[stat.ST_MODE]),
                                   uname,
                                   gname,
                                   st[stat.ST_SIZE],
                                   st[stat.ST_ATIME],
                                   st[stat.ST_MTIME],
                                   st[stat.ST_CTIME]))
                except OSError:
                    pass
                pass
            retval = EmulabResponse(RESPONSE_SUCCESS,
                                    value=result,
                                    output=str(result))
            pass
        except OSError, e:
            retval = EmulabResponse(RESPONSE_ERROR,
                                    value=e,
                                    output=(e.strerror + ": " + e.filename))
            pass

        return retval

    #
    # Get the list of potential NFS exports for an experiment.
    #
    def exports(self, version, argdict):
        if version != self.VERSION:
            return EmulabResponse(RESPONSE_BADVERSION,
                                  output="Client version mismatch!")

        try:
            checknologins()
            pass
        except NoLoginsError, e:
            return EmulabResponse(RESPONSE_REFUSED, output=str(e))

        # Start with the default set of exports, then
        res = [
            USERSROOT + "/" + UID, # XXX Use getpwuid() and handle admin
            SHAREROOT,
            ]

        # ... add the project/group listings.
        projs = DBQueryFatal("SELECT distinct pid,gid FROM group_membership "
                             "WHERE uid=%s and trust!='none' ORDER BY pid",
                             (UID,))

        for proj in projs:
            if proj[0] == proj[1]:
                res.append(PROJROOT + "/" + proj[0])
                pass
            else:
                res.append(GROUPROOT + "/" + proj[0] + "/" + proj[1])
                pass
            pass
        
        return EmulabResponse(RESPONSE_SUCCESS,
                              value=res,
                              output=str(res))

    pass


#
# This class implements the server side of the XMLRPC interface to image IDs.
#
class imageid:
    def __init__(self):
        self.VERSION = VERSION
        return

    def getlist(self, version, argdict):
        if version != self.VERSION:
            return EmulabResponse(RESPONSE_BADVERSION,
                                  output="Client version mismatch!")

        try:
            checknologins()
            pass
        except NoLoginsError, e:
            return EmulabResponse(RESPONSE_REFUSED, output=str(e))

        # Get the listing that is accessible to this user and
        res = DBQueryFatal(
            "SELECT distinct i.imagename,i.description FROM images as i "
            "left join group_membership as g on g.pid=i.pid "
            "WHERE g.uid=%s or i.global",
            (UID,))

        if len(res) == 0:
            return EmulabResponse(RESPONSE_ERROR,
                                  output="No image ids?")

        # ... package it up.
        result = {}
        for image in res:
            tmp = {
                "imageid" : image[0],
                "description" : image[1],
                }
            result[image[0]] = tmp
            pass

        return EmulabResponse(RESPONSE_SUCCESS,
                              value=result,
                              output=str(result))

    pass


#
# This class implements the server side of the XMLRPC interface to OS IDs.
#
class osid:
    def __init__(self):
        self.VERSION = VERSION
        return

    def getlist(self, version, argdict):
        if version != self.VERSION:
            return EmulabResponse(RESPONSE_BADVERSION,
                                  output="Client version mismatch!")

        try:
            checknologins()
            pass
        except NoLoginsError, e:
            return EmulabResponse(RESPONSE_REFUSED, output=str(e))

        # Get the listing that is accessible to this user and
        res = DBQueryFatal("SELECT distinct o.osname,o.description FROM "
                           "os_info as o "
                           "left join group_membership as g on g.pid=o.pid "
                           "where g.uid=%s or o.shared=1",
                           (UID,))

        if len(res) == 0:
            return EmulabResponse(RESPONSE_ERROR,
                                  output="No OS IDs?")

        # ... package it up.
        result = {}
        for osid in res:
            tmp = {
                "osid" : osid[0],
                "description" : osid[1],
                }
            result[osid[0]] = tmp
            pass

        return EmulabResponse(RESPONSE_SUCCESS,
                              value=result,
                              output=str(result))

    pass


#
# This class implements the server side of the XMLRPC interface to experiments.
#
class experiment:
    ##
    # Initialize the object.  Currently only sets the objects 'VERSION' value.
    #
    def __init__(self):
        self.VERSION = VERSION
        return

    ##
    # Echo a message, basically, prepend the host name to the parameter list.
    #
    # @param args The argument list to echo back.
    # @return The 'msg' value with this machine's name prepended.
    #
    def echo(self, version, argdict):
        if not argdict.has_key("str"):
            return EmulabResponse(RESPONSE_BADARGS,
                                  output="Must supply a string to echo!")
        
        return EmulabResponse(RESPONSE_SUCCESS, 0,
                             socket.gethostname() + ": " + str(version)
                             + " " + argdict["str"])

    #
    # Get the physical/policy constraints for experiment parameters.
    #
    def constraints(self, version, argdict):
        if version != self.VERSION:
            return EmulabResponse(RESPONSE_BADVERSION,
                                  output="Client version mismatch!")

        try:
            checknologins()
            pass
        except NoLoginsError, e:
            return EmulabResponse(RESPONSE_REFUSED, output=str(e))

        result = {
            "idle/threshold" : TBGetSiteVar("idle/threshold"),
            # XXX Add more...
            }
        
        return EmulabResponse(RESPONSE_SUCCESS,
                              value=result,
                              output=str(result))

    #
    # Get the list of experiments where the user is the head.
    #
    def getlist(self, version, argdict):
        if version != self.VERSION:
            return EmulabResponse(RESPONSE_BADVERSION,
                                  output="Client version mismatch!")
        
        try:
            checknologins()
            pass
        except NoLoginsError, e:
            return EmulabResponse(RESPONSE_REFUSED, output=str(e))

        # XXX Let the user specify the pid/gid
        dbres = DBQueryFatal("SELECT e.pid,e.gid,e.eid FROM experiments AS e "
                             "WHERE expt_head_uid=%s",
                             (UID,))

        # Build a dictionary of projects that refer to a dictionary of groups
        # that refer to a list of experiments in that group.
        result = {}
        for res in dbres:
            if not result.has_key(res[0]):
                result[res[0]] = {
                    res[1] : [ res[2], ]
                    }
                pass
            elif not result[res[0]].has_key(res[1]):
                result[res[0]][res[1]] = [ res[2], ]
                pass
            else:
                result[res[0]][res[1]].append(res[2])
                pass
            pass
        
        return EmulabResponse(RESPONSE_SUCCESS,
                              value=result,
                              output=str(result))

    #
    # Start an experiment using batchexp. We get the NS file inline, which
    # we have to write to a temp file first. 
    #
    def batchexp(self, version, argdict):
        if version != self.VERSION:
            return EmulabResponse(RESPONSE_BADVERSION,
                                  output="Client version mismatch!")

        try:
            checknologins()
            pass
        except NoLoginsError, e:
            return EmulabResponse(RESPONSE_REFUSED, output=str(e))

        argerror = CheckRequiredArgs(argdict, ("proj", "exp"))
        if (argerror):
            return argerror

        nsfilename = None
        argstr     = "-q"
        
        for opt, val in argdict.items():
            if opt == "batch":
                if not xbool(val):
                    argstr += " -i"
                    pass
                pass
            elif opt == "description":
                argstr += " -E "
                argstr += escapeshellarg(val)
                pass
            elif opt == "group":
                argstr += " -g "
                argstr += escapeshellarg(val)
                pass
            elif opt == "exp":
                argstr += " -e "
                argstr += escapeshellarg(val)
                pass
            elif opt == "proj":
                argstr += " -p "
                argstr += escapeshellarg(val)
                pass
            elif opt == "swappable":
                if not xbool(val):
                    argstr += " -S "
                    argstr += argdict["noswap_reason"]
                    pass
                pass
            elif opt == "noswap_reason":
                pass
            elif opt == "idleswap":
                if val == 0:
                    argstr += " -L "
                    argstr += escapeshellarg(argdict["noidleswap_reason"])
                    pass
                else:
                    argstr += " -l "
                    argstr += escapeshellarg(str(val))
                    pass
                pass
            elif opt == "noidleswap_reason":
                pass
            elif opt == "autoswap" or opt == "max_duration":
                argstr += " -a "
                argstr += escapeshellarg(str(val))
                pass
            elif opt == "noswapin":
                if xbool(val):
                    argstr += " -f "
                    pass
                pass
            elif opt == "wait":
                if xbool(val):
                    argstr += " -w "
                    pass
                pass
            elif opt == "nsfilepath":
                # Backend script will verify this local path. 
                nsfilename = escapeshellarg(val)
                pass
            elif opt == "nsfilestr":
                nsfilestr = val
            
                if len(nsfilestr) > (1024 * 512):
                    return EmulabResponse(RESPONSE_TOOBIG,
                                         output="NS File way too big!");
        
                (nsfp, nsfilename) = writensfile(nsfilestr)
                if not nsfilename:
                    return EmulabResponse(RESPONSE_SERVERERROR,
                                         output="Server Error")
                pass
            pass

        if nsfilename:
            argstr += " " + nsfilename
            pass

        (exitval, output) = runcommand(TBDIR + "/bin/batchexp " + argstr)
        if exitval:
            return EmulabResponse(RESPONSE_ERROR, exitval >> 8, output=output)
        
        return EmulabResponse(RESPONSE_SUCCESS, output=output)

    #
    # startexp is an alias for batchexp.
    # 
    def startexp(self, version, argdict):
        return self.batchexp(version, argdict)

    #
    # swap an experiment using swapexp. 
    #
    def swapexp(self, version, argdict):
        if version != self.VERSION:
            return EmulabResponse(RESPONSE_BADVERSION,
                                  output="Client version mismatch!")

        try:
            checknologins()
            pass
        except NoLoginsError, e:
            return EmulabResponse(RESPONSE_REFUSED, output=str(e))

        argerror = CheckRequiredArgs(argdict, ("proj", "exp", "direction"))
        if (argerror):
            return argerror

        argstr = "-q"
        for opt, val in argdict.items():
            if opt == "wait":
                if xbool(val):
                    argstr += " -w "
                    pass
                pass
            pass

        argstr += " -s " + escapeshellarg(argdict["direction"])
        argstr += " " + escapeshellarg(argdict["proj"])
        argstr += " " + escapeshellarg(argdict["exp"])

        (exitval, output) = runcommand(TBDIR + "/bin/swapexp " + argstr)
        if exitval:
            return EmulabResponse(RESPONSE_ERROR, exitval >> 8, output=output)
        
        return EmulabResponse(RESPONSE_SUCCESS, output=output)

    #
    # modify an experiment using swapexp. We get the NS file inline, which
    # we have to write to a temp file first. 
    #
    def modify(self, version, argdict):
        if version != self.VERSION:
            return EmulabResponse(RESPONSE_BADVERSION,
                                  output="Client version mismatch!")

        try:
            checknologins()
            pass
        except NoLoginsError, e:
            return EmulabResponse(RESPONSE_REFUSED, output=str(e))

        argerror = CheckRequiredArgs(argdict, ("proj", "exp"))
        if (argerror):
            return argerror

        nsfilename = None
        argstr     = "-q"
        
        for opt, val in argdict.items():
            if opt == "wait":
                if xbool(val):
                    argstr += " -w "
                    pass
                pass
            elif opt == "reboot":
                if xbool(val):
                    argstr += " -r "
                    pass
                pass
            elif opt == "restart_eventsys":
                if xbool(val):
                    argstr += " -e "
                    pass
                pass
            elif opt == "nsfilepath":
                # Backend script will verify this local path. 
                nsfilename = escapeshellarg(val)
                pass
            elif opt == "nsfilestr":
                nsfilestr = val
            
                if len(nsfilestr) > (1024 * 512):
                    return EmulabResponse(RESPONSE_TOOBIG,
                                         output="NS File way too big!");
        
                (nsfp, nsfilename) = writensfile(nsfilestr)
                if not nsfilename:
                    return EmulabResponse(RESPONSE_SERVERERROR,
                                         output="Server Error")
                pass
            pass

        argstr += " -s modify"
        argstr += " " + escapeshellarg(argdict["proj"])
        argstr += " " + escapeshellarg(argdict["exp"])

        if nsfilename:
            argstr += " " + nsfilename
            pass

        (exitval, output) = runcommand(TBDIR + "/bin/swapexp " + argstr)
        if exitval:
            return EmulabResponse(RESPONSE_ERROR, exitval >> 8, output=output)
        
        return EmulabResponse(RESPONSE_SUCCESS, output=output)

    #
    # end an experiment using endexp.
    #
    def endexp(self, version, argdict):
        if version != self.VERSION:
            return EmulabResponse(RESPONSE_BADVERSION,
                                  output="Client version mismatch!")
        
        try:
            checknologins()
            pass
        except NoLoginsError, e:
            return EmulabResponse(RESPONSE_REFUSED, output=str(e))

        argerror = CheckRequiredArgs(argdict, ("proj", "exp"))
        if (argerror):
            return argerror

        argstr = "-q"
        for opt, val in argdict.items():
            if opt == "wait":
                if xbool(val):
                    argstr += " -w "
                    pass
                pass
            pass

        argstr += " " + escapeshellarg(argdict["proj"])
        argstr += " " + escapeshellarg(argdict["exp"])

        (exitval, output) = runcommand(TBDIR + "/bin/endexp " + argstr)
        if exitval:
            return EmulabResponse(RESPONSE_ERROR, exitval >> 8, output=output)
        
        return EmulabResponse(RESPONSE_SUCCESS, output=output)

    #
    # Return the state of an experiment.
    #
    def state(self, version, argdict):
        if version != self.VERSION:
            return EmulabResponse(RESPONSE_BADVERSION,
                                  output="Client version mismatch!")

        try:
            checknologins()
            pass
        except NoLoginsError, e:
            return EmulabResponse(RESPONSE_REFUSED, output=str(e))

        argerror = CheckRequiredArgs(argdict, ("proj", "exp"))
        if (argerror):
            return argerror

        if not (re.match("^[-\w]*$", argdict["proj"]) and
                re.match("^[-\w]*$", argdict["exp"])):
            return EmulabResponse(RESPONSE_BADARGS,
                                  output="Improperly formed proj/exp!")
        
        res = DBQueryFatal("select state from experiments "
                           "where pid=%s and eid=%s",
                           (argdict["proj"], argdict["exp"]))

        if len(res) == 0:
            return EmulabResponse(RESPONSE_ERROR,
                                  output="No such experiment!")

        state = res[0][0]
        return EmulabResponse(RESPONSE_SUCCESS, value=state, output=state)

    #
    # Return the node/link mappings for an experiment.
    #
    def info(self, version, argdict):
        if version != self.VERSION:
            return EmulabResponse(RESPONSE_BADVERSION,
                                  output="Client version mismatch!")

        try:
            checknologins()
            pass
        except NoLoginsError, e:
            return EmulabResponse(RESPONSE_REFUSED, output=str(e))

        argerror = CheckRequiredArgs(argdict, ("proj", "exp", "aspect"))
        if (argerror):
            return argerror

        if not (re.match("^[-\w]*$", argdict["proj"]) and
                re.match("^[-\w]*$", argdict["exp"])):
            return EmulabResponse(RESPONSE_BADARGS,
                                  output="Illegal characters in arguments!")

        res = DBQueryFatal("select state from experiments "
                           "where pid=%s and eid=%s",
                           (argdict["proj"], argdict["exp"]))

        if len(res) == 0:
            return EmulabResponse(RESPONSE_ERROR,
                                  output="No such experiment!")
        state   = res[0][0]
        result  = {}
        mapping = None

        if state == "active":
            dbres = DBQuery(
                "select r.vname,r.node_id,n.type,n.def_boot_osid,ns.status,"
                "n.eventstate,"
                "(unix_timestamp(now()) - unix_timestamp( "
                "greatest(na.last_tty_act,na.last_net_act,na.last_cpu_act,"
                "na.last_ext_act))),ni.load_1min,ni.load_5min,ni.load_15min"
                "  from reserved as r "
                "left join nodes as n on r.node_id=n.node_id "
                "left join node_status as ns on ns.node_id=n.node_id "
                "left join node_activity as na on na.node_id=n.node_id "
                "left join node_idlestats as ni on ni.node_id=n.node_id "
                "where r.pid=%s and r.eid=%s "
                "order by r.vname",
                (argdict["proj"], argdict["exp"]))
            osmappings = {}
            mapping = {}
            for res in dbres:
                tmp = {}
                tmp["name"] = res[0]
                tmp["node"] = res[1]
                tmp["type"] = res[2]
                if not osmappings.has_key(res[3]):
                    osres = DBQuery(
                        "SELECT osname from os_info where osid=%s", (res[3],))
                    osmappings[res[3]] = osres[0][0]
                    pass
                tmp["osid"] = osmappings[res[3]]
                tmp["status"] = res[4]
                if res[5]:
                    tmp["eventstatus"] = res[5]
                    pass
                tmp["idle"] = res[6]
                if res[7]:
                    tmp["load_1min"] = res[7]
                    pass
                if res[8]:
                    tmp["load_5min"] = res[8]
                    pass
                if res[9]:
                    tmp["load_15min"] = res[9]
                    pass
                mapping[res[0]] = tmp
                pass
            pass

        if argdict["aspect"] == "mapping":
            if state != "active":
                return EmulabResponse(RESPONSE_ERROR,
                                      output="Experiment is not active!")
            # Just return the mapping above
            result = mapping
            pass
        elif argdict["aspect"] == "links":
            dbres = DBQueryFatal("SELECT vname,ips from virt_nodes "
                                 "where pid=%s and eid=%s",
                                 (argdict["proj"], argdict["exp"]))
            ipmap = {}
            for res in dbres:
                for ipinfo in string.split(res[1], " "):
                    if len(ipinfo) > 0:
                        port, ip = string.split(ipinfo, ":")
                        ipmap[res[0] + ":" + port] = ip
                        pass
                    pass
                pass
            
            dbres = DBQuery("select vname,member,mask,delay,bandwidth, "
                            "       lossrate,rdelay,rbandwidth,rlossrate "
                            "from virt_lans where pid=%s and eid=%s "
                            "order by vname,member",
                            (argdict["proj"], argdict["exp"]))

            if len(dbres) > 0:
                for res in dbres:
                    tmp = {}
                    tmp["name"]        = res[0]
                    tmp["member"]      = res[1]
                    tmp["ipaddr"]      = ipmap[res[1]]
                    tmp["mask"]        = res[2]
                    tmp["delay"]       = res[3]
                    tmp["bandwidth"]   = int(res[4])
                    tmp["plr"]         = res[5]
                    tmp["r_delay"]     = res[6]
                    tmp["r_bandwidth"] = int(res[7])
                    tmp["r_plr"]       = res[8]
                    result[res[1]]     = tmp
                    pass
                pass
            pass
        
        return EmulabResponse(RESPONSE_SUCCESS, value=result, output="")

    #
    # nscheck an NS file.
    #
    def nscheck(self, version, argdict):
        if version != self.VERSION:
            return EmulabResponse(RESPONSE_BADVERSION,
                                  output="Client version mismatch!")

        try:
            checknologins()
            pass
        except NoLoginsError, e:
            return EmulabResponse(RESPONSE_REFUSED, output=str(e))

        argstr = ""

        if argdict.has_key("nsfilestr"):
            nsfilestr = argdict["nsfilestr"]
            
            if len(nsfilestr) > (1024 * 512):
                return EmulabResponse(RESPONSE_TOOBIG,
                                     output="NS File way too big!");
        
            (nsfp, nsfilename) = writensfile(nsfilestr)
            if not nsfilename:
                return EmulabResponse(RESPONSE_SERVERERROR,
                                      output="Server Error")

            argstr += nsfilename
            pass
        elif argdict.has_key("nsfilepath"):
            # Backend script will verify this local path. 
            argstr += escapeshellarg(argdict["nsfilepath"])
            pass
        else:
            return EmulabResponse(RESPONSE_BADARGS,
                                 output="Must supply an NS file to check!");
        
        (exitval, output) = runcommand(TBDIR + "/bin/nscheck " + argstr)
        if exitval:
            return EmulabResponse(RESPONSE_ERROR, exitval >> 8, output=output)
        
        return EmulabResponse(RESPONSE_SUCCESS, output=output)

    #
    # Delay configuration
    #
    def delay_config(self, version, argdict):
        if version != self.VERSION:
            return EmulabResponse(RESPONSE_BADVERSION,
                                  output="Client version mismatch!")

        try:
            checknologins()
            pass
        except NoLoginsError, e:
            return EmulabResponse(RESPONSE_REFUSED, output=str(e))

        argerror = CheckRequiredArgs(argdict,
                                     ("proj", "exp", "link", "params"))
        if (argerror):
            return argerror

        argstr = ""
        for opt, val in argdict.items():
            if opt == "persist":
                if xbool(val):
                    argstr += " -m "
                    pass
                pass
            elif opt == "src":
                argstr += " -s "
                argstr += escapeshellarg(val)
                pass
            pass

        argstr += " " + escapeshellarg(argdict["proj"])
        argstr += " " + escapeshellarg(argdict["exp"])
        argstr += " " + escapeshellarg(argdict["link"])

        for opt, val in argdict["params"].items():
            argstr += " " + escapeshellarg(opt + "=" + str(val))
            pass
        
        (exitval, output) = runcommand(TBDIR + "/bin/delay_config " + argstr)
        if exitval:
            return EmulabResponse(RESPONSE_ERROR, exitval >> 8, output=output)
        
        return EmulabResponse(RESPONSE_SUCCESS, output=output)

    #
    # Wireless link configuration
    #
    def link_config(self, version, argdict):
        if version != self.VERSION:
            return EmulabResponse(RESPONSE_BADVERSION,
                                  output="Client version mismatch!")

        try:
            checknologins()
            pass
        except NoLoginsError, e:
            return EmulabResponse(RESPONSE_REFUSED, output=str(e))

        argerror = CheckRequiredArgs(argdict,
                                     ("proj", "exp", "link", "params"))
        if (argerror):
            return argerror

        argstr = ""
        for opt, val in argdict.items():
            if opt == "persist":
                if xbool(val):
                    argstr += " -m "
                    pass
                pass
            elif opt == "src":
                argstr += " -s "
                argstr += escapeshellarg(val)
                pass
            pass

        argstr += " " + escapeshellarg(argdict["proj"])
        argstr += " " + escapeshellarg(argdict["exp"])
        argstr += " " + escapeshellarg(argdict["link"])

        for opt, val in argdict["params"].items():
            argstr += " " + escapeshellarg(opt + "=" + str(val))
            pass
        
        (exitval, output) = runcommand(TBDIR + "/bin/link_config " + argstr)
        if exitval:
            return EmulabResponse(RESPONSE_ERROR, exitval >> 8, output=output)
        
        return EmulabResponse(RESPONSE_SUCCESS, output=output)

    #
    # iwconfig is an alias for link_config
    # 
    def iwconfig(self, version, argdict):
        return self.link_config(version, argdict)

    #
    # Reboot all nodes in an experiment.
    #
    def reboot(self, version, argdict):
        if version != self.VERSION:
            return EmulabResponse(RESPONSE_BADVERSION,
                                  output="Client version mismatch!")

        try:
            checknologins()
            pass
        except NoLoginsError, e:
            return EmulabResponse(RESPONSE_REFUSED, output=str(e))

        argerror = CheckRequiredArgs(argdict, ("proj", "exp"))
        if (argerror):
            return argerror

        argstr = ""
        for opt, val in argdict.items():
            if opt == "wait":
                if xbool(val):
                    argstr += " -w "
                    pass
                pass
            pass

        argstr += " -e "
        argstr += escapeshellarg(argdict["proj"] + "," + argdict["exp"])
        
        (exitval, output) = runcommand(TBDIR + "/bin/node_reboot " + argstr)
        if exitval:
            return EmulabResponse(RESPONSE_ERROR, exitval >> 8, output=output)
        
        return EmulabResponse(RESPONSE_SUCCESS, output=output)

    #
    # Reload all nodes in an experiment.
    #
    def reload(self, version, argdict):
        if version != self.VERSION:
            return EmulabResponse(RESPONSE_BADVERSION,
                                  output="Client version mismatch!")

        try:
            checknologins()
            pass
        except NoLoginsError, e:
            return EmulabResponse(RESPONSE_REFUSED, output=str(e))

        argerror = CheckRequiredArgs(argdict, ("proj", "exp"))
        if (argerror):
            return argerror

        argstr = ""
        for opt, val in argdict.items():
            if opt == "wait":
                if not xbool(val):
                    argstr += " -s "
                    pass
                pass
            elif opt == "imageproj":
                argstr += " -p "
                argstr += escapeshellarg(val)
                pass
            elif opt == "imageid":
                argstr += " -i "
                argstr += escapeshellarg(val)
                pass
            pass

        argstr += " -e "
        argstr += escapeshellarg(argdict["proj"] + "," + argdict["exp"])
        
        (exitval, output) = runcommand(TBDIR + "/bin/os_load " + argstr)

        if exitval:
            return EmulabResponse(RESPONSE_ERROR, exitval >> 8, output=output)
        
        return EmulabResponse(RESPONSE_SUCCESS, output=output)

    #
    # Download experiment topology.
    #
    def virtual_topology(self, version, argdict):
        if version != self.VERSION:
            return EmulabResponse(RESPONSE_BADVERSION,
                                 output="Client version mismatch!");
            pass

        try:
            checknologins()
            pass
        except NoLoginsError, e:
            return EmulabResponse(RESPONSE_REFUSED, output=str(e))

        argerror = CheckRequiredArgs(argdict, ("proj", "exp"))
        if (argerror):
            return argerror

        if not (re.match("^[-\w]*$", argdict["proj"]) and
                re.match("^[-\w]*$", argdict["exp"])):
            return EmulabResponse(RESPONSE_BADARGS,
                                  output="Illegal characters in arguments!")

        #
        # Check permission. This needs to be a lib routine!
        #
        res = DBQueryFatal("SELECT gid FROM experiments "
                           "WHERE pid=%s and eid=%s",
                           (argdict["proj"], argdict["exp"]))

        if len(res) == 0:
            return EmulabResponse(RESPONSE_ERROR,
                                  output="No such experiment: " +
                                  argdict["proj"] + "/" + argdict["exp"])

        gid = res[0][0]
        
        res = DBQueryFatal("SELECT trust FROM group_membership "
                           "WHERE uid=%s and pid=%s and gid=%s",
                           (UID, argdict["proj"], gid))

        if len(res) == 0:
            return EmulabResponse(
                RESPONSE_ERROR,
                output=("You do not have permission to access experiment: "
                        + argdict["proj"] + "/" + argdict["exp"]))


        res = DBQuery("SELECT * FROM experiments "
                      "WHERE pid=%s and eid=%s",
                      (argdict["proj"], argdict["exp"]), asDict=True);

        #
        # Convert NULL to ""
        #
        for key, val in res[0].items():
            if val == None:
                res[0][key] = ""
                pass
            pass

        result   = {}
        result["experiment"] = {}
        result["experiment"]["settings"] = res[0];

        #
        # Get the rest of the virtual tables.
        # 
        for key, val in virtual_tables.items():
            if key == "experiments":
                continue
            
            tag  = val["tag"]
            rows = []

            res = DBQuery("SELECT * FROM " + key + " " +
                          "WHERE pid=%s and eid=%s",
                          (argdict["proj"], argdict["exp"]), asDict=True);

            if len(res) > 0:
                for row in res:
                    #
                    # Convert NULL to ""
                    #
                    for key2, val2 in row.items():
                        if val2 == None:
                            row[key2] = ""
                            pass
                        pass

                    rows.append(row)
                    pass
                pass
            
            result["experiment"][tag] = rows
            pass

        result = (result,)
        
        return EmulabResponse(RESPONSE_SUCCESS, value=result, output="")
    
    #
    # Return the visualization data for the experiment.
    #
    def getviz(self, version, argdict):
        if version != self.VERSION:
            return EmulabResponse(RESPONSE_BADVERSION,
                                  output="Client version mismatch!")

        try:
            checknologins()
            pass
        except NoLoginsError, e:
            return EmulabResponse(RESPONSE_REFUSED, output=str(e))

        argerror = CheckRequiredArgs(argdict, ("proj", "exp"))
        if (argerror):
            return argerror

        if not (re.match("^[-\w]*$", argdict["proj"]) and
                re.match("^[-\w]*$", argdict["exp"])):
            return EmulabResponse(RESPONSE_BADARGS,
                                  output="Improperly formed proj/exp!")
        
        #
        # Check permission. This needs to be a lib routine!
        #
        res = DBQueryFatal("SELECT gid FROM experiments "
                           "WHERE pid=%s and eid=%s",
                           (argdict["proj"], argdict["exp"]))

        if len(res) == 0:
            return EmulabResponse(RESPONSE_ERROR,
                                  output="No such experiment: " +
                                  argdict["proj"] + "/" + argdict["exp"])

        gid = res[0][0]
        
        res = DBQueryFatal("SELECT trust FROM group_membership "
                           "WHERE uid=%s and pid=%s and gid=%s",
                           (UID, argdict["proj"], gid))

        if len(res) == 0:
            return EmulabResponse(
                RESPONSE_FORBIDDEN,
                output=("You do not have permission to access experiment: "
                        + argdict["proj"] + "/" + argdict["exp"]))

        dbres = DBQueryFatal("select vname,vis_type,x,y from vis_nodes "
                             "where pid=%s and eid=%s",
                             (argdict["proj"], argdict["exp"]))

        if len(dbres) == 0:
            return EmulabResponse(RESPONSE_ERROR,
                                  output="No such experiment!")

        result = {}
        for res in dbres:
            tmp = {}
            tmp["name"] = res[0]
            tmp["type"] = res[1]
            tmp["x"] = res[2]
            tmp["y"] = res[3]
            result[res[0]] = tmp
            pass

        return EmulabResponse(RESPONSE_SUCCESS,
                              value=result,
                              output=str(result))

    pass

#
# This class implements the server side of the XMLRPC interface to nodes.
#
class node:
    ##
    # Initialize the object.  Currently only sets the objects 'VERSION' value.
    #
    def __init__(self):
        self.VERSION = VERSION
        return

    #
    # Get the number of free nodes.
    #
    def available(self, version, argdict):
        if version != self.VERSION:
            return EmulabResponse(RESPONSE_BADVERSION,
                                  output="Client version mismatch!")

        try:
            checknologins()
            pass
        except NoLoginsError, e:
            return EmulabResponse(RESPONSE_REFUSED, output=str(e))

        res = DBQueryFatal("SELECT count(a.node_id) FROM nodes AS a "
                           "left join reserved as b on a.node_id=b.node_id "
                           "left join node_types as nt on a.type=nt.type "
                           "left join nodetypeXpid_permissions as p "
                           "  on a.type=p.type "
                           "WHERE b.node_id is null and a.role='testnode' "
                           "  and nt.class = 'pc' and p.pid is null and "
                           "      (a.eventstate='ISUP' or "
                           "       a.eventstate='PXEWAIT') and"
                           "      (p.pid is null)")

        if len(res) == 0:
            result = 0
            pass
        else:
            result = int(res[0][0])
            pass

        return EmulabResponse(RESPONSE_SUCCESS,
                              value=result,
                              output=str(result))


    #
    # Get the console parameters.
    #
    def console(self, version, argdict):
        if version != self.VERSION:
            return EmulabResponse(RESPONSE_BADVERSION,
                                  output="Client version mismatch!")

        argerror = CheckRequiredArgs(argdict, ("node",))
        if (argerror):
            return argerror

        try:
            checknologins()
            pass
        except NoLoginsError, e:
            return EmulabResponse(RESPONSE_REFUSED, output=str(e))

        if not re.match("^[-\w]*$", str(argdict["node"])):
            return EmulabResponse(RESPONSE_BADARGS,
                                  output="Improperly formed node value!")
        
        # XXX Refactor the trust stuff
        res = DBQueryFatal("SELECT e.pid,e.gid FROM reserved AS r "
                           "left join experiments as e on "
                           "     e.pid=r.pid and e.eid=r.eid "
                           "WHERE r.node_id=%s",
                           (argdict["node"],))

        if len(res) == 0:
            return EmulabResponse(RESPONSE_ERROR,
                                  output="No such node: " + argdict["node"])

        trust = DBQueryFatal("SELECT trust FROM group_membership "
                             "WHERE uid=%s and pid=%s and gid=%s",
                             (UID, res[0][0], res[0][1]))

        if len(trust) == 0:
            return EmulabResponse(
                RESPONSE_FORBIDDEN,
                output=("You do not have permission to access: "
                        + argdict["node"]))

        res = DBQueryFatal("SELECT server,portnum,keylen,keydata "
                           "FROM tiplines WHERE node_id=%s",
                           (argdict["node"],))
        
        if len(res) == 0:
            return EmulabResponse(RESPONSE_ERROR,
                                  output="No such node: " + argdict["node"])

        sha_fp = open("/usr/testbed/etc/capture.fingerprint").read()
        sha_fp = sha_fp.split("=")[1].strip().replace(":", "")
        
        sha1_fp = open("/usr/testbed/etc/capture.sha1fingerprint").read()
        sha1_fp = sha1_fp.split("=")[1].strip().replace(":", "")
        
        result = {
            "server" : res[0][0],
            "portnum" : res[0][1],
            # "keylen" : res[0][2],
            "keydata" : res[0][3],
            "certsha" : sha_fp,
            "certsha1" : sha1_fp,
            }

        return EmulabResponse(RESPONSE_SUCCESS,
                              value=result,
                              output=str(result))


    #
    # Get the ssh host keys
    #
    def hostkeys(self, version, argdict):
        if version != self.VERSION:
            return EmulabResponse(RESPONSE_BADVERSION,
                                  output="Client version mismatch!")

        argerror = CheckRequiredArgs(argdict, ("node",))
        if (argerror):
            return argerror

        try:
            checknologins()
            pass
        except NoLoginsError, e:
            return EmulabResponse(RESPONSE_REFUSED, output=str(e))

        if not re.match("^[-\w]*$", str(argdict["node"])):
            return EmulabResponse(RESPONSE_BADARGS,
                                  output="Improperly formed node value!")
        
        # XXX Refactor the trust stuff
        res = DBQueryFatal("SELECT e.pid,e.gid FROM reserved AS r "
                           "left join experiments as e on "
                           "     e.pid=r.pid and e.eid=r.eid "
                           "WHERE r.node_id=%s",
                           (argdict["node"],))

        if len(res) == 0:
            return EmulabResponse(RESPONSE_ERROR,
                                  output="No such node: " + argdict["node"])

        trust = DBQueryFatal("SELECT trust FROM group_membership "
                             "WHERE uid=%s and pid=%s and gid=%s",
                             (UID, res[0][0], res[0][1]))

        if len(trust) == 0:
            return EmulabResponse(
                RESPONSE_FORBIDDEN,
                output=("You do not have permission to access: "
                        + argdict["node"]))

        res = DBQueryFatal("SELECT sshrsa_v1,sshrsa_v2,sshdsa_v2,sfshostid "
                           "FROM node_hostkeys WHERE node_id=%s",
                           (argdict["node"],))
        
        if len(res) == 0:
            return EmulabResponse(RESPONSE_ERROR,
                                  output="No such node: " + argdict["node"])

        result = {}
        if res[0][0]:
            result["sshrsa_v1"] = res[0][0]
            pass
        if res[0][1]:
            result["sshrsa_v2"] = res[0][1]
            pass
        if res[0][2]:
            result["sshdsa_v2"] = res[0][2]
            pass
        if res[0][3]:
            result["sfshostid"] = res[0][3]
            pass

        return EmulabResponse(RESPONSE_SUCCESS,
                              value=result,
                              output=str(result))


    #
    # reboot nodes
    #
    def reboot(self, version, argdict):
        if version != self.VERSION:
            return EmulabResponse(RESPONSE_BADVERSION,
                                  output="Client version mismatch!")

        try:
            checknologins()
            pass
        except NoLoginsError, e:
            return EmulabResponse(RESPONSE_REFUSED, output=str(e))

        argerror = CheckRequiredArgs(argdict, ("nodes",))
        if (argerror):
            return argerror

        argstr = ""
        for opt, val in argdict.items():
            if opt == "wait":
                if xbool(val):
                    argstr += " -w "
                    pass
                pass
            pass

        tokens = argdict["nodes"].split(",")
        for token in tokens:
            argstr += " " + escapeshellarg(token)
            pass

        (exitval, output) = runcommand(TBDIR + "/bin/node_reboot " + argstr)
        if exitval:
            return EmulabResponse(RESPONSE_ERROR, exitval >> 8, output=output)
        
        return EmulabResponse(RESPONSE_SUCCESS, output=output)

    #
    # create_image.
    #
    def create_image(self, version, argdict):
        if version != self.VERSION:
            return EmulabResponse(RESPONSE_BADVERSION,
                                  output="Client version mismatch!")

        try:
            checknologins()
            pass
        except NoLoginsError, e:
            return EmulabResponse(RESPONSE_REFUSED, output=str(e))

        argerror = CheckRequiredArgs(argdict, ("imageid", "node"))
        if (argerror):
            return argerror

        argstr = ""
        for opt, val in argdict.items():
            if opt == "wait":
                if xbool(val):
                    argstr += " -w "
                    pass
                pass
            elif opt == "proj":
                argstr += " -p "
                argstr += escapeshellarg(val)
                pass
            pass

        argstr += " " + escapeshellarg(argdict["imageid"])
        argstr += " " + escapeshellarg(argdict["node"])

        (exitval, output) = runcommand(TBDIR + "/bin/create_image " + argstr)
        if exitval:
            return EmulabResponse(RESPONSE_ERROR, exitval >> 8, output=output)
        
        return EmulabResponse(RESPONSE_SUCCESS, output=output)

    #
    # Reload nodes.
    #
    def reload(self, version, argdict):
        if version != self.VERSION:
            return EmulabResponse(RESPONSE_BADVERSION,
                                  output="Client version mismatch!")

        try:
            checknologins()
            pass
        except NoLoginsError, e:
            return EmulabResponse(RESPONSE_REFUSED, output=str(e))

        argerror = CheckRequiredArgs(argdict, ("nodes",))
        if (argerror):
            return argerror

        argstr = ""
        for opt, val in argdict.items():
            if opt == "wait":
                if not xbool(val):
                    argstr += " -s "
                    pass
                pass
            elif opt == "imageproj":
                argstr += " -p "
                argstr += escapeshellarg(val)
                pass
            elif opt == "imageid":
                argstr += " -i "
                argstr += escapeshellarg(val)
                pass
            pass

        tokens = argdict["nodes"].split(",")
        for token in tokens:
            argstr += " " + escapeshellarg(token)
            pass

        (exitval, output) = runcommand(TBDIR + "/bin/os_load " + argstr)

        if exitval:
            return EmulabResponse(RESPONSE_ERROR, exitval >> 8, output=output)
        
        return EmulabResponse(RESPONSE_SUCCESS, output=output)

    pass

#
# Utility functions
#

#
# escapeshellarg() adds single quotes around a string and quotes/escapes any
# existing single quotes allowing string to be passed directly to a shell
# function and having it be treated as a single safe argument.
#
def escapeshellarg(s):
    s2 = ""

    for c in s:
        if c == '\'':
            s2 = s2 + '\'\\\''
        s2 = s2 + c

    return '\'' + s2 + '\''

#
# Run a command. args is a list of strings to pass as arguments to cmd.
# Return the exitcode and the output as a tuple.
# 
def runcommand(cmd):
    child  = popen2.Popen4(cmd)
    output = ""
    while (True):
        foo = child.fromchild.read(8192)
        if foo == "":
            break
        output += foo
        pass
    
    return (child.wait(), output)

def writensfile(str):
    tempfile.tempdir = "/var/tmp"
    try:
        fp = tempfile.NamedTemporaryFile(prefix="php")
        fp.write(str)
        fp.flush()

    except:
        SENDMAIL(TBOPS, "writensfile failed",
                 "Could not write temporary NS file:\n" +
                 "%s:%s" % (sys.exc_type, sys.exc_value))
        return None

    # Yuck. Need to maintain a ref so that the file is not deleted!
    return (fp, fp.name)

#
# Check for no logins.
#
def checknologins():
    if TBGetSiteVar("web/nologins") != "0":
        raise NoLoginsError, TBGetSiteVar("web/message")
    return

#
# A helper function for getting a site variable.
#
def TBGetSiteVar(name):
    res = DBQueryFatal("SELECT value,defaultvalue FROM sitevariables "
                       "WHERE name=%s",
                       (name,))

    if len(res) == 0:
        raise ValueError, "Unknown site variable: " + str(name)

    if res[0][0]:
        retval = res[0][0]
        pass
    else:
        retval = res[0][1]
        pass

    return retval

#
# Convert a file mode mask into something human readable and cross-platform.
#
def filetype(mode):
    if stat.S_ISDIR(mode):
        retval = "d"
        pass
    elif stat.S_ISCHR(mode):
        retval = "c"
        pass
    elif stat.S_ISBLK(mode):
        retval = "b"
        pass
    elif stat.S_ISREG(mode):
        retval = "f"
        pass
    elif stat.S_ISFIFO(mode):
        retval = "q"
        pass
    elif stat.S_ISLNK(mode):
        retval = "l"
        pass
    elif stat.S_ISSOCK(mode):
        retval = "s"
        pass
    else:
        retval = "u"
        pass
    return retval    

#
# A helper function for converting a value into a SQL date string.
#
def sqldate(value):
    if isinstance(value, xmlrpclib.DateTime):
        value = time.strptime(str(value), "%Y%m%dT%H:%M:%S")
        value = time.strftime("%Y-%m-%d %H:%M:%S", value)
        pass
    return value

#
# A helper function for converting an XMLRPC value into a boolean.
#
def xbool(value):
    retval = value
    if value:
        # XXX handle uppercase strings...
        if (value == True or
            value == "true" or
            value == "yes" or
            value == "on" or
            value == "1"):
            retval = True
            pass
        else:
            retval = False
            pass
        pass
    return retval

#
# Check for an acceptable NFS path.
#
def nfspath(value):
    retval = os.path.realpath(value)

    found = False
    for export in NFS_EXPORTS:
        if retval.startswith(export):
            found = True
            break
        pass

    if not found:
        raise OSError(errno.EPERM, "Path is not an NFS export", value)

    return retval
