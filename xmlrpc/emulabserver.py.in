#! /usr/bin/env python
#
# EMULAB-COPYRIGHT
# Copyright (c) 2004 University of Utah and the Flux Group.
# All rights reserved.
#
import sys
import socket
import os
import os.path
import stat
import popen2
import tempfile
import time
import re
import string
import pwd
import grp
import errno
import exceptions
import xmlrpclib
import signal
import types
import datetime

# Configure variables
TBDIR = "@prefix@"
BOSSNODE = "@BOSSNODE@"
BOSSEVENTPORT = "@BOSSEVENTPORT@"
OURDOMAIN = "@OURDOMAIN@"
USERNODE = "@USERNODE@"

TBPATH = os.path.join(TBDIR, "lib")
if TBPATH not in sys.path:
    sys.path.append(TBPATH)
    pass

from libdb        import *
from libtestbed   import SENDMAIL, TBOPS
from emulabclient import *

# Version
VERSION = 0.1

# Well known directories
PROJROOT = "/proj"
GROUPROOT = "/groups"
SHAREROOT = "/share"
USERSROOT = "/users"

# List of directories exported to nodes via NFS.
NFS_EXPORTS = [
    PROJROOT,
    GROUPROOT,
    SHAREROOT,
    USERSROOT,
    ]

#
# XXX
# This mirrors db/xmlconvert. Be sure to keep this table in sync with that table.
#
virtual_tables = {
    "experiments"		: { "rows"  : None, 
                                    "tag"   : "experiment",
                                    "attrs" : [ ] },
    "virt_nodes"		: { "rows"  : None, 
                                    "tag"   : "nodes",
                                    "attrs" : [ "vname" ]},
    "virt_lans"                 : { "rows"  : None, 
                                    "tag"   : "lans",
                                    "attrs" : [ "vname" ]},
    "virt_lan_lans"             : { "rows"  : None, 
                                    "tag"   : "lan_lans",
                                    "attrs" : [ "vname" ]},
    "virt_lan_settings"         : { "rows"  : None, 
                                    "tag"   : "lan_settings",
                                    "attrs" : [ "vname", "capkey" ]},
    "virt_lan_member_settings"  : { "rows"  : None, 
                                    "tag"   : "lan_member_settings",
                                    "attrs" : [ "vname", "member", "capkey" ]},
    "virt_trafgens"		: { "rows"  : None, 
                                    "tag"   : "trafgens",
                                    "attrs" : [ "vname", "vnode" ]},
    "virt_agents"		: { "rows"  : None, 
                                    "tag"   : "agents",
                                    "attrs" : [ "vname", "vnode" ]},
    "virt_node_desires"         : { "rows"  : None, 
                                    "tag"   : "node_desires",
                                    "attrs" : [ "vname", "desire" ]},
    "virt_routes"		: { "rows"  : None, 
                                    "tag"   : "routes",
                                    "attrs" : [ "vname", "src", "dst" ]},
    "virt_vtypes"		: { "rows"  : None, 
                                    "tag"   : "vtypes",
                                    "attrs" : [ "name" ]},
    "virt_programs"		: { "rows"  : None, 
                                    "tag"   : "programs",
                                    "attrs" : [ "vname", "vnode" ]},
    "nseconfigs"		: { "rows"  : None, 
                                    "tag"   : "nseconfigs",
                                    "attrs" : [ "vname" ]},
    "eventlist"                 : { "rows"  : None, 
                                    "tag"   : "events",
                                    "attrs" : [ "vname" ]}
    }
    
# Base class for emulab specific exceptions.
class EmulabError(exceptions.Exception):
    pass

# Exception thrown when logins are not allowed.
class NoLoginsError(EmulabError):
    pass

# Exception thrown an unknown user tries to import this module.
class UnknownUserError(EmulabError):
    pass

# Exception thrown when a timer expires.
class TimedOutError(EmulabError):
    pass

def TimeoutHandler(signum, frame):
    raise TimedOutError, 'Timer Expired'

#
# Arguments to methods are passed as a Dictionary. This converts to a XML
# "struct" which in Perl/PHP/Ruby would be a hash. So, a client written in
# pretty much any language should be able to talk to this class.
#

#
# A helper function for checking required arguments.
#
def CheckRequiredArgs(argdict, arglist):
    # proj,group,exp are aliases for pid,gid,eid
    if (argdict.has_key("pid") and not argdict.has_key("proj")):
        argdict["proj"] = argdict["pid"]
        pass
    if (argdict.has_key("gid") and not argdict.has_key("group")):
        argdict["group"] = argdict["gid"]
        pass
    if (argdict.has_key("eid") and not argdict.has_key("exp")):
        argdict["exp"] = argdict["eid"]
        pass

    # Okay, now check.
    for arg in arglist:
        if not argdict.has_key(arg):
            return EmulabResponse(RESPONSE_BADARGS,
                                  output="Must supply '" + arg + "'")
        pass
    return None

#
# Check user permission to access a project.
#
def CheckProjPermission(uid, pid):
    if not re.match("^[-\w]*$", pid):
        return EmulabResponse(RESPONSE_BADARGS,
                              output="Illegal characters in project ID!")

    res = DBQueryFatal("SELECT trust FROM group_membership "
                       "WHERE uid=%s and pid=%s and gid=%s",
                       (uid, pid, pid))

    if len(res) == 0:
        return EmulabResponse(RESPONSE_FORBIDDEN,
                              output=("You do not have permission to " +
                                      "access project: " + pid))
    
    return None

#
# Check user permission to access an experiment.
# 
def CheckExptPermission(uid, pid, eid):
    if not (re.match("^[-\w]*$", pid) and
            re.match("^[-\w]*$", eid)):
        return EmulabResponse(RESPONSE_BADARGS,
                  output="Illegal characters in project and/or experiment IDs!")
    
    res = DBQueryFatal("SELECT gid FROM experiments "
                       "WHERE pid=%s and eid=%s",
                       (pid, eid))

    if len(res) == 0:
        return EmulabResponse(RESPONSE_ERROR,
                              output="No such experiment: " +
                              pid + "/" + eid)

    gid = res[0][0]
        
    res = DBQueryFatal("SELECT trust FROM group_membership "
                       "WHERE uid=%s and pid=%s and gid=%s",
                       (uid, pid, gid))

    if len(res) == 0:
        return EmulabResponse(RESPONSE_FORBIDDEN,
                              output=("You do not have permission to " +
                                      "access experiment: " + pid + "/" + eid))
    return None

#
# This is a wrapper class so that you can invoke methods in dotted form.
# For example experiment.swapexp(...).
#
class EmulabServer:
    def __init__(self, readonly=0, clientip=None):
        self.readonly  = readonly;
        self.clientip  = clientip;
        self.instances = {};
        self.uid       = pwd.getpwuid(os.getuid())[0]

        self.instances["experiment"] = experiment(readonly=self.readonly);
        if readonly:
            return
        
        self.instances["emulab"]     = emulab(readonly=self.readonly);
        self.instances["user"]       = user(readonly=self.readonly);
        self.instances["fs"]         = fs(readonly=self.readonly);
        self.instances["imageid"]    = imageid(readonly=self.readonly);
        self.instances["osid"]       = osid(readonly=self.readonly);
        self.instances["node"]       = node(readonly=self.readonly);
        self.instances["elabinelab"] = elabinelab(clientip=self.clientip,
                                                  readonly=self.readonly);
        return

    def __getattr__(self, name):
        dotted = name.split(".");
        if len(dotted) != 2:
            raise AttributeError("Bad name '%s'" % name)
        if not self.instances.has_key(dotted[0]):
            raise AttributeError("unknown method '%s' (readonly=%d)" %
                                 (name, self.readonly))
        
        return getattr(self.instances[dotted[0]], dotted[1]);
    pass

#
# This class implements the server side of the XMLRPC interface to emulab as a
# whole.
#
class emulab:
    def __init__(self, readonly=0):
        self.readonly = readonly;
        self.VERSION  = VERSION
        self.uid      = pwd.getpwuid(os.getuid())[0]
        return

    #
    # Get the global 'notice' message that is usually printed under the menu
    # on the web site.
    #
    def message(self, version, argdict):
        if version != self.VERSION:
            return EmulabResponse(RESPONSE_BADVERSION,
                                  output="Client version mismatch!")

        msg = TBGetSiteVar("web/message")

        return EmulabResponse(RESPONSE_SUCCESS,
                              value=msg,
                              output=msg)

    #
    # Get the news items as a list of {subject,author,date,msgid} items for
    # dates between an option start and ending.
    #
    def news(self, version, argdict):
        if version != self.VERSION:
            return EmulabResponse(RESPONSE_BADVERSION,
                                  output="Client version mismatch!")

        # Process optional arguments.
        starting = None;
        if argdict.has_key("starting"):
            if not re.match("^[-:\w]*$", str(argdict["starting"])):
                return EmulabResponse(RESPONSE_BADARGS,
                                      output="Improperly formed 'starting'!")
            starting = sqldate(argdict["starting"])
            pass

        ending = None
        if argdict.has_key("ending"):
            if not re.match("^[-:\w]*$", str(argdict["ending"])):
                return EmulabResponse(RESPONSE_BADARGS,
                                      output="Improperly formed 'ending'!")
            ending = sqldate(argdict["ending"])
            pass

        # Construct the SQL date comparison
        if starting and ending:
            comparison = "BETWEEN %s and %s"
            sub = (starting, ending)
            pass
        elif starting:
            comparison = "> %s"
            sub = (starting,)
            pass
        elif ending:
            comparison = "< %s"
            sub = (ending,)
            pass
        else:
            comparison = ""
            sub = ()
            pass

        # Get the headlines and
        dbres = DBQueryFatal("SELECT subject,author,date,msgid FROM webnews "
                             "WHERE date "
                             + comparison
                             + " ORDER BY date DESC",
                             sub)

        # ... package them up
        result = []
        for res in dbres:
            tmp = {}
            tmp["subject"] = res[0]
            tmp["author"] = res[1]
            tmp["date"] = xmlrpclib.DateTime(
                time.strptime(str(res[2]), "%Y-%m-%d %H:%M:%S"))
            tmp["msgid"] = res[3]
            result.append(tmp)
            pass

        return EmulabResponse(RESPONSE_SUCCESS,
                              value=result,
                              output=str(result))
    
    pass


#
# This class implements the server side of the XMLRPC interface to user
# specific information.
#
class user:
    def __init__(self, readonly=0):
        self.readonly = readonly;
        self.VERSION  = VERSION
        self.uid      = pwd.getpwuid(os.getuid())[0]
        return

    #
    # Get the number of nodes this user is has allocated.
    #
    def nodecount(self, version, argdict):
        if version != self.VERSION:
            return EmulabResponse(RESPONSE_BADVERSION,
                                  output="Client version mismatch!")

        try:
            checknologins()
            pass
        except NoLoginsError, e:
            return EmulabResponse(RESPONSE_REFUSED, output=str(e))

        res = DBQueryFatal(
            "SELECT a.node_id FROM nodes AS a "
            "left join reserved as b on a.node_id=b.node_id "
            "left join node_types as nt on a.type=nt.type "
            "left join experiments as e on b.pid=e.pid and "
            " b.eid=e.eid "
            "WHERE e.expt_head_uid=%s and e.pid!='emulab-ops' "
            "  and a.role='testnode' and nt.class = 'pc'",
            (self.uid,))

        return EmulabResponse(RESPONSE_SUCCESS,
                              value=len(res),
                              output=str(len(res)))

    #
    # Get the listing of projects/groups that this user is a member of and,
    # optionally, has the permission to perform some task.
    #
    def membership(self, version, argdict):
        if version != self.VERSION:
            return EmulabResponse(RESPONSE_BADVERSION,
                                  output="Client version mismatch!")

        try:
            checknologins()
            pass
        except NoLoginsError, e:
            return EmulabResponse(RESPONSE_REFUSED, output=str(e))

        permission = "readinfo"
        if argdict.has_key("permission"):
            permission = argdict["permission"]
            pass

        # Convert the permission to a SQL condition.
        if permission == "readinfo":
            trust_clause = "trust!='none'"
            pass
        elif permission == "makegroup":
            trust_clause = "trust='project_root'"
            pass
        elif permission == "createexpt":
            trust_clause = ("(trust='project_root' or trust='group_root' or "
                            " trust='local_root')")
            pass
        elif permission == "makeosid" or permission == "makeimageid":
            # XXX Handle admin
            trust_clause = ("(trust='project_root' or trust='group_root' or "
                            " trust='local_root')")
            pass
        else:
            return EmulabResponse(RESPONSE_BADARGS,
                                  output=("Bad permission value: "
                                          + permission))

        res = DBQueryFatal("SELECT distinct pid,gid FROM group_membership "
                           "WHERE uid=%s and "
                           + trust_clause
                           + " ORDER BY pid",
                           (self.uid,))

        result = {}
        for proj in res:
            if result.has_key(proj[0]):
                # Add group to existing project list
                tmp = result[proj[0]]
                tmp.append(proj[1])
                pass
            else:
                # Add new project to root list
                tmp = [proj[1],]
                result[proj[0]] = tmp
                pass
            pass

        return EmulabResponse(RESPONSE_SUCCESS,
                              value=result,
                              output=str(result))

    pass


#
# This class implements the server side of the XMLRPC interface to the emulab
# NFS exports.
#
class fs:
    def __init__(self, readonly=0):
        self.readonly = readonly;
        self.VERSION  = VERSION
        self.uid      = pwd.getpwuid(os.getuid())[0]
        return

    #
    # Check the accessibility of a path.
    #
    def access(self, version, argdict):
        if version != self.VERSION:
            return EmulabResponse(RESPONSE_BADVERSION,
                                  output="Client version mismatch!");

        try:
            checknologins()
            pass
        except NoLoginsError, e:
            return EmulabResponse(RESPONSE_REFUSED, output=str(e))

        argerror = CheckRequiredArgs(argdict, ("permission", "path"))
        if (argerror):
            return argerror

        try:
            path = nfspath(argdict["path"]) # Scrub the path
            
            permission = argdict["permission"]

            # Convert the permission to a python compatible value.
            if permission == "read" or permission == "r":
                accessmode = os.R_OK
                pass
            elif permission == "write" or permission == "w":
                accessmode = os.W_OK
                pass
            elif permission == "execute" or permission == "x":
                accessmode = os.X_OK
                pass
            elif permission == "exists" or permission == "e":
                accessmode = os.F_OK
                pass
            else:
                return EmulabResponse(RESPONSE_BADARGS,
                                      output=("Bad permission value: "
                                              + permission))
            
            res = os.access(path, accessmode)

            return EmulabResponse(RESPONSE_SUCCESS,
                                  value=res,
                                  output=str(res))
        except OSError, e:
            return EmulabResponse(RESPONSE_ERROR,
                                  value=e,
                                  output=(e.strerror + ": " + e.filename))

        # Never reached...
        assert False
        pass

    #
    # Get a directory listing for a given path.
    #
    def listdir(self, version, argdict):
        if version != self.VERSION:
            return EmulabResponse(RESPONSE_BADVERSION,
                                  output="Client version mismatch!")

        try:
            checknologins()
            pass
        except NoLoginsError, e:
            return EmulabResponse(RESPONSE_REFUSED, output=str(e))

        argerror = CheckRequiredArgs(argdict, ("path",))
        if (argerror):
            return argerror

        try:
            path = nfspath(argdict["path"]) # Scrub the path

            # Make sure the path is accessible,
            if not os.access(path, os.X_OK):
                raise OSError(errno.EPERM, "Path is not accessible", path)

            # ... get the directory listing, and
            res = os.listdir(path)

            # ... package it up into a platform independent from.
            result = []
            for entry in res:
                try:
                    st = os.stat(os.path.join(path, entry))
                    # The UID/GID will be meaningless to the other side,
                    # resolve them before sending it back.
                    try:
                        uname = pwd.getpwuid(st[stat.ST_UID])[0]
                        pass
                    except:
                        # Unknown UID, just send the number as a string
                        uname = str(st[stat.ST_UID])
                        pass
                    try:
                        gname = grp.getgrgid(st[stat.ST_GID])[0]
                        pass
                    except:
                        # Unknown GID, just send the number as a string
                        gname = str(st[stat.ST_GID])
                        pass
                    result.append((entry,
                                   filetype(st[stat.ST_MODE]),
                                   stat.S_IMODE(st[stat.ST_MODE]),
                                   uname,
                                   gname,
                                   st[stat.ST_SIZE],
                                   st[stat.ST_ATIME],
                                   st[stat.ST_MTIME],
                                   st[stat.ST_CTIME]))
                except OSError:
                    pass
                pass
            retval = EmulabResponse(RESPONSE_SUCCESS,
                                    value=result,
                                    output=str(result))
            pass
        except OSError, e:
            retval = EmulabResponse(RESPONSE_ERROR,
                                    value=e,
                                    output=(e.strerror + ": " + e.filename))
            pass

        return retval

    #
    # Get the list of potential NFS exports for an experiment.
    #
    def exports(self, version, argdict):
        if version != self.VERSION:
            return EmulabResponse(RESPONSE_BADVERSION,
                                  output="Client version mismatch!")

        try:
            checknologins()
            pass
        except NoLoginsError, e:
            return EmulabResponse(RESPONSE_REFUSED, output=str(e))

        # Start with the default set of exports, then
        res = [
            USERSROOT + "/" + self.uid, # XXX Use getpwuid() and handle admin
            SHAREROOT,
            ]

        # ... add the project/group listings.
        projs = DBQueryFatal("SELECT distinct pid,gid FROM group_membership "
                             "WHERE uid=%s and trust!='none' ORDER BY pid",
                             (self.uid,))

        for proj in projs:
            if proj[0] == proj[1]:
                res.append(PROJROOT + "/" + proj[0])
                pass
            else:
                res.append(GROUPROOT + "/" + proj[0] + "/" + proj[1])
                pass
            pass
        
        return EmulabResponse(RESPONSE_SUCCESS,
                              value=res,
                              output=str(res))

    pass


#
# This class implements the server side of the XMLRPC interface to image IDs.
#
class imageid:
    def __init__(self, readonly=0):
        self.readonly = readonly;
        self.VERSION  = VERSION
        self.uid      = pwd.getpwuid(os.getuid())[0]
        return

    def getlist(self, version, argdict):
        if version != self.VERSION:
            return EmulabResponse(RESPONSE_BADVERSION,
                                  output="Client version mismatch!")

        try:
            checknologins()
            pass
        except NoLoginsError, e:
            return EmulabResponse(RESPONSE_REFUSED, output=str(e))

        # Get the listing that is accessible to this user and
        res = DBQueryFatal(
            "SELECT distinct i.imagename,i.description FROM images as i "
            "left join group_membership as g on g.pid=i.pid "
            "WHERE g.uid=%s or i.global",
            (self.uid,))

        if len(res) == 0:
            return EmulabResponse(RESPONSE_ERROR,
                                  output="No image ids?")

        # ... package it up.
        result = {}
        for image in res:
            tmp = {
                "imageid" : image[0],
                "description" : image[1],
                }
            result[image[0]] = tmp
            pass

        return EmulabResponse(RESPONSE_SUCCESS,
                              value=result,
                              output=str(result))

    pass


#
# This class implements the server side of the XMLRPC interface to OS IDs.
#
class osid:
    def __init__(self, readonly=0):
        self.readonly = readonly;
        self.VERSION  = VERSION
        self.uid      = pwd.getpwuid(os.getuid())[0]
        return

    def getlist(self, version, argdict):
        if version != self.VERSION:
            return EmulabResponse(RESPONSE_BADVERSION,
                                  output="Client version mismatch!")

        try:
            checknologins()
            pass
        except NoLoginsError, e:
            return EmulabResponse(RESPONSE_REFUSED, output=str(e))

        # Get the listing that is accessible to this user and
        res = DBQueryFatal("SELECT distinct "
                           "o.osname,o.pid,o.description,o.OS FROM "
                           "os_info as o "
                           "left join group_membership as g on g.pid=o.pid "
                           "where g.uid=%s or o.shared=1",
                           (self.uid,))

        if len(res) == 0:
            return EmulabResponse(RESPONSE_ERROR,
                                  output="No OS IDs?")

        # ... package it up.
        result = {}
        for osid in res:
            tmp = {
                "osid" : osid[0],
                "pid" : osid[1],
                "description" : osid[2],
                "OS" : osid[3],
                }
            result[osid[0]] = tmp
            pass

        return EmulabResponse(RESPONSE_SUCCESS,
                              value=result,
                              output=str(result))

    pass


#
# This class implements the server side of the XMLRPC interface to experiments.
#
class experiment:
    ##
    # Initialize the object.  Currently only sets the objects 'VERSION' value.
    #
    def __init__(self, readonly=0):
        self.readonly = readonly;
        self.VERSION  = VERSION
        self.uid      = pwd.getpwuid(os.getuid())[0]
        return

    ##
    # Echo a message, basically, prepend the host name to the parameter list.
    #
    # @param args The argument list to echo back.
    # @return The 'msg' value with this machine's name prepended.
    #
    def echo(self, version, argdict):
        if not argdict.has_key("str"):
            return EmulabResponse(RESPONSE_BADARGS,
                                  output="Must supply a string to echo!")
        
        return EmulabResponse(RESPONSE_SUCCESS, 0,
                             socket.gethostname() + ": " + str(version)
                             + " " + argdict["str"])

    #
    # Get the physical/policy constraints for experiment parameters.
    #
    def constraints(self, version, argdict):
        if version != self.VERSION:
            return EmulabResponse(RESPONSE_BADVERSION,
                                  output="Client version mismatch!")

        if self.readonly:
            return EmulabResponse(RESPONSE_FORBIDDEN,
                              output="Insufficient privledge to invoke method")
        
        try:
            checknologins()
            pass
        except NoLoginsError, e:
            return EmulabResponse(RESPONSE_REFUSED, output=str(e))

        result = {
            "idle/threshold" : TBGetSiteVar("idle/threshold"),
            # XXX Add more...
            }
        
        return EmulabResponse(RESPONSE_SUCCESS,
                              value=result,
                              output=str(result))

    #
    # Get the list of experiments where the user is the head.
    #
    def getlist(self, version, argdict):
        if version != self.VERSION:
            return EmulabResponse(RESPONSE_BADVERSION,
                                  output="Client version mismatch!")
        
        if self.readonly:
            return EmulabResponse(RESPONSE_FORBIDDEN,
                              output="Insufficient privledge to invoke method")
        
        try:
            checknologins()
            pass
        except NoLoginsError, e:
            return EmulabResponse(RESPONSE_REFUSED, output=str(e))

        # Figure out the format for the returned data.
        if argdict.has_key("format"):
            format = argdict["format"]
            pass
        else:
            format = "brief"
            pass

        # XXX Let the user specify the pid/gid
        dbres = DBQueryFatal("SELECT e.pid,e.gid,e.eid,e.expt_name,e.state,"
                             "e.expt_head_uid "
                             "  FROM experiments AS e "
                             "WHERE e.expt_head_uid=%s",
                             (self.uid,))

        # Build a dictionary of projects that refer to a dictionary of groups
        # that refer to a list of experiments in that group.
        result = {}
        for res in dbres:
            # Get everything from the DB result,
            pid = res[0]
            gid = res[1]
            eid = res[2]
            desc = res[3]
            state = res[4]
            expt_head = res[5]
            # ... make sure 'result' has the proper slots,
            if not result.has_key(pid):
                result[pid] = {
                    gid : list()
                    }
                pass
            elif not result[pid].has_key(gid):
                result[pid][gid] = list()
                pass

            # ... drop the data into place, and
            expdata = None
            if format == "brief":
                expdata = eid;
                pass
            elif format == "full":
                expdata = {
                    "pid" : pid,
                    "gid" : gid,
                    "name" : eid,
                    "description" : desc,
                    "state" : state,
                    "expt_head" : expt_head,
                    }
                pass

            # ... append it to the group list.
            result[pid][gid].append(expdata)
            pass
        
        return EmulabResponse(RESPONSE_SUCCESS,
                              value=result,
                              output=str(result))

    #
    # Start an experiment using batchexp. We get the NS file inline, which
    # we have to write to a temp file first. 
    #
    def batchexp(self, version, argdict):
        if version != self.VERSION:
            return EmulabResponse(RESPONSE_BADVERSION,
                                  output="Client version mismatch!")

        if self.readonly:
            return EmulabResponse(RESPONSE_FORBIDDEN,
                              output="Insufficient privledge to invoke method")
        
        try:
            checknologins()
            pass
        except NoLoginsError, e:
            return EmulabResponse(RESPONSE_REFUSED, output=str(e))

        argerror = CheckRequiredArgs(argdict, ("proj", "exp"))
        if (argerror):
            return argerror

        nsfilename = None
        argstr     = "-q"
        
        for opt, val in argdict.items():
            if opt == "batch":
                if not xbool(val):
                    argstr += " -i"
                    pass
                pass
            elif opt == "description":
                argstr += " -E "
                argstr += escapeshellarg(val)
                pass
            elif opt == "group":
                argstr += " -g "
                argstr += escapeshellarg(val)
                pass
            elif opt == "exp":
                argstr += " -e "
                argstr += escapeshellarg(val)
                pass
            elif opt == "proj":
                argstr += " -p "
                argstr += escapeshellarg(val)
                pass
            elif opt == "swappable":
                if not xbool(val):
                    if not argdict.has_key("noswap_reason"):
                        return EmulabResponse(RESPONSE_BADARGS,
                                       output="Must supply noswap reason!");
                    argstr += " -S "
                    argstr += escapeshellarg(argdict["noswap_reason"])
                    pass
                pass
            elif opt == "noswap_reason":
                pass
            elif opt == "idleswap":
                if val == 0:
                    if not argdict.has_key("noidleswap_reason"):
                        return EmulabResponse(RESPONSE_BADARGS,
                                      output="Must supply noidleswap reason!");
                    argstr += " -L "
                    argstr += escapeshellarg(argdict["noidleswap_reason"])
                    pass
                else:
                    argstr += " -l "
                    argstr += escapeshellarg(str(val))
                    pass
                pass
            elif opt == "noidleswap_reason":
                pass
            elif opt == "autoswap" or opt == "max_duration":
                argstr += " -a "
                argstr += escapeshellarg(str(val))
                pass
            elif opt == "noswapin":
                if xbool(val):
                    argstr += " -f "
                    pass
                pass
            elif opt == "wait":
                if xbool(val):
                    argstr += " -w "
                    pass
                pass
            elif opt == "nsfilepath":
                # Backend script will verify this local path. 
                nsfilename = escapeshellarg(val)
                pass
            elif opt == "nsfilestr":
                nsfilestr = val
            
                if len(nsfilestr) > (1024 * 512):
                    return EmulabResponse(RESPONSE_TOOBIG,
                                         output="NS File way too big!");
        
                (nsfp, nsfilename) = writensfile(nsfilestr)
                if not nsfilename:
                    return EmulabResponse(RESPONSE_SERVERERROR,
                                         output="Server Error")
                pass
            pass

        if nsfilename:
            argstr += " " + nsfilename
            pass

        (exitval, output) = runcommand(TBDIR + "/bin/batchexp " + argstr)
        if exitval:
            return EmulabResponse(RESPONSE_ERROR, exitval >> 8, output=output)
        
        return EmulabResponse(RESPONSE_SUCCESS, output=output)

    #
    # startexp is an alias for batchexp.
    # 
    def startexp(self, version, argdict):
        return self.batchexp(version, argdict)

    #
    # swap an experiment using swapexp. 
    #
    def swapexp(self, version, argdict):
        if version != self.VERSION:
            return EmulabResponse(RESPONSE_BADVERSION,
                                  output="Client version mismatch!")

        if self.readonly:
            return EmulabResponse(RESPONSE_FORBIDDEN,
                              output="Insufficient privledge to invoke method")
        
        try:
            checknologins()
            pass
        except NoLoginsError, e:
            return EmulabResponse(RESPONSE_REFUSED, output=str(e))

        argerror = CheckRequiredArgs(argdict, ("proj", "exp", "direction"))
        if (argerror):
            return argerror

        #
        # Check permission. This will check proj/exp for illegal chars.
        #
        permerror = CheckExptPermission(self.uid,
                                        argdict["proj"], argdict["exp"])
        if (permerror):
            return permerror

        if not (argdict["direction"] == "in" or
                argdict["direction"] == "out"):
            return EmulabResponse(RESPONSE_BADARGS,
                                  output="direction must be 'in' or 'out'");

        argstr = "-q"
        for opt, val in argdict.items():
            if opt == "wait":
                if xbool(val):
                    argstr += " -w "
                    pass
                pass
            pass

        argstr += " -s " + escapeshellarg(argdict["direction"])
        argstr += " " + escapeshellarg(argdict["proj"])
        argstr += " " + escapeshellarg(argdict["exp"])

        (exitval, output) = runcommand(TBDIR + "/bin/swapexp " + argstr)
        if exitval:
            return EmulabResponse(RESPONSE_ERROR, exitval >> 8, output=output)
        
        return EmulabResponse(RESPONSE_SUCCESS, output=output)

    #
    # modify an experiment using swapexp. We get the NS file inline, which
    # we have to write to a temp file first. 
    #
    def modify(self, version, argdict):
        if version != self.VERSION:
            return EmulabResponse(RESPONSE_BADVERSION,
                                  output="Client version mismatch!")

        if self.readonly:
            return EmulabResponse(RESPONSE_FORBIDDEN,
                              output="Insufficient privledge to invoke method")
        
        try:
            checknologins()
            pass
        except NoLoginsError, e:
            return EmulabResponse(RESPONSE_REFUSED, output=str(e))

        argerror = CheckRequiredArgs(argdict, ("proj", "exp"))
        if (argerror):
            return argerror

        #
        # Check permission. This will check proj/exp for illegal chars.
        #
        permerror = CheckExptPermission(self.uid,
                                        argdict["proj"], argdict["exp"])
        if (permerror):
            return permerror

        nsfilename = None
        argstr     = "-q"
        
        for opt, val in argdict.items():
            if opt == "wait":
                if xbool(val):
                    argstr += " -w "
                    pass
                pass
            elif opt == "reboot":
                if xbool(val):
                    argstr += " -r "
                    pass
                pass
            elif opt == "restart_eventsys":
                if xbool(val):
                    argstr += " -e "
                    pass
                pass
            elif opt == "nsfilepath":
                # Backend script will verify this local path. 
                nsfilename = escapeshellarg(val)
                pass
            elif opt == "nsfilestr":
                nsfilestr = val
            
                if len(nsfilestr) > (1024 * 512):
                    return EmulabResponse(RESPONSE_TOOBIG,
                                         output="NS File way too big!");
        
                (nsfp, nsfilename) = writensfile(nsfilestr)
                if not nsfilename:
                    return EmulabResponse(RESPONSE_SERVERERROR,
                                         output="Server Error")
                pass
            pass

        argstr += " -s modify"
        argstr += " " + escapeshellarg(argdict["proj"])
        argstr += " " + escapeshellarg(argdict["exp"])

        if nsfilename:
            argstr += " " + nsfilename
            pass

        (exitval, output) = runcommand(TBDIR + "/bin/swapexp " + argstr)
        if exitval:
            return EmulabResponse(RESPONSE_ERROR, exitval >> 8, output=output)
        
        return EmulabResponse(RESPONSE_SUCCESS, output=output)

    #
    # end an experiment using endexp.
    #
    def endexp(self, version, argdict):
        if version != self.VERSION:
            return EmulabResponse(RESPONSE_BADVERSION,
                                  output="Client version mismatch!")
        
        if self.readonly:
            return EmulabResponse(RESPONSE_FORBIDDEN,
                              output="Insufficient privledge to invoke method")
        
        try:
            checknologins()
            pass
        except NoLoginsError, e:
            return EmulabResponse(RESPONSE_REFUSED, output=str(e))

        argerror = CheckRequiredArgs(argdict, ("proj", "exp"))
        if (argerror):
            return argerror

        #
        # Check permission. This will check proj/exp for illegal chars.
        #
        permerror = CheckExptPermission(self.uid,
                                        argdict["proj"], argdict["exp"])
        if (permerror):
            return permerror

        argstr = "-q"
        for opt, val in argdict.items():
            if opt == "wait":
                if xbool(val):
                    argstr += " -w "
                    pass
                pass
            pass

        argstr += " " + escapeshellarg(argdict["proj"])
        argstr += " " + escapeshellarg(argdict["exp"])

        (exitval, output) = runcommand(TBDIR + "/bin/endexp " + argstr)
        if exitval:
            return EmulabResponse(RESPONSE_ERROR, exitval >> 8, output=output)
        
        return EmulabResponse(RESPONSE_SUCCESS, output=output)

    #
    # Get textual info from tbreport and send back as string
    #
    def expinfo(self, version, argdict):
        if version != self.VERSION:
            return EmulabResponse(RESPONSE_BADVERSION,
                                  output="Client version mismatch!")
        
        if self.readonly:
            return EmulabResponse(RESPONSE_FORBIDDEN,
                              output="Insufficient privledge to invoke method")
        
        try:
            checknologins()
            pass
        except NoLoginsError, e:
            return EmulabResponse(RESPONSE_REFUSED, output=str(e))

        argerror = CheckRequiredArgs(argdict, ("proj", "exp", "show"))
        if (argerror):
            return argerror

        #
        # Check permission. This will check proj/exp for illegal chars.
        #
        permerror = CheckExptPermission(self.uid,
                                        argdict["proj"], argdict["exp"])
        if (permerror):
            return permerror

        argstr = ""
        tokens = argdict["show"].split(",")
        for show in tokens:
            if show == "nodeinfo":
                argstr += " -n"
                pass
            elif show == "mapping":
                argstr += " -m"
                pass
            elif show == "linkinfo":
                argstr += " -l"
                pass
            elif show == "shaping":
                argstr += " -d"
                pass
            pass

        argstr += " " + escapeshellarg(argdict["proj"])
        argstr += " " + escapeshellarg(argdict["exp"])

        (exitval, output) = runcommand(TBDIR + "/bin/tbreport " + argstr)
        if exitval:
            return EmulabResponse(RESPONSE_ERROR, exitval >> 8, output=output)
        
        return EmulabResponse(RESPONSE_SUCCESS, output=output)

    #
    # Return the state of an experiment.
    #
    def state(self, version, argdict):
        if version != self.VERSION:
            return EmulabResponse(RESPONSE_BADVERSION,
                                  output="Client version mismatch!")

        if self.readonly:
            return EmulabResponse(RESPONSE_FORBIDDEN,
                              output="Insufficient privledge to invoke method")
        
#        try:
#            checknologins()
#            pass
#        except NoLoginsError, e:
#            return EmulabResponse(RESPONSE_REFUSED, output=str(e))

        argerror = CheckRequiredArgs(argdict, ("proj", "exp"))
        if (argerror):
            return argerror

        if not (re.match("^[-\w]*$", argdict["proj"]) and
                re.match("^[-\w]*$", argdict["exp"])):
            return EmulabResponse(RESPONSE_BADARGS,
                                  output="Improperly formed proj/exp!")

        #
        # Check permission.
        #
        permerror = CheckExptPermission(self.uid,
                                        argdict["proj"], argdict["exp"])
        if (permerror):
            return permerror

        res = DBQueryFatal("select state from experiments "
                           "where pid=%s and eid=%s",
                           (argdict["proj"], argdict["exp"]))

        if len(res) == 0:
            return EmulabResponse(RESPONSE_ERROR,
                                  output="No such experiment!")

        state = res[0][0]
        return EmulabResponse(RESPONSE_SUCCESS, value=state, output=state)

    #
    # Wait for an experiment to reach a state; this is especially useful
    # with batch experiments. There are probably race conditions inherent
    # in this stuff, but typical usage should not encounter them, I hope.
    #
    def statewait(self, version, argdict):
        if version != self.VERSION:
            return EmulabResponse(RESPONSE_BADVERSION,
                                  output="Client version mismatch!")

#        try:
#            checknologins()
#            pass
#        except NoLoginsError, e:
#            return EmulabResponse(RESPONSE_REFUSED, output=str(e))

        argerror = CheckRequiredArgs(argdict, ("proj", "exp", "state"))
        if (argerror):
            return argerror

        # Check for well formed proj/exp and
        if not (re.match("^[-\w]*$", argdict["proj"]) and
                re.match("^[-\w]*$", argdict["exp"])):
            return EmulabResponse(RESPONSE_BADARGS,
                                  output="Improperly formed proj/exp!")

        # ... timeout arguments.
        if (argdict.has_key("timeout") and
            isinstance(argdict["timeout"], types.StringType) and
            not re.match("^[\d]*$", argdict["timeout"])):
            return EmulabResponse(RESPONSE_BADARGS,
                                  output="Improperly formed timeout!")

        # Make sure the state argument is a list.
        if (not isinstance(argdict["state"], types.ListType)):
            argdict["state"] = [argdict["state"],]
            pass
        
        res = DBQueryFatal("select state from experiments "
                           "where pid=%s and eid=%s",
                           (argdict["proj"], argdict["exp"]))

        if len(res) == 0:
            return EmulabResponse(RESPONSE_ERROR,
                                  output="No such experiment: " +
                                  argdict["proj"] + "/" + argdict["exp"])

        #
        # Check permission.
        #
        permerror = CheckExptPermission(self.uid,
                                        argdict["proj"], argdict["exp"])
        if (permerror):
            return permerror

        #
        # First, see if the experiment is already in the desired state,
        #
        state = res[0][0]
        if (state in argdict["state"]):
            return EmulabResponse(RESPONSE_SUCCESS, value=state, output=state)

        # ... subscribe to the event, and then
        try:
            import tbevent
            pass
        except ImportError, e:
            return EmulabResponse(RESPONSE_ERROR, output="System Error")

        at = tbevent.address_tuple()
        at.objtype = "TBEXPTSTATE"
        at.objname = argdict["proj"] + "/" + argdict["exp"]
        at.expt    = argdict["proj"] + "/" + argdict["exp"]
        at.host    = BOSSNODE

        try:
            mc = tbevent.EventClient(server="localhost", port=BOSSEVENTPORT)
            mc.subscribe(at)
            pass
        except:
            return EmulabResponse(RESPONSE_ERROR,
                                  output="Could not connect to Event System")

        # ... check the state again in case it changed between the first
        # check and the subscription.
        res = DBQueryFatal("select state from experiments "
                           "where pid=%s and eid=%s",
                           (argdict["proj"], argdict["exp"]))

        if len(res) == 0:
            return EmulabResponse(RESPONSE_ERROR,
                                  output="No such experiment: " +
                                  argdict["proj"] + "/" + argdict["exp"])

        state = res[0][0]
        if (state in argdict["state"]):
            return EmulabResponse(RESPONSE_SUCCESS, value=state, output=state)

        if (argdict.has_key("timeout")):
            signal.signal(signal.SIGALRM, TimeoutHandler)
            signal.alarm(int(argdict["timeout"]))
            pass

        # Need to wait for an event.
        try:
            while True:
                ev = mc.poll()

                if ev == None:
                    time.sleep(1) # Slow down the polling.
                    continue

                # ... check if it is one the user cares about.
                if ((argdict["state"] == []) or
                    (ev.getEventType() in argdict["state"])):
                    retval = ev.getEventType()
                    break

                pass
            pass
        except TimedOutError, e:
            return EmulabResponse(RESPONSE_TIMEDOUT,
                                  output=("Timed out waiting for states: "
                                          + `argdict["state"]`))

        if (argdict.has_key("timeout")):
            signal.alarm(0)
            pass

        del(mc)
        
        return EmulabResponse(RESPONSE_SUCCESS, value=retval, output=retval)

    #
    # Wrap up above for a simple "waitforactive" to avoid leaking more
    # goo out then needed (eventstates).
    #
    def waitforactive(self, version, argdict):
        argdict["state"] = "active";
        return self.statewait(version, argdict);
        
    #
    # Return the node/link mappings for an experiment.
    #
    def info(self, version, argdict):
        if version != self.VERSION:
            return EmulabResponse(RESPONSE_BADVERSION,
                                  output="Client version mismatch!")

        if self.readonly:
            return EmulabResponse(RESPONSE_FORBIDDEN,
                              output="Insufficient privledge to invoke method")
        
        try:
            checknologins()
            pass
        except NoLoginsError, e:
            return EmulabResponse(RESPONSE_REFUSED, output=str(e))

        argerror = CheckRequiredArgs(argdict, ("proj", "exp", "aspect"))
        if (argerror):
            return argerror

        if not (re.match("^[-\w]*$", argdict["proj"]) and
                re.match("^[-\w]*$", argdict["exp"])):
            return EmulabResponse(RESPONSE_BADARGS,
                                  output="Illegal characters in arguments!")

        #
        # Check permission.
        #
        permerror = CheckExptPermission(self.uid,
                                        argdict["proj"], argdict["exp"])
        if (permerror):
            return permerror

        res = DBQueryFatal("select state from experiments "
                           "where pid=%s and eid=%s",
                           (argdict["proj"], argdict["exp"]))

        if len(res) == 0:
            return EmulabResponse(RESPONSE_ERROR,
                                  output="No such experiment!")
        state   = res[0][0]
        result  = {}
        mapping = None

        if state == "active":
            dbres = DBQuery(
                "select r.vname,r.node_id,n.type,n.def_boot_osid,ns.status,"
                "n.eventstate,"
                "(unix_timestamp(now()) - unix_timestamp( "
                "greatest(na.last_tty_act,na.last_net_act,na.last_cpu_act,"
                "na.last_ext_act))),ni.load_1min,ni.load_5min,ni.load_15min,"
                "n.phys_nodeid "
                "  from reserved as r "
                "left join nodes as n on r.node_id=n.node_id "
                "left join node_status as ns on ns.node_id=n.node_id "
                "left join node_activity as na on na.node_id=n.node_id "
                "left join node_idlestats as ni on ni.node_id=n.node_id "
                "where r.pid=%s and r.eid=%s "
                "order by r.vname",
                (argdict["proj"], argdict["exp"]))
            osmappings = {}
            mapping = {}
            for res in dbres:
                tmp = {}
                tmp["name"] = res[0]
                tmp["node"] = res[1]
                tmp["type"] = res[2]
                tmp["pnode"] = res[10];
                if not osmappings.has_key(res[3]):
                    osres = DBQuery(
                        "SELECT osname from os_info where osid=%s", (res[3],))
                    osmappings[res[3]] = osres[0][0]
                    pass
                tmp["osid"] = osmappings[res[3]]
                tmp["status"] = res[4]
                if res[5]:
                    tmp["eventstatus"] = res[5]
                    pass
                if res[6]:
                    tmp["idle"] = res[6]
                    pass
                if res[7]:
                    tmp["load_1min"] = res[7]
                    pass
                if res[8]:
                    tmp["load_5min"] = res[8]
                    pass
                if res[9]:
                    tmp["load_15min"] = res[9]
                    pass
                mapping[res[0]] = tmp
                pass
            pass

        if argdict["aspect"] == "mapping":
            if state != "active":
                return EmulabResponse(RESPONSE_ERROR,
                                      output="Experiment is not active!")
            # Just return the mapping above
            result = mapping
            pass
        elif argdict["aspect"] == "links":
            dbres = DBQueryFatal("SELECT vname,ips from virt_nodes "
                                 "where pid=%s and eid=%s",
                                 (argdict["proj"], argdict["exp"]))
            ipmap = {}
            for res in dbres:
                for ipinfo in string.split(res[1], " "):
                    if len(ipinfo) > 0:
                        port, ip = string.split(ipinfo, ":")
                        ipmap[res[0] + ":" + port] = ip
                        pass
                    pass
                pass
            
            dbres = DBQuery("select vname,member,mask,delay,bandwidth, "
                            "       lossrate,rdelay,rbandwidth,rlossrate "
                            "from virt_lans where pid=%s and eid=%s "
                            "order by vname,member",
                            (argdict["proj"], argdict["exp"]))

            if len(dbres) > 0:
                for res in dbres:
                    tmp = {}
                    tmp["name"]        = res[0]
                    tmp["member"]      = res[1]
                    tmp["ipaddr"]      = ipmap[res[1]]
                    tmp["mask"]        = res[2]
                    tmp["delay"]       = res[3]
                    tmp["bandwidth"]   = int(res[4])
                    tmp["plr"]         = res[5]
                    tmp["r_delay"]     = res[6]
                    tmp["r_bandwidth"] = int(res[7])
                    tmp["r_plr"]       = res[8]
                    result[res[1]]     = tmp
                    pass
                pass
            pass
        
        return EmulabResponse(RESPONSE_SUCCESS, value=result, output="")

    #
    # nscheck an NS file.
    #
    def nscheck(self, version, argdict):
        if version != self.VERSION:
            return EmulabResponse(RESPONSE_BADVERSION,
                                  output="Client version mismatch!")

        if self.readonly:
            return EmulabResponse(RESPONSE_FORBIDDEN,
                              output="Insufficient privledge to invoke method")
        
        try:
            checknologins()
            pass
        except NoLoginsError, e:
            return EmulabResponse(RESPONSE_REFUSED, output=str(e))

        argstr = ""

        if argdict.has_key("nsfilestr"):
            nsfilestr = argdict["nsfilestr"]
            
            if len(nsfilestr) > (1024 * 512):
                return EmulabResponse(RESPONSE_TOOBIG,
                                     output="NS File way too big!");
        
            (nsfp, nsfilename) = writensfile(nsfilestr)
            if not nsfilename:
                return EmulabResponse(RESPONSE_SERVERERROR,
                                      output="Server Error")

            argstr += nsfilename
            pass
        elif argdict.has_key("nsfilepath"):
            # Backend script will verify this local path. 
            argstr += escapeshellarg(argdict["nsfilepath"])
            pass
        else:
            return EmulabResponse(RESPONSE_BADARGS,
                                 output="Must supply an NS file to check!");
        
        (exitval, output) = runcommand(TBDIR + "/bin/nscheck " + argstr)
        if exitval:
            return EmulabResponse(RESPONSE_ERROR, exitval >> 8, output=output)
        
        return EmulabResponse(RESPONSE_SUCCESS, output=output)

    #
    # Delay configuration
    #
    def delay_config(self, version, argdict):
        if version != self.VERSION:
            return EmulabResponse(RESPONSE_BADVERSION,
                                  output="Client version mismatch!")

        if self.readonly:
            return EmulabResponse(RESPONSE_FORBIDDEN,
                              output="Insufficient privledge to invoke method")
        
        try:
            checknologins()
            pass
        except NoLoginsError, e:
            return EmulabResponse(RESPONSE_REFUSED, output=str(e))

        argerror = CheckRequiredArgs(argdict,
                                     ("proj", "exp", "link", "params"))
        if (argerror):
            return argerror

        #
        # Check permission. This will check proj/exp for illegal chars.
        #
        permerror = CheckExptPermission(self.uid,
                                        argdict["proj"], argdict["exp"])
        if (permerror):
            return permerror

        argstr = ""
        for opt, val in argdict.items():
            if opt == "persist":
                if xbool(val):
                    argstr += " -m "
                    pass
                pass
            elif opt == "src":
                argstr += " -s "
                argstr += escapeshellarg(val)
                pass
            pass

        argstr += " " + escapeshellarg(argdict["proj"])
        argstr += " " + escapeshellarg(argdict["exp"])
        argstr += " " + escapeshellarg(argdict["link"])

        for opt, val in argdict["params"].items():
            argstr += " " + escapeshellarg(opt + "=" + str(val))
            pass
        
        (exitval, output) = runcommand(TBDIR + "/bin/delay_config " + argstr)
        if exitval:
            return EmulabResponse(RESPONSE_ERROR, exitval >> 8, output=output)
        
        return EmulabResponse(RESPONSE_SUCCESS, output=output)

    #
    # Wireless link configuration
    #
    def link_config(self, version, argdict):
        if version != self.VERSION:
            return EmulabResponse(RESPONSE_BADVERSION,
                                  output="Client version mismatch!")

        if self.readonly:
            return EmulabResponse(RESPONSE_FORBIDDEN,
                              output="Insufficient privledge to invoke method")
        
        try:
            checknologins()
            pass
        except NoLoginsError, e:
            return EmulabResponse(RESPONSE_REFUSED, output=str(e))

        argerror = CheckRequiredArgs(argdict,
                                     ("proj", "exp", "link", "params"))
        if (argerror):
            return argerror

        #
        # Check permission. This will check proj/exp for illegal chars.
        #
        permerror = CheckExptPermission(self.uid,
                                        argdict["proj"], argdict["exp"])
        if (permerror):
            return permerror

        argstr = ""
        for opt, val in argdict.items():
            if opt == "persist":
                if xbool(val):
                    argstr += " -m "
                    pass
                pass
            elif opt == "src":
                argstr += " -s "
                argstr += escapeshellarg(val)
                pass
            pass

        argstr += " " + escapeshellarg(argdict["proj"])
        argstr += " " + escapeshellarg(argdict["exp"])
        argstr += " " + escapeshellarg(argdict["link"])

        for opt, val in argdict["params"].items():
            argstr += " " + escapeshellarg(opt + "=" + str(val))
            pass
        
        (exitval, output) = runcommand(TBDIR + "/bin/link_config " + argstr)
        if exitval:
            return EmulabResponse(RESPONSE_ERROR, exitval >> 8, output=output)
        
        return EmulabResponse(RESPONSE_SUCCESS, output=output)

    #
    # iwconfig is an alias for link_config
    # 
    def iwconfig(self, version, argdict):
        return self.link_config(version, argdict)

    #
    # Reboot all nodes in an experiment.
    #
    def reboot(self, version, argdict):
        if version != self.VERSION:
            return EmulabResponse(RESPONSE_BADVERSION,
                                  output="Client version mismatch!")

        if self.readonly:
            return EmulabResponse(RESPONSE_FORBIDDEN,
                              output="Insufficient privledge to invoke method")
        
        try:
            checknologins()
            pass
        except NoLoginsError, e:
            return EmulabResponse(RESPONSE_REFUSED, output=str(e))

        argerror = CheckRequiredArgs(argdict, ("proj", "exp"))
        if (argerror):
            return argerror

        #
        # Check permission. This will check proj/exp for illegal chars.
        #
        permerror = CheckExptPermission(self.uid,
                                        argdict["proj"], argdict["exp"])
        if (permerror):
            return permerror

        argstr = ""
        for opt, val in argdict.items():
            if opt == "wait":
                if xbool(val):
                    argstr += " -w "
                    pass
                pass
            elif opt == "power":
                if xbool(val):
                    argstr += " -f "
                    pass
                pass
            elif opt == "reconfig":
                if xbool(val):
                    argstr += " -c "
                    pass
                pass
            pass

        argstr += " -e "
        argstr += escapeshellarg(argdict["proj"] + "," + argdict["exp"])
        
        (exitval, output) = runcommand(TBDIR + "/bin/node_reboot " + argstr)
        if exitval:
            return EmulabResponse(RESPONSE_ERROR, exitval >> 8, output=output)
        
        return EmulabResponse(RESPONSE_SUCCESS, output=output)

    #
    # Reload all nodes in an experiment.
    #
    def reload(self, version, argdict):
        if version != self.VERSION:
            return EmulabResponse(RESPONSE_BADVERSION,
                                  output="Client version mismatch!")

        if self.readonly:
            return EmulabResponse(RESPONSE_FORBIDDEN,
                              output="Insufficient privledge to invoke method")
        
        try:
            checknologins()
            pass
        except NoLoginsError, e:
            return EmulabResponse(RESPONSE_REFUSED, output=str(e))

        argerror = CheckRequiredArgs(argdict, ("proj", "exp"))
        if (argerror):
            return argerror

        #
        # Check permission. This will check proj/exp for illegal chars.
        #
        permerror = CheckExptPermission(self.uid,
                                        argdict["proj"], argdict["exp"])
        if (permerror):
            return permerror

        argstr = ""
        for opt, val in argdict.items():
            if opt == "wait":
                if not xbool(val):
                    argstr += " -s "
                    pass
                pass
            elif opt == "imageproj":
                argstr += " -p "
                argstr += escapeshellarg(val)
                pass
            elif opt == "imagename":
                argstr += " -i "
                argstr += escapeshellarg(val)
                pass
            elif opt == "imageid":
                argstr += " -m "
                argstr += escapeshellarg(val)
                pass
            elif opt == "reboot":
                if not xbool(val):
                    argstr += " -r "
                    pass
                pass
            pass

        argstr += " -e "
        argstr += escapeshellarg(argdict["proj"] + "," + argdict["exp"])
        
        (exitval, output) = runcommand(TBDIR + "/bin/os_load " + argstr)

        if exitval:
            return EmulabResponse(RESPONSE_ERROR, exitval >> 8, output=output)
        
        return EmulabResponse(RESPONSE_SUCCESS, output=output)

    #
    # Download experiment topology.
    #
    def virtual_topology(self, version, argdict):
        if version != self.VERSION:
            return EmulabResponse(RESPONSE_BADVERSION,
                                 output="Client version mismatch!");
            pass

        if self.readonly:
            return EmulabResponse(RESPONSE_FORBIDDEN,
                              output="Insufficient privledge to invoke method")
        
        try:
            checknologins()
            pass
        except NoLoginsError, e:
            return EmulabResponse(RESPONSE_REFUSED, output=str(e))

        argerror = CheckRequiredArgs(argdict, ("proj", "exp"))
        if (argerror):
            return argerror

        if not (re.match("^[-\w]*$", argdict["proj"]) and
                re.match("^[-\w]*$", argdict["exp"])):
            return EmulabResponse(RESPONSE_BADARGS,
                                  output="Illegal characters in arguments!")

        #
        # Check permission.
        #
        permerror = CheckExptPermission(self.uid,
                                        argdict["proj"], argdict["exp"])
        if (permerror):
            return permerror

        res = DBQuery("SELECT * FROM experiments "
                      "WHERE pid=%s and eid=%s",
                      (argdict["proj"], argdict["exp"]), asDict=True);

        #
        # Convert NULL to ""
        #
        for key, val in res[0].items():
            if val == None:
                res[0][key] = ""
                pass
            elif isinstance(val, datetime.datetime):
                res[0][key] = xmlrpclib.DateTime(
                    time.strptime(str(val), "%Y-%m-%d %H:%M:%S"))
                pass
            pass

        result   = {}
        result["experiment"] = {}
        result["experiment"]["settings"] = res[0];

        #
        # Get the rest of the virtual tables.
        # 
        for key, val in virtual_tables.items():
            if key == "experiments":
                continue
            
            tag  = val["tag"]
            rows = []

            res = DBQuery("SELECT * FROM " + key + " " +
                          "WHERE pid=%s and eid=%s",
                          (argdict["proj"], argdict["exp"]), asDict=True);

            if len(res) > 0:
                for row in res:
                    #
                    # Convert NULL to ""
                    #
                    for key2, val2 in row.items():
                        if val2 == None:
                            row[key2] = ""
                            pass
                        elif isinstance(val2, datetime.datetime):
                            row[key2] = xmlrpclib.DateTime(
                                time.strptime(str(val2), "%Y-%m-%d %H:%M:%S"))
                            pass
                        pass

                    rows.append(row)
                    pass
                pass
            
            result["experiment"][tag] = rows
            pass

        result = (result,)
        
        return EmulabResponse(RESPONSE_SUCCESS, value=result, output="")
    
    def virtual_topology_xml(self, version, argdict):
        if version != self.VERSION:
            return EmulabResponse(RESPONSE_BADVERSION,
                                 output="Client version mismatch!");
            pass

        if self.readonly:
            return EmulabResponse(RESPONSE_FORBIDDEN,
                              output="Insufficient privledge to invoke method")
        
        try:
            checknologins()
            pass
        except NoLoginsError, e:
            return EmulabResponse(RESPONSE_REFUSED, output=str(e))

        argerror = CheckRequiredArgs(argdict, ("proj", "exp"))
        if (argerror):
            return argerror

        if not (re.match("^[-\w]*$", argdict["proj"]) and
                re.match("^[-\w]*$", argdict["exp"])):
            return EmulabResponse(RESPONSE_BADARGS,
                                  output="Illegal characters in arguments!")

        #
        # Check permission. 
        #
        permerror = CheckExptPermission(self.uid,
                                        argdict["proj"], argdict["exp"])
        if (permerror):
            return permerror

        argstr  = ""
        argstr += " " + escapeshellarg(argdict["proj"])
        argstr += " " + escapeshellarg(argdict["exp"])
        
        (exitval, output) = runcommand(TBDIR + "/libexec/xmlconvert " + argstr)
        if exitval:
            return EmulabResponse(RESPONSE_ERROR, exitval >> 8, output=output)
        
        return EmulabResponse(RESPONSE_SUCCESS, value=output, output="")
    
    #
    # Return the visualization data for the experiment.
    #
    def getviz(self, version, argdict):
        if version != self.VERSION:
            return EmulabResponse(RESPONSE_BADVERSION,
                                  output="Client version mismatch!")

        if self.readonly:
            return EmulabResponse(RESPONSE_FORBIDDEN,
                              output="Insufficient privledge to invoke method")
        
        try:
            checknologins()
            pass
        except NoLoginsError, e:
            return EmulabResponse(RESPONSE_REFUSED, output=str(e))

        argerror = CheckRequiredArgs(argdict, ("proj", "exp"))
        if (argerror):
            return argerror

        if not (re.match("^[-\w]*$", argdict["proj"]) and
                re.match("^[-\w]*$", argdict["exp"])):
            return EmulabResponse(RESPONSE_BADARGS,
                                  output="Improperly formed proj/exp!")

        #
        # Check permission. 
        #
        permerror = CheckExptPermission(self.uid,
                                        argdict["proj"], argdict["exp"])
        if (permerror):
            return permerror

        dbres = DBQueryFatal("select vname,vis_type,x,y from vis_nodes "
                             "where pid=%s and eid=%s",
                             (argdict["proj"], argdict["exp"]))

        if len(dbres) == 0:
            return EmulabResponse(RESPONSE_ERROR,
                                  output="No such experiment!")

        result = {}
        for res in dbres:
            tmp = {}
            tmp["name"] = res[0]
            tmp["type"] = res[1]
            tmp["x"] = res[2]
            tmp["y"] = res[3]
            result[res[0]] = tmp
            pass

        return EmulabResponse(RESPONSE_SUCCESS,
                              value=result,
                              output=str(result))

    #
    # Return the thumbnail image of experiment's topology.
    #
    def thumbnail(self, version, argdict):
        if version != self.VERSION:
            return EmulabResponse(RESPONSE_BADVERSION,
                                  output="Client version mismatch!")

        if self.readonly:
            return EmulabResponse(RESPONSE_FORBIDDEN,
                              output="Insufficient privledge to invoke method")
        
        try:
            checknologins()
            pass
        except NoLoginsError, e:
            return EmulabResponse(RESPONSE_REFUSED, output=str(e))

        # Check for valid arguments.
        argerror = CheckRequiredArgs(argdict, ("proj", "exp"))
        if (argerror):
            return argerror

        if not (re.match("^[-\w]*$", argdict["proj"]) and
                re.match("^[-\w]*$", argdict["exp"])):
            return EmulabResponse(RESPONSE_BADARGS,
                                  output="Improperly formed proj/exp!")

        #
        # Check permission. This will check proj/exp for illegal chars.
        #
        permerror = CheckExptPermission(self.uid,
                                        argdict["proj"], argdict["exp"])
        if (permerror):
            return permerror

        dbres = DBQueryFatal(
            "select s.rsrcidx from experiments as e "
            "left join experiment_stats as s on s.exptidx=e.idx "
            "where e.pid=%s and e.eid=%s",
            (argdict["proj"], argdict["exp"]))

        if len(dbres) == 0:
            return EmulabResponse(RESPONSE_ERROR,
                                  output="No such experiment!")
        
        dbres = DBQueryFatal(
            "select thumbnail from experiment_resources "
            "where idx=%s",
            (dbres[0][0],))

        # The return is a PNG, which needs to be encoded as base64 before
        # sending over XML-RPC.
        result = xmlrpclib.Binary(dbres[0][0])
        
        return EmulabResponse(RESPONSE_SUCCESS,
                              value=result,
                              output="ok")

    #
    # Control the event system.
    #
    def eventsys_control(self, version, argdict):
        if version != self.VERSION:
            return EmulabResponse(RESPONSE_BADVERSION,
                                  output="Client version mismatch!")

        if self.readonly:
            return EmulabResponse(RESPONSE_FORBIDDEN,
                              output="Insufficient privledge to invoke method")
        
        try:
            checknologins()
            pass
        except NoLoginsError, e:
            return EmulabResponse(RESPONSE_REFUSED, output=str(e))

        argerror = CheckRequiredArgs(argdict, ("proj", "exp", "action"))
        if (argerror):
            return argerror

        if not (re.match("^[-\w]*$", argdict["proj"]) and
                re.match("^[-\w]*$", argdict["exp"]) and
                re.match("^[-\w]*$", argdict["action"])):
            return EmulabResponse(RESPONSE_BADARGS,
                                  output="Improperly formed proj/exp/op!")

        if not (argdict["action"] == "start" or
                argdict["action"] == "stop" or
                argdict["action"] == "replay"):
            return EmulabResponse(RESPONSE_BADARGS,
                               output="action must be one of start|stop|replay")

        #
        # Check permission. 
        #
        permerror = CheckExptPermission(self.uid,
                                        argdict["proj"], argdict["exp"])
        if (permerror):
            return permerror

        argstr  = ""
        argstr += " " + escapeshellarg(argdict["action"])
        argstr += " " + escapeshellarg(argdict["proj"])
        argstr += " " + escapeshellarg(argdict["exp"])
        
        (exitval, output) = runcommand(TBDIR + "/bin/eventsys_control "
                                       + argstr)
        if exitval:
            return EmulabResponse(RESPONSE_ERROR, exitval >> 8, output=output)
        
        return EmulabResponse(RESPONSE_SUCCESS, value=exitval, output="")

    #
    # savelogs. What a silly thing to do.
    # 
    def savelogs(self, version, argdict):
        if version != self.VERSION:
            return EmulabResponse(RESPONSE_BADVERSION,
                                 output="Client version mismatch!");
            pass

        if self.readonly:
            return EmulabResponse(RESPONSE_FORBIDDEN,
                              output="Insufficient privledge to invoke method")
        
        try:
            checknologins()
            pass
        except NoLoginsError, e:
            return EmulabResponse(RESPONSE_REFUSED, output=str(e))

        argerror = CheckRequiredArgs(argdict, ("proj", "exp"))
        if (argerror):
            return argerror

        if not (re.match("^[-\w]*$", argdict["proj"]) and
                re.match("^[-\w]*$", argdict["exp"])):
            return EmulabResponse(RESPONSE_BADARGS,
                                  output="Illegal characters in arguments!")

        #
        # Check permission. 
        #
        permerror = CheckExptPermission(self.uid,
                                        argdict["proj"], argdict["exp"])
        if (permerror):
            return permerror

        argstr  = ""
        argstr += " " + escapeshellarg(argdict["proj"])
        argstr += " " + escapeshellarg(argdict["exp"])
        
        (exitval, output) = runcommand(TBDIR + "/bin/savelogs " + argstr)
        if exitval:
            return EmulabResponse(RESPONSE_ERROR, exitval >> 8, output=output)
        
        return EmulabResponse(RESPONSE_SUCCESS, value=exitval, output="")
    
    #
    # portstats
    # 
    def portstats(self, version, argdict):
        if version != self.VERSION:
            return EmulabResponse(RESPONSE_BADVERSION,
                                 output="Client version mismatch!");
            pass

        if self.readonly:
            return EmulabResponse(RESPONSE_FORBIDDEN,
                              output="Insufficient privledge to invoke method")
        
        try:
            checknologins()
            pass
        except NoLoginsError, e:
            return EmulabResponse(RESPONSE_REFUSED, output=str(e))

        #
        # Pass the whole thing off to the backend script. It would be nice
        # to do this differently, but too much trouble.
        #
        proj   = None;
        expt   = None;
        argstr = ""
        for opt, val in argdict.items():
            if opt == "errors-only":
                if xbool(val):
                    argstr += " -e "
                    pass
                pass
            elif opt == "all":
                if xbool(val):
                    argstr += " -a "
                    pass
                pass
            elif opt == "clear":
                if xbool(val):
                    argstr += " -z "
                    pass
                pass
            elif opt == "quiet":
                if xbool(val):
                    argstr += " -q "
                    pass
                pass
            elif opt == "absolute":
                if xbool(val):
                    argstr += " -c "
                    pass
                pass
            elif opt == "physnames":
                if xbool(val):
                    argstr += " -p "
                    pass
                pass
            elif opt == "proj":
                proj = val;
                pass
            elif opt == "exp":
                expt = val;
                pass
            pass

        if (proj or expt):
            if ((not (proj and expt)) or argdict.has_key("physnames")):
                return EmulabResponse(RESPONSE_BADARGS,
                                      output="pid/eid/physnames")
            argstr += " " + escapeshellarg(proj);
            argstr += " " + escapeshellarg(expt);
            pass

        for name in argdict["nodeports"]:
            argstr += " " + escapeshellarg(name);
            pass
        
        (exitval, output) = runcommand(TBDIR + "/bin/portstats " + argstr)
        if exitval:
            return EmulabResponse(RESPONSE_ERROR, exitval >> 8, output=output)
        
        return EmulabResponse(RESPONSE_SUCCESS, value=exitval, output=output)
    
    #
    # readycount
    # 
    def readycount(self, version, argdict):
        if version != self.VERSION:
            return EmulabResponse(RESPONSE_BADVERSION,
                                 output="Client version mismatch!");
            pass

        if self.readonly:
            return EmulabResponse(RESPONSE_FORBIDDEN,
                              output="Insufficient privledge to invoke method")
        
        try:
            checknologins()
            pass
        except NoLoginsError, e:
            return EmulabResponse(RESPONSE_REFUSED, output=str(e))

        #
        # Pass the whole thing off to the backend script. It would be nice
        # to do this differently, but too much trouble.
        #
        proj   = None;
        expt   = None;
        argstr = ""
        for opt, val in argdict.items():
            if opt == "set":
                if xbool(val):
                    argstr += " -s "
                    pass
                pass
            elif opt == "clear":
                if xbool(val):
                    argstr += " -c "
                    pass
                pass
            elif opt == "list":
                if xbool(val):
                    argstr += " -l "
                    pass
                pass
            elif opt == "physnames":
                if xbool(val):
                    argstr += " -p "
                    pass
                pass
            elif opt == "proj":
                proj = val;
                pass
            elif opt == "exp":
                expt = val;
                pass
            pass

        if (proj or expt):
            if ((not (proj and expt)) or argdict.has_key("physnames")):
                return EmulabResponse(RESPONSE_BADARGS,
                                      output="pid/eid/physnames")
            argstr += " " + escapeshellarg(proj);
            argstr += " " + escapeshellarg(expt);
            pass

        for name in argdict["nodes"]:
            argstr += " " + escapeshellarg(name);
            pass
        
        (exitval, output) = runcommand(TBDIR + "/bin/readycount " + argstr)
        if exitval:
            return EmulabResponse(RESPONSE_ERROR, exitval >> 8, output=output)
        
        return EmulabResponse(RESPONSE_SUCCESS, value=exitval, output=output)

    #
    # Get event agent list for event scheduler.
    #
    def event_agentlist(self, version, argdict):
        if version != self.VERSION:
            return EmulabResponse(RESPONSE_BADVERSION,
                                  output="Client version mismatch!")

        argerror = CheckRequiredArgs(argdict, ("proj", "exp"))
        if (argerror):
            return argerror

        if not (re.match("^[-\w]*$", argdict["proj"]) and
                re.match("^[-\w]*$", argdict["exp"])):
            return EmulabResponse(RESPONSE_BADARGS,
                                  output="Improperly formed proj/exp!")

        #
        # Check permission. 
        #
        permerror = CheckExptPermission(self.uid,
                                        argdict["proj"], argdict["exp"])
        if (permerror):
            return permerror

        #
        # We return the result as a list of lists.
        #
        result = []

	res = DBQuery("select vi.vname,vi.vnode,r.node_id,o.type "
                      " from virt_agents as vi "
                      "left join reserved as r on "
                      " r.vname=vi.vnode and r.pid=vi.pid and "
                      " r.eid=vi.eid "
                      "left join event_objecttypes as o on "
                      " o.idx=vi.objecttype "
                      "where vi.pid=%s and vi.eid=%s",
                      (argdict["proj"], argdict["exp"]))

        for agent in res:
            if agent[2] == None:
                nodeid = ""
                ipaddr = ""
                pass
            else:
                ipres = DBQuery("select IP from nodes as n2 "
			 "left join nodes as n1 on n1.node_id=n2.phys_nodeid "
			 "left join node_types as nt on n1.type=nt.type "
			 "left join interfaces as i on "
			 "i.node_id=n1.node_id and i.iface=nt.control_iface "
			 "where n2.node_id=%s",
                         (agent[2]))

                if not ipres or len(ipres) == 0:
                    continue

                ipaddr = ipres[0][0];
                nodeid = agent[2]
                pass 
            
            result.append((agent[0], agent[1], nodeid, ipaddr, agent[3]))
            pass
        
        return EmulabResponse(RESPONSE_SUCCESS, value=result)
    
    #
    # Get event group list for event scheduler.
    #
    def event_grouplist(self, version, argdict):
        if version != self.VERSION:
            return EmulabResponse(RESPONSE_BADVERSION,
                                  output="Client version mismatch!")

        argerror = CheckRequiredArgs(argdict, ("proj", "exp"))
        if (argerror):
            return argerror

        if not (re.match("^[-\w]*$", argdict["proj"]) and
                re.match("^[-\w]*$", argdict["exp"])):
            return EmulabResponse(RESPONSE_BADARGS,
                                  output="Improperly formed proj/exp!")

        #
        # Check permission. 
        #
        permerror = CheckExptPermission(self.uid,
                                        argdict["proj"], argdict["exp"])
        if (permerror):
            return permerror

        #
        # We return the result as a list of lists.
        #
        result = []

	res = DBQuery("select group_name,agent_name from event_groups "
                      "where pid=%s and eid=%s",
                      (argdict["proj"], argdict["exp"]))

        for group in res:
            result.append((group[0], group[1]))
            pass
        
        return EmulabResponse(RESPONSE_SUCCESS, value=result)
    
    #
    # Get event list for event scheduler.
    #
    def event_eventlist(self, version, argdict):
        if version != self.VERSION:
            return EmulabResponse(RESPONSE_BADVERSION,
                                  output="Client version mismatch!")

        argerror = CheckRequiredArgs(argdict, ("proj", "exp"))
        if (argerror):
            return argerror

        if not (re.match("^[-\w]*$", argdict["proj"]) and
                re.match("^[-\w]*$", argdict["exp"])):
            return EmulabResponse(RESPONSE_BADARGS,
                                  output="Improperly formed proj/exp!")

        #
        # Check permission. 
        #
        permerror = CheckExptPermission(self.uid,
                                        argdict["proj"], argdict["exp"])
        if (permerror):
            return permerror

        #
        # We return the result as a list of lists.
        #
        result = []

	res = DBQuery("select ex.idx,ex.time,ex.vname,"
                      " ot.type,et.type,ex.arguments from eventlist as ex "
                      "left join event_eventtypes as et on "
                      " ex.eventtype=et.idx "
                      "left join event_objecttypes as ot on "
                      " ex.objecttype=ot.idx "
                      "where ex.pid=%s and ex.eid=%s "
                      "order by ex.time ASC",
                      (argdict["proj"], argdict["exp"]))

        for event in res:
            result.append((str(event[0]), str(event[1]), event[2],
                           event[3], event[4], event[5]));
            pass
        
        return EmulabResponse(RESPONSE_SUCCESS, value=result)
    
    pass

#
# This class implements the server side of the XMLRPC interface to nodes.
#
class node:
    ##
    # Initialize the object.  Currently only sets the objects 'VERSION' value.
    #
    def __init__(self, readonly=0):
        self.readonly = readonly;
        self.VERSION  = VERSION
        self.uid      = pwd.getpwuid(os.getuid())[0]
        return

    #
    # Get the number of free nodes.
    #
    def available(self, version, argdict):
        if version != self.VERSION:
            return EmulabResponse(RESPONSE_BADVERSION,
                                  output="Client version mismatch!")

        try:
            checknologins()
            pass
        except NoLoginsError, e:
            return EmulabResponse(RESPONSE_REFUSED, output=str(e))

        if not argdict.has_key("class"):
            argdict["class"] = "pc"
            pass

        if not re.match("^[-\w]*$", str(argdict["class"])):
            return EmulabResponse(RESPONSE_BADARGS,
                                  output="Improperly formed node class")
        
        type_test = ""
        if argdict.has_key("type"):
            if not re.match("^[-\w]*$", str(argdict["type"])):
                return EmulabResponse(RESPONSE_BADARGS,
                                      output="Improperly formed node type")
            
            type_test = " and nt.type='%s'" % (str(argdict["type"]),)
            pass

        pid_clause = ""
        if argdict.has_key("proj"):
            permerror = CheckProjPermission(self.uid, argdict["proj"])
            if permerror:
                return permerror

            pid_clause = " or p.pid='%s'" % (str(argdict["proj"]),)
            pass
        
        res = DBQueryFatal("SELECT count(a.node_id) FROM nodes AS a "
                           "left join reserved as b on a.node_id=b.node_id "
                           "left join node_types as nt on a.type=nt.type "
                           "left join nodetypeXpid_permissions as p "
                           "  on a.type=p.type "
                           "WHERE b.node_id is null and a.role='testnode' "
                           "  and nt.class=%s and "
                           "      (p.pid is null" + pid_clause + ") and "
                           "      (a.eventstate='ISUP' or "
                           "       a.eventstate='PXEWAIT')" + type_test,
                           (argdict["class"],))

        if len(res) == 0:
            result = 0
            pass
        else:
            result = int(res[0][0])
            pass

        return EmulabResponse(RESPONSE_SUCCESS,
                              value=result,
                              output=str(result))

    #
    # Get the console parameters.
    #
    def console(self, version, argdict):
        if version != self.VERSION:
            return EmulabResponse(RESPONSE_BADVERSION,
                                  output="Client version mismatch!")

        argerror = CheckRequiredArgs(argdict, ("node",))
        if (argerror):
            return argerror

        try:
            checknologins()
            pass
        except NoLoginsError, e:
            return EmulabResponse(RESPONSE_REFUSED, output=str(e))

        if not re.match("^[-\w]*$", str(argdict["node"])):
            return EmulabResponse(RESPONSE_BADARGS,
                                  output="Improperly formed node value!")
        
        # XXX Refactor the trust stuff
        res = DBQueryFatal("SELECT e.pid,e.gid FROM reserved AS r "
                           "left join experiments as e on "
                           "     e.pid=r.pid and e.eid=r.eid "
                           "WHERE r.node_id=%s",
                           (argdict["node"],))

        if len(res) == 0:
            return EmulabResponse(RESPONSE_ERROR,
                                  output="No such node: " + argdict["node"])

        trust = DBQueryFatal("SELECT trust FROM group_membership "
                             "WHERE uid=%s and pid=%s and gid=%s",
                             (self.uid, res[0][0], res[0][1]))

        if len(trust) == 0:
            return EmulabResponse(
                RESPONSE_FORBIDDEN,
                output=("You do not have permission to access: "
                        + argdict["node"]))

        res = DBQueryFatal("SELECT server,portnum,keylen,keydata "
                           "FROM tiplines WHERE node_id=%s",
                           (argdict["node"],))
        
        if len(res) == 0:
            return EmulabResponse(RESPONSE_ERROR,
                                  output="No such node: " + argdict["node"])

        sha_fp = open("/usr/testbed/etc/capture.fingerprint").read()
        sha_fp = sha_fp.split("=")[1].strip().replace(":", "")
        
        sha1_fp = open("/usr/testbed/etc/capture.sha1fingerprint").read()
        sha1_fp = sha1_fp.split("=")[1].strip().replace(":", "")
        
        result = {
            "server" : res[0][0],
            "portnum" : res[0][1],
            # "keylen" : res[0][2],
            "keydata" : res[0][3],
            "certsha" : sha_fp,
            "certsha1" : sha1_fp,
            }

        return EmulabResponse(RESPONSE_SUCCESS,
                              value=result,
                              output=str(result))


    #
    # Get the ssh host keys
    #
    def hostkeys(self, version, argdict):
        if version != self.VERSION:
            return EmulabResponse(RESPONSE_BADVERSION,
                                  output="Client version mismatch!")

        argerror = CheckRequiredArgs(argdict, ("node",))
        if (argerror):
            return argerror

        try:
            checknologins()
            pass
        except NoLoginsError, e:
            return EmulabResponse(RESPONSE_REFUSED, output=str(e))

        if not re.match("^[-\w]*$", str(argdict["node"])):
            return EmulabResponse(RESPONSE_BADARGS,
                                  output="Improperly formed node value!")
        
        # XXX Refactor the trust stuff
        res = DBQueryFatal("SELECT e.pid,e.gid FROM reserved AS r "
                           "left join experiments as e on "
                           "     e.pid=r.pid and e.eid=r.eid "
                           "WHERE r.node_id=%s",
                           (argdict["node"],))

        if len(res) == 0:
            return EmulabResponse(RESPONSE_ERROR,
                                  output="No such node: " + argdict["node"])

        trust = DBQueryFatal("SELECT trust FROM group_membership "
                             "WHERE uid=%s and pid=%s and gid=%s",
                             (self.uid, res[0][0], res[0][1]))

        if len(trust) == 0:
            return EmulabResponse(
                RESPONSE_FORBIDDEN,
                output=("You do not have permission to access: "
                        + argdict["node"]))

        res = DBQueryFatal("SELECT sshrsa_v1,sshrsa_v2,sshdsa_v2,sfshostid "
                           "FROM node_hostkeys WHERE node_id=%s",
                           (argdict["node"],))
        
        if len(res) == 0:
            return EmulabResponse(RESPONSE_ERROR,
                                  output="No such node: " + argdict["node"])

        result = {}
        if res[0][0]:
            result["sshrsa_v1"] = res[0][0]
            pass
        if res[0][1]:
            result["sshrsa_v2"] = res[0][1]
            pass
        if res[0][2]:
            result["sshdsa_v2"] = res[0][2]
            pass
        if res[0][3]:
            result["sfshostid"] = res[0][3]
            pass

        return EmulabResponse(RESPONSE_SUCCESS,
                              value=result,
                              output=str(result))


    #
    # reboot nodes
    #
    def reboot(self, version, argdict):
        if version != self.VERSION:
            return EmulabResponse(RESPONSE_BADVERSION,
                                  output="Client version mismatch!")

        try:
            checknologins()
            pass
        except NoLoginsError, e:
            return EmulabResponse(RESPONSE_REFUSED, output=str(e))

        argerror = CheckRequiredArgs(argdict, ("nodes",))
        if (argerror):
            return argerror

        argstr = ""
        for opt, val in argdict.items():
            if opt == "wait":
                if xbool(val):
                    argstr += " -w "
                    pass
                pass
            elif opt == "power":
                if xbool(val):
                    argstr += " -f "
                    pass
                pass
            elif opt == "reconfig":
                if xbool(val):
                    argstr += " -c "
                    pass
                pass
            pass

        tokens = argdict["nodes"].split(",")
        for token in tokens:
            argstr += " " + escapeshellarg(token)
            pass

        (exitval, output) = runcommand(TBDIR + "/bin/node_reboot " + argstr)
        if exitval:
            return EmulabResponse(RESPONSE_ERROR, exitval >> 8, output=output)
        
        return EmulabResponse(RESPONSE_SUCCESS, output=output)

    #
    # create_image.
    #
    def create_image(self, version, argdict):
        if version != self.VERSION:
            return EmulabResponse(RESPONSE_BADVERSION,
                                  output="Client version mismatch!")

        try:
            checknologins()
            pass
        except NoLoginsError, e:
            return EmulabResponse(RESPONSE_REFUSED, output=str(e))

        argerror = CheckRequiredArgs(argdict, ("imagename", "node"))
        if (argerror):
            return argerror

        argstr = ""
        for opt, val in argdict.items():
            if opt == "wait":
                if xbool(val):
                    argstr += " -w "
                    pass
                pass
            elif opt == "imageproj":
                argstr += " -p "
                argstr += escapeshellarg(val)
                pass
            pass

        argstr += " " + escapeshellarg(argdict["imagename"])
        argstr += " " + escapeshellarg(argdict["node"])

        (exitval, output) = runcommand(TBDIR + "/bin/create_image " + argstr)
        if exitval:
            return EmulabResponse(RESPONSE_ERROR, exitval >> 8, output=output)
        
        return EmulabResponse(RESPONSE_SUCCESS, output=output)

    #
    # Reload nodes.
    #
    def reload(self, version, argdict):
        if version != self.VERSION:
            return EmulabResponse(RESPONSE_BADVERSION,
                                  output="Client version mismatch!")

        try:
            checknologins()
            pass
        except NoLoginsError, e:
            return EmulabResponse(RESPONSE_REFUSED, output=str(e))

        argerror = CheckRequiredArgs(argdict, ("nodes",))
        if (argerror):
            return argerror

        argstr = ""
        for opt, val in argdict.items():
            if opt == "wait":
                if not xbool(val):
                    argstr += " -s "
                    pass
                pass
            elif opt == "imageproj":
                argstr += " -p "
                argstr += escapeshellarg(val)
                pass
            elif opt == "imagename":
                argstr += " -i "
                argstr += escapeshellarg(val)
                pass
            elif opt == "imageid":
                argstr += " -m "
                argstr += escapeshellarg(val)
                pass
            elif opt == "reboot":
                if not xbool(val):
                    argstr += " -r "
                    pass
                pass
            pass

        tokens = argdict["nodes"].split(",")
        for token in tokens:
            argstr += " " + escapeshellarg(token)
            pass

        (exitval, output) = runcommand(TBDIR + "/bin/os_load " + argstr)

        if exitval:
            return EmulabResponse(RESPONSE_ERROR, exitval >> 8, output=output)
        
        return EmulabResponse(RESPONSE_SUCCESS, output=output)

    #
    # Turn on/off admin mode (boot into FreeBSD MFS).
    #
    def adminmode(self, version, argdict):
        if version != self.VERSION:
            return EmulabResponse(RESPONSE_BADVERSION,
                                  output="Client version mismatch!")

        try:
            checknologins()
            pass
        except NoLoginsError, e:
            return EmulabResponse(RESPONSE_REFUSED, output=str(e))

        argerror = CheckRequiredArgs(argdict, ("mode", "node"))
        if (argerror):
            return argerror

        if (argdict["mode"] != "on" and
            argdict["mode"] != "off"):
            return EmulabResponse(RESPONSE_BADARGS,
                                  output="mode must be on or off")

        argstr = ""
        for opt, val in argdict.items():
            if opt == "wait":
                if xbool(val):
                    argstr += " -w "
                    pass
                pass
            elif opt == "reboot":
                if not xbool(val):
                    argstr += " -n "
                    pass
                pass
            pass

        argstr += " " + escapeshellarg(argdict["mode"]);
        argstr += " " + escapeshellarg(argdict["node"]);

        (exitval, output) = runcommand(TBDIR + "/bin/node_admin " + argstr)

        if exitval:
            return EmulabResponse(RESPONSE_ERROR, exitval >> 8, output=output)
        
        return EmulabResponse(RESPONSE_SUCCESS, output=output)

    def tbuisp(self, version, argdict):
        if version != self.VERSION:
            return EmulabResponse(RESPONSE_BADVERSION,
                                  output="Client version mismatch!")

        try:
            checknologins()
            pass
        except NoLoginsError, e:
            return EmulabResponse(RESPONSE_REFUSED, output=str(e))

        argerror = CheckRequiredArgs(argdict, ("op", "filestr", "nodes"))
        if (argerror):
            return argerror

        (fp, filename) = writensfile(argdict["filestr"].data)

        argstr = escapeshellarg(argdict["op"])
        argstr += " " + filename
        argstr += " " + escapeshellarg(" ".join(argdict["nodes"]))

        (exitval, output) = runcommand(TBDIR + "/bin/tbuisp " + argstr)
        if exitval:
            return EmulabResponse(RESPONSE_ERROR, exitval >> 8, output=output)

        return EmulabResponse(RESPONSE_SUCCESS, output=output)

    pass


#
# Hack class to get ElabInElab limping along ... Note that nothing we do
# in this class can damage anything or mess up anything outside the expt.
#
class elabinelab:
    ##
    # Initialize the object.  Currently only sets the objects 'VERSION' value.
    #
    def __init__(self, clientip=None, readonly=0):
        self.readonly = readonly;
        self.clientip = clientip;
        self.VERSION  = VERSION
        self.uid      = pwd.getpwuid(os.getuid())[0]
        self.pid      = None;
        self.eid      = None;
        return

    #
    # Anything we do from this class has to include pid/eid, and that
    # pid/eid has to have it elabinelab bit set, and the uid of the
    # user invoking the method has to be the creator of the experiment.
    # This might seem overly pedantic, but its probably how it would
    # look if this was a standalone RPC server supporting elabinelab.
    #
    def verifystuff(self):
        if self.clientip == None:
            return EmulabResponse(RESPONSE_ERROR,
                                  output="SSL connections only")
            
        res = DBQueryFatal("select i.node_id,r.pid,r.eid,"
                           "       e.elab_in_elab,e.state,e.expt_head_uid, "
                           "       r.inner_elab_role "
                           "  from interfaces as i "
                           "left join reserved as r on r.node_id=i.node_id "
                           "left join experiments as e on e.pid=r.pid and "
                           "     e.eid=r.eid "
                           "where i.IP=%s and i.role='ctrl'",
                           (self.clientip))
        
        # IP must map to a node.
        if len(res) == 0:
            return EmulabResponse(RESPONSE_ERROR,
                                  output="No such node for IP: " +
                                  self.clientip)
        
        # Node must be reserved.
        if res[0][1] == None:
            return EmulabResponse(RESPONSE_ERROR,
                                  output="Node is not reserved: " + res[0][0])
        
        # Needed below
        self.pid = res[0][1]
        self.eid = res[0][2]
        
        # Must be an ElabInElab experiment.
        if int(res[0][3]) != 1:
            return EmulabResponse(RESPONSE_FORBIDDEN,
                                  output="Not an elabinelab experiment: " +
                                  res[0][1] + "/" + res[0][2]);
        
        # Experiment must be active (not swapping say).
        if res[0][4] != "active":
            return EmulabResponse(RESPONSE_ERROR,
                                  output="Experiment is not active: " +
                                  res[0][1] + "/" + res[0][2]);
        
        # SSL certificate of caller must map to uid of experiment creator.
        if res[0][5] != self.uid:
            return EmulabResponse(RESPONSE_FORBIDDEN,
                                  output="Must be creator to access " +
                                  "elabinelab method for " +
                                  res[0][1] + "/" + res[0][2]);
        
        # Must be the boss node that is making the request.
        if res[0][6] != "boss":
            return EmulabResponse(RESPONSE_FORBIDDEN,
                                  output="Must be boss node accessing " +
                                  "elabinelab method for " +
                                  res[0][1] + "/" + res[0][2]);
        
        return None;

    #
    # Power cycle a node.
    # 
    def power(self, version, argdict):
        if version != self.VERSION:
            return EmulabResponse(RESPONSE_BADVERSION,
                                  output="Client version mismatch!")

        try:
            checknologins()
            pass
        except NoLoginsError, e:
            return EmulabResponse(RESPONSE_REFUSED, output=str(e))

        argerror = CheckRequiredArgs(argdict, ("nodes", "op"))
        if (argerror):
            return argerror

        verifyerror = self.verifystuff();
        if (verifyerror):
            return verifyerror

        if (argdict["op"] != "on" and
            argdict["op"] != "off" and
            argdict["op"] != "cycle"):
            return EmulabResponse(RESPONSE_BADARGS,
                                  output="op must be on, off or cycle")

        argstr = argdict["op"];
        tokens = argdict["nodes"].split(",")
        for token in tokens:
            argstr += " " + escapeshellarg(token)
            pass

        (exitval, output) = runcommand(TBDIR + "/bin/power " + argstr)
        if exitval:
            return EmulabResponse(RESPONSE_ERROR, exitval >> 8, output=output)
        
        return EmulabResponse(RESPONSE_SUCCESS, output=output)
    
    #
    # node tip acl stuff so inner console link works, redirecting user
    # to where the real console is (outer emulab).
    # 
    def console(self, version, argdict):
        if version != self.VERSION:
            return EmulabResponse(RESPONSE_BADVERSION,
                                  output="Client version mismatch!")

        try:
            checknologins()
            pass
        except NoLoginsError, e:
            return EmulabResponse(RESPONSE_REFUSED, output=str(e))

        argerror = CheckRequiredArgs(argdict, ("node",))
        if (argerror):
            return argerror

        verifyerror = self.verifystuff();
        if (verifyerror):
            return verifyerror

        #
        # Funnel up to node.console() routine
        # 
        node_instance = node(readonly=self.readonly);
        
        return node_instance.console(version, argdict);
    
    #
    # vlan control
    # 
    def vlans(self, version, argdict):
        if version != self.VERSION:
            return EmulabResponse(RESPONSE_BADVERSION,
                                  output="Client version mismatch!")

        try:
            checknologins()
            pass
        except NoLoginsError, e:
            return EmulabResponse(RESPONSE_REFUSED, output=str(e))

        argerror = CheckRequiredArgs(argdict, ("op", "arg"))
        if (argerror):
            return argerror

        verifyerror = self.verifystuff();
        if (verifyerror):
            return verifyerror

        if (argdict["op"] != "setup" and
            argdict["op"] != "destroy"):
            return EmulabResponse(RESPONSE_BADARGS,
                                  output="op must be setup or destroy")

        argstr = "-p " + self.pid + " -e " + self.eid + " " + argdict["op"];
     
        #
        # Figure out how to convert the stuff we got into something we can
        # pass on the command line to perl backend.
        # 
        if argdict["op"] == "destroy":
            #
            # Destroy is easy; just pass a list of id numbers out. The backend
            # script does all the verification.
            #
            if (isinstance(argdict["arg"], types.IntType)):
                argstr += " " + str(argdict["arg"])
                pass
            else:
                tokens = argdict["arg"].split(",")
                for token in tokens:
                    argstr += " " + escapeshellarg(token)
                    pass
                pass
            pass
        else:
            #
            # Setup is harder. Pass a set of strings to the script,
            # consisting of:
            #
            #           id,node:iface,speed,duplex,vtag
            #
            for id, idval in argdict["arg"].items():
                vtag = idval["virtual"]
                
                for port, portarray in idval["members"].items():
                    speed  = portarray["speed"]
                    duplex = portarray["duplex"]
                    
                    thisarg = escapeshellarg(str(id) + "," + port + "," +
                                             str(speed) + "," +
                                             duplex + "," + vtag)
                    
                    argstr += " " + thisarg;
                    pass
                pass
            pass

        (exitval, output) = runcommand(TBDIR + "/sbin/snmpit.proxy " + argstr)
        if exitval:
            return EmulabResponse(RESPONSE_ERROR, exitval >> 8, output=output)
        
        return EmulabResponse(RESPONSE_SUCCESS, output=output)
    
    #
    # Fire up a frisbeed for an image,
    # 
    def frisbeelauncher(self, version, argdict):
        if version != self.VERSION:
            return EmulabResponse(RESPONSE_BADVERSION,
                                  output="Client version mismatch!")

        try:
            checknologins()
            pass
        except NoLoginsError, e:
            return EmulabResponse(RESPONSE_REFUSED, output=str(e))

        argerror = CheckRequiredArgs(argdict, ("imageid",))
        if (argerror):
            return argerror
        
        if not re.match("^[-\@\w\+\.]*$", str(argdict["imageid"])):
            return EmulabResponse(RESPONSE_BADARGS,
                                  output="Improperly formed imageid value!")
        
        verifyerror = self.verifystuff();
        if (verifyerror):
            return verifyerror
        
        argstr = escapeshellarg(argdict["imageid"])
        
        (exitval, output) = runcommand(TBDIR + "/sbin/frisbeelauncher " + argstr)
        if exitval:
            return EmulabResponse(RESPONSE_ERROR, exitval >> 8, output=output)
        
        #
        # Success. Must get the loadinfo out of the DB so we can pass it back.
        #
        res = DBQueryFatal("select load_address from images where imageid=%s",
                           (argdict["imageid"],))
        
        # Hmm, something went wrong?
        if len(res) == 0:
            return EmulabResponse(RESPONSE_ERROR,
                                  output="Imageid is gone: " +
                                  argdict["imageid"])
        
        if (res[0][0] == None or res[0][0] == ""):
            return EmulabResponse(RESPONSE_ERROR,
                                  output="No load_address in DB: " +
                                  argdict["imageid"])
        
        return EmulabResponse(RESPONSE_SUCCESS, str(res[0][0]), output=output)
    pass

#
# Utility functions
#

#
# escapeshellarg() adds single quotes around a string and quotes/escapes any
# existing single quotes allowing string to be passed directly to a shell
# function and having it be treated as a single safe argument.
#
def escapeshellarg(s):
    s2 = ""

    for c in s:
        if c == '\'':
            s2 = s2 + '\'\\\''
        s2 = s2 + c

    return '\'' + s2 + '\''

#
# Run a command. args is a list of strings to pass as arguments to cmd.
# Return the exitcode and the output as a tuple.
# 
def runcommand(cmd):
    child  = popen2.Popen4(cmd)
    output = ""
    while (True):
        foo = child.fromchild.read(1024 * 16)
        if foo == "":
            break
        output += foo
        pass
    
    return (child.wait(), output)

def writensfile(str):
    tempfile.tempdir = "/var/tmp"
    try:
        fp = tempfile.NamedTemporaryFile(prefix="php")
        fp.write(str)
        fp.flush()

    except:
        SENDMAIL(TBOPS, "writensfile failed",
                 "Could not write temporary NS file:\n" +
                 "%s:%s" % (sys.exc_type, sys.exc_value))
        return None

    # Yuck. Need to maintain a ref so that the file is not deleted!
    return (fp, fp.name)

#
# Check for no logins.
#
def checknologins():
    if TBGetSiteVar("web/nologins") != "0":
        raise NoLoginsError, TBGetSiteVar("web/message")
    return

#
# A helper function for getting a site variable.
#
def TBGetSiteVar(name):
    res = DBQueryFatal("SELECT value,defaultvalue FROM sitevariables "
                       "WHERE name=%s",
                       (name,))

    if len(res) == 0:
        raise ValueError, "Unknown site variable: " + str(name)

    if res[0][0]:
        retval = res[0][0]
        pass
    else:
        retval = res[0][1]
        pass

    return retval

#
# Convert a file mode mask into something human readable and cross-platform.
#
def filetype(mode):
    if stat.S_ISDIR(mode):
        retval = "d"
        pass
    elif stat.S_ISCHR(mode):
        retval = "c"
        pass
    elif stat.S_ISBLK(mode):
        retval = "b"
        pass
    elif stat.S_ISREG(mode):
        retval = "f"
        pass
    elif stat.S_ISFIFO(mode):
        retval = "q"
        pass
    elif stat.S_ISLNK(mode):
        retval = "l"
        pass
    elif stat.S_ISSOCK(mode):
        retval = "s"
        pass
    else:
        retval = "u"
        pass
    return retval    

#
# A helper function for converting a value into a SQL date string.
#
def sqldate(value):
    if isinstance(value, xmlrpclib.DateTime):
        value = time.strptime(str(value), "%Y%m%dT%H:%M:%S")
        value = time.strftime("%Y-%m-%d %H:%M:%S", value)
        pass
    return value

#
# A helper function for converting an XMLRPC value into a boolean.
#
def xbool(value):
    retval = value
    if value:
        # XXX handle uppercase strings...
        if (value == True or
            value == "true" or
            value == "yes" or
            value == "on" or
            value == "1"):
            retval = True
            pass
        else:
            retval = False
            pass
        pass
    return retval

#
# Check for an acceptable NFS path.
#
def nfspath(value):
    retval = os.path.realpath(value)

    found = False
    for export in NFS_EXPORTS:
        if retval.startswith(export):
            found = True
            break
        pass

    if not found:
        raise OSError(errno.EPERM, "Path is not an NFS export", value)

    return retval
