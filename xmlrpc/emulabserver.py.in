#! /usr/bin/env python
#
# EMULAB-COPYRIGHT
# Copyright (c) 2004 University of Utah and the Flux Group.
# All rights reserved.
#
import sys
import socket
import os
import popen2
import tempfile
import time
sys.path.append("@prefix@/lib")
import libdb
from libtestbed   import SENDMAIL, TBOPS
from emulabclient import *

# Configure variables
TBDIR = "@prefix@"

# Version
VERSION = 0.1

#
# Arguments to methods are passed as a Dictionary. This converts to a XML
# "struct" which in Perl/PHP/Ruby would be a hash. So, a client written in
# pretty much any language should be able to talk to this class.
#

#
# This class implements the server side of the XMLRPC interface to experiments.
#
class experiment:
    ##
    # Initialize the object.  Currently only sets the objects 'VERSION' value.
    #
    def __init__(self):
        self.VERSION = VERSION
        return

    ##
    # Echo a message, basically, prepend the host name to the parameter list.
    #
    # @param args The argument list to echo back.
    # @return The 'msg' value with this machine's name prepended.
    #
    def echo(self, version, argdict):
        if not argdict.has_key("str"):
            return EmulabResponse(RESPONSE_BADARGS,
                                 output="Must supply a string to echo!");
        
        return EmulabResponse(RESPONSE_SUCCESS, 0,
                             socket.gethostname() + ": " + str(version)
                             + " " + argdict["str"])

    #
    # Start an experiment using batchexp. We get the NS file inline, which
    # we have to write to a temp file first. 
    #
    def batchexp(self, version, argdict):
        if version != self.VERSION:
            return EmulabResponse(RESPONSE_BADVERSION,
                                 output="Client version mismatch!");
            pass

        if not (argdict.has_key("pid") and
                argdict.has_key("eid")):
            return EmulabResponse(RESPONSE_BADARGS,
                                 output="Must supply pid and eid!");

        nsfilename = None
        argstr     = ""
        
        for opt, val in argdict.items():
            if opt == "batch":
                if val == "false":
                    argstr += " -i"
                    pass
                pass
            elif opt == "description":
                argstr += " -E "
                argstr += escapeshellarg(val)
                pass
            elif opt == "gid":
                argstr += " -g "
                argstr += escapeshellarg(val)
                pass
            elif opt == "eid":
                argstr += " -e "
                argstr += escapeshellarg(val)
                pass
            elif opt == "pid":
                argstr += " -p "
                argstr += escapeshellarg(val)
                pass
            elif opt == "swappable":
                if val == "false":
                    argstr += " -S "
                    argstr += argdict["noswap_reason"]
                    pass
                pass
            elif opt == "noswap_reason":
                pass
            elif opt == "idleswap":
                if val == 0:
                    argstr += " -L "
                    argstr += escapeshellarg(argdict["noidleswap_reason"])
                    pass
                else:
                    argstr += " -l "
                    argstr += escapeshellarg(val)
                    pass
                pass
            elif opt == "noidleswap_reason":
                pass
            elif opt == "autoswap":
                argstr += " -a "
                argstr += escapeshellarg(val)
                pass
            elif opt == "noswapin":
                if val == "true":
                    argstr += " -f "
                    pass
                pass
            elif opt == "wait":
                if val == "true":
                    argstr += " -w "
                    pass
                pass
            elif opt == "nsfilepath":
                # Backend script will verify this local path. 
                nsfilename = escapeshellarg(val)
                pass
            elif opt == "nsfilestr":
                nsfilestr = val
            
                if len(nsfilestr) > (1024 * 512):
                    return EmulabResponse(RESPONSE_TOOBIG,
                                         output="NS File way too big!");
        
                (nsfp, nsfilename) = writensfile(nsfilestr)
                if not nsfilename:
                    return EmulabResponse(RESPONSE_SERVERERROR,
                                         output="Server Error")
                pass
            pass

        if nsfilename:
            argstr += " " + nsfilename
            pass

        (exitval, output) = runcommand(TBDIR + "/bin/batchexp " + argstr)
        if exitval:
            return EmulabResponse(RESPONSE_ERROR, exitval >> 8, output=output)
        
        return EmulabResponse(RESPONSE_SUCCESS, output=output)

    #
    # startexp is an alias for batchexp.
    # 
    def startexp(self, version, argdict):
        return self.batchexp(version, argdict)

    #
    # swap an experiment using swapexp. 
    #
    def swapexp(self, version, argdict):
        if version != self.VERSION:
            return EmulabResponse(RESPONSE_BADVERSION,
                                 output="Client version mismatch!");
            pass

        argstr     = ""
        
        for opt, val in argdict.items():
            if opt == "wait":
                if val == "true":
                    argstr += " -w "
                    pass
                pass
            pass

        if not (argdict.has_key("pid") and
                argdict.has_key("eid") and
                argdict.has_key("direction")):
            return EmulabResponse(RESPONSE_BADARGS,
                                 output="Must supply pid, eid and direction!");

        argstr += " -s " + escapeshellarg(argdict["direction"])
        argstr += " " + escapeshellarg(argdict["pid"])
        argstr += " " + escapeshellarg(argdict["eid"])

        (exitval, output) = runcommand(TBDIR + "/bin/swapexp " + argstr)
        if exitval:
            return EmulabResponse(RESPONSE_ERROR, exitval >> 8, output=output)
        
        return EmulabResponse(RESPONSE_SUCCESS, output=output)

    #
    # swap an experiment using swapexp. We get the NS file inline, which
    # we have to write to a temp file first. 
    #
    def modify(self, version, argdict):
        if version != self.VERSION:
            return EmulabResponse(RESPONSE_BADVERSION,
                                 output="Client version mismatch!");
            pass

        nsfilename = None
        argstr     = ""
        
        for opt, val in argdict.items():
            if opt == "wait":
                if val == "true":
                    argstr += " -w "
                    pass
                pass
            elif opt == "reboot":
                if val == "true":
                    argstr += " -r "
                    pass
                pass
            elif opt == "restart_eventsys":
                if val == "true":
                    argstr += " -e "
                    pass
                pass
            elif opt == "nsfilepath":
                # Backend script will verify this local path. 
                nsfilename = escapeshellarg(val)
                pass
            elif opt == "nsfilestr":
                nsfilestr = val
            
                if len(nsfilestr) > (1024 * 512):
                    return EmulabResponse(RESPONSE_TOOBIG,
                                         output="NS File way too big!");
        
                (nsfp, nsfilename) = writensfile(nsfilestr)
                if not nsfilename:
                    return EmulabResponse(RESPONSE_SERVERERROR,
                                         output="Server Error")
                pass
            pass

        if not (argdict.has_key("pid") and
                argdict.has_key("eid")):
            return EmulabResponse(RESPONSE_BADARGS,
                                 output="Must supply pid and eid!");

        argstr += " -s modify"
        argstr += " " + escapeshellarg(argdict["pid"])
        argstr += " " + escapeshellarg(argdict["eid"])

        if nsfilename:
            argstr += " " + nsfilename
            pass

        (exitval, output) = runcommand(TBDIR + "/bin/swapexp " + argstr)
        if exitval:
            return EmulabResponse(RESPONSE_ERROR, exitval >> 8, output=output)
        
        return EmulabResponse(RESPONSE_SUCCESS, output=output)

    #
    # end an experiment using endexp.
    #
    def endexp(self, version, argdict):
        if version != self.VERSION:
            return EmulabResponse(RESPONSE_BADVERSION,
                                 output="Client version mismatch!");
            pass

        argstr     = ""
        
        for opt, val in argdict.items():
            if opt == "wait":
                if val == "true":
                    argstr += " -w "
                    pass
                pass
            pass

        if not (argdict.has_key("pid") and
                argdict.has_key("eid")):
            return EmulabResponse(RESPONSE_BADARGS,
                                 output="Must supply pid and eid!");

        argstr += " " + escapeshellarg(argdict["pid"])
        argstr += " " + escapeshellarg(argdict["eid"])

        (exitval, output) = runcommand(TBDIR + "/bin/endexp " + argstr)
        if exitval:
            return EmulabResponse(RESPONSE_ERROR, exitval >> 8, output=output)
        
        return EmulabResponse(RESPONSE_SUCCESS, output=output)

    #
    # nscheck an NS file.
    #
    def nscheck(self, version, argdict):
        if version != self.VERSION:
            return EmulabResponse(RESPONSE_BADVERSION,
                                 output="Client version mismatch!");
            pass

        argstr = ""

        if argdict.has_key("nsfilestr"):
            nsfilestr = argdict["nsfilestr"]
            
            if len(nsfilestr) > (1024 * 512):
                return EmulabResponse(RESPONSE_TOOBIG,
                                     output="NS File way too big!");
        
            (nsfp, nsfilename) = writensfile(nsfilestr)
            if not nsfilename:
                return EmulabResponse(RESPONSE_SERVERERROR, output="Server Error")

            argstr += nsfilename
            pass
        elif argdict.has_key("nsfilepath"):
            # Backend script will verify this local path. 
            argstr += escapeshellarg(argdict["nsfilepath"])
            pass
        else:
            return EmulabResponse(RESPONSE_BADARGS,
                                 output="Must supply an NS file to check!");
        
        (exitval, output) = runcommand(TBDIR + "/bin/nscheck " + argstr)
        if exitval:
            return EmulabResponse(RESPONSE_ERROR, exitval >> 8, output=output)
        
        return EmulabResponse(RESPONSE_SUCCESS, output=output)

    #
    # Delay configuration
    #
    def delay_config(self, version, argdict):
        if version != self.VERSION:
            return EmulabResponse(RESPONSE_BADVERSION,
                                 output="Client version mismatch!");
            pass

        argstr = ""
        
        for opt, val in argdict.items():
            if opt == "persist":
                if val == "true":
                    argstr += " -m "
                    pass
                pass
            elif opt == "src":
                argstr += " -s "
                argstr += escapeshellarg(val)
                pass
            pass

        if not (argdict.has_key("pid") and
                argdict.has_key("eid") and
                argdict.has_key("link") and
                argdict.has_key("params")):
            return EmulabResponse(RESPONSE_BADARGS,
                                 output="Must supply pid, eid, link, params!");

        argstr += " " + escapeshellarg(argdict["pid"])
        argstr += " " + escapeshellarg(argdict["eid"])
        argstr += " " + escapeshellarg(argdict["link"])

        for opt, val in argdict["params"].items():
            argstr += " " + escapeshellarg(opt + "=" + val)
            pass
        
        (exitval, output) = runcommand(TBDIR + "/bin/delay_config " + argstr)
        if exitval:
            return EmulabResponse(RESPONSE_ERROR, exitval >> 8, output=output)
        
        return EmulabResponse(RESPONSE_SUCCESS, output=output)

    #
    # Reboot all nodes in an experiment.
    #
    def reboot(self, version, argdict):
        if version != self.VERSION:
            return EmulabResponse(RESPONSE_BADVERSION,
                                 output="Client version mismatch!");
            pass

        argstr = ""
        
        for opt, val in argdict.items():
            if opt == "wait":
                if val == "true":
                    argstr += " -w "
                    pass
                pass
            pass

        if not (argdict.has_key("pid") and
                argdict.has_key("eid")):
            return EmulabResponse(RESPONSE_BADARGS,
                                 output="Must supply pid and eid!");

        argstr += " -e " + escapeshellarg(argdict["pid"] + "," + argdict["eid"])
        
        (exitval, output) = runcommand(TBDIR + "/bin/node_reboot " + argstr)
        if exitval:
            return EmulabResponse(RESPONSE_ERROR, exitval >> 8, output=output)
        
        return EmulabResponse(RESPONSE_SUCCESS, output=output)

    #
    # Reload all nodes in an experiment.
    #
    def reload(self, version, argdict):
        if version != self.VERSION:
            return EmulabResponse(RESPONSE_BADVERSION,
                                 output="Client version mismatch!");
            pass

        argstr = ""
        
        for opt, val in argdict.items():
            if opt == "wait":
                if val == "false":
                    argstr += " -s "
                    pass
                pass
            elif opt == "imagepid":
                argstr += " -p "
                argstr += escapeshellarg(val)
                pass
            elif opt == "imageid":
                argstr += " -i "
                argstr += escapeshellarg(val)
                pass
            pass

        if not (argdict.has_key("pid") and
                argdict.has_key("eid")):
            return EmulabResponse(RESPONSE_BADARGS,
                                 output="Must supply pid and eid!");

        argstr += " -e " + escapeshellarg(argdict["pid"] + "," + argdict["eid"])
        
        (exitval, output) = runcommand(TBDIR + "/bin/os_load " + argstr)

        if exitval:
            return EmulabResponse(RESPONSE_ERROR, exitval >> 8, output=output)
        
        return EmulabResponse(RESPONSE_SUCCESS, output=output)

    pass

#
# This class implements the server side of the XMLRPC interface to nodes.
#
class node:
    ##
    # Initialize the object.  Currently only sets the objects 'VERSION' value.
    #
    def __init__(self):
        self.VERSION = VERSION
        return

    #
    # reboot nodes
    #
    def reboot(self, version, argdict):
        if version != self.VERSION:
            return EmulabResponse(RESPONSE_BADVERSION,
                                 output="Client version mismatch!");
            pass

        argstr = ""
        
        for opt, val in argdict.items():
            if opt == "wait":
                if val == "true":
                    argstr += " -w "
                    pass
                pass
            pass

        if not (argdict.has_key("nodes")):
            return EmulabResponse(RESPONSE_BADARGS,
                                 output="Must supply a list of nodes!");

        tokens = argdict["nodes"].split(",")
        for token in tokens:
            argstr += " " + escapeshellarg(token)
            pass

        (exitval, output) = runcommand(TBDIR + "/bin/node_reboot " + argstr)
        if exitval:
            return EmulabResponse(RESPONSE_ERROR, exitval >> 8, output=output)
        
        return EmulabResponse(RESPONSE_SUCCESS, output=output)

    #
    # create_image.
    #
    def create_image(self, version, argdict):
        if version != self.VERSION:
            return EmulabResponse(RESPONSE_BADVERSION,
                                 output="Client version mismatch!");
            pass

        argstr = ""
        
        for opt, val in argdict.items():
            if opt == "wait":
                if val == "true":
                    argstr += " -w "
                    pass
                pass
            elif opt == "pid":
                argstr += " -p "
                argstr += escapeshellarg(val)
                pass
            pass

        if not (argdict.has_key("imageid") and
                argdict.has_key("node")):
            return EmulabResponse(RESPONSE_BADARGS,
                                 output="Must supply imageid and node!");

        argstr += " " + escapeshellarg(argdict["imageid"])
        argstr += " " + escapeshellarg(argdict["node"])

        (exitval, output) = runcommand(TBDIR + "/bin/create_image " + argstr)
        if exitval:
            return EmulabResponse(RESPONSE_ERROR, exitval >> 8, output=output)
        
        return EmulabResponse(RESPONSE_SUCCESS, output=output)

    #
    # Reload nodes.
    #
    def reload(self, version, argdict):
        if version != self.VERSION:
            return EmulabResponse(RESPONSE_BADVERSION,
                                 output="Client version mismatch!");
            pass

        argstr = ""
        
        for opt, val in argdict.items():
            if opt == "wait":
                if val == "false":
                    argstr += " -s "
                    pass
                pass
            elif opt == "imagepid":
                argstr += " -p "
                argstr += escapeshellarg(val)
                pass
            elif opt == "imageid":
                argstr += " -i "
                argstr += escapeshellarg(val)
                pass
            pass

        if not (argdict.has_key("nodes")):
            return EmulabResponse(RESPONSE_BADARGS,
                                 output="Must supply a list of nodes!");

        tokens = argdict["nodes"].split(",")
        for token in tokens:
            argstr += " " + escapeshellarg(token)
            pass

        (exitval, output) = runcommand(TBDIR + "/bin/os_load " + argstr)

        if exitval:
            return EmulabResponse(RESPONSE_ERROR, exitval >> 8, output=output)
        
        return EmulabResponse(RESPONSE_SUCCESS, output=output)

    pass

#
# Utility functions
#

#
# escapeshellarg() adds single quotes around a string and quotes/escapes any
# existing single quotes allowing string to be passed directly to a shell
# function and having it be treated as a single safe argument.
#
def escapeshellarg(s):
    s2 = ""

    for c in s:
        if c == '\'':
            s2 = s2 + '\'\\\''
        s2 = s2 + c

    return '\'' + s2 + '\''

#
# Run a command. args is a list of strings to pass as arguments to cmd.
# Return the exitcode and the output as a tuple.
# 
def runcommand(cmd):
    child  = popen2.Popen4(cmd)
    output = child.fromchild.read(8192)
    return (child.wait(), output)

def writensfile(str):
    tempfile.tempdir = "/var/tmp"
    try:
        fp = tempfile.NamedTemporaryFile(prefix="php")
        fp.write(str)
        fp.flush()

    except:
        SENDMAIL(TBOPS, "writensfile failed",
                 "Could not write temporary NS file:\n" +
                 "%s:%s" % (sys.exc_type, sys.exc_value))
        return None
        pass

    # Yuck. Need to maintain a ref so that the file is not deleted!
    return (fp, fp.name)
