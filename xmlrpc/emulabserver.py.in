#! /usr/bin/env python
#
# EMULAB-COPYRIGHT
# Copyright (c) 2004 University of Utah and the Flux Group.
# All rights reserved.
#
import sys
import socket
import os
import popen2
import tempfile
import time
import re
import string
sys.path.append("@prefix@/lib")
from libdb        import *
from libtestbed   import SENDMAIL, TBOPS
from emulabclient import *

# Configure variables
TBDIR = "@prefix@"

# Version
VERSION = 0.1

#
# Arguments to methods are passed as a Dictionary. This converts to a XML
# "struct" which in Perl/PHP/Ruby would be a hash. So, a client written in
# pretty much any language should be able to talk to this class.
#

#
# A helper function for checking required arguments.
#
def CheckRequiredArgs(argdict, arglist):
    # proj,group,exp are aliases for pid,gid,eid
    if (argdict.has_key("pid") and not argdict.has_key("proj")):
        argdict["proj"] = argdict["pid"]
        pass
    if (argdict.has_key("gid") and not argdict.has_key("group")):
        argdict["group"] = argdict["gid"]
        pass
    if (argdict.has_key("eid") and not argdict.has_key("exp")):
        argdict["exp"] = argdict["eid"]
        pass

    # Okay, now check.
    for arg in arglist:
        if not argdict.has_key(arg):
            return EmulabResponse(RESPONSE_BADARGS,
                                  output="Must supply '" + arg + "'")
        pass
    return None

#
# This class implements the server side of the XMLRPC interface to experiments.
#
class experiment:
    ##
    # Initialize the object.  Currently only sets the objects 'VERSION' value.
    #
    def __init__(self):
        self.VERSION = VERSION
        return

    ##
    # Echo a message, basically, prepend the host name to the parameter list.
    #
    # @param args The argument list to echo back.
    # @return The 'msg' value with this machine's name prepended.
    #
    def echo(self, version, argdict):
        if not argdict.has_key("str"):
            return EmulabResponse(RESPONSE_BADARGS,
                                 output="Must supply a string to echo!");
        
        return EmulabResponse(RESPONSE_SUCCESS, 0,
                             socket.gethostname() + ": " + str(version)
                             + " " + argdict["str"])

    #
    # Start an experiment using batchexp. We get the NS file inline, which
    # we have to write to a temp file first. 
    #
    def batchexp(self, version, argdict):
        if version != self.VERSION:
            return EmulabResponse(RESPONSE_BADVERSION,
                                 output="Client version mismatch!");
            pass

        argerror = CheckRequiredArgs(argdict, ("proj", "exp"))
        if (argerror):
            return argerror

        nsfilename = None
        argstr     = ""
        
        for opt, val in argdict.items():
            if opt == "batch":
                if val == "false":
                    argstr += " -i"
                    pass
                pass
            elif opt == "description":
                argstr += " -E "
                argstr += escapeshellarg(val)
                pass
            elif opt == "group":
                argstr += " -g "
                argstr += escapeshellarg(val)
                pass
            elif opt == "exp":
                argstr += " -e "
                argstr += escapeshellarg(val)
                pass
            elif opt == "proj":
                argstr += " -p "
                argstr += escapeshellarg(val)
                pass
            elif opt == "swappable":
                if val == "false":
                    argstr += " -S "
                    argstr += argdict["noswap_reason"]
                    pass
                pass
            elif opt == "noswap_reason":
                pass
            elif opt == "idleswap":
                if val == 0:
                    argstr += " -L "
                    argstr += escapeshellarg(argdict["noidleswap_reason"])
                    pass
                else:
                    argstr += " -l "
                    argstr += escapeshellarg(val)
                    pass
                pass
            elif opt == "noidleswap_reason":
                pass
            elif opt == "autoswap":
                argstr += " -a "
                argstr += escapeshellarg(val)
                pass
            elif opt == "noswapin":
                if val == "true":
                    argstr += " -f "
                    pass
                pass
            elif opt == "wait":
                if val == "true":
                    argstr += " -w "
                    pass
                pass
            elif opt == "nsfilepath":
                # Backend script will verify this local path. 
                nsfilename = escapeshellarg(val)
                pass
            elif opt == "nsfilestr":
                nsfilestr = val
            
                if len(nsfilestr) > (1024 * 512):
                    return EmulabResponse(RESPONSE_TOOBIG,
                                         output="NS File way too big!");
        
                (nsfp, nsfilename) = writensfile(nsfilestr)
                if not nsfilename:
                    return EmulabResponse(RESPONSE_SERVERERROR,
                                         output="Server Error")
                pass
            pass

        if nsfilename:
            argstr += " " + nsfilename
            pass

        (exitval, output) = runcommand(TBDIR + "/bin/batchexp " + argstr)
        if exitval:
            return EmulabResponse(RESPONSE_ERROR, exitval >> 8, output=output)
        
        return EmulabResponse(RESPONSE_SUCCESS, output=output)

    #
    # startexp is an alias for batchexp.
    # 
    def startexp(self, version, argdict):
        return self.batchexp(version, argdict)

    #
    # swap an experiment using swapexp. 
    #
    def swapexp(self, version, argdict):
        if version != self.VERSION:
            return EmulabResponse(RESPONSE_BADVERSION,
                                 output="Client version mismatch!");
            pass

        argerror = CheckRequiredArgs(argdict, ("proj", "exp", "direction"))
        if (argerror):
            return argerror

        argstr = ""
        for opt, val in argdict.items():
            if opt == "wait":
                if val == "true":
                    argstr += " -w "
                    pass
                pass
            pass

        argstr += " -s " + escapeshellarg(argdict["direction"])
        argstr += " " + escapeshellarg(argdict["proj"])
        argstr += " " + escapeshellarg(argdict["exp"])

        (exitval, output) = runcommand(TBDIR + "/bin/swapexp " + argstr)
        if exitval:
            return EmulabResponse(RESPONSE_ERROR, exitval >> 8, output=output)
        
        return EmulabResponse(RESPONSE_SUCCESS, output=output)

    #
    # swap an experiment using swapexp. We get the NS file inline, which
    # we have to write to a temp file first. 
    #
    def modify(self, version, argdict):
        if version != self.VERSION:
            return EmulabResponse(RESPONSE_BADVERSION,
                                 output="Client version mismatch!");
            pass

        argerror = CheckRequiredArgs(argdict, ("proj", "exp"))
        if (argerror):
            return argerror

        nsfilename = None
        argstr     = ""
        
        for opt, val in argdict.items():
            if opt == "wait":
                if val == "true":
                    argstr += " -w "
                    pass
                pass
            elif opt == "reboot":
                if val == "true":
                    argstr += " -r "
                    pass
                pass
            elif opt == "restart_eventsys":
                if val == "true":
                    argstr += " -e "
                    pass
                pass
            elif opt == "nsfilepath":
                # Backend script will verify this local path. 
                nsfilename = escapeshellarg(val)
                pass
            elif opt == "nsfilestr":
                nsfilestr = val
            
                if len(nsfilestr) > (1024 * 512):
                    return EmulabResponse(RESPONSE_TOOBIG,
                                         output="NS File way too big!");
        
                (nsfp, nsfilename) = writensfile(nsfilestr)
                if not nsfilename:
                    return EmulabResponse(RESPONSE_SERVERERROR,
                                         output="Server Error")
                pass
            pass

        argstr += " -s modify"
        argstr += " " + escapeshellarg(argdict["proj"])
        argstr += " " + escapeshellarg(argdict["exp"])

        if nsfilename:
            argstr += " " + nsfilename
            pass

        (exitval, output) = runcommand(TBDIR + "/bin/swapexp " + argstr)
        if exitval:
            return EmulabResponse(RESPONSE_ERROR, exitval >> 8, output=output)
        
        return EmulabResponse(RESPONSE_SUCCESS, output=output)

    #
    # end an experiment using endexp.
    #
    def endexp(self, version, argdict):
        if version != self.VERSION:
            return EmulabResponse(RESPONSE_BADVERSION,
                                 output="Client version mismatch!");
            pass

        argerror = CheckRequiredArgs(argdict, ("proj", "exp"))
        if (argerror):
            return argerror

        argstr = ""
        for opt, val in argdict.items():
            if opt == "wait":
                if val == "true":
                    argstr += " -w "
                    pass
                pass
            pass

        argstr += " " + escapeshellarg(argdict["proj"])
        argstr += " " + escapeshellarg(argdict["exp"])

        (exitval, output) = runcommand(TBDIR + "/bin/endexp " + argstr)
        if exitval:
            return EmulabResponse(RESPONSE_ERROR, exitval >> 8, output=output)
        
        return EmulabResponse(RESPONSE_SUCCESS, output=output)

    #
    # Return the state of an experiment.
    #
    def state(self, version, argdict):
        if version != self.VERSION:
            return EmulabResponse(RESPONSE_BADVERSION,
                                 output="Client version mismatch!");
            pass

        argerror = CheckRequiredArgs(argdict, ("proj", "exp"))
        if (argerror):
            return argerror

        if not (re.match("^[-\w]*$", argdict["proj"]) and
                re.match("^[-\w]*$", argdict["exp"])):
            return EmulabResponse(RESPONSE_BADARGS,
                                  output="Improperly formed proj/exp!")
        
        res = DBQueryFatal("select state from experiments "
                           "where pid=%s and eid=%s",
                           (argdict["proj"], argdict["exp"]))

        if len(res) == 0:
            return EmulabResponse(RESPONSE_ERROR,
                                  output="No such experiment!")
        
        state = res[0][0]
        return EmulabResponse(RESPONSE_SUCCESS, value=state, output=state)

    #
    # Return the state of an experiment.
    #
    def info(self, version, argdict):
        if version != self.VERSION:
            return EmulabResponse(RESPONSE_BADVERSION,
                                 output="Client version mismatch!");
            pass

        argerror = CheckRequiredArgs(argdict, ("proj", "exp", "aspect"))
        if (argerror):
            return argerror

        if not (re.match("^[-\w]*$", argdict["proj"]) and
                re.match("^[-\w]*$", argdict["exp"])):
            return EmulabResponse(RESPONSE_BADARGS,
                                  output="Illegal characters in arguments!")

        res = DBQueryFatal("select state from experiments "
                           "where pid=%s and eid=%s",
                           (argdict["proj"], argdict["exp"]))

        if len(res) == 0:
            return EmulabResponse(RESPONSE_ERROR,
                                  output="No such experiment!")
        state   = res[0][0]
        result  = {}
        mapping = None

        if state == "active":
            dbres = DBQuery("select r.vname,r.node_id,n.type "
                            "  from reserved as r "
                            "left join nodes as n on r.node_id=n.node_id "
                            "where r.pid=%s and r.eid=%s "
                            "order by vname",
                            (argdict["proj"], argdict["exp"]))
            mapping = {}
            for res in dbres:
                tmp = {}
                tmp["name"] = res[0]
                tmp["node"] = res[1]
                tmp["type"] = res[2]
                mapping[res[0]] = tmp
                pass
            pass

        if argdict["aspect"] == "mapping":
            if state != "active":
                return EmulabResponse(RESPONSE_ERROR,
                                      output="Experiment is not active!")
            # Just return the mapping above
            result = mapping
            pass
        elif argdict["aspect"] == "links":
            dbres = DBQueryFatal("SELECT vname,ips from virt_nodes "
                                 "where pid=%s and eid=%s",
                                 (argdict["proj"], argdict["exp"]))
            ipmap = {}
            for res in dbres:
                for ipinfo in string.split(res[1], " "):
                    port, ip = string.split(ipinfo, ":")
                    ipmap[res[0] + ":" + port] = ip
                    pass
                pass
            
            dbres = DBQuery("select vname,member,mask,delay,bandwidth, "
                            "       lossrate,rdelay,rbandwidth,rlossrate "
                            "from virt_lans where pid=%s and eid=%s "
                            "order by vname,member",
                            (argdict["proj"], argdict["exp"]))

            for res in dbres:
                tmp = {}
                tmp["name"]        = res[0]
                tmp["member"]      = res[1]
                tmp["ipaddr"]      = ipmap[res[1]]
                tmp["mask"]        = res[2]
                tmp["delay"]       = res[3]
                tmp["bandwidth"]   = int(res[4])
                tmp["plr"]         = res[5]
                tmp["r_delay"]     = res[6]
                tmp["r_bandwidth"] = int(res[7])
                tmp["r_plr"]       = res[8]
                result[res[1]]     = tmp
                pass
            pass
        
        return EmulabResponse(RESPONSE_SUCCESS,
                              value=result, output=str(result))

    #
    # nscheck an NS file.
    #
    def nscheck(self, version, argdict):
        if version != self.VERSION:
            return EmulabResponse(RESPONSE_BADVERSION,
                                 output="Client version mismatch!");
            pass

        argstr = ""

        if argdict.has_key("nsfilestr"):
            nsfilestr = argdict["nsfilestr"]
            
            if len(nsfilestr) > (1024 * 512):
                return EmulabResponse(RESPONSE_TOOBIG,
                                     output="NS File way too big!");
        
            (nsfp, nsfilename) = writensfile(nsfilestr)
            if not nsfilename:
                return EmulabResponse(RESPONSE_SERVERERROR,
                                      output="Server Error")

            argstr += nsfilename
            pass
        elif argdict.has_key("nsfilepath"):
            # Backend script will verify this local path. 
            argstr += escapeshellarg(argdict["nsfilepath"])
            pass
        else:
            return EmulabResponse(RESPONSE_BADARGS,
                                 output="Must supply an NS file to check!");
        
        (exitval, output) = runcommand(TBDIR + "/bin/nscheck " + argstr)
        if exitval:
            return EmulabResponse(RESPONSE_ERROR, exitval >> 8, output=output)
        
        return EmulabResponse(RESPONSE_SUCCESS, output=output)

    #
    # Delay configuration
    #
    def delay_config(self, version, argdict):
        if version != self.VERSION:
            return EmulabResponse(RESPONSE_BADVERSION,
                                 output="Client version mismatch!");
            pass

        argerror = CheckRequiredArgs(argdict,
                                     ("proj", "exp", "link", "params"))
        if (argerror):
            return argerror

        argstr = ""
        for opt, val in argdict.items():
            if opt == "persist":
                if val == "true":
                    argstr += " -m "
                    pass
                pass
            elif opt == "src":
                argstr += " -s "
                argstr += escapeshellarg(val)
                pass
            pass

        argstr += " " + escapeshellarg(argdict["proj"])
        argstr += " " + escapeshellarg(argdict["exp"])
        argstr += " " + escapeshellarg(argdict["link"])

        for opt, val in argdict["params"].items():
            argstr += " " + escapeshellarg(opt + "=" + val)
            pass
        
        (exitval, output) = runcommand(TBDIR + "/bin/delay_config " + argstr)
        if exitval:
            return EmulabResponse(RESPONSE_ERROR, exitval >> 8, output=output)
        
        return EmulabResponse(RESPONSE_SUCCESS, output=output)

    #
    # Reboot all nodes in an experiment.
    #
    def reboot(self, version, argdict):
        if version != self.VERSION:
            return EmulabResponse(RESPONSE_BADVERSION,
                                 output="Client version mismatch!");
            pass

        argerror = CheckRequiredArgs(argdict, ("proj", "exp"))
        if (argerror):
            return argerror

        argstr = ""
        for opt, val in argdict.items():
            if opt == "wait":
                if val == "true":
                    argstr += " -w "
                    pass
                pass
            pass

        argstr += " -e "
        argstr += escapeshellarg(argdict["proj"] + "," + argdict["exp"])
        
        (exitval, output) = runcommand(TBDIR + "/bin/node_reboot " + argstr)
        if exitval:
            return EmulabResponse(RESPONSE_ERROR, exitval >> 8, output=output)
        
        return EmulabResponse(RESPONSE_SUCCESS, output=output)

    #
    # Reload all nodes in an experiment.
    #
    def reload(self, version, argdict):
        if version != self.VERSION:
            return EmulabResponse(RESPONSE_BADVERSION,
                                 output="Client version mismatch!");
            pass

        argerror = CheckRequiredArgs(argdict, ("proj", "exp"))
        if (argerror):
            return argerror

        argstr = ""
        for opt, val in argdict.items():
            if opt == "wait":
                if val == "false":
                    argstr += " -s "
                    pass
                pass
            elif opt == "imageproj":
                argstr += " -p "
                argstr += escapeshellarg(val)
                pass
            elif opt == "imageid":
                argstr += " -i "
                argstr += escapeshellarg(val)
                pass
            pass

        argstr += " -e "
        argstr += escapeshellarg(argdict["proj"] + "," + argdict["exp"])
        
        (exitval, output) = runcommand(TBDIR + "/bin/os_load " + argstr)

        if exitval:
            return EmulabResponse(RESPONSE_ERROR, exitval >> 8, output=output)
        
        return EmulabResponse(RESPONSE_SUCCESS, output=output)

    pass

#
# This class implements the server side of the XMLRPC interface to nodes.
#
class node:
    ##
    # Initialize the object.  Currently only sets the objects 'VERSION' value.
    #
    def __init__(self):
        self.VERSION = VERSION
        return

    #
    # reboot nodes
    #
    def reboot(self, version, argdict):
        if version != self.VERSION:
            return EmulabResponse(RESPONSE_BADVERSION,
                                 output="Client version mismatch!");
            pass

        argerror = CheckRequiredArgs(argdict, ("nodes"))
        if (argerror):
            return argerror

        argstr = ""
        for opt, val in argdict.items():
            if opt == "wait":
                if val == "true":
                    argstr += " -w "
                    pass
                pass
            pass

        tokens = argdict["nodes"].split(",")
        for token in tokens:
            argstr += " " + escapeshellarg(token)
            pass

        (exitval, output) = runcommand(TBDIR + "/bin/node_reboot " + argstr)
        if exitval:
            return EmulabResponse(RESPONSE_ERROR, exitval >> 8, output=output)
        
        return EmulabResponse(RESPONSE_SUCCESS, output=output)

    #
    # create_image.
    #
    def create_image(self, version, argdict):
        if version != self.VERSION:
            return EmulabResponse(RESPONSE_BADVERSION,
                                 output="Client version mismatch!");
            pass

        argerror = CheckRequiredArgs(argdict, ("imageid", "node"))
        if (argerror):
            return argerror

        argstr = ""
        for opt, val in argdict.items():
            if opt == "wait":
                if val == "true":
                    argstr += " -w "
                    pass
                pass
            elif opt == "proj":
                argstr += " -p "
                argstr += escapeshellarg(val)
                pass
            pass

        argstr += " " + escapeshellarg(argdict["imageid"])
        argstr += " " + escapeshellarg(argdict["node"])

        (exitval, output) = runcommand(TBDIR + "/bin/create_image " + argstr)
        if exitval:
            return EmulabResponse(RESPONSE_ERROR, exitval >> 8, output=output)
        
        return EmulabResponse(RESPONSE_SUCCESS, output=output)

    #
    # Reload nodes.
    #
    def reload(self, version, argdict):
        if version != self.VERSION:
            return EmulabResponse(RESPONSE_BADVERSION,
                                 output="Client version mismatch!");
            pass

        argerror = CheckRequiredArgs(argdict, ("nodes"))
        if (argerror):
            return argerror

        argstr = ""
        for opt, val in argdict.items():
            if opt == "wait":
                if val == "false":
                    argstr += " -s "
                    pass
                pass
            elif opt == "imageproj":
                argstr += " -p "
                argstr += escapeshellarg(val)
                pass
            elif opt == "imageid":
                argstr += " -i "
                argstr += escapeshellarg(val)
                pass
            pass

        tokens = argdict["nodes"].split(",")
        for token in tokens:
            argstr += " " + escapeshellarg(token)
            pass

        (exitval, output) = runcommand(TBDIR + "/bin/os_load " + argstr)

        if exitval:
            return EmulabResponse(RESPONSE_ERROR, exitval >> 8, output=output)
        
        return EmulabResponse(RESPONSE_SUCCESS, output=output)

    pass

#
# Utility functions
#

#
# escapeshellarg() adds single quotes around a string and quotes/escapes any
# existing single quotes allowing string to be passed directly to a shell
# function and having it be treated as a single safe argument.
#
def escapeshellarg(s):
    s2 = ""

    for c in s:
        if c == '\'':
            s2 = s2 + '\'\\\''
        s2 = s2 + c

    return '\'' + s2 + '\''

#
# Run a command. args is a list of strings to pass as arguments to cmd.
# Return the exitcode and the output as a tuple.
# 
def runcommand(cmd):
    child  = popen2.Popen4(cmd)
    output = child.fromchild.read(8192)
    return (child.wait(), output)

def writensfile(str):
    tempfile.tempdir = "/var/tmp"
    try:
        fp = tempfile.NamedTemporaryFile(prefix="php")
        fp.write(str)
        fp.flush()

    except:
        SENDMAIL(TBOPS, "writensfile failed",
                 "Could not write temporary NS file:\n" +
                 "%s:%s" % (sys.exc_type, sys.exc_value))
        return None
        pass

    # Yuck. Need to maintain a ref so that the file is not deleted!
    return (fp, fp.name)
