#! /usr/bin/env python
#
# EMULAB-COPYRIGHT
# Copyright (c) 2004 University of Utah and the Flux Group.
# All rights reserved.
#
import sys
import socket
import os
import popen2
import tempfile
import time
sys.path.append("@prefix@/lib")
import libdb
from libtestbed   import SENDMAIL, TBOPS
from emulabclient import *

# Configure variables
TBDIR = "@prefix@"

#
# This class implements the server side of the XMLRPC interface to Emulab. 
#
# Arguments passed as a Dictionary. This converts to a XML "struct"
# which in Perl/PHP/Ruby would be a hash. So, a client written in
# pretty much any language should be able to talk to this class.
#
class emulabserver:
    ##
    # Initialize the object.  Currently only sets the objects 'VERSION' value.
    #
    def __init__(self):
        self.VERSION = 0.1
        return

    ##
    # Echo a message, basically, prepend the host name to the parameter list.
    #
    # @param args The argument list to echo back.
    # @return The 'msg' value with this machine's name prepended.
    #
    def echo(self, version, argdict):
        if not argdict.has_key("str"):
            return ResponseBlock(RESPONSE_BADARGS,
                                 output="Must supply a string to echo!");
        
        return ResponseBlock(RESPONSE_SUCCESS, 0,
                             socket.gethostname() + ": " + str(version)
                             + " " + argdict["str"])

    #
    # Start an experiment using batchexp. We get the NS file inline, which
    # we have to write to a temp file first. 
    #
    def batchexp(self, version, argdict):
        if version != self.VERSION:
            return ResponseBlock(RESPONSE_BADVERSION,
                                 output="Client version mismatch!");
            pass

        if not (argdict.has_key("pid") and
                argdict.has_key("eid")):
            return ResponseBlock(RESPONSE_BADARGS,
                                 output="Must supply pid and eid!");

        nsfilename = None
        argstr     = ""
        
        for opt, val in argdict.items():
            if opt in ("batchmode"):
                if val == 0:
                    argstr += " -i"
                    pass
                pass
            elif opt in ("description"):
                argstr += " -E "
                argstr += escapeshellarg(val)
                pass
            elif opt in ("gid"):
                argstr += " -g "
                argstr += escapeshellarg(val)
                pass
            elif opt in ("eid"):
                argstr += " -e "
                argstr += escapeshellarg(val)
                pass
            elif opt in ("pid"):
                argstr += " -p "
                argstr += escapeshellarg(val)
                pass
            elif opt in ("idleswap"):
                if opt == 0:
                    argstr += " -S "
                    argstr += argdict["noswap_reason"]
                    pass
                pass
            elif opt in ("noswap_reason"):
                pass
            elif opt in ("idleswap"):
                if opt == 0:
                    argstr += " -L "
                    argstr += escapeshellarg(argdict["noidleswap_reason"])
                    pass
                else:
                    argstr += " -l "
                    argstr += escapeshellarg(val)
                    pass
                pass
            elif opt in ("noidleswap_reason"):
                pass
            elif opt in ("autoswap"):
                argstr += " -a "
                argstr += escapeshellarg(val)
                pass
            elif opt in ("frontend"):
                argstr += " -f "
                pass
            elif opt in ("waitmode"):
                argstr += " -w "
                pass
            elif opt in ("nsfilepath"):
                # Backend script will verify this local path. 
                nsfilename = escapeshellarg(val)
                pass
            elif opt in ("nsfilestr"):
                nsfilestr = val
            
                if len(nsfilestr) > (1024 * 512):
                    return ResponseBlock(RESPONSE_TOOBIG,
                                         output="NS File way too big!");
        
                (nsfp, nsfilename) = writensfile(nsfilestr)
                if not nsfilename:
                    return ResponseBlock(RESPONSE_SERVERERROR,
                                         output="Server Error")
                pass
            pass

        if nsfilename:
            argstr += " " + nsfilename
            pass

        (exitval, output) = runcommand(TBDIR + "/bin/batchexp " + argstr)
        if exitval:
            return ResponseBlock(RESPONSE_ERROR, exitval >> 8, output=output)
        
        return ResponseBlock(RESPONSE_SUCCESS, output=output)

    #
    # startexp is an alias for batchexp.
    # 
    def startexp(self, version, argdict):
        return self.batchexp(version, argdict)

    #
    # swap an experiment using swapexp. We get the NS file inline, which
    # we have to write to a temp file first. 
    #
    def swapexp(self, version, argdict):
        if version != self.VERSION:
            return ResponseBlock(RESPONSE_BADVERSION,
                                 output="Client version mismatch!");
            pass

        nsfilename = None
        argstr     = ""
        
        for opt, val in argdict.items():
            if opt in ("waitmode"):
                argstr += " -w "
                pass
            elif opt in ("reboot_nodes"):
                argstr += " -r "
                pass
            elif opt in ("restart_eventsys"):
                argstr += " -e "
                pass
            elif opt in ("swapop"):
                argstr += " -s "
                argstr += escapeshellarg(val)
                pass
            elif opt in ("nsfilepath"):
                # Backend script will verify this local path. 
                nsfilename = escapeshellarg(val)
                pass
            elif opt in ("nsfilestr"):
                nsfilestr = val
            
                if len(nsfilestr) > (1024 * 512):
                    return ResponseBlock(RESPONSE_TOOBIG,
                                         output="NS File way too big!");
        
                (nsfp, nsfilename) = writensfile(nsfilestr)
                if not nsfilename:
                    return ResponseBlock(RESPONSE_SERVERERROR,
                                         output="Server Error")
                pass
            pass

        if not (argdict.has_key("pid") and
                argdict.has_key("eid")):
            return ResponseBlock(RESPONSE_BADARGS,
                                 output="Must supply pid and eid!");

        argstr += " " + escapeshellarg(argdict["pid"])
        argstr += " " + escapeshellarg(argdict["eid"])

        if nsfilename:
            argstr += " " + nsfilename
            pass

        (exitval, output) = runcommand(TBDIR + "/bin/swapexp " + argstr)
        if exitval:
            return ResponseBlock(RESPONSE_ERROR, exitval >> 8, output=output)
        
        return ResponseBlock(RESPONSE_SUCCESS, output=output)

    #
    # end an experiment using endexp.
    #
    def endexp(self, version, argdict):
        if version != self.VERSION:
            return ResponseBlock(RESPONSE_BADVERSION,
                                 output="Client version mismatch!");
            pass

        argstr     = ""
        
        for opt, val in argdict.items():
            if opt in ("waitmode"):
                argstr += " -w "
                pass
            pass

        if not (argdict.has_key("pid") and
                argdict.has_key("eid")):
            return ResponseBlock(RESPONSE_BADARGS,
                                 output="Must supply pid and eid!");

        argstr += " " + escapeshellarg(argdict["pid"])
        argstr += " " + escapeshellarg(argdict["eid"])

        (exitval, output) = runcommand(TBDIR + "/bin/endexp " + argstr)
        if exitval:
            return ResponseBlock(RESPONSE_ERROR, exitval >> 8, output=output)
        
        return ResponseBlock(RESPONSE_SUCCESS, output=output)

    #
    # nscheck an NS file.
    #
    def nscheck(self, version, argdict):
        if version != self.VERSION:
            return ResponseBlock(RESPONSE_BADVERSION,
                                 output="Client version mismatch!");
            pass

        argstr = ""

        if argdict.has_key("nsfilestr"):
            nsfilestr = argdict["nsfilestr"]
            
            if len(nsfilestr) > (1024 * 512):
                return ResponseBlock(RESPONSE_TOOBIG,
                                     output="NS File way too big!");
        
            (nsfp, nsfilename) = writensfile(nsfilestr)
            if not nsfilename:
                return ResponseBlock(RESPONSE_SERVERERROR, output="Server Error")

            argstr += nsfilename
            pass
        elif argdict.has_key("nsfilepath"):
            # Backend script will verify this local path. 
            argstr += escapeshellarg(argdict["nsfilepath"])
            pass
        else:
            return ResponseBlock(RESPONSE_BADARGS,
                                 output="Must supply an NS file to check!");
        
        (exitval, output) = runcommand(TBDIR + "/bin/nscheck " + argstr)
        if exitval:
            return ResponseBlock(RESPONSE_ERROR, exitval >> 8, output=output)
        
        return ResponseBlock(RESPONSE_SUCCESS, output=output)

    #
    # create_image.
    #
    def create_image(self, version, argdict):
        if version != self.VERSION:
            return ResponseBlock(RESPONSE_BADVERSION,
                                 output="Client version mismatch!");
            pass

        argstr = ""
        
        for opt, val in argdict.items():
            if opt in ("pid"):
                argstr += " -p "
                argstr += escapeshellarg(val)
                pass
            pass

        if not (argdict.has_key("imageid") and
                argdict.has_key("nodeid")):
            return ResponseBlock(RESPONSE_BADARGS,
                                 output="Must supply imageid and nodeid!");

        argstr += " " + escapeshellarg(argdict["imageid"])
        argstr += " " + escapeshellarg(argdict["nodeid"])

        (exitval, output) = runcommand(TBDIR + "/bin/create_image " + argstr)
        if exitval:
            return ResponseBlock(RESPONSE_ERROR, exitval >> 8, output=output)
        
        return ResponseBlock(RESPONSE_SUCCESS, output=output)

    #
    # create_image.
    #
    def delay_config(self, version, argdict):
        if version != self.VERSION:
            return ResponseBlock(RESPONSE_BADVERSION,
                                 output="Client version mismatch!");
            pass

        argstr = ""
        
        for opt, val in argdict.items():
            if opt in ("modify_exp"):
                argstr += " -m "
                pass
            elif opt in ("srcvnode"):
                argstr += " -s "
                argstr += escapeshellarg(val)
                pass
            pass

        if not (argdict.has_key("pid") and
                argdict.has_key("eid") and
                argdict.has_key("link") and
                argdict.has_key("params")):
            return ResponseBlock(RESPONSE_BADARGS,
                                 output="Must supply pid, eid, link, params!");

        argstr += " " + escapeshellarg(argdict["pid"])
        argstr += " " + escapeshellarg(argdict["eid"])
        argstr += " " + escapeshellarg(argdict["link"])

        for opt, val in argdict["params"].items():
            argstr += " " + opt + "=" + val
            pass
        
        (exitval, output) = runcommand(TBDIR + "/bin/delay_config " + argstr)
        if exitval:
            return ResponseBlock(RESPONSE_ERROR, exitval >> 8, output=output)
        
        return ResponseBlock(RESPONSE_SUCCESS, output=output)

    pass

#
# Utility functions
#

#
# escapeshellarg() adds single quotes around a string and quotes/escapes any
# existing single quotes allowing string to be passed directly to a shell
# function and having it be treated as a single safe argument.
#
def escapeshellarg(s):
    s2 = ""

    for c in s:
        if c == '\'':
            s2 = s2 + '\'\\\''
        s2 = s2 + c

    return '\'' + s2 + '\''

#
# Run a command. args is a list of strings to pass as arguments to cmd.
# Return the exitcode and the output as a tuple.
# 
def runcommand(cmd):
    child  = popen2.Popen4(cmd)
    output = child.fromchild.read(8192)
    return (child.wait(), output)

def writensfile(str):
    tempfile.tempdir = "/var/tmp"
    try:
        fp = tempfile.NamedTemporaryFile(prefix="php")
        fp.write(str)
        fp.flush()

    except:
        SENDMAIL(TBOPS, "writensfile failed",
                 "Could not write temporary NS file:\n" +
                 "%s:%s" % (sys.exc_type, sys.exc_value))
        return None
        pass

    # Yuck. Need to maintain a ref so that the file is not deleted!
    return (fp, fp.name)
