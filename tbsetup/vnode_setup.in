#!/usr/bin/perl -wT

#
# EMULAB-COPYRIGHT
# Copyright (c) 2000-2003 University of Utah and the Flux Group.
# All rights reserved.
#
use English;
use Getopt::Std;

#
# Set up the vnode state on a virtual (multiplexed) node.
#
# XXX - This script should only be run from os_setup!
#
# The output is all jumbled together since the updates are issued in parallel.
# Might be a pain when debugging. 
# 
sub usage()
{
    print STDOUT "Usage: vnode_setup [-f] [-k] <pid> <eid> [node ...]\n";
    exit(-1);
}
my  $optlist = "fdk";

#
# We don't want to run this script unless its the real version.
# That is, it must be setuid root. 
#
if ($EUID != 0) {
    die("*** $0:\n".
	"    Must be root! Maybe its a development version?\n");
}

#
# Configure variables
#
my $TB		= "@prefix@";
my $TESTMODE    = @TESTMODE@;
my $TBOPS       = "@TBOPSEMAIL@";
my $TBLOGS      = "@TBLOGSEMAIL@";
my $CLIENT_BIN  = "@CLIENT_BINDIR@";

my $ssh		= "$TB/bin/sshtb -n";
my $debug       = 0;
my $force       = 0;
my $failed      = 0;
my $killmode    = 0;
my $dbuid;

my $MAX_CHILDREN = 8;

#
# Load the Testbed support stuff. 
#
use lib "@prefix@/lib";
use libdb;
use libtestbed;

# un-taint path
$ENV{'PATH'} = '/bin:/usr/bin:/usr/local/bin';
delete @ENV{'IFS', 'CDPATH', 'ENV', 'BASH_ENV'};

# Turn off line buffering on output
$| = 1; 

#
# Parse command arguments. Once we return from getopts, all that should be
# left are the required arguments.
#
%options = ();
if (! getopts($optlist, \%options)) {
    usage();
}
if (@ARGV < 2) {
    usage();
}
if (defined($options{"f"})) {
    $force = 1;
}
if (defined($options{"d"})) {
    $debug = 1;
}
if (defined($options{"k"})) {
    $killmode = 1;
}
my $pid   = shift(@ARGV);
my $eid   = shift(@ARGV);

#
# Untaint the arguments.
#
if ($pid =~ /^([-\@\w]+)$/) {
    $pid = $1;
}
else {
    die("*** Bad data in pid: $pid\n");
}	
if ($eid =~ /^([-\@\w]+)$/) {
    $eid = $1;
}
else {
    die("*** Bad data in eid: $eid\n");
}

#
# Verify permission to muck with this experiment.
#
if (!TBAdmin($UID) &&
    !TBExptAccessCheck($UID, $pid, $eid, TB_EXPT_DESTROY)) {
    die("*** $0:\n".
	"    You do not have permission to mess with $pid/$eid!\n");
}

#
# Get the list of nodes in this experiment.
#
my @nodes = ExpNodes($pid, $eid);
if (! @nodes) {
    warn("*** $0:\n".
	 "    No allocated nodes in experiment $pid/$eid!\n");
    exit(0);
}

# Nodes on the command line. Operate only on this set.
if (@ARGV) {
    my %fulllist = ();

    # Temporary hash list for searching.
    foreach my $node ( @nodes ) {
	$fulllist{$node} = 1;
    }
    @nodes = ();

    foreach my $node ( @ARGV ) {
	if ($node =~ /^([-\@\w]+)$/) {
	    $node = $1;

	    if (!defined($fulllist{$node})) {
		die("*** $0:\n".
		     "   Node $node is not allocated to $pid/$eid!\n");
	    }
	}
	else {
	    die("Bad node name: $node.");
	}
	push(@nodes, $node);
    }
}
my $exptstate = ExpState($pid, $eid);

# Just the vnodes mam.
foreach my $node (@nodes) {
    my $pnode;
    my $jailed;
    my $plab;
    my $allocstate;
    my $mode = ($killmode ? "teardown" : "setup");

    if (! TBIsNodeVirtual($node, \$jailed, \$plab)) {
	next;
    }
    if (! TBPhysNodeID($node, \$pnode)) {
	die("*** $0:\n".
	    "    No physical node for $node!\n");
    }

    TBGetNodeAllocState($node, \$allocstate);

    #
    # On remote nodes, or when forcemode is on, always do the deed.
    # Otherwise, look at experiment state.
    #
    if (!$force) {
	if ($exptstate eq EXPTSTATE_SWAPPING) {
	    #
	    # When swapping, local vnodes go down with the physnode.
	    #
	    if (! TBIsNodeRemote($node)) {
		print "$node will $mode with local node $pnode.\n";
		next;
	    }
	    elsif ($allocstate eq TBDB_ALLOCSTATE_DOWN) {
		if (!$plab) {
		    print "$node failed to boot; skipping $mode.\n";
		    next;
		}
		# Plab nodes need to be cleaned up.
		print "$node failed to boot; changing to cleanup.\n";
		$mode = "cleanup";
	    }
	}
	elsif ($exptstate eq EXPTSTATE_ACTIVATING) {
	    #
	    # The allocstate determines if the vnode actually needs to
	    # be setup or torndown. Note that a failed experiment will
	    # cause a bunch of vnodes to be torndown, while in the
	    # ACTIVATING state. See os_setup and assign_wrapper; the
	    # idea is to avoid doing setup/teardown up vnodes on
	    # machines that are rebooting anyway, or that failed.
	    # Complicated by modify which could add/subtract a vnode on
	    # an existing machine, but not reboot the machine. Note that
	    # free (now unused) vnodes will land in RES_TEARDOWN. It is
	    # assumed that these booted okay, and need to be torndown,
	    # even though they are not RES_READY.
	    #
	    if (! TBIsNodeRemote($node)) {
		if ($killmode) {
		    if ($allocstate eq TBDB_ALLOCSTATE_DOWN) {
			print "$node failed to boot; skipping $mode.\n";
			next;
		    }
		    elsif ($allocstate eq TBDB_ALLOCSTATE_RES_INIT_CLEAN()) {
			print "$node never booted; skipping $mode.\n";
			next;
		    }
		    elsif ($allocstate eq TBDB_ALLOCSTATE_RES_READY()) {
			print "$node will $mode with local node $pnode.\n";
			next;
		    }
		}
		elsif ($allocstate eq TBDB_ALLOCSTATE_RES_READY()) {
		    print "$node is already setting up on local node $pnode\n";
		    next;
		}
	    }
	    else {
		if ($killmode) {
		    if ($allocstate eq TBDB_ALLOCSTATE_DEAD) {
			# plab only. See below.
			print "$node failed to initialize; skipping $mode.\n";
			next;
		    }
		    elsif ($allocstate eq TBDB_ALLOCSTATE_DOWN) {
			if (!$plab) {
			    print "$node failed to boot; skipping $mode.\n";
			    next;
			}
			# Plab nodes need to be cleaned up.
			print "$node failed to boot; changing to cleanup.\n";
			$mode = "cleanup";
		    }
		    elsif ($allocstate eq TBDB_ALLOCSTATE_RES_INIT_CLEAN()) {
			print "$node never booted; skipping $mode.\n";
			next;
		    }
		}
		elsif ($allocstate eq TBDB_ALLOCSTATE_RES_READY()) {
		    print "$node is already set up on remote node $pnode\n";
		    next;
		}
		elsif ($allocstate eq TBDB_ALLOCSTATE_RES_INIT_DIRTY()) {
		    print "$node needs a reboot on remote node $pnode\n";
		    $mode = "reboot";
		}
	    }
	}
    }

    #
    # When setting up a vnode, force its event state into SHUTDOWN since
    # no telling what its initial state is. 
    # 
    if ($mode eq "teardown" || $mode eq "reboot") {
	TBSetNodeEventState($node, TBDB_NODESTATE_SHUTDOWN);
    }

    #
    # Put this into the list of calls we have to make in the next loop
    #
    push @vnodes, [$node, $pnode, $mode, $jailed, $plab];

}


sub plabnode($$$$) {
    my ($mode, $pid, $eid, $vnode) = @_;

    my $plabpid = 0;
    $plabpid = fork();
        
    if ($plabpid) {
        local $SIG{TERM} = 
            sub { 
                kill("TERM", $plabpid); 
                print STDERR "*** $0:\n".
                    "    Plab node allocation terminated.\n"; 
                exit(1);
            };
        
        my $childpid = wait();
        if ($childpid < 0) {
            die("*** $0:\n".
                "    Uh oh, wait() returned a negative number");
        }
        elsif ($childpid != $plabpid) {
            die("*** $0:\n".
                "    Whoops! pid returned by wait() != pid ".
                "from fork().");
        }
        
        if ($?) {
            #print STDERR "*** $0:\n" .
            #    "    Plab node $mode failed\n";
            # Should check DB state instead.
            return($?);
        }
    }
    else {
        exec("$TB/sbin/plabnode $mode $pid $eid $vnode");    
        die("*** $0:\n".
            "    exec failed!\n");
    }

    return(0);
}


my $children = 0;
my %child_vnodes = ();
while (1) {

    #
    # We're done when we've hit the last vnode, and we've outlived all of our
    # children
    #
    if ((!@vnodes) && ($children == 0)) {
	last;
    }

    #
    # There are more free slots
    #
    if (($children <= $MAX_CHILDREN) && @vnodes) {
	#
	# Look for a vnode that is not on a pnode we're already working on
	# 
	# XXX - do this!
	
	my ($vnode, $pnode, $mode, $jailed, $plab) = @{pop @vnodes};
    
	print STDOUT "Doing $mode of vnode $vnode on $pnode ...\n";

	#
	# Run an ssh command in a child process, protected by an alarm to
	# ensure that the ssh is not hung up forever if the machine is in some
	# funky state.
	# 
	my $syspid = fork();

	if ($syspid) {
	    #
	    # Just keep track of it, we'll wait for it finish down below
	    #
	    $child_vnodes{$syspid} =
		[$vnode, $pnode, $mode, $jailed, $plab, time()];
	    $children++;
	} else {
	    # Must change our real UID to root so that ssh will work.
	    $UID = 0;

            # If this is a plab vnode, we need to allocate it first.
            # This will give us a vserver on the physical plab node to
            # work in.
	    if ($plab && $mode eq "setup") {
                if(plabnode("alloc", $pid, $eid, $vnode)) {
                    print STDERR "*** $0:\n" .
                                 "    Plab node allocation failed\n";
                    # Should check DB state instead.
                    exit(99);
                }
            }

	    # Cleanup is used only on plab nodes.
	    if ($mode ne "cleanup") {
		my $args = (($mode eq "teardown") ? "-k " :
			    ($mode eq "reboot" ? "-r " : " "));
		$args   .= ($jailed   ? "-j " : " ");
		$args   .= ($plab     ? "-p " : " ");
		$args   .= "$vnode ";
	
		exec("$ssh -host $vnode $CLIENT_BIN/vnodesetup $args");
		die("*** $0:\n".
		    "    exec failed!\n");
	    }
	    exit(0);
	}
    } else {
	#
	# We have too many of the little rugrats, wait for one to die
	#

	#
	# Set up a timer - we want to kill processes after they hit 120 seconds
	# old (not much of a life, is it?), so we find the first one marked for
	# death.
	#
	my $oldest = 0;
	my $oldestpid = 0;
	while (my ($pid, $aref) = each %child_vnodes) {
	    my ($vnode, $pnode, $mode, $jailed, $plab, $birthtime) = @$aref;
	    if ($birthtime > $oldest) {
		$oldest = $birthtime;
		$oldestpid = $pid;
	    }
	}

	#
	# Sanity check
	#
	if (!$oldest) {
	    die "*** $0\n".
	    	"Uh oh, I have no children left, something is wrong!\n";
	}

	#
	# Kill of the oldest if he gets too old while we're waiting
	#
        local $SIG{ALRM} = sub { kill("TERM", $oldestpid); };
        alarm(($oldest + 120) - time());

	my $childpid = wait();
	my $exitstatus = $?;
	alarm 0;

	#
	# Another sanity check
	#
	if ($childpid < 0) {
	    die "*** $0\n".
	    	"wait() returned <0, something is wrong!\n";
	}

	#
	# Look up to see what vnode, etc. this was associated with - if we
	# don't know about this child, ignore it
	#
	my $aref = $child_vnodes{$childpid};
	next unless @$aref;
	my ($vnode, $pnode, $mode, $jailed, $plab, $birthtime) = @$aref;
	$children--;
	delete $child_vnodes{$childpid};

	#
	# Look for setup failure, reported back through ssh.
	# 
	if ($exitstatus) {
	    print STDERR "vnode $vnode $mode on $pnode returned $?.\n"
		if $debug;

	    if ($exitstatus == 256) {
		print STDERR "$vnode is not running sshd.\n" if $debug;
	    }
	    elsif ($exitstatus == 15) {
		print STDERR "$vnode is wedged.\n" if $debug;
	    }
	    elsif ($exitstatus >> 8 == 99) {
		print STDERR "$vnode did not allocate properly.\n" if $debug;
	    }

	    push @failed_nodes, [$vnode, $pnode, $mode, $exitstatus];
	    
	    warn("*** $0:\n".
		 "    Virtual node $vnode $mode failure!\n");
	}

	if ($plab) {
	    #
	    # I am totally unhappy with this mess.
	    #
	    if ((($mode eq "teardown") || ($mode eq "cleanup")) ||
		($exitstatus && (($exitstatus >> 8) != 99))) {
		#
		# Besides teardown/cleanup, we want to do this if the
		# vnode setup on the node failed, but only if the
		# plabnode alloc worked (it can fail too, exits with 99).
		#
                if (plabnode("free", $pid, $eid, $vnode)) {
		    warn("*** $0:\n".
			 "    Plab node free of $vnode failed");
		}
	    }
	    
	    #
	    # If the node was in the setup process, then mark its allocstate
	    # as down so os_setup knows not to bother waiting for it. DEAD
	    # is a temp state, different then DOWN. It indicates the node
	    # was never instantiated (important distinction for plab). 
	    #
	    if ($exitstatus &&
		(($mode eq "setup") || ($mode eq "reboot"))) {
		TBSetNodeAllocState($vnode, TBDB_ALLOCSTATE_DEAD());
	    }
	}
    }
}

#
# Send mail to testbed-ops about failed nodes
#
if (@failed_nodes) { 
    my $failed_lines = join("\n",map { join("\t",@{$_}) } @failed_nodes);
    SENDMAIL($TBOPS, "Virtual Node failure for $pid/$eid",
	"The following virtual nodes failed: \n" .
	"vnode\t\tpnode\tmode\texit status\n" .
	$failed_lines);
}

if ($killmode) {
    print STDOUT "Vnode teardown finished.\n";
}
else {
    print STDOUT "Vnode setup initiated on all nodes ...\n";
}
exit 0;
