#!/usr/bin/perl -wT
#
# EMULAB-COPYRIGHT
# Copyright (c) 2000-2010 University of Utah and the Flux Group.
# All rights reserved.
#
use English;
use Getopt::Std;

#
# Load an image onto a disk. The image must be in the DB images table,
# which defines how/where to load, and what partitions are affected.
# The nodes and partitions tables are updated appropriately.
#
sub usage()
{
    print("Usage: os_load [-s] [[-p <pid>] -i <imageid>] <node> [node ...]\n".
	  "       os_load [-s] [[-p <pid>] -i <imageid>] -e pid,eid\n".
	  "       os_load -l\n".
	  "Use -i to specify a comma seperated list of image IDs.\n".
          "       Use the node default otherwise.\n".
	  "Use -p to specify the project ID in which to find the imageid.\n".
	  "       If the image is not found in <pid> also try ".TB_OPSPID().".\n".
	  "Use -m to specify the internal name(s) if an image ID.\n".
	  "Use -c to reload the current default.\n".
	  "Use -s to start reload, but do not wait for it to complete.\n".
	  "Use -w to wait for the nodes to finish booting.\n".
	  "Use -r to supress rebooting nodes - you need to to it yourself\n".
	  "Use -e to reload all the nodes in an experiment.\n" .
	  "Use -l to get a list of images you are permitted to load.\n".
	  "Use -z <style> to zero all unallocated blocks on the disk\n".
	  "       style==0: do not zero (same as not using -z)\n".
	  "       style==1: let frisbee do the zeroing\n".
	  "       style==2: zero disk before running frisbee\n".
          "Use -P to prepare the disk as if a whole disk image was loaded\n".
          "Use -F to force the load if Emulab tries to optimize it away\n".
          "Use -R to push a reconfig to the node after the reload\n".
          "Use -D to set a specific debug level\n");
    exit(-1);
}
my $optlist   = "swldD:i:e:p:m:rz:PcRF";
my $waitmode  = 1;
my $listonly  = 0;
my $debug     = 0;
my $noreboot  = 0;
my $zerofree  = 0;
my $prepare   = 0;
my $usecurrent= 0;
my $reconfig  = 0;
my $force     = 0;
my @nodes     = ();
my $imagepid;
my $pid;
my $eid;
my @imageids = ();
my $imagenames;

# Configure variables
my $TB		= "@prefix@";

# Load the Testbed support stuff.
use lib "@prefix@/lib";
use libdb;
use libosload;
use libtestbed;
use Experiment;
use Node;
use OSinfo;
use Image;
use EmulabFeatures;
use User;

# Be careful not to exit on transient error
$libdb::DBQUERY_MAXTRIES = 30;

# un-taint path
$ENV{'PATH'} = '/bin:/usr/bin:/usr/local/bin';
delete @ENV{'IFS', 'CDPATH', 'ENV', 'BASH_ENV'};

# Turn off line buffering on output
$| = 1;

#
# Parse command arguments. Once we return from getopts, all that should be
# left are the required arguments.
#
my %options = ();
if (! getopts($optlist, \%options)) {
    usage();
}
$debug = 1
    if (defined($options{"d"}));
if (defined($options{"D"}) && $options{"D"} =~ /^(\d+)$/) {
    $debug = $1;
}

# List only mode. No need to do anymore argument processing.
sub dolisting();
if (defined($options{"l"})) {
    dolisting();
    exit(0);
}

$waitmode = 0
    if (defined($options{"s"}));
$waitmode = 2
    if (defined($options{"w"}));
$noreboot = 1
    if (defined($options{"r"}));
$zerofree = $options{"z"}
    if (defined($options{"z"}));
$prepare = 1
    if (defined($options{"P"}));
$usecurrent = 1
    if (defined($options{"c"}));
$reconfig = 1
    if (defined($options{"R"}));
$force   = 1
    if (defined($options{"F"}));

#
# Figure out which nodes. Choice of nodes on command line, or all nodes in an
# experiment. To get all free nodes, must use sched_reload. 
# 
my $experiment;
if (defined($options{"e"})) {
    usage()
	if (@ARGV);

    my $pideid = $options{"e"};

    if ($pideid =~ /([-\w]*),([-\w]*)/) {
	$pid = $1;
	$eid = $2;

        $experiment = Experiment->Lookup($pid, $eid);
	if (!defined($experiment)) {
	    die("*** $0:\n".
		"    No such experiment $pid/$eid!\n");
	}
	if (! (@nodes = $experiment->NodeList(0, 1))) {
	    die("*** $0:\n".
		"    There are no nodes in $pid/$eid!\n");
	}
    }
    else {
	die("*** $0:\n".
	    "    Invalid argument to -e option: $pideid\n");
	usage();
    }
}
else {
    usage()
	if (! @ARGV);

    foreach my $nodeid (@ARGV) {
	my $node = Node->Lookup($nodeid);
	if (!defined($node)) {
	    die("*** $0:\n".
		"    No such node $nodeid!\n");
	}
	if (!$node->IsReserved()) {
	    die("*** $0:\n".
		"    Node $nodeid is not reserved; reserve it first!\n");
	}    
	push(@nodes, $node);
    }
}

#
# Image name (user visible name, not the internal ID). User is allowed
# to specify the pid the belongs to, but this is mostly broken cause
# images are stored in proj trees and created via NFS, so not really
# possibly to share images between projects; must be a member of the
# project. Could be fixed.
# 
if (defined($options{"i"})) {
    usage()
	if (defined($options{"m"}));

    if (defined($options{"p"})) {
	$imagepid = $options{"p"};
	
	if ($imagepid =~ /^([-\w\.\+]+)$/) {
	    $imagepid = $1;
	}
	else {
	    die("*** Bad data in imagepid: $imagepid.\n");
	}
    }
    
    $imagenames = $options{"i"};

    foreach my $imagename (split /,/, $imagenames) {
	
	if ($imagename =~ /^([-\w\.\+]+)$/) {
	    $imagename = $1;
	}
	else {
	    die("*** Bad data in imagename: $imagename.\n");
	}
	
	#
	# If -p option given, use that.
	# If in experiment mode, then use the pid of the experiment, unless
	# a -p option was given.
	# Otherwise look in the system project.
	#
	my $imageid;
	if (defined($imagepid)) {
	    $imageid = TBImageID($imagepid, $imagename);
	}
	if (! $imageid && defined($pid)) {
	    $imageid = TBImageID($pid, $imagename);
	}
	if (! $imageid) {
	    $imageid = TBImageID(TB_OPSPID(), $imagename);
	}
	if (! $imageid) {
	    die("*** $0:\n".
		"	 No such image $imagename!\n");
	}
	push @imageids, $imageid;
    }
}

#
# Or an internal imageID. Sometimes easier.
# 
if (defined($options{"m"})) {
    usage()
	if (defined($options{"i"}));

    foreach my $imageid (split /,/, $options{"m"}) {

	if ($imageid =~ /^([-\w\.\+]+)$/) {
	    $imageid = $1;
	}
	else {
	    die("*** Bad data in imageid: $imageid\n");
	}

	push @imageids, $imageid;
    }
}

#
# Weed out non-imageable nodes (e.g., virtnodes, emotes, etc.)
#
my $first = 1;
my @temp = ();
foreach my $node ( @nodes ) {
    my $nodeid = $node->node_id();
    if ($node->isvirtnode()) {
	#
	# Some virtnodes can be reloaded, IF their virthost is running an OS
	# that supports subimages, and if the new child OS can run on the
	# current virthost OS.
	#
	my $parent = $node->GetPhysHost();
	my $failed = 0;
	if (defined($parent)) {
	    my ($def_boot_osid,undef,undef) = $parent->GetOsids();
            my $posinfo = OSinfo->Lookup($def_boot_osid);
            if (defined($posinfo) && $posinfo->FeatureSupported("suboses")) {
                foreach my $imageid (@imageids) {
		    my $image = Image->Lookup($imageid);
		    my $osinfo = OSinfo->Lookup($image->default_osid());
		    if (!$osinfo->IsSubOS()) {
			print "*** reload($nodeid): $osinfo is not a subOS and thus cannot run on a virtnode, skipping!\n";
			$failed = 1;
		    }
		    elsif (!$osinfo->RunsOnParent($posinfo)) {
			print "*** reload($nodeid): subOS $osinfo cannot run on parent node $parent running $posinfo, skipping!\n";
			$failed = 1;
		    }
                }
            }
            else {
                print "*** reload ($nodeid): parent os $posinfo on $parent does not support suboses, skipping!\n";
                $failed = 1;
            }
        }
        else {
	    print "*** reload ($nodeid): could not find parent phys host!\n";
	    $failed = 1;
        }

        if ($failed) {
	    $first = 0;
	    next;
        }
    }
    elsif (!$node->imageable()) {
	#
	# Common mistake: forget the -i before the imagename, e.g.,
	# "os_load FBSD54-STD pcNN", which results in pcNN getting loaded
	# with the default image.  So if the first arg fails as a node, but
	# is an image ID, assume they have made this mistake and stop.
	#
	my $_pid = defined($imagepid) ? $imagepid : TB_OPSPID();
	if ($first && !defined($imagenames) && TBImageID($_pid, $nodeid)) {
	    print "*** reload: forgot the -i before image name $nodeid?\n";
	    exit(1);
	}
	print "*** reload ($nodeid): cannot image node, skipped.\n";
	$first = 0;
	next;
    }
    push(@temp, $node);
    $first = 0;
}
@nodes = @temp;
if (! @nodes) {
    print "*** reload: No nodes to load. Exiting.\n";
    exit(0);
}

#
# Okay, call into the library using a hash of arguments. Pass a reference
# to the args array, and to a return parameter for the list of failed nodes.
#
# NB: Permission checking is done in the library. Maybe that is wrong?
#
my %osloadargs  = ();
my %failednodes = ();

$osloadargs{'debug'}    = $debug;
$osloadargs{'waitmode'} = $waitmode;
$osloadargs{'noreboot'} = $noreboot;
$osloadargs{'zerofree'} = $zerofree;
$osloadargs{'prepare'}  = $prepare;
$osloadargs{'nodelist'} = [ map { $_->node_id() } @nodes ];
# No imageid means to load the default image.
$osloadargs{'imageids'} = [ @imageids ]
    if (@imageids);
$osloadargs{'swapinfo'} = 1;
$osloadargs{'usecurrent'} = $usecurrent;

my $user = User->ThisUser();
if (EmulabFeatures->FeatureEnabled("NewOsload",$user,undef,$experiment)) {
    require libosload_new;
    my $loadobj = libosload_new->New();
    $loadobj->debug($debug);
    #
    # XXX basically, tell devices that try not to reload (like switches)
    # that they really need to do it -- if the user or reload daemon actually
    # invokes this script, we *have* to reload!
    #
    $osloadargs{'force'} = $force;
    #
    # XXX basically, tell devices that might be reconfig'd via push from us
    # (like switches) that a reconfig should follow the reload!
    #
    $osloadargs{'reconfig'} = $reconfig;

    exit($loadobj->osload(\%osloadargs, \%failednodes));
}

exit(osload(\%osloadargs, \%failednodes));

# Print a listing of imageids.
sub dolisting() {
    my($query_result);

    if ($UID && !TBAdmin($UID)) {
	my ($me) = getpwuid($UID);
	$query_result =
	    DBQueryFatal("select distinct i.* from images as i ".
			 "left join group_membership as g on g.pid=i.pid ".
			 "where g.uid='$me' or i.global ".
			 "order by i.pid,i.imageid");
    } else {
	$query_result =
	    DBQueryFatal("SELECT * FROM images order by imageid");
    }

    if ($query_result->numrows) {
	printf "%-12s %-20s %s\n", "Pid", "Imagename", "Description";
	printf "------------ -------------------- -------------------------\n";

	for ($i = 0; $i < $query_result->numrows; $i++) {
	    my %row  = $query_result->fetchhash();
	    my $id   = $row{'imageid'};
	    my $pid  = $row{'pid'};
	    my $name = $row{'imagename'};
	    my $desc = $row{'description'};

	    printf "%-12s %-20s %s\n", $pid, $name, $desc;
	}
    }
}
