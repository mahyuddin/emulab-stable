#!/usr/bin/perl -wT
use English;
use Getopt::Std;

#
# XXX boss.emulab.net and users.emulab.net wired in. 
#     wd0 wired in. Should come from node_types table in DB
# 

#
# Load an image onto a disk. The image must be in the DB images table,
# which defines how/where to load, and what partitions are affected.
# The nodes and partitions tables are updated appropriately. 
# 
sub usage()
{
    print STDOUT
	"Usage: os_load [-s] [[-p <pid>] -i <imagename>] [-m <imageid>] ".
        "<node> [node ...]\n".
	"       os_load [-s] [[-p <pid>] -i <imagename>] [-m <imageid>] ".
        "-e pid,eid\n".
	"       os_load -l\n".
	"Use -i to specify an image name. Use node default otherwise.\n".
	"Use -m to specify an image ID (internal name, TB admins only!).\n".
	"Use -s to start reload, but do not wait for it to complete.\n".
	"Use -e to reload all the nodes in an experiment.\n" .
        "Use -l to get a list of images you are permitted to load.\n";
    exit(-1);
}
my  $optlist = "sldrni:e:p:m:b";

#
# Configure variables
#
my $TB		= "@prefix@";
my $TESTMODE    = @TESTMODE@;
my $TBOPS       = "@TBOPSEMAIL@";
my $BOSSADDR	= "@BOSSNODE@";
my $USERADDR	= "@USERNODE@";

#
# Max number of simultaneous loads. Will be better with Frisbee.
# 
my $MAXLOADS	= 2;

#
# Max number of retries (per node) before its deemed fatal. This allows
# for the occasional pxeboot failure.
#
my $MAXRETRIES  = 1;

#
# Load the Testbed support stuff. 
#
use lib "@prefix@/lib";
use libdb;
use libtestbed;

my $NETDISKOSID = "NETDISK-STD";
my $FRISBEEPATH = "$BOSSADDR:/tftpboot/pxeboot.frisbee";
my $FRISBEELAUNCHER = "$TB/sbin/frisbeelauncher";
my $nodereboot	= "$TB/bin/node_reboot";
my $schedreload	= "$TB/bin/sched_reload";
my $ping	= "/sbin/ping";
my $dbg		= 0;
my @row;
my $usedefault  = 1;
my $imagename;
my $imageid;
my $imagepid    = TB_OPSPID;
my %imageid_row;
my @nodes       = ();
my %retries	= ();
my $mereuser    = 0;
my $waitmode    = 1;
my $failures    = 0;
my $startwait   = 0;
my $type	= TB_DEFAULT_RELOADTYPE;
my $cmdline     = "";

# un-taint path
$ENV{'PATH'} = '/bin:/usr/bin:/usr/local/bin';
delete @ENV{'IFS', 'CDPATH', 'ENV', 'BASH_ENV'};

$| = 1; #Turn off line buffering on output

#
# Parse command arguments. Once we return from getopts, all that should be
# left are the required arguments.
#
%options = ();
if (! getopts($optlist, \%options)) {
    usage();
}
if (defined($options{"d"})) {
    $dbg++;
}
if (defined($options{"l"})) {
    dolisting();
    exit(0);
}
if (defined($options{"s"})) {
    $waitmode = 0;
}
if (defined($options{"r"})) {
    if (defined($options{"n"})) {
	die "Only one of -r or -n should be given\n";
    }
    $type = TB_RELOADTYPE_FRISBEE;
}
if (defined($options{"n"})) {
    $type = TB_RELOADTYPE_NETDISK;
}

if (defined($options{"i"}) && defined($options{"m"})) {
    usage();
}

if (defined($options{"i"})) {
    $imagename  = $options{"i"};
    $usedefault = 0;

    if ($imagename =~ /^([-\w\.\+]+)$/) {
	$imagename = $1;
    }
    else {
	die("*** Bad data in $imagename.\n");
    }
    if (defined($options{"p"})) {
	$imagepid = $options{"p"};
	
	if ($imagepid =~ /^([-\w\.\+]+)$/) {
	    $imagepid = $1;
	}
	else {
	    die("*** Bad data in $imagepid.\n");
	}
    }
}
if (defined($options{"m"})) {
    $imageid = $options{"m"};
    $usedefault = 0;

    if ($imageid =~ /^([-\w\.\+]+)$/) {
	$imageid = $1;
    }
    else {
	die("*** Bad data in $imageid\n");
    }
}
if (defined($options{"e"})) {
    if (@ARGV) {
	usage();
    }
    my $pideid = $options{"e"};
    
    if ($pideid =~ /([-\w]*),([-\w]*)/) {
	if (! (@nodes = ExpNodes($1, $2))) {
	    die("*** $0:\n".
		"    There are no nodes in $1/$2!\n");
	}
    }
    else {
	die("Invalid argument to -e option: $pideid\n");
	usage();
    }
}
else {
    if (! @ARGV) {
	usage();
    }
    #
    # Untaint nodes.
    #
    foreach my $node ( @ARGV ) {
	if ($node =~ /^([-\@\w]+)$/) {
	    $node = $1;
	}
	else {
	    die("*** Bad node name: $node.\n");
	}
    
	push(@nodes, $node);
    }
}

#
# Figure out who called us. Root and admin types can do whatever they
# want. Normal users can only change nodes in experiments in their
# own projects.
#
if ($UID && !TBAdmin($UID)) {
    $mereuser = 1;

    if (! TBNodeAccessCheck($UID, TB_NODEACCESS_LOADIMAGE, @nodes)) {
	die("*** $0:\n".
            "    You do not have permission to load images on one (or more) ".
	    "nodes!\n");
    }
}

#
# Convert external name to internal (imageid), and check permission.
#
if (defined($imagename)) {
    if (! ($imageid = TBImageID($imagepid, $imagename))) {
	die("*** $0:\n".
	    "    No such image $imagename in project $imagepid!\n");
    }
}

if (defined($imageid) && $mereuser &&
    ! TBImageIDAccessCheck($UID, $imageid, TB_IMAGEID_READINFO)) {
    die("*** $0:\n".
	"    You do not have permission to load this image!\n");
}

#
# Loop for each node.
# 
foreach my $node (@nodes) {
    #
    # Oh, I suppose it would be nice to do this just once per imageid,
    # but that would be a pain. Not in the mood.
    #
    
    #
    # Get default imageid for this node.
    #
    my $default_imageid;
    if (! ($default_imageid = DefaultImageID($node))) {
	die("*** $0:\n".
	    "    No default imageid is defined for $node!\n");
    }
    if ($usedefault) {
	$imageid = $default_imageid;
    }

    print STDERR "Using $imageid for for $node\n" if $dbg;
    
    my $db_result =
	DBQueryFatal("select * from images where imageid='$imageid'");
    
    if ($db_result->numrows < 1) {
	die("*** $0:\n".
	    "    No such imageid $imageid is defined in the DB!\n");
    }
    %imageid_row = $db_result->fetchhash();
    
    my $loadpart  = $imageid_row{'loadpart'};
    my $loadlen   = $imageid_row{'loadlength'};
    my $imagepath = $imageid_row{'path'};
    my $defosid   = $imageid_row{'default_osid'};
    my $shared    = $imageid_row{'shared'};

    #
    # 0 means load the entire disk.
    #
    my $diskpart = "";
    if ($loadpart) {
	$diskpart = "wd0:s${loadpart}";
    }
    else {
	$diskpart = "wd0";
    }

    #
    # For now, all testbed default images come from paper and all pid specific
    # images come from plastic:/proj.
    # 
    if (! $shared) {
	if (! ($imagepath =~ /^\/proj\//)) {
	    die("*** $0:\n".
		"    Your image must reside in /proj\n");
	}
	$cmdline = "${USERADDR}:$imagepath $diskpart";    
    }
    else {
	$cmdline = "${BOSSADDR}:$imagepath $diskpart";
    }
    
    print STDOUT "Changing default OS for $node to $defosid\n";
    if (!$TESTMODE) {
      DBQueryFatal("update nodes set ".
		   "def_boot_osid='$defosid',def_boot_path='' ".
		   "where node_id='$node'");
    }

    # Put it in the current_reloads table so that nodes can find out which
    # OS to load
    DBQueryFatal("replace into current_reloads ".
		 "(node_id, image_id) values ('$node', '$imageid')");

    #
    # If loading an image (which is not the default) then
    # schedule a reload for it so that when the experiment is terminated
    # it will get a fresh default image before getting reallocated to
    # another experiment.
    #
    if ($imageid ne $default_imageid) {
	if (! TBSetSchedReload($node, $default_imageid)) {
	    print "*** $0:\n".
		  "    WARNING: Could not schedule default reload for $node!";
	}
    }

    #
    # Assign partition table entries for each partition in the image.
    # This is complicated by the fact that an image that covers only
    # part of the slices, should only change the partition table entries
    # for the subset of slices that are written to disk.
    #
    my $startpart = $loadpart == 0 ? 1 : $loadpart;
    my $endpart   = $loadpart + $loadlen;
	
    for ($i = $startpart; $i < $endpart; $i++) {
	my $partname = "part${i}_osid";
	
	if (defined($imageid_row{$partname})) {
	    my $osid = $imageid_row{$partname};

	    DBQueryFatal("replace into partitions ".
			 "(partition, osid, node_id) ".
			 "values('$i', '$osid', '$node')");
	}
	else {
	    DBQueryFatal("delete from partitions ".
			 "where node_id='$node' and partition='$i'");
	}
    }
    
    print STDOUT "Setting up reload for $node\n";
    if (!$TESTMODE) {
        SetupReload($node);
    }
}

#
# Exit if not doing about actual reload.
#
if ($TESTMODE) {
    print STDOUT "OS Reload (Setup/Testmode) Done!\n";
    exit 0;
}

#
# Fire off a mass reboot if not in waitmode.
#
if (! $waitmode) {
    system("$nodereboot @nodes");
    $failures = $? >> 8;

    print STDOUT "OS Reload (no waiting) Done!\n";
    exit $failures;
}

#
# Okay, in waitmode we do a couple at a time and wait for them to come
# back alive before proceeding to the next one.
#
# The retry vector is initialized to the number of retries we allow per
# node, afterwhich its a fatal error.
#
foreach my $node (@nodes) {
    $retries{$node} = $MAXRETRIES;
}

while (@nodes) {
    my @batch  = ();
    my @failed = ();
    my $i;

    #
    # If doing a netdisk load, only do a few at a time. For frisbee, we do
    # 'em all
    #
    if ($type eq TB_RELOADTYPE_NETDISK) {
	for ($i = 0; $i < $MAXLOADS && @nodes > 0; $i++) {
	    push(@batch, shift(@nodes));
	}
    } elsif ($type eq TB_RELOADTYPE_FRISBEE) {
	@batch = @nodes;
	@nodes = ();
    }
    
    print "Issuing reboot for @batch and then waiting ...\n";

    system("$nodereboot @batch");
    if ($?) {
	print "Reboot failed for (some of) @batch. Quitting!\n";
	exit ($? >> 8);
    }

    #
    # Now wait for them.
    #
    $startwait = time;
    @failed = WaitTillReloadDone(@batch);
    while (@failed) {
	my $node = shift(@failed);

	if ($retries{$node}) {
	    print "*** Trying $node again (resetting/rebooting) ...\n";
	    push(@nodes, $node);

	    # Possible race with reboot?
	    SetupReload($node);

	    # Retry until count hits zero.
	    $retries{$node} -= 1;
	}
	else {
	    print "*** $node failed too many times. Skipping!\n";
	    $failures++;
	}
    }
}

print "OS Reload Done! There were $failures failures!\n";
exit($failures);

#
# Wait for a reload to finish. We do this in a rather kludgey manner,
# by waiting for bootinfo to clear the DB state (next_boot_osid).
# 
sub WaitTillReloadDone {
    my (@nodes) = @_;
    my %done	= ();
    my $count   = @nodes;
    my @failed  = ();

    #
    # Seems like a long time to wait, but it ain't!
    # 
    my $maxwait = (60 * 10);

    foreach my $node ( @nodes ) {
	$done{$node}  = 0;
    }

    print STDERR "Waiting for @nodes to finish reloading\n" if $dbg;

    #
    # Start a counter going, relative to the time we rebooted the first
    # node. 
    # 
    my $waittime  = 0;
    my $minutes   = 0;

    while ($count) {
	foreach my $node ( @nodes ) {
	    if (! $done{$node}) {
		my ($query_result, @row);

		if ($type eq TB_RELOADTYPE_FRISBEE) {
		    $query_result =
			DBQueryFatal("SELECT next_pxe_boot_path FROM nodes ".
				     "where node_id='$node'");
		}
		else {
		    $query_result =
			DBQueryFatal("SELECT next_boot_osid FROM nodes ".
				     "where node_id='$node'");
		}

		@row = $query_result->fetchrow_array();
		if (! $row[0]) {
		    print STDERR "$node alive and well\n" if $dbg;
		    $count--;
		    $done{$node} = 1;
		    next;
		}
	
		$waittime = time - $startwait;
		if ($waittime > $maxwait) {
		    my $t = (int ($waittime / 60));
		    
		    print "*** $node appears wedged; ".
			"its been $t minutes since it was rebooted.\n";

		    $count--;
		    $done{$node} = 1;
		    push(@failed, $node);
		    next;
		}
		if (int($waittime / 60) > $minutes) {
		    $minutes = int($waittime / 60);
		    print "Still waiting for $node - ".
			"its been $minutes minute(s)\n";
		}
	    }
	}
	sleep(5);
    }
    return @failed;
}

#
# Setup a reload. Note that type, imageid, and cmdline are global.
#
sub SetupReload($)
{
    my ($node) = @_;

    if ($type eq TB_RELOADTYPE_FRISBEE) {
	DBQueryFatal("update nodes set ".
		     "next_pxe_boot_path='$FRISBEEPATH'" .
		     "where node_id='$node'");
	
	system "$FRISBEELAUNCHER $imageid" and
	    die "*** Unable to launch frisbee daemon\n";
    }
    elsif ($type eq TB_RELOADTYPE_NETDISK) {
	DBQueryFatal("update nodes set ".
		     "next_boot_osid='$NETDISKOSID',".
		     "next_boot_cmd_line='$cmdline' ".
		     "where node_id='$node'");
    }
    else {
	die "*** Unknown reload type ($type)\n";
    }
}

#
# Print a listing of imageids.
#
sub dolisting()
{
    my($query_result);
    
    if ($UID && !TBAdmin($UID)) {
	my ($me) = getpwuid($UID);
	
	$query_result =
	    DBQueryFatal("select distinct i.* from images as i ".
			 "left join group_membership as g on g.pid=i.pid ".
			 "where g.uid='$me' or i.shared ".
			 "order by i.pid,i.imageid");
    }
    else {
	$query_result =
	    DBQueryFatal("SELECT * FROM images order by imageid");
    }
    
    for ($i = 0; $i < $query_result->numrows; $i++) {
	my %row  = $query_result->fetchhash();
	my $id   = $row{'imageid'};
	my $desc = $row{'description'};

	printf "%-20s %s\n", $id, $desc;
    }
}
