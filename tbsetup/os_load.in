#!/usr/bin/perl -wT
use English;
use Getopt::Std;
   
#
# XXX boss.emulab.net and users.emulab.net wired in. 
#     wd0 wired in. Should come from node_types table in DB
# 

#
# Load an image onto a disk. The image must be in the DB images table,
# which defines how/where to load, and what partitions are affected.
# The nodes and partitions tables are updated appropriately. 
# 
# usage: os_load [-s] <imageid> <node> [node ...]
# usage: os_load -l
#
sub usage()
{
    print STDOUT "Usage: os_load [-sw] [-f] <imageid> <node> [node ...]\n".
	"Use -s to setup reload only, but do not issue a reboot\n".
	"Use -w to block waiting for nodes to finish reloading\n".
	"    (-s and -w are mutually exclusive)\n".
	"Use -l to get a list of images you are permitted to load\n" .
	"Use -f to use (highly experimental) frisbee support instead of netdisk\n";
    exit(-1);
}
my  $optlist = "sldwf";

#
# Configure variables
#
my $TB		= "@prefix@";
my $TESTMODE    = @TESTMODE@;
my $TBOPS       = "@TBOPSEMAIL@";

#
# Max number of simultaneous loads. Will be better with Frisbee.
# 
my $MAXLOADS	= 2;

#
# Load the Testbed support stuff. 
#
use lib "@prefix@/lib";
use libdb;
use libtestbed;

my $BOSSADDR	= "boss.emulab.net";
my $USERADDR	= "users.emulab.net";
my $NETDISKOSID = "NETDISK-STD";
my $FRISBEEPATH = "boss.emulab.net:/tftpboot/pxeboot.frisbee";
my $nodereboot	= "$TB/bin/node_reboot";
my $ping	= "/sbin/ping";
my $dbg		= 0;
my @row;
my %imageid_row = ();
my @nodes       = ();
my $mereuser    = 0;
my $setuponly   = 0;
my $waitmode    = 0;
my $failures    = 0;
my $startwait   = 0;
my $frisbee     = 0;

# un-taint path
$ENV{'PATH'} = '/bin:/usr/bin:/usr/local/bin';
delete @ENV{'IFS', 'CDPATH', 'ENV', 'BASH_ENV'};

$| = 1; #Turn off line buffering on output

#
# Parse command arguments. Once we return from getopts, all that should be
# left are the required arguments.
#
%options = ();
if (! getopts($optlist, \%options)) {
    usage();
}
if (defined($options{"l"})) {
    dolisting();
    exit(0);
}
if (@ARGV < 2) {
    usage();
}
if (defined($options{"s"})) {
    $setuponly = 1;
}
if (defined($options{"w"})) {
    $waitmode = 1;
}
if (defined($options{"f"})) {
    $frisbee = 1;
}
if ($waitmode && $setuponly) {
    usage();
}
my $imageid = shift;

#
# Untaint args.
#
if ($imageid =~ /^([-\@\w.\+]+)$/) {
    $imageid = $1;
}
else {
    die("Bad data in $imageid.");
}

foreach my $node ( @ARGV ) {
    if ($node =~ /^([-\@\w]+)$/) {
	$node = $1;
    }
    else {
	die("Bad node name: $node.");
    }
    
    push(@nodes, $node);
}

#
# Figure out who called us. Root and admin types can do whatever they
# want. Normal users can only change nodes in experiments in their
# own projects.
#
if ($UID && !TBAdmin($UID)) {
    $mereuser = 1;
}

#
# Grab the imageid description from the DB. The permission check for this
# is that mere user can load an image from any project he/she is a member of,
# or any image that has a null pid field, since those are defined to be
# open to anyone. 
#
$db_result = DBQueryFatal("select * from images where imageid='$imageid'");
    
if ($db_result->numrows < 1) {
    die("No such imageid $imageid!");
}
%imageid_row = $db_result->fetchhash();

my $imagepid = 0;
if (defined($imageid_row{'pid'})) {
    $imagepid = $imageid_row{'pid'};
}
    
if ($mereuser && $imagepid && !ProjMember($imagepid)) {
    die("You do not have permission to load imageid $imageid!");
}

#
# Check to make sure that mere user is allowed to muck with nodes
#
if ($mereuser) {
    foreach my $node (@nodes) {
	if (! NodeAccessCheck(\$node)) {
	    die("You do not have permission to load images on $node\n");
	}
    }
}

my $loadpart  = $imageid_row{'loadpart'};
my $loadlen   = $imageid_row{'loadlength'};
my $imagepath = $imageid_row{'path'};
my $defosid   = $imageid_row{'default_osid'};

#
# 0 means load the entire disk.
#
my $diskpart = "";
if ($loadpart) {
    $diskpart = "wd0:s${loadpart}";
}
else {
    $diskpart = "wd0";
}

#
# For now, all testbed default images from from paper and all pid specific
# images come from plastic:/proj.
# 
my $cmdline = "";
if ($imagepid) {
    if (! ($imagepath =~ /^\/proj\//)) {
	die("Your image must reside in /proj\n");
    }
    $cmdline = "${USERADDR}:$imagepath $diskpart";    
}
else {
    $cmdline = "${BOSSADDR}:$imagepath $diskpart";
}

#
# Loop for each node.
# 
foreach my $node (@nodes) {
    my $pc = $node;
	
    print STDOUT "Changing default OS for $pc to $defosid\n";
    if (!$TESTMODE) {
      DBQueryFatal("update nodes set ".
		   "def_boot_osid='$defosid',def_boot_path='' ".
		   "where node_id='$pc'");
    }

    #
    # Assign partition table entries for each partition in the image.
    # This is complicated by the fact that an image that covers only
    # part of the slices, should only change the partition table entries
    # for the subset of slices that are written to disk. In reality, this
    # is silly since there is no telling what the disk is going to end
    # up looking like after a partial image is written, especially if its
    # a user generated image. Not sure how to handle this yet. For now
    # lets just say that a user defined images essentially wipe the disk
    # except for the stuff they write. 
    #
    for ($i = 1; $i <= 4; $i++) {
	my $partname = "part${i}_osid";
	
	if (defined($imageid_row{$partname})) {
	    my $osid = $imageid_row{$partname};

	    DBQueryFatal("replace into partitions ".
			 "(partition, osid, node_id) ".
			 "values('$i', '$osid', '$pc')");
	}
	else {
	    DBQueryFatal("delete from partitions ".
			 "where node_id='$pc' and partition='$i'");
	}
    }
    
    print STDOUT "Setting up reload for $pc\n";
    if (!$TESTMODE) {
         if ($frisbee) {
	     DBQueryFatal("update nodes set ".
	                  "next_pxe_boot_path='$FRISBEEPATH'" .
	 		  "where node_id='$pc'");
			  # XXX: Need to pass image somehow

	 } else {
	     DBQueryFatal("update nodes set ".
	                  "next_boot_osid='$NETDISKOSID',".
	 		  "next_boot_cmd_line='$cmdline' ".
	 		  "where node_id='$pc'");
	}
    }
}

#
# Exit if not doing about actual reload.
#
if ($setuponly || $TESTMODE) {
    print STDOUT "OS Reload (Setup/Testmode) Done!\n";
    exit 0;
}

#
# Fire off a mass reboot if not in waitmode.
#
if (! $waitmode) {
    system("$nodereboot @nodes");
    $failures = $? >> 8;

    print STDOUT "OS Reload (no waiting) Done!\n";
    exit $failures;
}

#
# Okay, in waitmode we do a couple at a time and wait for them to come
# back alive before proceeding to the next one.
#
while (@nodes) {
    my @batch = ();
    my $i;

    for ($i = 0; $i < $MAXLOADS && @nodes > 0; $i++) {
	push(@batch, shift(@nodes));
    }
    
    print "Issuing reload/reboot for @batch and then waiting ...\n";

    system("$nodereboot @batch");
    $failures = $? >> 8;
    if ($failures) {
	print "Reboot failed for (some of) @batch. Quitting!\n";
	exit $failures;
    }

    #
    # Now wait for them.
    #
    $startwait = time;
    foreach my $node (@batch) {
	if (WaitTillReloadDone($node) == 0) {
	    print "$node appears have reloaded okay.\n";
	    next;
	}

	print "$node may be down.\n".
	      "Please contact $TBOPS for assistance.\n";
    }
}

#
# Print a listing of imageids.
#
sub dolisting()
{
    my($query_result);
    
    if ($UID && !TBAdmin($UID)) {
	my ($me) = getpwuid($UID);
	
	$query_result =
	    DBQueryFatal("select distinct i.* from images as i ".
			 "left join proj_memb as p on ".
			 " i.pid IS NULL or p.pid=i.pid ".
			 "where p.uid='$me' order by i.pid,o.imageid");
    }
    else {
	$query_result =
	    DBQueryFatal("SELECT * FROM images order by imageid");
    }
    
    for ($i = 0; $i < $query_result->numrows; $i++) {
	my %row  = $query_result->fetchhash();
	my $id   = $row{'imageid'};
	my $desc = $row{'description'};

	printf "%-20s %s\n", $id, $desc;
    }
}

#
# Wait for a reload to finish. We do this in a rather kludgey manner,
# by waiting for bootinfo to clear the DB state (next_boot_osid).
# 
sub WaitTillReloadDone {
    my ($pc) = @_;

    print STDERR "Waiting for $pc to finish reloading\n" if $dbg;
    
    #
    # Seven minutes seems like a long time to wait, but it ain't!
    # 
    my $maxwait = (60 * 7);

    #
    # Start a counter going, relative to the time we rebooted the first
    # node. 
    # 
    my $waittime  = 0;
    my $minutes   = 0;

    while (1) {
	my ($query_result, @row);

	if ($frisbee) {
	    $query_result =
		DBQueryFatal("SELECT next_pxe_boot_path FROM nodes ".
			     "where node_id='$pc'");
	} else {
	    $query_result =
		DBQueryFatal("SELECT next_boot_osid FROM nodes ".
			     "where node_id='$pc'");
	}

        @row = $query_result->fetchrow_array();
	if (! $row[0]) {
	    print STDERR "$pc alive and well\n" if $dbg;
	    return 0;
	}
	
	$waittime = time - $startwait;
	if ($waittime > $maxwait) {
	    print "$pc appears unresponsive; its been ",
	    (int ($waittime / 60))," minutes since reload started.\n";
	    return 1;
	}
	if (int($waittime / 60) > $minutes) {
	    $minutes = int($waittime / 60);
	    print "Still waiting for $pc - its been $minutes minute(s)\n";
	}
	sleep(5);
    }
}

