#!/usr/bin/perl -wT
#
# EMULAB-COPYRIGHT
# Copyright (c) 2000-2004 University of Utah and the Flux Group.
# All rights reserved.
#
use English;
use Getopt::Std;

#
# Load an image onto a disk. The image must be in the DB images table,
# which defines how/where to load, and what partitions are affected.
# The nodes and partitions tables are updated appropriately.
#
sub usage()
{
    print STDOUT
	"Usage: os_load [-s] [[-p <pid>] -i <imagename>] <node> [node ...]\n".
	"       os_load [-s] [[-p <pid>] -i <imagename>] -e pid,eid\n".
	"       os_load -l\n".
	"Use -i to specify an image name. Use node default otherwise.\n".
	"Use -m to specify an image ID (internal name).\n".
	"Use -s to start reload, but do not wait for it to complete.\n".
	"Use -r to supress rebooting nodes - you'll need to to it yourself\n".
	"Use -e to reload all the nodes in an experiment.\n" .
        "Use -l to get a list of images you are permitted to load.\n";
    exit(-1);
}
my $optlist   = "sldi:e:p:m:r";
my $waitmode  = 1;
my $listonly  = 0;
my $debug     = 0;
my $noreboot  = 0;
my @nodes     = ();
my $imagepid  = TB_OPSPID;	# Default to looking for ID in emulab-ops proj.
my $imagename;
my $imageid;

# Configure variables
my $TB		= "@prefix@";

# Load the Testbed support stuff.
use lib "@prefix@/lib";
use libdb;
use libosload;
use libtestbed;

# Be careful not to exit on transient error
$libdb::DBQUERY_MAXTRIES = 30;

# un-taint path
$ENV{'PATH'} = '/bin:/usr/bin:/usr/local/bin';
delete @ENV{'IFS', 'CDPATH', 'ENV', 'BASH_ENV'};

# Turn off line buffering on output
$| = 1;

#
# Parse command arguments. Once we return from getopts, all that should be
# left are the required arguments.
#
my %options = ();
if (! getopts($optlist, \%options)) {
    usage();
}
$debug = 1
    if (defined($options{"d"}));

# List only mode. No need to do anymore argument processing.
if (defined($options{"l"})) {
    dolisting();
    exit(0);
}

$waitmode = 0
    if (defined($options{"s"}));
$noreboot = 1
    if (defined($options{"r"}));

#
# Image name (user visible name, not the internal ID). User is allowed
# to specify the pid the belongs to, but this is mostly broken cause
# images are stored in proj trees and created via NFS, so not really
# possibly to share images between projects; must be a member of the
# project. Could be fixed.
# 
if (defined($options{"i"})) {
    usage()
	if (defined($options{"m"}));
    
    $imagename = $options{"i"};
    
    if ($imagename =~ /^([-\w\.\+]+)$/) {
	$imagename = $1;
    }
    else {
	die("*** Bad data in imagename: $imagename.\n");
    }

    if (defined($options{"p"})) {
	$imagepid = $options{"p"};
	
	if ($imagepid =~ /^([-\w\.\+]+)$/) {
	    $imagepid = $1;
	}
	else {
	    die("*** Bad data in imagepid: $imagepid.\n");
	}
    }

    # Convert external name to internal.
    if (! ($imageid = TBImageID($imagepid, $imagename))) {
	die("*** $0:\n".
	    "    No such image $imagename in project $imagepid!\n");
    }
}

#
# Or an internal imageID. Sometimes easier.
# 
if (defined($options{"m"})) {
    usage()
	if (defined($options{"i"}));

    $imageid = $options{"m"};
    
    if ($imageid =~ /^([-\w\.\+]+)$/) {
	$imageid = $1;
    }
    else {
	die("*** Bad data in imageid: $imageid\n");
    }
}

#
# Figure out which nodes. Choice of nodes on command line, or all nodes in an
# experiment. To get all free nodes, must use sched_reload. 
# 
if (defined($options{"e"})) {
    usage()
	if (@ARGV);
    
    my $pideid = $options{"e"};

    if ($pideid =~ /([-\w]*),([-\w]*)/) {
	if (! (@nodes = ExpNodes($1, $2))) {
	    die("*** $0:\n".
		"    There are no nodes in $1/$2!\n");
	}
	$imagepid = $1;
    }
    else {
	die("*** $0:\n".
	    "    Invalid argument to -e option: $pideid\n");
	usage();
    }
}
else {
    usage()
	if (! @ARGV);
    
    # Untaint nodes.
    foreach my $node (@ARGV) {
	if ($node =~ /^([-\w]+)$/) {
	    $node = $1;
	}
	else {
	    die("*** Bad node name: $node.\n");
	}
	push(@nodes, $node);
    }
}

# VIRTNODE HACK: Virtual nodes are special. Do not reload! 
my @temp = ();
foreach my $node ( @nodes ) {
    if (TBIsNodeVirtual($node)) {
	print "*** reload ($node): Skipping virtual node.\n";
	next;
    }
    push(@temp, $node);
}
@nodes = @temp;
if (! @nodes) {
    print "*** reload: No nodes to load. Exiting.\n";
    exit(0);
}

#
# Okay, call into the library using a hash of arguments. Pass a reference
# to the args array, and to a return parameter for the list of failed nodes.
#
# NB: Permission checking is done in the library. Maybe that is wrong?
#
my %osloadargs  = ();
my %failednodes = ();

$osloadargs{'debug'}    = $debug;
$osloadargs{'waitmode'} = $waitmode;
$osloadargs{'noreboot'} = $noreboot;
$osloadargs{'nodelist'} = [ @nodes ];
# No imageid means to load the default image.
$osloadargs{'imageid'}  = $imageid
    if (defined($imageid));

exit(osload(\%osloadargs, \%failednodes));

# Print a listing of imageids.
sub dolisting() {
    my($query_result);

    if ($UID && !TBAdmin($UID)) {
	my ($me) = getpwuid($UID);
	$query_result =
	    DBQueryFatal("select distinct i.* from images as i ".
			 "left join group_membership as g on g.pid=i.pid ".
			 "where g.uid='$me' or i.global ".
			 "order by i.pid,i.imageid");
    } else {
	$query_result =
	    DBQueryFatal("SELECT * FROM images order by imageid");
    }

    if ($query_result->numrows) {
	printf "%-12s %-20s %s\n", "Pid", "Imagename", "Description";
	printf "------------ -------------------- -------------------------\n";

	for ($i = 0; $i < $query_result->numrows; $i++) {
	    my %row  = $query_result->fetchhash();
	    my $id   = $row{'imageid'};
	    my $pid  = $row{'pid'};
	    my $name = $row{'imagename'};
	    my $desc = $row{'description'};

	    printf "%-12s %-20s %s\n", $pid, $name, $desc;
	}
    }
}
