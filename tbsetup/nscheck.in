#!/usr/bin/perl -wT

#
# EMULAB-COPYRIGHT
# Copyright (c) 2000-2004 University of Utah and the Flux Group.
# All rights reserved.
#

use English;
use Getopt::Std;

#
# Syntax check an NS file.
#
# usage: nscheck <nsfile>
#
# Exit value is important; 
# $status < 0 - Fatal error. Something went wrong we did not expect.
# $status = 0 - Parsed okay.
# $status > 0 - Parse error. 
#
sub usage()
{
    print STDOUT "Usage: nscheck <nsfile>\n";
    exit(-1);
}
my  $optlist = "";

#
# Function phototype(s)
#
sub fatal($);

#
# Configure variables
#
my $TB       = "@prefix@";
my $parser   = "$TB/libexec/parse-ns";
my $status   = 0;
my $dirname;

#
# Turn off line buffering on output
#
$| = 1;

#
# Untaint the path
# 
$ENV{'PATH'} = "/bin:/usr/bin:/sbin:/usr/sbin";
delete @ENV{'IFS', 'CDPATH', 'ENV', 'BASH_ENV'};

#
# Parse command arguments. Once we return from getopts, all that should
# left are the required arguments.
#
%options = ();
if (! getopts($optlist, \%options)) {
    usage();
}
if (@ARGV != 1) {
    usage();
}
my ($tempfile) = @ARGV;

#
# Untaint the arguments.
#
# Note different taint check (allow /).
if ($tempfile =~ /^([-\w\.\/]+)$/) {
    $tempfile = $1;
}
else {
    fatal("Tainted argument $tempfile");
}

#
# Called from ops interactively. Make sure NS file in /proj or /users.
#
# Use realpath to resolve any symlinks.
#
my $translated = `realpath $tempfile`;
if ($translated =~ /^([-\w\.\/]+)$/) {
    $tempfile = $1;
}
else {
    fatal("Tainted nsfile returned by realpath: $translated\n");
}

#
# The file must reside in /proj, /groups, or /users. Since this script
# runs as the caller, regular file permission checks ensure its a file
# the user is allowed to use. /tmp/$guid-$nsref.nsfile also allowed
# since this script is invoked directly from web interface, which generates
# a name that should not be guessable, so as long as it looks to be in
# proper format, we accept it. 
#
if (! ($tempfile =~ /^\/tmp\/[-\w]+-\d+\.nsfile/) &&
    ! ($tempfile =~ /^\/var\/tmp\/php\w+/) &&
    ! ($tempfile =~ /^\/proj/) &&
    ! ($tempfile =~ /^\/groups/) &&
    ! ($tempfile =~ /^\/users/)) {
    fatal("$tempfile does not resolve to an appropriate directory!\n");
}

$nsfile    = "foo.ns";

# Check for existence of NS file and exit with error such that web
# interface tells the user (positive exit value).
if (! -f $tempfile || ! -r $tempfile || -z $tempfile) {
    print STDERR "*** $0:\n".
	         "    $tempfile does not exist or is not a readable file!\n";
    exit(1);
}

#
# Make a temp dir and copy the NS file into it. We run the scripts
# from that directory cause it writes temp files.
# 
$dirname = "/tmp/parse-$$";

mkdir($dirname, 0775) or
    fatal("Could not mkdir $dirname");

if (system("/bin/cp", "$tempfile", "$dirname/$nsfile")) {
    fatal("Could not copy $tempfile to $dirname");
}

chdir($dirname) or
    fatal("Could not chdir to $dirname");

#
# Run parse in impotent mode on the NS file.  This has no effect but
# will display any errors.
#
# Be sure to exit with >0 staus
#

if (system("$parser -n -a $nsfile") != 0) {
    print "NS Parse failed!\n";
    $status = 1;
}

system("/bin/rm", "-rf", "$dirname");
exit $status;

sub fatal($)
{
    my($mesg) = $_[0];

    system("/bin/rm", "-rf", "$dirname")
	if (defined($dirname));

    die("*** $0:\n".
	"    $mesg\n");
}
