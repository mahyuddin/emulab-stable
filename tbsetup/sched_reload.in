#!/usr/bin/perl -wT
use English;
use Getopt::Std;
   
#
# Schedule the reloading of a disk partition on a node. If the node is
# currently not reserved, start the loading now after reserving it to 
# testbed:reloading. Otherwise, put the right info into the database, and 
# nfree will do it when the node gets freed.
# 
# usage: sched_reload [-f | -p] <imageid> <node> [node ...]
#
sub usage()
{
    print STDOUT "Usage: sched_reload [-f | -p] <imageid> <node> [node ...]\n".
	"Use the -f to force reload. Fail if node cannot be reserved.\n".
	"Use the -p to pend reload for the reload daemon.\n" .
	"Use the -r use Frisbee rather than netdisk (experimental).\n";
    exit(-1);
}
my  $optlist = "fpr";

#
# Configure variables
#
my $TB     = "@prefix@";

#
# Load the Testbed support stuff. 
#
use lib "@prefix@/lib";
use libdb;

#
# These come from the library.
# 
my $RELOADPID	= NODERELOADING_PID;
my $RELOADEID	= NODERELOADING_EID;
my $PENDINGEID	= NODERELOADPENDING_EID;

my $osload      = "$TB/bin/os_load";
my $nalloc      = "$TB/bin/nalloc";
my $name        = "";
my $error       = 0;
my $debug       = 0;
my $force	= 0;
my $pend	= 0;
my $frisbee	= 0;
my @nodes       = ();
my @row;

# un-taint path
$ENV{'PATH'} = '/bin:/usr/bin:/usr/local/bin';
delete @ENV{'IFS', 'CDPATH', 'ENV', 'BASH_ENV'};

$| = 1; #Turn off line buffering on output

#
# Parse command arguments. Once we return from getopts, all that should be
# left are the required arguments.
#
%options = ();
if (! getopts($optlist, \%options)) {
    usage();
}
if (@ARGV < 2) {
    usage();
}
if (defined($options{"f"})) {
    $force = $options{"f"};
}
if (defined($options{"p"})) {
    $pend = $options{"p"};
}
if (defined($options{"r"})) {
    $frisbee = 1;
	$osload .= " -r ";
}
if ($pend and $force) {
    usage();
}
my $imageid   = shift;

#
# Untaint args.
#
if ($imageid =~ /^([-\@\w.\+]+)$/) {
    $imageid = $1;
}
else {
    die("Bad data in $imageid.");
}

foreach my $node ( @ARGV ) {
    if ($node =~ /^([-\@\w]+)$/) {
	$node = $1;
    }
    else {
	die("Bad node name: $node.");
    }
    
    push(@nodes, $node);
}

#
# Root and admin types can do whatever they want.
# Mere users cannot schedule reloads.
#
if ($UID && !TBAdmin($UID)) {
    die("Only root or TB administrators can schedule disk reloads.\n");
}

#
# A loop.
# 
my @load_list=();
foreach my $node (@nodes) {
    my $pc = $node;
    my $allocated = 0;

    $sth = DBQueryFatal("select * from nodes where node_id='$pc'");
    if ($sth->num_rows() != 1) {
      print STDERR "Node $pc doesn't exist. Skipping $pc.\n";
      next;
    }
    
    print STDERR "Checking if $pc is reserved...";
    $sth = DBQueryFatal("select * from reserved where node_id='$pc'");
   
    if ( ($sth->num_rows()) < 1) {
        print STDERR "Available.\nReserving and adding to list.\n";
	my $eid;
	if ($pend) {
	    $eid = $PENDINGEID;
	}
	else {
	    $eid = $RELOADEID;
	}
	my $cmd = "$nalloc $RELOADPID $eid $pc";

        if ( system($cmd) != 0 ) {
	    print STDERR "WARNING: Could not reserve $pc!\n";
	} else {
	    #
	    # Kill the last_reservation so that whoever gets the node next
	    # won't be fooled into thinking a reload is required.
	    #
	    DBQueryFatal("delete from last_reservation where node_id='$pc'");
	    push (@load_list,$pc);
	    $allocated = 1;
	}
    } else {
        print STDERR "Reserved.\n";      
    }

    #
    # If force and not able to reserve, do not pend a reload.
    # 
    if ($force && !$allocated) {
	$error++;
	next;
    }

    # Put it in the reloads table so TMCD knows to free it.
    print STDERR "Scheduling reload of $imageid for $pc:\n";
    DBQueryFatal("replace into reloads ".
		 "(node_id, image_id) values ('$pc', '$imageid')");
}

if ($pend) {
    print STDOUT "Reload Scheduling Done!\n";
    exit $error;
}

if (@load_list > 0) {
  print STDERR "Running os_load on ",join(", ",@load_list),":\n";
  $cmd = "$osload $imageid @load_list";
  print STDERR "Calling '$cmd'\n";
  if ( system($cmd) != 0 ) {
    print STDERR "WARNING: OS_LOAD FAILED ON @load_list!\n";
  }
}

print STDOUT "Reload Scheduling Done!\n";
exit $error;
