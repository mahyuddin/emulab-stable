#!/usr/bin/perl -wT

#
# EMULAB-COPYRIGHT
# Copyright (c) 2000-2004 University of Utah and the Flux Group.
# All rights reserved.
#

use English;
use Getopt::Std;
   
#
# Schedule the reloading of a disk partition on a node. If the node is
# currently not reserved, start the loading now after reserving it to 
# testbed:reloading. Otherwise, put the right info into the database, and 
# nfree will do it when the node gets freed.
# 
sub usage()
{
    print STDOUT "Usage: sched_reload [-f | -n] [-m <imageid>] ".
	         "[[-p <pid>] -i <imagename>] <node> [node ...]\n".
		 "       sched_reload <options> -e pid,eid\n".
		 "       sched_reload <options> -t type [type ...]\n".
		 "       sched_reload <options> -c class\n".
	"Use -i to specify an image name. Use node default otherwise.\n".
	"Use -m to specify an image ID (internal name, TB admins only!).\n".
	"Use -f to force reload. Fail if node cannot be reserved.\n".
	"Use -n to pend reload for the reload daemon.\n".
        "Use -e to schedule a reload for all nodes in an experiment.\n".
        "Use -t to schedule a reload for all nodes of a particular type.\n".
        "Use -c to schedule a reload for all nodes of a particular class.\n";
    exit(-1);
}
my  $optlist = "fnp:i:e:m:tc:";

#
# Configure variables
#
my $TB     = "@prefix@";

#
# Load the Testbed support stuff. 
#
use lib "@prefix@/lib";
use libdb;

#
# These come from the library.
# 
my $RELOADPID	= NODERELOADING_PID;
my $RELOADEID	= NODERELOADING_EID;
my $PENDINGEID	= NODERELOADPENDING_EID;

my $osload      = "$TB/bin/os_load -s";
my $nalloc      = "$TB/bin/nalloc";
my $name        = "";
my $error       = 0;
my $debug       = 0;
my $force	= 0;
my $pend	= 0;
my @nodes       = ();
my $type	= TB_DEFAULT_RELOADTYPE;
my $usedefault  = 1;
my $imagename;
my $imageid;
my $imagepid    = TB_OPSPID;
my %imagenodes  = ();
my @row;
my $eidmode     = 0;
my $typemode    = 0;
my $classmode   = 0;
my @types	= ();
my $class;
my $pid;
my $eid;

# un-taint path
$ENV{'PATH'} = '/bin:/usr/bin:/usr/local/bin';
delete @ENV{'IFS', 'CDPATH', 'ENV', 'BASH_ENV'};

$| = 1; #Turn off line buffering on output

#
# Parse command arguments. Once we return from getopts, all that should be
# left are the required arguments.
#
%options = ();
if (! getopts($optlist, \%options)) {
    usage();
}
if (defined($options{"f"})) {
    $force = 1;
}
if (defined($options{"n"})) {
    $pend = 1;
}
if ($pend and $force) {
    usage();
}
if (defined($options{"i"}) && defined($options{"m"})) {
    usage();
}
if (defined($options{"i"})) {
    $imagename  = $options{"i"};
    $usedefault = 0;

    if ($imagename =~ /^([-\w\.\+]+)$/) {
	$imagename = $1;
    }
    else {
	die("Bad data in $imagename.");
    }
    
    if (defined($options{"p"})) {
	$imagepid = $options{"p"};
	
	if ($imagepid =~ /^([-\w\.\+]+)$/) {
	    $imagepid = $1;
	}
	else {
	    die("*** Bad data in $imagepid.\n");
	}
    }
}
if (defined($options{"m"})) {
    $imageid = $options{"m"};
    $usedefault = 0;

    if ($imageid =~ /^([-\w\.\+]+)$/) {
	$imageid = $1;
    }
    else {
	die("*** Bad data in $imageid\n");
    }
}
if (defined($options{"e"})) {
    if (@ARGV) {
	usage();
    }
    
    $eidmode = $options{"e"};
    if ($eidmode =~ /([-\w]*),([-\w]*)/) {
	$pid = $1;
	$eid = $2;
    }
    else {
	print STDOUT "Invalid argument to -e option: $eidmode\n";
	usage();
    }
}
elsif (defined($options{"t"})) {
    if (!@ARGV) {
	usage();
    }
    
    $typemode = 1;

    #
    # Untaint types,
    #
    foreach my $type ( @ARGV ) {
	if ($type =~ /^([-\w]+)$/) {
	    $type = $1;
	}
	else {
	    die("Bad type name: $type.");
	}
    
	push(@types, $type);
    }
}
elsif (defined($options{"c"})) {
    $classmode = 1;
    $class     = $options{"c"};

    if ($class =~ /^([-\w]+)$/) {
	$class = $1;
    }
    else {
	die("*** Bad data in $class\n");
    }
}
else {
    if (@ARGV < 1) {
	usage();
    }
}

if ($eidmode) {
    if (! (@nodes = ExpNodes($pid, $eid))) {
	die("*** $0:\n".
	    "    There are no nodes allocated to experiment $pid/$eid!");
    }
}
elsif ($typemode) {
    foreach my $type ( @types ) {
	my $query_result =
	    DBQueryFatal("select node_id from nodes ".
			 "where type='$type' and role='testnode'");

	while (my ($node) = $query_result->fetchrow_array()) {
	    push(@nodes, $node);
	}
    }
}
elsif ($classmode) {
    my $query_result =
	    DBQueryFatal("select n.node_id from nodes as n ".
			 "left join node_types as nt on n.type=nt.type ".
			 "where nt.class='$class' and n.role='testnode'");

    while (my ($node) = $query_result->fetchrow_array()) {
	push(@nodes, $node);
    }
}
else {
    #
    # Untaint nodes.
    #
    foreach my $node ( @ARGV ) {
	if ($node =~ /^([-\@\w]+)$/) {
	    $node = $1;
	}
	else {
	    die("Bad node name: $node.");
	}
    
	push(@nodes, $node);
    }
}

#
# VIRTNODE HACK: Virtual nodes are special. Do not reload!
#
my @temp = ();
foreach my $node ( @nodes ) {
    if (TBIsNodeVirtual($node)) {
	print "*** Skipping virtual node $node ...\n";
	next;
    }
    push(@temp, $node);
}
@nodes = @temp;
if (! @nodes) {
    print "No nodes to load. Exiting ...\n";
    exit(0);
}

#
# Root and admin types can do whatever they want.
# Mere users cannot schedule reloads.
#
if ($UID && !TBAdmin($UID)) {
    die("*** $0:\n".
	"     Only root or TB administrators can schedule disk reloads.\n");
}

#
# Confirm a valid imagename if one was specified. Otherwise we are going
# to pull it out of the DB for each node.
#
if (defined($imagename)) {
    if (! ($imageid = TBImageID($imagepid, $imagename))) {
	die("*** $0:\n".
	    "    No such image $imagename in project $imagepid!\n");
    }
}

#
# Loop through each node.
# 
my @load_list=();
foreach my $node (@nodes) {
    my $pc = $node;
    my $allocated = 0;

    $sth = DBQueryFatal("select node_id from nodes where node_id='$pc'");
    if ($sth->num_rows() != 1) {
      print STDERR "Node $pc does not exist. Skipping $pc.\n";
      next;
    }

    #
    # Get default imageid for this node if none specified on comand line.
    #
    if ($usedefault) {
	if (! DefaultImageID($node, \$imageid) || !defined($imageid)) {
	    print STDERR
		"*** Node $pc does not have a default imageid. Skipping!\n";
	    next;
	}
    }
    
    print STDERR "Checking if $pc is reserved...";
    $sth = DBQueryFatal("select node_id from reserved where node_id='$pc'");
   
    if ( ($sth->num_rows()) < 1) {
        print STDERR "Available.\nReserving and adding to list.\n";
	my $eid;
	if ($pend) {
	    $eid = $PENDINGEID;
	}
	else {
	    $eid = $RELOADEID;
	}
	my $cmd = "$nalloc $RELOADPID $eid $pc";

        if ( system($cmd) != 0 ) {
	    print STDERR "WARNING: Could not reserve $pc!\n";
	} else {
	    #
	    # Kill the last_reservation so that whoever gets the node next
	    # won't be fooled into thinking a reload is required.
	    #
	    DBQueryFatal("delete from last_reservation where node_id='$pc'");
	    $allocated = 1;
	}
    } else {
        print STDERR "Reserved.\n";      
    }

    #
    # If force and not able to reserve, do not pend a reload.
    # 
    if ($force && !$allocated) {
	$error++;
	next;
    }

    # Put it in the reloads table so TMCD knows to free it.
    if (! TBSetSchedReload($pc, $imageid, $type)) {
	die("*** $0:\n".
	    "    Could not set scheduled reload for $pc!"); 
    }
    
    #
    # The point of this hash table is so that we can gather up all the
    # nodes per imageid and issue single requests to os_load, so that it
    # can optimize things (say, for Frisbee). It is possible to get multiple
    # imageids when using the node defaults instead of a command line imageid.
    #
    # Note that building up a hashed array of lists is a mighty odd operation
    # in PERL, hence this funny looking code!
    #
    if ($allocated) {
	if (! defined($imagenodes{$imageid})) {
	    $imagenodes{$imageid} = [ $node ];
	}
	else {
	    push(@{ $imagenodes{$imageid} }, $node);
	}
    }
}

if ($pend) {
    print STDOUT "Reload Scheduling Done! There were $error failures!\n";
    exit $error;
}

#
# Now issue the reloads, one per imageid. The hash table we created above
# stores a list of nodes for each imageid.
#
foreach my $id ( keys(%imagenodes) ) {
    my @nodelist = @{ $imagenodes{$imageid} };

    my $cmd = "$osload -m $id @nodelist";

    print "Issuing $cmd\n";
    if (system($cmd)) {
	print STDERR "*** WARNING: Failed $cmd\n";
	$error++;
    }
}

print STDOUT "Reload Scheduling Done! There were $error failures!\n";
exit $error;
