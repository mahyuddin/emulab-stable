#!/usr/bin/perl -w
# This rather ugly programs takes a post-assign IR file and the 
# original ns file and adds the ip and ip-mac sections.  This is 
# necessary because assign has no awareness of the IP layer.

# LIMITATIONS:
#  Assumes at most 1 link between any two nodes. [Fixing this limitations
# would also involved changing the TB cmd syntax]

# Set this to 1 for debugging
$verbose = 0;

# prints output if verbose is
sub printdb {
    if ($verbose) {
	print "DB: $_[0]";
    }
};

# This is the prefix used for assigning otherwise unassigned IP addresses:
$ip_base = "192.168";

#
# Configure variables
#
my $IRLIB  = "@prefix@/lib/ir";
my $DBNAME = "@TBDBNAME@";

push(@INC, $IRLIB);
require libir;

use DBI;
$driver = "mysql";
$dbh = DBI->connect("DBI:$driver:database=$DBNAME;host=localhost") || do {
    print STDERR "Could not connect to DB.\n";
    exit(1);
};

if ($#ARGV != 1) {
    print STDERR "Syntax: $0 irfile tbcmdfile\n";
    exit(1);
}

($irfile,$tbcmdfile) = @ARGV;

# read IR file
eval {&ir_read($irfile)};
if ($@) {
    print STDERR "Could not read $irfile ($@)\n";
    exit(1);
}

# open tbcmd file
open(TBCMD,$tbcmdfile) || do {
    print STDERR "Could not open $tbcmdfile\n";
    exit(1);
};

# Read mac map into vlanmap
# vlanmap is indexed by vlan name and contains a reference
# to a list of MACs.
&ir_exists("/vlan") || do {
    print STDERR "IR does not contain vlan section.\n";
    exit(1);
};
foreach (split("\n",&ir_get("/vlan"))) {
    @vlan = split;
    $vlanmap{$vlan[0]} = [@vlan[1..$#vlan]];
}

# Read in node map into vnodemap and rvnodemap (reverse)
# vnodemap is indexed by virtual and contains the physical name
# rvnodemap is indexed by physical name and contains the virtual name.
&ir_exists("/virtual/nodes") || do {
    print STDERR "IR does not contain virtual/nodes section.\n";
    exit(1);
};
foreach (split("\n",&ir_get("/virtual/nodes"))) {
    ($virtual,$physical) = split;
    $vnodemap{$virtual} = $physical;
    $rvnodemap{$physical} = $virtual;
}

# Read in nodes
&ir_exists("/topology/nodes") || do {
    print STDERR "IR does not contain topology/nodes section.\n";
    exit(1);
};
foreach (split("\n",&ir_get("/topology/nodes"))) {
    @t = split;
    ($node,$type) = @t;
    $nodetypes{$node} = $type;
}

# Read in the links
&ir_exists("/topology/links") || do {
    print STDERR "IR does not contain topology/links section.\n";
    exit(1);
};
foreach (split("\n",&ir_get("/topology/links"))) {
    @t = split;
    ($link,$src,$dst) = @t[0,1,3];
    $links{$link} = [$src,$dst];
}

# Get a list of delays
#&ir_exists("/delay") || do {
#    print STDERR "IR does not contain delay section.\n";
#    exit(1);
#};
#foreach (split("\n",&ir_get("/delay"))) {
#    @t = split;
#    $delays{$t[0]} = 1;
#}

# Pull the MAC table from the database.
# MACTABLE is indexed by virtual node name and contains a reference
# to a list of MACs.
$sth = $dbh->prepare("SELECT node_id,MAC from interfaces");
$sth->execute || do {
    print STDERR "Could not get MAC table from DB.\n";
    exit(1);
};
while (@row = $sth->fetchrow_array) {
    ($node,$mac) = @row;
    if (defined($rvnodemap{$node})) {
	if (! defined($MACTABLE{$rvnodemap{$node}})) {
	    $MACTABLE{$rvnodemap{$node}} = [];
	}
	push(@{$MACTABLE{$rvnodemap{$node}}},$mac);
    }
}
$sth->finish;

# Get an idea of what LANs there are
&ir_exists("/topology/lans") || do {
    print STDERR "IR does not contain topology/lans section.\n";
    exit(1);
};
foreach (split("\n",&ir_get("/topology/lans"))) {
    printdb("$_\n");
    ($lan,$nodesraw,$linksraw) = /^([^ ]+) "([^\"]+)" [^ ]+ [^ ]+ [^ ]+(?: )?(.*)$/;
    printdb("lan='$lan' nodes='$nodesraw' links='$linksraw'\n");
    my(@nodes) = split(" ",$nodesraw);
    $lans{$lan} = [$lan,\@nodes];
    # Check for sharkshelf
    if ($nodetypes{$nodes[0]} eq "shark") {
	# We need to fill in the MACs for the vlan map for this lan
	# since there is no actual VLAN for it.
	$vlanmap{$lan} = [];
	foreach $shark (@nodes) {
	    push(@{$vlanmap{$lan}},@{$MACTABLE{$shark}});
	}
	# Linksraw only has a single link otherwise assign_wrapper would have
	# generated an error.
	($src,$dst) = @{$links{$linksraw}};
	if ($src eq $lan) {
	    $other = $dst;
	} else {
	    $other = $src;
	}
	push(@{$vlanmap{$lan}},@{$MACTABLE{$other}});
    }
}

# This is a list of error messages
@ERRORS = ();

# Read NS file
# IP is indexed either by src or by src:dst and contains the IP address.
while (<TBCMD>) {
    chop;
    @line = split;
    $_ = $line[0];
  SWITCH1: {
      /^tb-set-ip$/ && do {
	  # tb-set-ip <node> <ip>
	  if ($#line != 2) {
	      push(@ERRORS,"Syntax: tb-set-ip node ip\n");
	      last SWITCH1;
	  } 
	  ($node,$ip) = @line[1..2];
	  if (!defined($vnodemap{$node})) {
	      push(@ERRORS,"$node is not a valid node.\n");
	      last SWITCH1;
	  }
	  # This actually matches a valid IP address
	  if (! ($ip =~ /^([0-9]{1,3}\.){3,3}[0-9]{1,3}$/)) {
	      push(@ERRORS,"$ip is not a valid ip address.\n");
	      last SWITCH1;
	  }
	  $IP{$node} = $ip;
	  last SWITCH1;
      };
      /^tb-set-ip-interface$/ && do {
	  push(@ERRORS,"tb-set-ip-interface should have been converted to tb-set-ip-link.  Check for newest version of tb_compat.tcl");
	  last SWITCH1;
      };
      /^tb-set-ip-link$/ && do {
	  # tb-set-ip-link <node> <link> <ip>
	  if ($#line != 3) {
	      push(@ERRORS,"Syntax: tb-set-ip-link node link ip\n");
	      last SWITCH1;
	  } 
	  ($node,$link,$ip) = @line[1..3];
	  if (! defined($vnodemap{$node})) {
	      push(@ERRORS,"$node is not a valid node.\n");
	      last SWITCH1;
	  }
	  if (! defined($links{$link})) {
	      push(@ERRORS,"$link is not a valid link.\n");
	      last SWITCH1;
	  } 
	  if (! ($ip =~ /^([0-9]{1,3}\.){3,3}[0-9]{1,3}$/)) {
	      push(@ERRORS,"$ip is not a valid ip address.\n");
	      last SWITCH1;
	  }
	  $IP{"$node:$link"} = $ip;
	  last SWITCH1;
      };
      /^tb-set-ip-lan$/ && do {
	  # tb-set-ip-lan <node> <lan> <ip>
	  if ($#line != 3) {
	      push(@ERRORS,"Syntax: tb-set-ip-lan node lan ip\n");
	      last SWITCH1;
	  } 
	  ($node,$lan,$ip) = @line[1..3];
	  if (! defined($vnodemap{$node})) {
	      push(@ERRORS,"$node is not a valid node.\n");
	      last SWITCH1;
	  }
	  if (! defined($lans{$lan})) {
	      push(@ERRORS,"$lan is not a valid lan.\n");
	      last SWITCH1;
	  } 
	  if (! ($ip =~ /^([0-9]{1,3}\.){3,3}[0-9]{1,3}$/)) {
	      push(@ERRORS,"$ip is not a valid ip address.\n");
	      last SWITCH1;
	  }
	  $IPLAN{"$node:$lan"} = $ip;
	  last SWITCH1;
      };
  }
}

close(TBCMD);


# At this point we have most of the data we need.  We now loop through all
# the virtual links (/topology/links) assigning them IP addresses.  This is 
# done in two phases.  The first phase uses the TB commands to assign
# IP addresses.  In the second phase all remaining links are assigned
# IP addresses.

# There are two IP addresses associated with each link.  Since each link
# is uniquely defined by it's src and dst we can denote each end of the
# link by src->dst vs. dst->src.

# We store the ir contents in ip_section.
$ip_section = '';

# ip_mac_section is actually an array since we need to add this to the
# DB.  It's values are references to lists of [mac,ip]
@ip_mac_section = ();

# ips_assigned keeps track of which slots we've filled.  It's indexed by
# src:dst indicating that the IP at src going to dst is filled.

# ips_node is indexed by node and keeps track of all the IPs currently
# assigned by a node. This is needed for proper subnetting.  The contents
# is a reference to a list.

# single_node is used to catch trying to use the set-ip cmd on nodes
# with multiple links.  It's basically a counter for how much set-ips
# are done on a node.

# to_assign is filled out with what slots remain to be assigned.  It's
# indexed by link and contains a reference to a list [src,dst,flag] where 
# if flag is 0 it indicates the slot src->dst and if flag is one it 
# indicates that both src->dst and dst->src need to be filled.

# lansubnet holds the subnet for a LAN.

# intersect - intersection of two lists.  Takes two list references
# and returns a single element.
# We assume that the intersection is of size 1 for optimization.
sub intersect {
    local($Aref,$Bref) = @_;
    local($A,$B);
    foreach $A (@$Aref) {
	foreach $B (@$Bref) {
	    if ($A eq $B) {
		return $A;
	    }
	}
    }
    return "";
};

# islan - Just returns 1 if the passed node is a lan
sub islan {
    return defined($lans{$_[0]});
};

# get_macs link - Returns all MAC addresses associated with a link.  Because
# a link can pass through a delay node this may be more than two.  Returns
# an array.
sub get_macs {
    local($macs)=[];
    if (defined($vlanmap{$_[0]})) {
	push(@$macs,@{$vlanmap{$_[0]}});
    }
    if (defined($vlanmap{"dsrc_$_[0]"})) {
	push(@$macs,@{$vlanmap{"dsrc_$_[0]"}});
    } 
    if (defined($vlanmap{"ddst_$_[0]"})) {
	push(@$macs,@{$vlanmap{"ddst_$_[0]"}});
    }
    # XXX - Not sure if this is correct
	# XXX - ricci: still not sure if it is! The old code checked to make sure
	# that one of the nodes was a delay node - I'm not sure why this was desirable,
	# but it broke things

    if (defined($links{$_[0]})) {
  	my($src,$dst) = @{$links{$_[0]}};
  	if (&islan($src)) {
  	    push(@$macs,@{$vlanmap{$src}});
  	} elsif (&islan($dst)) {
  	    push(@$macs,@{$vlanmap{$dst}});
  	}
    }

    return $macs;
};

# Phase 1
foreach $link (keys(%links)) {
    ($src,$dst) = @{$links{$link}};

    printdb "Looking at $link ($src <-> $dst)\n";
    if (&islan($src) && &islan($dst)) {
	printdb "Skipping LAN link\n";
	next; # skip lan links
    }
   
    # We need to do two iterations, (A=src, B=dst) and (A=dst, B=src)
    $A = $src; $B = $dst;
    foreach (1..2) {
	printdb "A=$src B=$dst\n";
	# skip where A is a lan
	if (&islan($A)) {
	    $tmp = $A;
	    $A = $B;
	    $B = $tmp;
	    next;
	}
	# Look for assigned ip
	if (defined($IP{"$A:$link"})) {
	    printdb "Defined link IP " . $IP{"$A:$link"} . "\n";
	    if (&islan($B)) {
		$lansubnet{$B} = &get_subnet($IP{"$A:$link"});
		printdb "lansubnet{$B} = $lansubnet{$B}\n";
	    }
	    $ip_section .= "$A $B $IP{$A . ':' . $link}\n";
	    printdb "ip_section .= \"$A $B " . $IP{"$A:$link"} . "\n";
	    push(@ip_mac_section, 
		 [&intersect($MACTABLE{$A},&get_macs($link)),$IP{"$A:$link"}]);
	    printdb "ip_mac_section <- [" . join(",",&intersect($MACTABLE{$A},&get_macs($link))) . "," . $IP{"$A:$link"} . "]\n";
	    $ips_assigned{$IP{"$A:$link"}} = 1;
	    if (!defined($ips_node{$A})) {
		$ips_node{$A} = [];
	    }
	    push(@{$ips_node{$A}},$IP{"$A:$link"});
	} elsif (defined($IP{$A})) {
	    printdb "Node IP address $IP{$A}\n";
	    # node-wide IP address
	    if (defined($single_node{$A})) {
		printdb "ERROR multi-link node\n";
		push(@ERRORS,"Can not use set-ip on nodes with multiple links ($A)");
	    } else {
		# mark as a single_node
		if (&islan($B)) {
		    $lansubnet{$B} = &get_subnet($IP{$A});
		}
		$single_node{$A} = 1;
		$ip_section .= "$A $B $IP{$A}\n";
		printdb "ip_section .= $A $B $IP{$A}\n";
		push(@ip_mac_section,
		     [&intersect($MACTABLE{$A},&get_macs($link)),$IP{$A}]);
		printdb "ip_mac_section <- [" . join(",",&intersect($MACTABLE{$A},&get_macs($link))) . ",$IP{$A}]\n";
		$ips_assigned{$IP{$A}} = 1;
		if (!defined($ips_node{$A})) {
		    $ips_node{$A} = [];
		}
		push(@{$ips_node{$A}},$IP{$A});
	    }
	} else {
	    # mark for phase 2
	    if (defined($to_assign{$link})) {
		$to_assign{$link} = [$A,$B,1];
	    } else {
		$to_assign{$link} = [$A,$B,0];
	    }
	}
	# swap for step 2
	$A = $dst; $B = $src;
    }
}

# Now we need to deal with IP addresses of LANs
foreach $lan (keys(%lans)) {
    printdb "lan $lan\n";
    @nodes = @{$lans{$lan}[1]};
    foreach $node (@nodes) {
	printdb "Looking at $node\n";
	if (defined($IPLAN{"$node:$lan"}) ||
	    defined($IPLAN{"$lan:$node"})) {
	    if (defined($IPLAN{"$node:$lan"})) {
		$ip = $IPLAN{"$node:$lan"};
		$ips_assigned{$ip} = 1;
	    } else {
		$ip = $IPLAN{"$lan:$node"};
		$ips_assigned{$ip} = 1;
	    }
	    printdb "Found link IP $ip\n";
	    $ip_section .= "$node $lan $ip\n";
	    printdb "ip_section .= $node $lan $ip\n";
	    push(@ip_mac_section,
		 [&intersect($MACTABLE{$node},&get_macs($lan)),$ip]);
	    printdb "ip_mac_section <- [" . join(",",&intersect($MACTABLE{$node},&get_macs($lan))) . ",$ip]\n";
	    if (! defined($ips_node{$node})) {
		$ips_node{$node} = [];
	    } 
	    push(@{$ips_node{$node}},$ip);
	    $lansubnet{$lan} = &get_subnet($ip);
	    printdb "lansubnet{$lan} = $lansubnet{$lan}\n";
	} elsif (defined($IP{$node})) {
	    printdb "Found node address\n";
	    if (defined($single_node{$node})) {
		push(@ERRORS,"Can not use set-ip on nodes with multiple links ($node)");
	    } else {
		$single_node{$node} = 1;
		$ip_section .= "$node $lan $IP{$node}\n";
		printdb "ip_section .= $node $lan $IP{$node}\n";
		push(@ip_mac_section,
		     [&intersect($MACTABLE{$node},&get_macs($lan)),$IP{$node}]);
		printdb "ip_mac_section <- [" . join(",",&intersect($MACTABLE{$node},&get_macs($lan))) . ",$IP{$node}]\n";
		$ips_assigned{$IP{$node}} = 1;
		if (!defined($ips_node{$node})) {
		    $ips_node{$node} = [];
		}
		push(@{$ips_node{$node}},$IP{$node});
		$lansubnet{$lan} = &get_subnet($IP{$node});
		printdb "lansubnet{$lan} = $lansubnet{$lan}\n";
	    }
	} else {
	    $to_assign{"${node}_${lan}"} = [$node,$lan,0];
	    $vlanmap{"${node}_${lan}"} = $vlanmap{$lan};
	}
    }
}
    
# Phase 2 - Assigning all unassigned nodes.

# find_free_ip <subnet> - is a try-every-possibility routine that
# finds the first free ip in a given subnet.
# Note: unlike in handle_ip.tcl this does not add the return to
# ips_assigned.
sub find_free_ip {
    local($subnet) = $_[0];
    local($i);
    for ($i=2;$i<250;$i++) {
	if (!defined($ips_assigned{"$subnet.$i"})) {
	    return "$subnet.$i";
	}
    }
    return "";
};
  
# get_subnet <ip> - Just parses out the subnet from an IP address.
# Note: Does no checking to see if $ip is a correct ip address.
sub get_subnet {
    local($ip) = $_[0];
    local(@t) = split('\.',$ip);
    return join(".",@t[0..2]);
};

# find_free_subnet - Another try everything routine for finding
# an unused subnet.
sub find_free_subnet {
    local(%used);
    local($i);

    foreach (keys(%ips_assigned)) {
	$used{&get_subnet($_)} = 1;
    }
    for ($i=2;$i<250;$i++) {
	if (!defined($used{"$ip_base.$i"})) {
	    return "$ip_base.$i";
	}
    }

    return "";
};

foreach $left (keys(%to_assign)) {
    ($node,$dst,$both) = @{$to_assign{$left}};
    printdb "Dealing with $left: $node,$dst,$both\n";
    if ($both == 1) {
	$subnet = &find_free_subnet();
	$ipA = &find_free_ip($subnet);
	$ips_assigned{$ipA} = 1;
	$ipB = &find_free_ip($subnet);
	$ips_assigned{$ipB} = 1;
	$ip_section .= "$node $dst $ipA\n";
	printdb "ip_section .= $node $dst $ipA\n";
	$macs = &get_macs($left);
	push(@ip_mac_section,[&intersect($MACTABLE{$node},$macs),$ipA]);
	printdb "ip_mac_section .= ".&intersect($MACTABLE{$node},$macs).",$ipA\n";
	$ip_section .= "$dst $node $ipB\n";
	push(@ip_mac_section,[&intersect($MACTABLE{$dst},$macs),$ipB]);
	printdb "ip_mac_section .= ".&intersect($MACTABLE{$dst},$macs).",$ipB\n";
	push(@{$ips_node{$node}},$ipA);
	push(@{$ips_node{$dst}},$ipB);
    } else {
	if (defined($IP{"$dst:$left"})) {
	    $subnet = &get_subnet($IP{"$dst:$left"});
	} elsif (defined($IP{$dst})) {
	    $subnet = &get_subnet($IP{$dst});
	} else {
	    if (defined($lansubnet{$dst})) {
		$subnet = $lansubnet{$dst};
	    } else {
		$subnet = &find_free_subnet();
	    }
	}
	printdb "subnet = $subnet\n";
	if (&islan($dst)) {
	    $lansubnet{$dst} = $subnet;
	    printdb "lansubnet{$dst} = $lansubnet{$dst}\n";
	}
	$ip = &find_free_ip($subnet);
	$ips_assigned{$ip} = 1;
	$ip_section .= "$node $dst $ip\n";
	printdb "ip_section .= $node $dst $ip\n";
	push(@ip_mac_section,
	     [&intersect($MACTABLE{$node},&get_macs($left)),$ip]);
	printdb "ip_mac_section  <- [" . join(",",&intersect($MACTABLE{$node},&get_macs($left))) . ",$ip]\n";
	push(@{$ips_node{$node}},$ip);
    }
}

# Output
if ($#ERRORS != -1) {
    foreach (@ERRORS) {
	print STDERR $_ . "\n";
    }
    exit(1);
}

# We need to check whether the section exists arleady or not
if (! &ir_exists("/ip")) {
    # Fresh file just append.
    open(IRFILE,">>$irfile") || do {
	print STDERR "Can not open $irfile for appending.\n";
	exit(1);
    };
    print IRFILE "START ip\n";
    print IRFILE "START map\n";
    print IRFILE $ip_section;
    print IRFILE "END map\n";
    print IRFILE "START mac\n";
    foreach (@ip_mac_section) {
	($mac,$ip) = @$_;
	if ( $mac =~ /^08002b81/ ) { #It's a shark
	  $sth = $dbh->
	    prepare("UPDATE interfaces set IPalias = '$ip' where MAC = '$mac'");
	} else {
	  $sth = $dbh->
	    prepare("UPDATE interfaces set IP = '$ip' where MAC = '$mac'");
	}
	$sth->execute;
	print IRFILE "$mac $ip\n";
    }
    print IRFILE "END mac\n";
    print IRFILE "END ip\n";
    
    close(IRFILE);
} else {
    # Use libir to overwrite.
    # We need to generate the ip_mac section
    $ip_mac_raw = "";
    foreach (@ip_mac_section) {
	($mac,$ip) = @$_;
	if ( $mac =~ /^08002b81/ ) { #It's a shark
	  $sth = $dbh->
	    prepare("UPDATE interfaces set IPalias = '$ip' where MAC = '$mac'");
	} else {
	  $sth = $dbh->
	    prepare("UPDATE interfaces set IP = '$ip' where MAC = '$mac'");
	}
	$sth->execute;
	$ip_mac_raw .= "$mac $ip\n";
    }
    &ir_set("/ip/map",$ip_section);
    &ir_set("/ip/mac",$ip_mac_raw);
    eval {&ir_write($irfile)};
    if ($@) {
	print STDERR "Could not write $irfile ($@)\n";
	exit(1);
    }
}

0;
