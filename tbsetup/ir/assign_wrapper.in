#!/usr/bin/perl -w

# This rather complex program acts as an interface between the IR
# and the assign engine.  It translate between LANs and the star
# topologies used to emulate lans in assign.  It genertes the 
# top file, calls assign, and then interprets the output, generating
# the /virtual and /vlan section.

# The ptop file should be generated with 'avail | ptopgen'

# Syntax: assign_wrapper <ir> <ptop>

# Limitations:
#   It is assumed that mac addresses are sufficient to generate vlans.  From
# this data it should be possible to look up all other pertinant information
# about nodes.  This is usually correct except in the case where there are
# multiple paths between nodes are different switches.  Any information
# about which path was chosen by assign (for load balancing) is lost.
#  Note that assign itself has a limitation that no two switches can have 
# more than one intermediate switch.

# Debugging:
#  Running with -v will produce a large amount of useful output.

# Caveats:
#   The support for direct and interswitch links has not been
# testbed much at all.

# Some settings
# delaythresh is the maximum delay in ms above which a delay node is needed
# maxrun is the number of times to rerun assign if no match is found.
# assign is the path to assign
$delaythresh = 10;
$maxrun = 5;

#
# Configure variables
#
my $IRLIB  = "@prefix@/lib/ir";
my $assign = "@prefix@/libexec/assign";

push(@INC,$IRLIB);
require libir;

$verbose = -1;
if ($#ARGV == 2) {
    if ($ARGV[0] eq "-v") {
	$verbose = 1;
	($irfile,$ptopfile) = @ARGV[1,2];
    } 
} elsif ($#ARGV == 1) {
    if ($ARGV[0] ne "-v") {
	$verbose = 0;
	($irfile,$ptopfile) = @ARGV;
    }
} 
if ($verbose == -1) {
    print STDERR "Syntax: $0 [-v] irfile ptopfile\n";
    exit(1);
}

# printdb - prints out a debug message passed to it if $verbose == 1
sub printdb {
    if ($verbose) {
	print "DB: $_[0]";
    }
};

# We now read in the topology section
eval {&ir_read($irfile)};
if ($@) {
    print STDERR "Could not read $irfile ($@)\n";
    exit(1);
}

# nodes is a hash indexed by node name and valued with a list of link names.
# nodetype is a hash indexed by node name and values with the type of the node.
$raw = eval {&ir_get("/topology/nodes")};
if ($@) {
    print STDERR "Could not load /topology/nodes.\n";
    exit(1);
}
foreach (split("\n",$raw)) {
    @info = split;
    ($nodename,$nodetype,@links) = @info;
    printdb "nodetype{$nodename} = $nodetype\n";
    $nodetypes{$nodename} = $nodetype;
    $linklist = [];
    foreach (@links) {
	push(@$linklist,$_);
    }
    printdb "nodes{$nodename} = " . join(" ",@$linklist) . "\n";
    $nodes{$nodename} = $linklist;
}

# links is a hash indexed by link name and containing a list:
#  [src,dst,bw,delay,loss]
$raw = eval {&ir_get("/topology/links")};
if ($@) {
    print STDERR "Could not load /topology/links.\n";
    exit(1);
}
foreach (split("\n",$raw)) {
    @info = split;
    ($link,$src,$dst,$bw,$delay,$loss) = @info[0,1,3,5,7,9];
    $delay =~ s/[mM][sS]$//;
    $bw =~ s/[mM][bB]$//;
    printdb "links{$link} = [$src,$dst,$bw,$delay,$loss]\n";
    $links{$link} = [$src,$dst,$bw,$delay,$loss];
}

# lans is a hash indexed by lan name and containing a list:
#  [nodes,bw,delay,loss,links]
# where nodes and links are references to arrays of the nodes in
# the lan and the external links to the lan, respectively.
$raw = eval {&ir_get("/topology/lans")};
if ($@) {
    print STDERR "Could not load /topology/lans.\n";
    exit(1);
}
foreach (split("\n",$raw)) {
    ($lan,$nodes_raw,$bw,$delay,$loss,$links_raw) = 
	/([^ ]+) "([^\"]+)" ([^ ]+) ([^ ]+) ([^ ]+)(?:[ \t]+(.*))?$/;
    $nodes_tmp = [];
    foreach (split(" ",$nodes_raw)) {
	push(@$nodes_tmp,$_);
    }
    $links_tmp = [];
    if (defined $links_raw) {
      foreach (split(" ",$links_raw)) {
	push(@$links_tmp,$_);
      }
    }
    $delay =~ s/[mM][sS]$//;
    $bw =~ s/[mM][bB]$//;
    printdb "lans{$lan} = [$nodes_raw,$bw,$delay,$loss".
      (defined $links_raw ? ",$links_raw" : "")."]\n";
    $lans{$lan} = [$nodes_tmp,$bw,$delay,$loss,$links_tmp];
}

# min just returns the minimum value of it's arguments
sub min {
    $min = $_[0];
    foreach (@_[1,$#_]) {
	if ($_ < $min) {
	    $min = $_;
	}
    }
    return $min;
};
# LAN conversion

# We now need to turn LANs into links and nodes.  Each lan gets a central
# node of type "lan".  In an undealyed lan all the links in the lan are
# linked directly to that node.  In a delayed lan a bunch of delay nodes 
# are created with "1/2" delays and linked to the lan node and the nodes in
# the lan are linked to those delay nodes.  We actually don't create the delay
# nodes here we just set up the links as delayed and let the next section
# deal with it.
foreach $lan (keys(%lans)) {
    @info = @{$lans{$lan}};
    @nodes = @{$info[0]};
    @extlinks = @{$info[4]};
    ($bw,$delay,$loss) = @info[1,2,3];

    printdb "Converting $lan ($bw,$delay,$loss)\n";

    # Add lan node
    $nodetypes{$lan} = "lan";
    $nodes{$lan} = [];
    push(@{$nodes{$lan}},@extlinks);

    # Add links
    foreach $node (@nodes) {
	$link = "$lan-$node";
	# "1/2" of the loss in this sequential case if 1-sqrt(1-loss)
	$links{$link} = [$lan,$node,$bw,$delay/2,1-sqrt(1-$loss)];
	printdb "Created link $link = [" . join(",",@{$links{$link}}) . "]\n";
	push(@{$nodes{$lan}},$link);
    }
    printdb "nodes{$lan} = " . join(" ",@{$nodes{$lan}}) . "\n";
}


# Add delays 
$delayindex = 0;

# delayinfo is indexed by delay node name and contains a list of:
# [$bw,$delay,$loss]

# We now handle delays.  We just need to split links with delay
# charateristics.  There is one special case in that we need to add a
# special delay node for lan<->lan links even if there are no delay
# characteristics on either lan or the link.
foreach $link (keys(%links)) {
    ($src,$dst,$bw,$delay,$loss) = @{$links{$link}};
    
    printdb "Looking at $link ($src,$dst,$bw,$delay,$loss)\n";
    if (defined($lans{$src}) && defined($lans{$dst})) {
	# lan<->lan link
	# Create delay node
	$delayname = "delay$delayindex";
	$delayindex++;
	$nodetypes{$delayname} = "delay";
	$nodes{$delayname} = ["dsrc_$link","ddst_$link"];
	$links{"dsrc_$link"} = [$src,$delayname,0,0,0];
	$links{"ddst_$link"} = [$delayname,$dst,0,0,0];
	printdb "lan<->lan Created $delayname with links dsrc_$link and ddst_$link\n";
	# !!! - This could be improved (splice)
	$newsrclinks = [];
	foreach (@{$nodes{$src}}) {
	    if ($_ eq $link) {
		push(@$newsrclinks,"dsrc_$link");
	    } else {
		push(@$newsrclinks,$_);
	    }
	}
	$nodes{$src} = $newsrclinks;
	$newdstlinks = [];
	foreach (@{$nodes{$dst}}) {
	    if ($_ eq $link) {
		push(@$newdstlinks,"ddst_$link");
	    } else {
		push(@$newdstlinks,$_);
	    }
	}
	$nodes{$dst} = $newdstlinks;
	
	($Abw,$Adelay,$Aloss) = @{$lans{$src}}[1,2,3];
	($Bbw,$Bdelay,$Bloss) = @{$lans{$dst}}[1,2,3];
	# For loss here we have a probability problem.  We know that
	# our packet will go through a delay node on each lan
	# with a loss rate of (1-sqrt(1-$[AB]loss)).  We want to set
 	# the loss rate of this delay node to be the total loss rate
	# as if the packet passed through a hop of loss rate $Aloss
	# and a hop of $Bloss and a hop of $loss.
	# Let A=(1-sqrt(1-Aloss)
	# Let B=(1-sqrt(1-Bloss)
	# A, B are fixed along with Aloss, Bloss, and loss.  
	# Let r be the loss of this delay node.
	# The loss rate then is: (1-(1-A)*(1-B)*(1-r))
	# We want this to equal (1-(1-Aloss)*(1-Bloss)*(1-loss))
	# Solving for r:
	# r = 1-(1-Aloss)*(1-Bloss)*(1-loss)/((1-A)*(1-B))
	# The denomenator is 0 if either A or B is 1 which happens if
	# Aloss or Bloss is 1.  In this case we want r to be 1.
	if (($Aloss == 1) || ($Bloss == 1)) {
	    $r = 1;
	} else {
	    $r = (1-(1-$Aloss)*(1-$Bloss)*(1-$loss))/
		(sqrt(1-$Aloss)*sqrt(1-$Bloss));
	}
	$delayinfo{$delayname} = [&min($Abw,$Bbw,$bw),
			      $Adelay/2+$Bdelay/2+$delay,
			      $r];
	printdb "delayinfo{$delayname} = [" . join(",",@{$delayinfo{$delayname}}) . "]\n";
	
	# Remove the original link
	delete $links{$link};
    } elsif (($bw != 100) || ($loss != 0.0) || ($delay > $delaythresh)) {
	# We need a delay link
	$delayname = "delay$delayindex";
	$delayindex++;
	$nodetypes{$delayname} = "delay";
	$nodes{$delayname} = ["dsrc_$link","ddst_$link"];
	$links{"dsrc_$link"} = [$src,$delayname,0,0,0];
	$links{"ddst_$link"} = [$delayname,$dst,0,0,0];
	$delayinfo{$delayname} = [$bw,$delay,$loss];

	printdb "Created delay $delayname and links dsrc_$link and ddst_$link\n";
	printdb "delayinfo{$delayname} = [$bw,$delay,$loss]\n";
	
        # !!! - This could be improved (splice)
	$newsrclinks = [];
	foreach (@{$nodes{$src}}) {
	    if ($_ eq $link) {
		push(@$newsrclinks,"dsrc_$link");
	    } else {
		push(@$newsrclinks,$_);
	    }
	}
	$nodes{$src} = $newsrclinks;
	$newdstlinks = [];
	foreach (@{$nodes{$dst}}) {
	    if ($_ eq $link) {
		push(@$newdstlinks,"ddst_$link");
	    } else {
		push(@$newdstlinks,$_);
	    }
	}
	$nodes{$dst} = $newdstlinks;
	
	# Remove the original link
	delete $links{$link};
    }
}

# TOP file
# It's time to write out the top file.
$topfile = "/tmp/$$.top";
open(TOPFILE,"> $topfile") || do {
    print STDERR "Could not open $topfile.";
    exit(1);
};

foreach $node (keys(%nodetypes)) {
    print TOPFILE "node $node $nodetypes{$node}\n";
}
foreach $link (keys(%links)) {
    ($src,$dst) = @{$links{$link}}[0,1];
    print TOPFILE "link $link $src $dst 100\n";
}
close(TOPFILE);

# Run assign

# After assign finishes correctly several data structures will be
# filled out.
# v2pmap is indexed by virtual node name and contains the physical node name
# p2vmap is indexed by physical node name and contains the virtual node name
# plinks is indexed by input link name and contains:
#   ["intraswitch",srclink,srcmac,dstlink,dstmac]
#   ["interswitch",srclink,srcmac,dstlink,dstmac]
#   ["direct",plink,srcmac,dstmac]

# getmac takes a string in the format (mac0,mac1) where mac0,mac1 is either
# [a-f0-9]+ or (null) and returns the first non-null one.
sub getmac {
    $macstring=$_[0];
    ($A,$B) = ($macstring =~ /^\(([^,]+),([^,]+)\)$/);
    if ($A ne "(null)") {
	return $A;
    } else {
	return $B;
    }
};

#print "Running assign ($assign -b -t $ptopfile $topfile)\n";
#print "  Log in assign.log\n";
$run = 1;
while ($run <= $maxrun) {
    printdb "run $run\n"; 
    open(ASSIGNFP,"$assign -b -t $ptopfile $topfile | tee assign.log |");
    
    # init some variables
    $violations=0;
    $score=-1;
    
    # read output
    # Header
    while (<ASSIGNFP>) {
	chop;
	/^With ([0-9]+) violations$/ && do {
	    $violations = $1;
	    last;
	};
	/^[ \t]+BEST SCORE: [ \t]+([0-9]+\.[0-9]+)/ && ($score=$1);
    }
    # We don't bother reading anything else if violations occured.
    if (($violations == 0) && ($score != -1)) {
	# read nodes section
	while (<ASSIGNFP> !~ /^Nodes:/) {}
	while (<ASSIGNFP>) {
	    chop;
	    /^End Nodes$/ && last;
	    @info = split;
	    ($virtual,$physical) = @info[0,2];
	    printdb "v2pmap{$virtual} = $physical\n";
	    printdb "p2vmap{$physical} = $virtual\n";
	    $v2pmap{$virtual} = $physical;
	    $p2vmap{$physical} = $virtual;
	}
	# read Edges
	while (<ASSIGNFP> !~ /^Edges:/) {}
	while (<ASSIGNFP>) {
	    /^End Edges$/ && last;
	    @info = split;
	    $line = $_;
	    $_ = $info[1]; # type
	  SWITCH1: {
	      /^intraswitch$/ && do {
		  ($vlink,$plinkA,$macA,$plinkB,$macB) = @info[0,2,3,4,5];
		  $plinks{$vlink} = ["intraswitch",$plinkA,
				     &getmac($macA),$plinkB,&getmac($macB)];
		  printdb "plinks{$vlink}=[" . join(",",@{$plinks{$vlink}}) . "]\n";
		  last SWITCH1;
	      };
	      /^interswitch$/ && do {
		  # Can either be:
		  # vlink "interswitch" plinkA macA plinkB macB plinkC macC
		  # or 
		  # vlink "interswitch" plinkA macA plinkB macB
		  # In the first case plinkB/macB will be a switch<->switch
		  # link that we ignore.
		  if ($#info == 7) {
		      ($vlink,$plinkA,$macA,$plinkB,$macB) = @info[0,2,3,6,7];
		  } else {
		      ($vlink,$plinkA,$macA,$plinkB,$macB) = @info[0,2,3,4,5];
		  }
		  $plinks{$vlink} = ["interswitch",$plinkA,
				     &getmac($macA),$plinkB,&getmac($macB)];
		  printdb "plinks{$vlink}=[" . join(",",@{$plinks{$vlink}}) . "]\n";
		  last SWITCH1;
	      };
	      /^direct$/ && do {
		  ($vlink,$plink,$mac) = @info[0,2,3];
		  ($macA,$macB) = ($mac =~ /^\(([^,]+),([^,]+)\)$/);
		  $plinks{$vlink} = ["direct",$plink,$macA,$macB];
		  printdb "plinks{$vlink}=[" . join(",",@{$plinks{$vlink}}) . "]\n";
		  last SWITCH1;
	      };
	      print "Found garbage: $line\n";
	  }
	}
    }
    
    while (<ASSIGNFP>) { } # Read anything left in the pipe before closing

    close(ASSIGNFP);
    
    if ($violations > 0) {
	print "Run $run resulted in $violations violations.";
	$run++;
	next;
    } elsif ($score == -1) {
	print "No score reported???";
	$run++;
	next;
    }

    last;
}

if (($violations != 0) || ($score == -1)) {
    print "Assign failed to find a valid solution - Exiting.\n";
    exit -1;
}

# Filling out IR file

# We now have all the information we need to fill out the /virtual and
# /vlan sections of the IR file as well as fill out the delay table of
# the database.

# node<->node
# /virtual/links
#   <vlink> <psrc> <pdst>
# /vlan
#   <vlink> <srcmac> <dstmac>

# node<->delay<->node
# /virtual/links
#   <vlink> <src> <delayA> <delayB> <dst>
# /vlan
#   <dsrc_vlink> <srcmac> <delayAmac>
#   <ddst_vlink> <delayBmac> <dstmac>

# lan<->delay<->lan
# /virtual/links
#   <vlink> <src> <delayA> <delayB> <dst>
# /vlan
#   put <delayAmac> into vlan for <src> and <delayBmac> into vlan for <dst>

# lan<->delay<->node
# /virtual/links
#   nothing
# /vlan
#   put <delayAmac> into vlan for the lan and add entry
#   <ddst/dsrc_vlink> <delayBmac> <nodemac>

# lan<->node
# /virtual/links 
#   nothing
# /vlan
#   put <nodemac> into vlan for lan

# We also will have a /virtual/nodes that has: <vnode> <pnode>
# In all cases we use the virtual lan name instead of the physical lan
# name, which has no persistant meaning.

# vlans will be indexed by vlan name and contain a list of mac addresses.
# vlinks is indexed by virtual link and contains the physical links
#   that make it up.

# nodename - assign returns <node>-<port> strings.  This returns the
# <node> part.
sub nodename {
    $s = $_[0];
    @r = split("-",$s);
    return $r[0];
};

# getlan - This just takes a <pnode>-<port> string and returns the 
# virtual lan or "".
sub getlan {
    $pnode = $_[0];
    if (defined($lans{$p2vmap{&nodename($pnode)}})) {
	return $p2vmap{&nodename($pnode)};
    } else {
	return "";
    }
};

# We initialize the vlans table for all lans
foreach $lan (keys(%lans)) {
    $vlans{$lan} = [];
}

foreach (keys(%plinks)) {
    # ignore ddst_* as those will be handled when we handle dsrc_*
    /^ddst_.+$/ && next;

    @info = @{$plinks{$_}};
    ($type,$plinkA,$macA) = @info[0,1,2];
    if ($type ne "direct") {
	($plinkB,$macB) = @info[3,4];
    } else {
	$plinkB = "";
	$macB = $info[3];
    }
    printdb "Looking at $_ ($type,$plinkA,$macA,$plinkB,$macB)\n";
    if (/^dsrc_(.+)$/) {
	# delayed link
	# read in second half
	$vlink=$1;
	@info2 = @{$plinks{"ddst_$vlink"}};
	($type2,$plinkA2,$macA2) = @info2[0,1,2];
	if ($type2 ne "direct") {
	    ($plinkB2,$macB2) = @info2[3,4];
	} else {
	    $plinkB2 = "";
	    $macB2 = $info2[3];
	}
	printdb "Delayed link, second half = ($type2,$plinkA2,$macA2,$plinkB2,$macB2)\n";

	# We have a total of 16 possibilities for delay links.
	# Luckily it comes in two dimensions that can be handled
	# seperately.

	# now we sort into src, delayA, delayB, and dst.
	# possibilities:
	#   A & A2
	#   A & B2
	#   B & A2
	#   B & B2
	if (&nodename($plinkA) eq &nodename($plinkA2)) {
	    $src = $plinkB;$srcmac = $macB;
	    $delayA = $plinkA;$delayAmac = $macA;
	    $delayB = $plinkA2;$delayBmac = $macA2;
	    $dst = $plinkB2;$dstmac = $macB2;
	} elsif (&nodename($plinkA) eq &nodename($plinkB2)) {
	    $src = $plinkB;$srcmac = $macB;
	    $delayA = $plinkA;$delayAmac = $macA;
	    $delayB = $plinkB2;$delayBmac = $macB2;
	    $dst = $plinkA2;$dstmac = $macA2;
	} elsif (&nodename($plinkB) eq &nodename($plinkA2)) {
	    $src = $plinkA;$srcmac = $macA;
	    $delayA = $plinkB;$delayAmac = $macB;
	    $delayB = $plinkA2;$delayBmac = $macA2;
	    $dst = $plinkB2;$dstmac = $macB2;
	} elsif (&nodename($plinkB) eq &nodename($plinkB2)) {
	    $src = $plinkA;$srcmac = $macA;
	    $delayA = $plinkB;$delayAmac = $macB;
	    $delayB = $plinkB2;$delayBmac = $macB2;
	    $dst = $plinkA2;$dstmac = $macA2;
	}
	push(@{$delayinfo{$p2vmap{&nodename($delayA)}}},($delayAmac,$delayBmac));
	printdb "src=$src ($srcmac) delayA=$delayA ($delayAmac) delayB=$delayB ($delayBmac) dst=$dst ($dstmac)\n";
	printdb "delayinfo{" . $p2vmap{&nodename($delayA)} . "}=[" . join(",",@{$delayinfo{$p2vmap{&nodename($delayA)}}}) . "]\n";

	# now we have another four possibilities:
	if (&getlan($src) && &getlan($dst)) {
	    # lan<->delay<->lan
	    $srclan = &getlan($src);
	    push(@{$vlans{$srclan}},$delayAmac);
	    $dstlan = &getlan($dst);
	    push(@{$vlans{$dstlan}},$delayBmac);
	    $vlinks{$vlink} = [$srclan,$delayA,$delayB,$dstlan];
	    printdb "lan<->delay<->lan - $delayAmac->$srclan, $delayBmac->$dstlan\n";
	    printdb "vlinks{$vlink}=[" . join(" ",@{$vlinks{$vlink}}) . "]\n";
	} elsif (&getlan($dst)) {
	    # node<->delay<->lan
	    $lan = &getlan($dst);
	    push(@{$vlans{$lan}},$delayBmac);
	    $vlans{"dsrc_$vlink"} = [$srcmac,$delayAmac];
	    printdb "node<->delay<->lan - dsrc_$vlink = [$srcmac,$delayAmac], $delayBmac->$lan\n";
	} elsif (&getlan($src)) {
	    # lan<->delay<->node
	    $lan = &getlan($src);
	    push(@{$vlans{$lan}},$delayAmac);
	    $vlans{"dsrc_$vlink"} = [$delayBmac,$dstmac];
	    printdb "lan<->delay<->node - ddst_$vlink = [$delayBmac,$dstmac], $delayAmac -> $lan\n";
	} else {
	    # node<->delay<->node
	    $vlans{"dsrc_$vlink"} = [$srcmac,$delayAmac];
	    $vlans{"ddst_$vlink"} = [$delayBmac,$dstmac];
	    $vlinks{$vlink} = [$src,$delayA,$delayB,$dst];
	    printdb "node<->delay<->node - dsrc_$vlink = [$srcmac,$delayAmac], ddst_$vlink = [$delayBmac,$dstmac]\n";
	    printdb "vlinks{$vlink}=[" . join(",",@{$vlinks{$vlink}}) . "]\n";
	}
    } else {
	# undelayed link
	printdb "Undelayed link\n";
	if (&getlan($plinkA) || &getlan($plinkB)) {
	    # lan<->node - i.e. the node belongs in the lan
	    $lan = &getlan($plinkA);
	    $mac = $macB;
	    if (! $lan) {
		$lan = &getlan($plinkB);
		$mac = $macA;
	    }
	    push(@{$vlans{$lan}},$mac);
	    printdb "lan<->node - $mac->$lan\n";
	} else {
	    # node<->node
	    $vlans{$_} = [$macA,$macB];
	    $vlinks{$_} = [$plinkA,$plinkB];
	    printdb "node<->node $_=[$macA,$macB]\n";
	    printdb "vlinks{$_}=[" . join(",",@{$vlinks{$_}}) . "]\n";
	}
    }
}

# Open IR file for appending
# This is just a matter of dumping data structures

open(IRFILE,">>$irfile") || do {
    print STDERR "Could not open $irfile for appending.\n";
    exit(1);
};

print IRFILE "START virtual\n";
print IRFILE "START nodes\n";
foreach $vnode (keys(%v2pmap)) {
    if (! defined($lans{$vnode})) {
	print IRFILE "$vnode $v2pmap{$vnode}\n";
    }
}
print IRFILE "END nodes\n";

print IRFILE "START links\n";
foreach $vlink (keys(%vlinks)) {
    print IRFILE "$vlink " . join(" ",@{$vlinks{$vlink}}) . "\n";
}
print IRFILE "END links\n";
print IRFILE "END virtual\n";

print IRFILE "START vlan\n";
foreach $vlan (keys(%vlans)) {
    print IRFILE "$vlan " . join(" ",@{$vlans{$vlan}}) . "\n";
}
print IRFILE "END vlan\n";

print IRFILE "START delay\n";
foreach $delay (keys(%delayinfo)) {
    print IRFILE $v2pmap{$delay} . " " . join(" ",@{$delayinfo{$delay}}) . "\n";
}
print IRFILE "END delay\n";

close IRFILE;


# We're done! - Now the calling script will make sure the resources are
# available, reserve them, and call postassign to copy the data into the
# DB.

unlink $topfile;

print "Assignment complete\n";

0;
