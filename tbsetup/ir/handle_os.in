#!/usr/bin/perl -w

# This handles all the OS TB commands:
# create-os
# set-dnard-os
# set-node-os

# Yet to do:
# Any sort of delta support

#
# Configure variables
#
my $IRLIB  = "@prefix@/lib/ir";
my $DBNAME = "@TBDBNAME@";

push(@INC, $IRLIB);
require libir;

if ($#ARGV != 1) {
    print STDERR "Syntax: $0 ir_file tbcmdfile\n";
    exit 1;
}
($irfile,$tbcmdfile) = @ARGV;

use DBI;

$driver = "mysql";
$dbh = DBI->connect("DBI:$driver:database=$DBNAME;host=localhost") 
    || die "Could not connect to DB.\n";

# List of ERROR messages
@ERRORS = ();

# read IR file
eval {&ir_read($irfile)};
if ($@) {
    print STDERR "Could not read $irfile ($@)\n";
    exit(1);
}

# open the tbcmd file
open(TBCMD,$tbcmdfile) || do {
    print STDERR "Could not open $tbcmdfile.\n";
    exit(1);
};

# Load the node types and grab the default OS from the database
# %nodetype is indexed by virtual node id and contains the type
# %defaultos is indexed by type and contains the default OS
# $delayos is the delay os, currently assumed to be os of PC's
# XXX - Should grab this from the DB eventually
$delayos = "FBSD40-STD";
$raw = eval {&ir_get("/topology/nodes")};
if ($@) {
    print STDERR "Could not load /topology/nodes.\n";
    exit(1);
}
foreach (split("\n",$raw)) {
    @info = split;
    $node = $info[0];
    $type = $info[1];
    $nodetype{$node} = $type;
    if (! defined($ostype{$type})) {
	$sth = $dbh->prepare("SELECT image_id from node_types where type = \"$type\"");
	$rr = $sth->execute;
	if ($rr == 0) {
	    push(@ERRORS,"Invalid type $type");
	    $ostype{$type} = "INVALID";
	} else {
	    @result = $sth->fetchrow_array;
	    $ostype{$type} = $result[0];
	}
	$sth->finish;
    }
}

# Load the nodemap and set up an initial os table
# nodemap is indexed by virtual node id and contains the physical node id
# os is indexed by physical node id and contains the image id
$raw = eval {&ir_get("/virtual/nodes")};
if ($@) {
    print STDERR "Could not load /virtual/nodes.  Run assign first.\n";
    exit(1);
}
foreach (split("\n",$raw)) {
    ($virtual,$physical) = split;
    $nodemap{$virtual} = $physical;
    if (!defined($nodetype{$virtual})) {
	# assume to be a delay node
	$os{$physical} = $delayos;
    } else {
	$os{$physical} = $ostype{$nodetype{$virtual}};
    }
}
# Now we parse the tbcmd file
# %images is indexed by label and contains "$path $partition"
while (<TBCMD>) {
    chop;
    @line = split;
    $_ = $line[0];
  SWITCH: {
      /^tb-create-os$/ && do {
	  # Should add some checking for partition
	  if ($#line != 3) {
	      push(@ERRORS,"Syntax: tb-create-os label path partition");
	  } else {
	      ($label,$path,$partition) = @line[1..3];
	      $images{$label} = "$path $partition";
	  }
	  last SWITCH;
      };
      /^tb-set-node-os$/ && do {
	  if ($#line != 2) {
	      push(@ERRORS,"Syntax: tb-set-node-os nodespec os");
	  } else {
	      ($nodespec,$label) = @line[1..2];
	      # Do initial checking on label
	      # We also get the valid type for this image and store it
	      # in valid_type;
	      if (! defined($images{$label})) {
		  # Check DB
		  $sth = $dbh->prepare("SELECT type from disk_images where image_id = \"$label\"");
		  $rr = $sth->execute;
		  if ($rr == 0) {
		      # Bad OS
		      $sth->finish;
		      push(@ERRORS,"Unknown OS label $label");
		      last SWITCH;
		  } else {
		      @result = $sth->fetchrow_array;
		      $sth->finish;
		      $valid_type = $result[0];
		  }
	      } else {
		  # Custom image - don't know type info
		  $valid_type = "";
	      }
	      foreach (keys(%nodemap)) {
		  if (eval("/^$nodespec" . '$' . "/")) {
		      if (($valid_type ne "") &&
			  ($nodetype{$_} ne $valid_type)) {
			  push(@ERRORS,"$_ is of type $nodetype($_), OS $label is of type $valid_type");
			  $os{$nodemap{$_}} = "INVALID";
		      } else {
			  $os{$nodemap{$_}} = $label;
		      }
		  }
	      }
	  }
	      
	  last SWITCH;
      };
      /^tb-set-node-deltas$/ && do {
	  # PLACE HOLDER
	  last SWITCH;
      };
  }
}
 
close(TBCMD);

# Check if we're good so far
if ($#ERRORS != -1) {
    foreach (@ERRORS) {
	print STDERR $_ . "\n";
    }
    exit(1);
}

## Handle cmdline/startup/etc.
if (! &ir_exists("/cmdline")) {
    print STDERR "IR incomplete: No /cmdline.\n";
    exit(1);
}
foreach (split("\n",&ir_get("/cmdline"))) {
    ($node,$cmdline) = /^([^ ]+)(.*)$/;
    $cmdline =~ s/^ //;
    $sth = $dbh->prepare("UPDATE nodes set def_boot_cmd_line = \"$cmdline\" where node_id = \"$node\"");
    $sth->execute;
    $sth->finish;
}
if (! &ir_exists("/startup")) {
    print STDERR "IR incomplete: No /startup.\n";
    exit(1);
}
foreach (split("\n",&ir_get("/startup"))) {
    ($node,$cmdline) = /^([^ ]+)(.*)$/;
    $cmdline =~ s/^ //;
    $sth = $dbh->prepare("UPDATE nodes set startupcmd = \"$cmdline\", startstatus = \"none\" where node_id = \"$node\"");
    $sth->execute;
    $sth->finish;
}
if (! &ir_exists("/rpms")) {
    print STDERR "IR incomplete: No /rpms.\n";
    exit(1);
}
foreach (split("\n",&ir_get("/rpms"))) {
    ($node,$rpms) = /^([^ ]+)(.*)$/;
    $rpms =~ s/^ //;
    $rpms =~ s/ /:/g;
    $sth = $dbh->prepare("UPDATE nodes set rpms = \"$rpms\" where node_id = \"$node\"");
    $sth->execute;
    $sth->finish;
}

# Let's do some output
# We allow running this on an IR file that has already been handle_os'ed
# it simply overwrites in that case.
if (! &ir_exists("/os")) {
    # Fresh file, just append
    open(IRFILE,">> $irfile") || do {
	print STDERR "Could not open $irfile for appending.\n";
	exit(1);
    };
    print IRFILE "START os\n";
    print IRFILE "START images\n";
    foreach (sort(keys(%images))) {
	print IRFILE "$_ $images{$_}\n";
    }
    print IRFILE "END images\n";
    print IRFILE "START nodes\n";
    foreach (sort(keys(%os))) {
	print IRFILE "$_ $os{$_}\n";
    }
    print IRFILE "END nodes\n";
    print IRFILE "END os\n";
    close(IRFILE);
} else {
    # Here we use libir to overwrite the sections.
    $images_raw = "";
    foreach (sort(keys(%images))) {
	$images_raw .= "$_ $images{$_}\n";
    }
    &ir_set("/os/images",$images_raw);
    $nodes_raw = "";
    foreach (sort(keys(%os))) {
	$nodes_raw .= "$_ $os{$_}\n";
    }
    &ir_set("/os/nodes",$nodes_raw);
    eval {&ir_write($irfile)};
    if ($@) {
	print STDERR "Could not write $irfile ($@)\n";
	exit(1);
    }
}



