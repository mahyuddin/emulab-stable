#!/usr/bin/perl -w

# This handles all the OS TB commands:
# create-os
# set-dnard-os
# set-node-os

# Yet to do:
# Any sort of delta support

#
# Configure variables
#
my $IRLIB  = "@prefix@/lib/ir";
my $DBNAME = "@TBDBNAME@";

push(@INC, $IRLIB);
require libir;

if ($#ARGV != 1) {
    print STDERR "Syntax: $0 ir_file tbcmdfile\n";
    exit 1;
}
($irfile,$tbcmdfile) = @ARGV;

use DBI;

$driver = "mysql";
$dbh = DBI->connect("DBI:$driver:database=$DBNAME;host=localhost") 
    || die "Could not connect to DB.\n";

# List of ERROR messages
@ERRORS = ();

# read IR file
eval {&ir_read($irfile)};
if ($@) {
    print STDERR "Could not read $irfile ($@)\n";
    exit(1);
}

# open the tbcmd file
open(TBCMD,$tbcmdfile) || do {
    print STDERR "Could not open $tbcmdfile.\n";
    exit(1);
};

# Load the node types and grab the default OS from the database
# %nodetype is indexed by virtual node id and contains the type
# %defaultos is indexed by type and contains the default OS
# $delayos is the delay os, currently assumed to be os of PC's
# XXX - Should grab this from the DB eventually
$delayos = "FBSD40-STD";
$raw = eval {&ir_get("/topology/nodes")};
if ($@) {
    print STDERR "Could not load /topology/nodes.\n";
    exit(1);
}
foreach (split("\n",$raw)) {
    @info = split;
    $node = $info[0];
    $type = $info[1];
    $nodetype{$node} = $type;
    if (! defined($ostype{$type})) {
	# Special case - shark shelf
	if ($type eq "shark-shelf") {
	    $subtype = "shark";
	} else {
	    $subtype = $type;
	}
	$sth = $dbh->prepare("SELECT image_id from node_types where type = \"$subtype\"");
	$rr = $sth->execute;
	if ($rr == 0) {
	    push(@ERRORS,"Invalid type $type");
	    $ostype{$type} = "INVALID";
	} else {
	    @result = $sth->fetchrow_array;
	    $ostype{$type} = $result[0];
	}
	$sth->finish;
    }
}

# Load the nodemap and set up an initial os table
# nodemap is indexed by virtual node id and contains the physical node id
# os is indexed by physical node id and contains the image id
$raw = eval {&ir_get("/virtual/nodes")};
if ($@) {
    print STDERR "Could not load /virtual/nodes.  Run assign first.\n";
    exit(1);
}
foreach (split("\n",$raw)) {
    ($virtual,$physical) = split;
    $nodemap{$virtual} = $physical;
    if (!defined($nodetype{$virtual})) {
	# assume to be a delay node
	$os{$physical} = $delayos;
    } else {
	if ($nodetype{$virtual} ne "shark-shelf") {
	    $os{$physical} = $ostype{$nodetype{$virtual}};
	} else {
	    for ($i=1;$i<=8;$i++) {
		$os{"$physical-$i"} = $ostype{"shark-shelf"};
	    }
	}
    }
}
# Now we parse the tbcmd file
# %images is indexed by label and contains "$path $partition"
while (<TBCMD>) {
    chop;
    @line = split;
    $_ = $line[0];
  SWITCH: {
      /^tb-create-os$/ && do {
	  # Should add some checking for partition
	  if ($#line != 3) {
	      push(@ERRORS,"Syntax: tb-create-os label path partition");
	  } else {
	      ($label,$path,$partition) = @line[1..3];
	      $images{$label} = "$path $partition";
	  }
	  last SWITCH;
      };
      /^tb-set-dnard-os$/ && do {
	  if ($#line != 3) {
	      push(@ERRORS,"Syntax: tb-set-dnard-os shelf n os");
	  } else {
	      ($shelf,$n,$label) = @line[1..3];
	      if (! defined($nodemap{$shelf})) {
		  push(@ERRORS,"Unknown node $shelf\n");
		  last SWITCH;
	      }
	      if (! (($n =~ /[0-9]-[0-9]/) || ($n =~ /[0-9]/))) {
		  push(@ERRORS,"n must either be a number or a range start-end\n");
		  last SWITCH;
	      }
	      
	      # The label should either be in the images table or
	      # in the DB.
	      if (! defined($images{$label})) {
		  # Check DB
		  $sth = $dbh->prepare("SELECT image_id from disk_images where image_id = \"$label\"");
		  $rr = $sth->execute;
		  if ($rr == 0) {
		      # Bad OS
		      $sth->finish;
		      push(@ERRORS,"Unknown OS label $label");
		      last SWITCH;
		  }
		  $sth->finish;
	      }
	      $prefix = $nodemap{$shelf};
	      if ($n =~ /[0-9]-[0-9]/) {
		  ($start,$end) = split("-",$n);
		  foreach ($start..$end) {
		      $os{"$prefix-$_"}=$label;
		  }
	      } else {
		  $os{"$prefix-$n"}=$label;
	      }
	  }
	  last SWITCH;
      };
      /^tb-set-node-os$/ && do {
	  if ($#line != 2) {
	      push(@ERRORS,"Syntax: tb-set-node-os nodespec os");
	  } else {
	      ($nodespec,$label) = @line[1..2];
	      # Do initial checking on label
	      # We also get the valid type for this image and store it
	      # in valid_type;
	      if (! defined($images{$label})) {
		  # Check DB
		  $sth = $dbh->prepare("SELECT type from disk_images where image_id = \"$label\"");
		  $rr = $sth->execute;
		  if ($rr == 0) {
		      # Bad OS
		      $sth->finish;
		      push(@ERRORS,"Unknown OS label $label");
		      last SWITCH;
		  } else {
		      @result = $sth->fetchrow_array;
		      $sth->finish;
		      $valid_type = $result[0];
		  }
	      } else {
		  # Custom image - don't know type info
		  $valid_type = "";
	      }
	      foreach (keys(%nodemap)) {
		  if (eval("/^$nodespec" . '$' . "/")) {
		      # Special case, make sure we aren't talking about sharks
		      if ($nodetype{$_} eq "shark-shelf") {
			  push(@ERRORS,"Use set-dnard-os for setting os of shark shelf $_\n");
		      } elsif (($valid_type ne "") &&
			  ($nodetype{$_} ne $valid_type)) {
			  push(@ERRORS,"$_ is of type $nodetype($_), OS $label is of type $valid_type");
			  $os{$nodemap{$_}} = "INVALID";
		      } else {
			  $os{$nodemap{$_}} = $label;
		      }
		  }
	      }
	  }
	      
	  last SWITCH;
      };
      /^tb-set-dnard-deltas$/ && do {
	  # PLACE HOLDER
	  last SWITCH;
      };
      /^tb-set-node-deltas$/ && do {
	  # PLACE HOLDER
	  last SWITCH;
      };
  }
}
 
close(TBCMD);

# Check if we're good so far
if ($#ERRORS != -1) {
    foreach (@ERRORS) {
	print STDERR $_ . "\n";
    }
    exit(1);
}

# Let's do some output
# We allow running this on an IR file that has already been handle_os'ed
# it simply overwrites in that case.
if (! &ir_exists("/os")) {
    # Fresh file, just append
    open(IRFILE,">> $irfile") || do {
	print STDERR "Could not open $irfile for appending.\n";
	exit(1);
    };
    print IRFILE "START os\n";
    print IRFILE "START images\n";
    foreach (sort(keys(%images))) {
	print IRFILE "$_ $images{$_}\n";
    }
    print IRFILE "END images\n";
    print IRFILE "START nodes\n";
    foreach (sort(keys(%os))) {
	print IRFILE "$_ $os{$_}\n";
    }
    print IRFILE "END nodes\n";
    print IRFILE "END os\n";
    close(IRFILE);
} else {
    # Here we use libir to overwrite the sections.
    $images_raw = "";
    foreach (sort(keys(%images))) {
	$images_raw .= "$_ $images{$_}\n";
    }
    &ir_set("/os/images",$images_raw);
    $nodes_raw = "";
    foreach (sort(keys(%os))) {
	$nodes_raw .= "$_ $os{$_}\n";
    }
    &ir_set("/os/nodes",$nodes_raw);
    eval {&ir_write($irfile)};
    if ($@) {
	print STDERR "Could not write $irfile ($@)\n";
	exit(1);
    }
}



