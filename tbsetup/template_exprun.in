#!/usr/bin/perl -wT
#
# EMULAB-COPYRIGHT
# Copyright (c) 2006 University of Utah and the Flux Group.
# All rights reserved.
#
use English;
use strict;
use Getopt::Std;
use POSIX qw(isatty setsid);
use POSIX qw(strftime);
use Errno qw(EDQUOT);
use XML::Simple;
use Data::Dumper;

#
# Create a new experiment template. 
#
# Exit codes are important; they tell the web page what has happened so
# it can say something useful to the user. Fatal errors are mostly done
# with die(), but expected errors use this routine. At some point we will
# use the DB to communicate the actual error.
#
# $status < 0 - Fatal error. Something went wrong we did not expect.
# $status = 0 - Everything okay.
# $status > 0 - Expected error. User not allowed for some reason. 
# 
sub usage()
{
    print(STDERR
	  "Usage: template_exprun [-q] [-w] [-r <runid>] ".
	  "-a <action> -e <eid> <guid/vers>\n".
	  "switches and arguments:\n".
	  "-a <action> - start or stop\n".
	  "-w          - wait for run to start\n".
	  "-s          - save DB contents at end of run; default is clean\n".
	  "-q          - be less chatty\n".
	  "-E <str>    - A pithy sentence describing the run\n".
	  "-r <runid>  - A token ... we will make on up for you\n".
	  "-p <file>   - XML file of parameter bindings\n".
	  "-e <eid>    - The instance name\n".
	  "<guid/vers> - GUID and version to swapin\n");
    exit(-1);
}
my $optlist	 = "qwp:E:a:r:e:dsc";
my %options      = ();
my $quiet        = 0;
my $waitmode     = 0;
my $debug        = 0;
my $clean        = 0;
my $paramfile;
my %parameters   = ();
my $action;
my $description;
my $runid;
my $eid;
my $guid;
my $version;
my $inputfile;
my $handle;

#
# Configure variables
#
my $TB		= "@prefix@";
my $PROJROOT	= "/proj";
my $EVENTSYS	= @EVENTSYS@;
my $TBOPS	= "@TBOPSEMAIL@";
my $TBLOGS	= "@TBLOGSEMAIL@";
my $TBDOCBASE	= "@TBDOCBASE@";
my $TBBASE	= "@TBBASE@";
my $CONTROL	= "@USERNODE@";

# Locals
my $user_name;
my $user_email;
my $logname;
my $dbuid;
my $pid;
my $exptidx;
my $template;
my $instance;
# For the END block below.
my $cleaning    = 0;
my $justexit    = 1;

# Programs we need
my $checkquota  = "$TB/sbin/checkquota";
my $archcontrol = "$TB/bin/archive_control";
my $eventcontrol= "$TB/bin/eventsys_control";

# Protos
sub ParseArgs();
sub fatal($$);
sub sighandler($);
sub SignalProgAgents($);	       

#
# Testbed Support libraries
#
use lib "@prefix@/lib";
use libdb;
use libtestbed;
use libtblog;
use libArchive;
use Template;
use event;

# Be careful not to exit on transient error
$libdb::DBQUERY_MAXTRIES = 0;

#
# Turn off line buffering on output
#
$| = 1;

#
# Set umask for start/swap. We want other members in the project to be
# able to swap/end experiments, so the log and intermediate files need
# to be 664 since some are opened for append.
#
umask(0002);

#
# Untaint the path
#
# un-taint path
$ENV{'PATH'} = '/bin:/usr/bin:/usr/local/bin';
delete @ENV{'IFS', 'CDPATH', 'ENV', 'BASH_ENV'};

#
# Verify user and get his DB uid.
#
if (! UNIX2DBUID($UID, \$dbuid)) {
    tbdie("You do not exist in the Emulab Database!");
}

#
# Get email info for user.
#
if (! UserDBInfo($dbuid, \$user_name, \$user_email)) {
    tbdie("Cannot determine your name and email address.");
}

#
# Before doing anything else, check for overquota ... lets not waste
# our time. Make sure user sees the error by exiting with 1.
#
if (system("$checkquota $dbuid") != 0) {
    tberror("You are over your disk quota on $CONTROL; please cleanup!");
    exit(1);
}

# Now parse arguments.
ParseArgs();

if ($action eq "start" && !defined($runid)) {
    tbdie("Must provide a run ID (-r argument) when starting a new run!");
}

#
# In wait mode, block SIGINT until we spin off the background process.
#
if ($waitmode) {
    $SIG{QUIT} = 'IGNORE';
    $SIG{TERM} = 'IGNORE';
    $SIG{INT}  = 'IGNORE';
}

#
# Grab template and do access check.
#
$template = Template->Lookup($guid, $version);

if (!defined($template)) {
    tbdie("Experiment template $guid/$version does not exist!");
}
if (! TBProjAccessCheck($dbuid,
			$template->pid(), $template->gid(),
			TB_PROJECT_CREATEEXPT)) {
    tberror("You do not have permission to instantiate template ".
	    "$guid/$version");
    exit(1);
}
$pid = $template->pid();

#
# Grab Instance.
#
if (! TBExptIDX($pid, $eid, \$exptidx)) {
    tbdie("Could not get experiment index for $pid,$eid!");
}

$instance = Template::Instance->LookupByExptidx($exptidx);

if (!defined($instance)) {
    tbdie("Experiment instance $eid in $guid/$version does not exist!");
}
   
if (ExpState($pid, $eid) ne EXPTSTATE_ACTIVE()) {
    tberror("Template instance experiment $pid/$eid in not active!");
    exit(1);
}

#
# If we have a parameter file, we need to copyin the values and store
# them in the DB for this experiment. Note that these override existing
# values, so we start with those first.
#
# XXX Do we keep these values in the DB forever? Or just keep the XML file
# around and archived? 
#
$instance->BindingList(\%parameters) == 0
    or tbdie("Could not get binding list for $instance");

if (defined($paramfile)) {
    my $donebad = 0;
    
    my $parse  = XMLin($paramfile,
		       VarAttr => 'name',
		       ContentKey => '-content',
		       SuppressEmpty => undef);

    foreach my $name (keys(%{ $parse->{'parameter'} })) {
	my $value = $parse->{'parameter'}->{$name}->{'value'};

	if (! TBcheck_dbslot($name,
			     "experiment_template_instance_bindings", "name",
			     TBDB_CHECKDBSLOT_WARN|TBDB_CHECKDBSLOT_ERROR)) {
	    tberror("Illegal characters in parameter name: $name");
	    $donebad++;
	}
	if (defined($value) &&
	    ! TBcheck_dbslot($value,
			     "experiment_template_instance_bindings", "value",
			     TBDB_CHECKDBSLOT_WARN|TBDB_CHECKDBSLOT_ERROR)) {
	    tberror("Illegal characters in parameter value: $value");
	    $donebad++;
	}
	# DB records inserted below, once experiment is pre-loaded.
	$parameters{$name} = $value;
    }
    # User sees this error.
    exit(1)
	if ($donebad);
}

#
# Catch this so we can clean up.
#
$SIG{TERM} = \&sighandler;

#
# If not in batch mode, go into the background. Parent exits.
#
if (! $debug) {
    $logname = TBExptCreateLogFile($pid, $eid, "newrun");

    TBExptSetLogFile($pid, $eid, $logname);
    TBExptOpenLogFile($pid, $eid);

    if (my $childpid = TBBackGround($logname)) {
	#
	# Parent exits normally, unless in waitmode. We have to set
	# justexit to make sure the END block below does not run.
	#
	$justexit = 1;

	if (!$waitmode) {
	    print("A new run is being started for $pid/$eid.\n")
		if (! $quiet);
	    exit(0);
	}
	print("Waiting for new run to start.\n")
	    if (! $quiet);
	    
	if (-t STDIN && !$quiet) {
	    print("You may type ^C at anytime.".
		  "\n".
		  "You will not actually interrupt the experiment itself.\n");
	}
	
	# Give child a chance to run.
	select(undef, undef, undef, 0.25);
	
	#
	# Reset signal handlers. User can now kill this process, without
	# stopping the child.
	#
	$SIG{TERM} = 'DEFAULT';
	$SIG{INT}  = 'DEFAULT';
	$SIG{QUIT} = 'DEFAULT';

	#
	# Wait until child exits or until user gets bored and types ^C.
	#
	waitpid($childpid, 0);
	
	print("Done. Exited with status: $?\n")
	    if (! $quiet);
	exit($? >> 8);
    }
    TBdbfork();
}

#
# When in waitmode, must put ourselves in another process group so that
# an interrupt to the parent will not have any effect on the backend.
#
if ($waitmode) {
    POSIX::setsid();
}

#
# Might not be a current run, which is okay.
#
if (defined($instance->runidx())) {
    SignalProgAgents("STOP");

    # Ug. I need to figure out how to hook into the event sequence
    # mechanism so I can use a completion event.
    print "Asking program agents to stop ... this will take a moment.\n";
    sleep(5);
    
    # This sets the stop time.
    $instance->StopCurrentRun() == 0
	or fatal(-1, "Could not stop experiment run for $instance!");

    # This runs loghole.
    print "Asking loghole to sync the logfiles ... this will take a minute.\n";
    $instance->LogHole() == 0
	or fatal(-1, "Loghole failed");

    print "Dumping the instance database ... this will take a minute.\n";
    $instance->DumpDB() == 0
	or fatal(-1, "Dump Database failed");

    #
    # Commit the archive. 
    #
    my $this_run   = $instance->CurrentRun();
    my $this_runid = $this_run->{"runid"};
    
    system("$archcontrol -t ${action}run_${this_runid} commit $pid $eid");

    # This has to be done after the archive commit, so we can find the tag.
    $instance->FinalizeCurrentRun() == 0
	or fatal(-1, "Could not finalize experiment run for $instance!");

    print "Experiment run '$this_runid' has been stopped.\n";    
}

goto done
    if ($action eq "stop");

#
# Clean/Clear if requested before generating the new run, in case there
# is a problem.
#
if ($clean) {
    # This runs loghole.
    print "Asking loghole to clean the logs ... this will take a moment.\n";
    $instance->LogClean() == 0
	or fatal(-1, "Loghole failed");

    print "Cleaning the instance database ... this will take a moment.\n";
    $instance->CleanDB() == 0
	or fatal(-1, "Dump Database failed");
}

#
# Generate a new run.
#
$instance->NewRun($runid, $description) == 0
    or fatal(-1, "Could not create new experiment run for $instance!");

#
# At this point, we need to force a cleanup no matter how we exit.
# See the END block below.
#
$justexit = 0;

#
# And the bindings for the run ...
#
if ($paramfile) {
    foreach my $name (keys(%parameters)) {
	my $value = $parameters{$name};

	$instance->NewRunBinding($name, $value) == 0
	    or fatal(-1, "Could not create new experiment run binding ".
		     "for $instance!");

        #
        # Hmm. Before we actually swapin, copy the parameters to the
        # environment table so that they are available to the program
        # agent when it starts up on the nodes (say, on reboot).
	#
	if (defined($value)) {
	    $value = DBQuoteSpecial($value);
	}
	else {
	    $value = "''";
	}
	DBQueryFatal("replace into virt_user_environment set ".
		     "   name='$name', value=$value, ".
		     "   pid='$pid', eid='$eid'");	
    }
    SignalProgAgents("RELOAD");
    # XXX Need to use a completion event!
    sleep(5);
}

#
# Restart the event stream from the beginning.
#
print "Asking the event system to replay events ...\n";
system("$eventcontrol replay $pid $eid") == 0
    or fatal(-1, "Could not restart the event system!");

print "Experiment run '$runid' has been started.\n";
done:

# Stop the web interface from spewing.
TBExptCloseLogFile($pid, $eid)
    if (defined($logname));

exit(0);

#
# Parse command arguments. Once we return from getopts, all that are
# left are the required arguments.
#
sub ParseArgs()
{
    if (! getopts($optlist, \%options)) {
	usage();
    }

    if (@ARGV != 1) {
	usage();
    }
    #
    # Pick up guid/version first and untaint.
    #
    my $tmp = shift(@ARGV);

    if ($tmp =~ /^([\w]*)\/([\d]*)$/) {
	$guid = $1;
	$version = $2;
    }
    else {
	tbdie("Bad data in argument: $tmp");
    }
    
    if (defined($options{"e"})) {
	$eid = $options{"e"};

	if ($eid =~ /^([-\w]+)$/) {
	    $eid = $1;
	}
	else {
	    tbdie("Bad data in argument: $eid.");
	}
	if (! TBcheck_dbslot($eid, "experiments", "eid",
			   TBDB_CHECKDBSLOT_WARN|TBDB_CHECKDBSLOT_ERROR)) {
	    tbdie("Improper experiment name (id)!");
	}
    }
    else {
	tberror("Must provide an experiment ID (-e option)!");
	exit(1);
    }

    if (defined($options{"r"})) {
	$runid = $options{"r"};

	if ($runid =~ /^([-\w]+)$/) {
	    $runid = $1;
	}
	else {
	    tbdie("Bad data in argument: $runid.");
	}
	if (! TBcheck_dbslot($runid, "experiments", "eid",
			   TBDB_CHECKDBSLOT_WARN|TBDB_CHECKDBSLOT_ERROR)) {
	    tbdie("Improper experiment name (id)!");
	}
    }
    
    if (defined($options{"a"})) {
	$action = $options{"a"};

	if ($action ne "start" and $action ne "stop") {
	    tbdie("Improper -a argument: $action.");
	}
	# Need the equiv of a taint check.
	if ($action =~ /^([\w]+)$/) {
	    $action = $1;
	}
    }
    else {
	tbdie("Must provide an action (-a argument)!");
    }

    if (defined($options{"q"})) {
	$quiet = 1;
    }
    if (defined($options{"w"})) {
	$waitmode = 1;
    }
    if (defined($options{"d"})) {
	$debug = 1;
    }
    if (defined($options{"c"})) {
	$clean = 1;
    }
    if (defined($options{"E"})) {
	if (! TBcheck_dbslot($options{"E"},
			     "experiment_templates", "description",
			     TBDB_CHECKDBSLOT_WARN|TBDB_CHECKDBSLOT_ERROR)) {
	    tbdie("Improper template description!");
	}
	$description = $options{"E"};
    }

    if (defined($options{"p"})) {
	my $inputfile = $options{"p"};

	# Note different taint check (allow /).
	if ($inputfile =~ /^([-\w\.\/]+)$/) {
	    $inputfile = $1;
	}
	else {
	    tbdie("Bad data in parameter file: $inputfile");
	}

	#
	# Called from ops interactively. Make sure NS file in /proj or /users.
	#
	# Use realpath to resolve any symlinks.
	#
	my $translated = `realpath $inputfile`;
	if ($translated =~ /^([-\w\.\/]+)$/) {
	    $inputfile = $1;
	}
	else {
	    tbdie("Bad data returned by realpath: $translated");
	}

	#
	# The file must reside in /proj, /groups, or /users. Since this script
	# runs as the caller, regular file permission checks ensure its a file
	# the user is allowed to use. /tmp/$pid-$eid.nsfile.XXXXX also allowed
	# since this script is invoked directly from web interface.
	#
	if (! ($inputfile =~ /^\/tmp\/[-\w]+-\d+\.xml/) &&
	    ! ($inputfile =~ /^\/tmp\/\d+\.xml/) &&
	    ! ($inputfile =~ /^\/var\/tmp\/php\w+/) &&
	    ! ($inputfile =~ /^\/proj/) &&
	    ! ($inputfile =~ /^\/groups/) &&
	    ! ($inputfile =~ /^\/users/)) {
	    tberror("$inputfile does not resolve to an allowed directory!");
	    # Note positive status; so error goes to user not tbops.
	    exit(1);
	}
	$paramfile = $inputfile;
    }
}

#
# Cleanup the mess.
#
sub cleanup()
{
    $instance->DeleteCurrentRun()
	if (defined($instance));
}

sub fatal($$)
{
    my ($errorstat, $msg) = @_;
    
    tberror $msg;
    tbinfo "Cleaning up and exiting with status $errorstat ...";

    # Stop the web interface from spewing.
    TBExptCloseLogFile($pid, $eid)
	if (defined($logname));

    #
    # This exit will drop into the END block below.
    # 
    exit($errorstat);
}

sub sighandler($) {
    my ($signame) = @_;
    
    $SIG{TERM} = 'IGNORE';
    my $pgrp = getpgrp(0);
    kill('TERM', -$pgrp);
    sleep(1);
    fatal(-1, "Caught SIG${signame}!");
}

#
# Send the new environement strings to the program agents as an event.
# This bypasses the scheduler and goes directly. Not sure if this is the
# best approach, but I like it better then restarting the agents and having
# them contact tmcd.
#
sub SignalProgAgents($)
{
    my ($action) = @_;
    
    if (!defined($handle)) {
	my $URL     = "elvin://" . TB_EVENTSERVER();
	my $keyfile = TBDB_EVENTKEY($pid, $eid);
	
	$handle = event_register_withkeyfile($URL, 0, $keyfile);
	
	fatal(-1, "Could not connect to event system!")
	    if (!$handle);
    }
    
    my $tuple = address_tuple_alloc();
    fatal(-1, "Could not allocate an address tuple\n")
	if (!$tuple);
   
    %$tuple = (host      => $event::ADDRESSTUPLE_ALL,
	       objtype   => "PROGRAM",
	       objname   => $event::ADDRESSTUPLE_ALL,
	       eventtype => $action,
	       expt      => "$pid/$eid");

    my $notification = event_notification_alloc($handle, $tuple);
    fatal(-1, "Could not allocate a notification\n")
	if (!$notification);

    if ($action eq "RELOAD") {
	# Add in the new environ strings.
	my $binding_string = "";
    
	foreach my $name (keys(%parameters)) {
	    my $value = $parameters{$name};

	    $binding_string .= "$name=$value\n";
	}

	if (! event_notification_put_string($handle, $notification,
					    "environment", $binding_string)) {
	    fatal(-1, "Could not add environment strings to notification\n")
	    }
    }
    
    if (!event_notify($handle, $notification)) {
	fatal(-1, "could not send environment event notification!");
    }
}

END {
    # Normal exit, nothing to do.
    if (!$? || $justexit) {
	return;
    }
    my $saved_exitcode = $?;
    
    if ($cleaning) {
	#
	# We are screwed; a recursive error. Someone will have to clean
	# up by hand. 
	#
	SENDMAIL($TBOPS, 
		 "Template Creation Failure: $pid/$eid",
		 "Recursive error in cleanup! This is very bad.");
	$? = $saved_exitcode;
	return;
    }
    $cleaning = 1;
    cleanup();
    $? = $saved_exitcode;
}

