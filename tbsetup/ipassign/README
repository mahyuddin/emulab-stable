Command Line Options
--------------------
This program reads from the standard input. Normally, only standard output is
written to. If there is an error, standard error is written to. Currently,
certain check results and progress messages are printed to standard error
as well. When the program is integrated with the rest of Emulab, these will
be removed.

Note that for now, the command line option should include '-c ', then either '-s ' or '-p<number> ', then one of '-h ', '-l ', or '-n '.

Example: "bin/ipassign -c -p2 -n < graph/pastry44.graph"
         Use conservative bitspace allocation for 2 partitions with
         host-to-network routing on the pastry44 graph.

Example: "bin/ipassign -c -s -h < graph/smalltern.graph"
         Use conservative bitspace allocation for square root of the # of LANs
         partitions with host-host routing on the smalltern graph


'-p#'   When calculating assignment for ip addresses, # is used to set how
        many partitions to create. Example: '-p20' would create 20 partitions.

'-ps'   Search for the proper number of partitions by running METIS repeatedly
        and scoring the result.

'-pq'   Use the square root of the number of LANs as the number of partitions.
	(default)

'-c', '-b', and '-g' modify the same behaviour. If more than one is
used, the last one used takes precedence.
!!! Always use this for now. Dynamic bitspace allocation is not yet
    implemented !!!
'-c'    Use conservative bitspace allocation. Each level of the hierarchy
        is allocated a fixed number of bits. Only takes effect alongside
	of -p or -s
#'-b'    Instead of using a single level of hierachy in which a set number
#        of partitions are used, cut the graph in half assigning each
#        half a zero or one, cut each of the resulting subgraphs in half,
#        etc. until the graph has been fully partitioned.
#        -- NOT IMPLEMENTED --
#'-g'    Partition the graph using a greedy marriage algorithm instead of
#        METIS.
#        -- NOT IMPLEMENTED --



'-h', '-l', and '-n' modify the same behaviour. If more than one is used, the
last one used takes precedence.

'-h'    When calculating the routing tables, use host-to-host routing. This
        will create one table entry for every host in the network.

'-l'    Calculate routing using host-lan routing. This will create a table
        entry for each LAN in the network.
	Note that there is a bug here which causes circular routes on large
        topologies. I am tracking it down.

'-n'    Host-to-net routing. Calculate routes using a hierarchical network
        number if possible. Otherwise use a LAN. Theoretically, this should
        produce the smallest number of routes in each routing table. (default)
        -- NOT IMPLEMENTED --

Input
-----

The input consists of a series of specifications for LANs (a link is just a
LAN with only two nodes). Each LAN is specified by the number of bits used
to represent that LAN, number representing the weight (this must be integral), 
followed by a series of integers, each one representing a node which the LAN
is connected to. The LANs are automatically numbered in order of appearance
(starting at 0). Note that the number of bits is only used for dynamic IP
assignment, which is not yet implemented. Therefore the first number is
ignored for now.

<bits> <weight> <node> <node> [node [...]]

Example graph:

8 1 0 1
8 1 0 2
8 1 1 2

This graph would contain three LANs. The first has a weight of 1, and is
connected to nodes 0 and 1. The second is also of weight 1 and is
connected to nodes 0 and 2. The third is weight 1 and connects nodes 1 and 2.

Nodes should be numbered starting at 0 and every number up to (numNodes - 1)
should have an associated node.

Output
------

Output is divided into two sections. The first section associates each node-lan
connection pair with an IP address. The second section, delimited by '%%' on
a line by itself, shows the routing table associated with each node.

<route-file> := <ip-section> "%%\n" <route-section>

<ip-section> := <ip-line>*

<ip-line> := <LAN#> " " <node#> " " <IP-address> "\n"

<route-section> := <route-table>*

<route-table> := "Routing table for node: " <node#> "\n" <route>* "%%\n"

<route> := "Destination: " <IP-address> "/" <netmask-size>
           " FirstHop: " <IP-address> "\n"

An example of the output for the above graph for host-host routing would be:

0 0 10.0.0.1
0 1 10.0.0.2
1 0 10.0.1.1
1 2 10.0.1.2
2 1 10.0.2.1
2 2 10.0.2.2
%%
Routing table for node: 0
Destination: 10.0.2.1/32 FirstHop: 10.0.0.2
Destination: 10.0.2.2/32 FirstHop: 10.0.1.2
%%
Routing table for node: 1
Destination: 10.0.1.1/32 FirstHop: 10.0.0.1
Destination: 10.0.1.2/32 FirstHop: 10.0.2.2
%%
Routing table for node: 2
Destination: 10.0.0.1/32 FirstHop: 10.0.1.1
Destination: 10.0.0.2/32 FirstHop: 10.0.2.1
%%

If there was an error, this program returns 1, otherwise it returns 0.

Process
-------

Framework -- The framework processes the command line arguments and uses
             the results to figure out what kind of ip assignment and routing
             to do. Then it takes care of populating their inputs and acts
             as an intermediary for feeding the results of ip assignment
             into the router.

ConservativeAssigner --

HostRouter --

LanRouter --

NetRouter --

Errors
------

Non-numeric and non-whitespace characters in the input are invalid.
LANs must have at least two nodes connected to them.
Input graphs should be connected

Room for Improvement
--------------------



Bugs
----

In the LAN-router, circular topologies are generated for large graphs. I am
investigating it. This is not that critical as LAN routing is not used
frequently.



