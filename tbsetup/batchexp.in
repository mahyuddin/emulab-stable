#!/usr/bin/perl -wT

#
# EMULAB-COPYRIGHT
# Copyright (c) 2000-2004 University of Utah and the Flux Group.
# All rights reserved.
#

use English;
use Getopt::Std;

#
# Create an experiment. The experiment is either run immediately, or
# placed into the batch system to be run later. If no NS file is
# supplied, an experiment shell is created (this is currently an admin
# only option).
#
# Exit codes are important; they tell the web page what has happened so
# it can say something useful to the user. Fatal errors are mostly done
# with die(), but expected errors use this routine. At some point we will
# use the DB to communicate the actual error.
#
# $status < 0 - Fatal error. Something went wrong we did not expect.
# $status = 0 - Everything okay.
# $status > 0 - Expected error. User not allowed for some reason. 
# 
sub usage()
{
    die("Usage: batchexp [-i [-f]] [-x expires] [-E description] [-g gid] ".
	"[-s] [-a <autotime>] [-l <idletime>]] [-n low|high] ".
        "-p <pid> -e <eid> [<nsfile>]\n");
}

my  $optlist = "iE:d:g:x:e:p:sa:l:n:fq";

#
# Configure variables
#
my $TB       = "@prefix@";
my $DBNAME   = "@TBDBNAME@";
my $PROJROOT = "/proj";
my $EVENTSYS = @EVENTSYS@;

#
# Testbed Support libraries
#
use lib "@prefix@/lib";
use libdb;
use libtestbed;

my $parser   = "$TB/libexec/parse-ns";
my $mkexpdir = "$TB/libexec/mkexpdir";
my $startexp = "$TB/bin/startexp";
my $tbdata   = "tbdata";
my $immediate= 0;
my $frontend = 0;
my $quiet    = 0;
my $errorstat=-1;
my $dbuid;
my @row;

#
# Turn off line buffering on output
#
$| = 1;

#
# Set umask for start/swap. We want other members in the project to be
# able to swap/end experiments, so the log and intermediate files need
# to be 664 since some are opened for append.
#
umask(0002);

#
# Untaint the path
#
# un-taint path
$ENV{'PATH'} = '/bin:/usr/bin:/usr/local/bin';
delete @ENV{'IFS', 'CDPATH', 'ENV', 'BASH_ENV'};

my $eid;
my $pid;
my $gid;
my $description;
my $expires;
my $tempnsfile;
my $swappable = 0;
my $idleswap = 0;
my $idleswaptime = 60 * TBGetSiteVar("idle/threshold");
my $autoswap = 0;
my $autoswaptime = 10 * 60;
my $idleignore = 0;
my $priority   = TB_EXPTPRIORITY_LOW;
my $exptstate  = EXPTSTATE_NEW();

#
# Verify user and get his DB uid.
#
if (! UNIX2DBUID($UID, \$dbuid)) {
    die("*** $0:\n".
        "    You do not exist in the Emulab Database!\n");
}

#
# Parse command arguments.
#
ParseArgs();

#
# Sanity check them.
#
if (!defined($pid) || !defined($eid)) {
    usage();
}
if (!defined($gid)) {
    $gid = $pid;
}
if (defined($description)) {
    $description = DBQuoteSpecial($description);
}
else {
    $description = "'Created by $dbuid'";
}
if (! defined($expires)) {
    $expires = DBDateTime(60 * 60 * 24 * 30);
}
if (!defined($tempnsfile) && !TBAdmin($dbuid)) {
    die("*** $0:\n".
	"    Only admins can create experiments with no NS file\n");
}
$nsfile = "$eid.ns";

#
# Make sure UID is allowed to create experiments in this project.
#
if (! TBProjAccessCheck($dbuid, $pid, $gid, TB_PROJECT_CREATEEXPT)) {
    die("*** $0:\n".
	"    You do not have permission to create experiments in $pid/$gid\n");
}

#
# If no NS file, then override swap/idle stuff. Again, might change
# when new forms installed
#
if (!defined($tempnsfile)) {
    $swappable     = 0;
    $idleswap      = 0;
}
elsif (! -f $tempnsfile || ! -r $tempnsfile) {
    # Exit so that user sees the error, not us.
    print STDERR "*** $0:\n".
	         "    $tempnsfile does not exist or is not a readable file!\n";
    exit(1);
}

#
# Batch jobs get a shorter idle time
#
my $swaptime = $idleswaptime;
if (!$immediate && TBSiteVarExists("idle/batch_threshold")) {
    my $batchidleswaptime = TBGetSiteVar("idle/batch_threshold");
    if ($swaptime > $batchidleswaptime) {
	$swaptime = $batchidleswaptime;
    }
}

#
# Grab me a secret key for accessing tar/rpm files via the web interface.
# Grab another secret key for the event system HMACs.
#
my $webkey   = TBGenSecretKey();
my $eventkey = TBGenSecretKey();

#
# Create an experiment record. The pid/eid has to be unique, so lock the
# table for the check/insert.
#
DBQueryFatal("lock tables experiments write");

$query_result =
    DBQueryFatal("SELECT pid,eid FROM experiments ".
		 "WHERE eid='$eid' and pid='$pid'");

if ($query_result->numrows) {
    DBQueryWarn("unlock tables");
    die("*** $0:\n".
        "    Experiment $eid in project $pid already exists!\n");
}

#
# Insert the record. This reserves the pid/eid for us. If its a batchmode
# experiment, we will update the record later so that the batch daemon
# will recognize it. We insert the record as locked and ACTIVATING so that
# no one can mess with the experiment until later. 
#
if (! DBQueryWarn("INSERT INTO experiments ".
		  "(eid, pid, gid, expt_created, expt_expires, expt_name,".
		  " expt_head_uid,expt_swap_uid, state, priority, swappable,".
		  " idleswap, idleswap_timeout, autoswap, autoswap_timeout,".
		  " idle_ignore, keyhash, expt_locked, eventkey) ".
		  "VALUES ('$eid', '$pid', '$gid', now(), '$expires', ".
		  "$description,'$dbuid', '$dbuid', '$exptstate', $priority, ".
		  "$swappable, $idleswap, '$swaptime', $autoswap, ".
		  "'$autoswaptime', $idleignore, '$webkey', ".
		  "now(), '$eventkey')")) {
    DBQueryWarn("unlock tables");
    die("*** $0:\n".
	"    Database error inserting record for $pid/$eid!\n");
}

if (! DBQueryWarn("unlock tables")) {
    fatal("Unexpected DB Error!");
}

#
# Create an experiment_resources record for the above record.
#
if (! DBQueryWarn("insert into experiment_resources (idx, tstamp, exptidx) ".
		  "select 0, now(), idx from experiments ".
		  "where pid='$pid' and eid='$eid'")) {
    DBQueryWarn("unlock tables");
    fatal("DB error inserting experiment resources record for $pid/$eid!\n");
}

#
# Now create an experiment_stats record to match.
#
if (! DBQueryWarn("insert into experiment_stats ".
		  "(eid, pid, creator, gid, created, batch, exptidx,rsrcidx) ".
		  "select '$eid', '$pid', '$dbuid', '$gid', now(), ".
		  ($immediate ? 0 : 1) .
		  ", e.idx,r.idx from experiments as e ".
		  "left join experiment_resources as r on e.idx=r.exptidx ".
		  "where pid='$pid' and eid='$eid'")) {
    DBQueryWarn("unlock tables");
    fatal("DB error inserting experiment stats record for $pid/$eid!\n");
}

#
# Create a directory structure for the experiment.
#
if (system("$mkexpdir $pid $gid $eid") != 0) {
    fatal("$mkexpdir failed");
}

#
# Dump the eventkey into a file in the experiment directory. 
#
if ($EVENTSYS) {
    open(KEY, ">" . TBDB_EVENTKEY($pid, $eid)) or
	fatal("Could not create eventkey file: $!");
    print KEY $eventkey;
    close(KEY);
}

# And dump the web key too.
open(KEY, ">" . TBDB_WEBKEY($pid, $eid)) or
    fatal("Could not create webkey file: $!");
print KEY $webkey;
close(KEY);

#
# If no NS file, we are done. We must unlock it and reset its state
# appropriately. We leave the experiment in the "new" state so that
# the user is forced to do a modify first (to give it a topology). 
#
if (!defined($tempnsfile)) {
    TBUnLockExp($pid, $eid, EXPTSTATE_NEW());
    exit(0);
}

#
# Grab the working directory path, and thats where we work.
# The user's experiment directory is off in /proj space.
#
my $workdir = TBExptWorkDir($pid, $eid);

chdir("$workdir") or
    fatal("Could not chdir to $workdir: $!");

#
# Now we can get the NS file!
#
if (system("/bin/cp", "$tempnsfile", "$nsfile")) {
    fatal("Could not copy $tempnsfile to $workdir/$nsfile");
}
chmod(0664, "$nsfile");

#
# Run parse in impotent mode on the NS file.  This has no effect but
# will display any errors.
#
if (system("$parser -n $pid $gid $eid $nsfile") != 0) {
    # Obey exit status protocol for web page.
    $errorstat = 1;
    fatal("NS Parse failed!");
}

#
# A batch experiment is essentially preloaded (frontend mode) and then
# dropped into the batch queue, unless the user requested only preload.
# Startexp figures all this out, and in fact this script could easily
# be merged with startexp. Note that we call startexp with the experiment
# locked, and it checks to make sure. 
#
my $optargs = "";
$optargs .= " -f"
    if ($frontend);
$optargs .= " -b"
    if ($quiet);

if (system("$startexp $optargs -g $gid $pid $eid $nsfile")) {
    # Obey exit status protocol for web page.
    $errorstat = 1;
    fatal("Failed to start experiment $pid/$eid!");
}
exit(0);

sub fatal($)
{
    my($mesg) = $_[0];

    print STDOUT "*** $0:\n";
    print STDOUT "    $mesg\n";

    #
    # Generally, we do not delete the stats/resource record, but if we
    # failed at this point, no point in keeping the record. Just a
    # waste of space since the testbed_stats log indicates there was a
    # failure and why (sorta, via the exit code).
    #
    if (($query_result =
	 DBQueryWarn("select idx from experiments ".
		     "where pid='$pid' and eid='$eid'"))) {

	my ($idx) = $query_result->fetchrow_array;

	if (defined($idx) && $idx) {
	    DBQueryWarn("DELETE from experiment_stats ".
			"WHERE eid='$eid' and pid='$pid' and exptidx=$idx");
	    DBQueryWarn("DELETE from experiment_resources ".
			"WHERE exptidx=$idx");
	}
    }

    #
    # Clear the record and cleanup.
    #
    TBExptDestroy($pid, $eid);

    exit($errorstat);
}

#
# Parse command arguments. Once we return from getopts, all that should
# left are the required arguments.
#
sub ParseArgs()
{
    my %options = ();
    if (! getopts($optlist, \%options)) {
	usage();
    }

    if (@ARGV > 1) {
	usage();
    }
    if (@ARGV == 1) {
	$tempnsfile = $ARGV[0];

	# Note different taint check (allow /).
	if ($tempnsfile =~ /^([-\@\w\.\/]+)$/) {
	    $tempnsfile = $1;
	}
	else {
	    fatal("Bad data in argument: $tempnsfile");
	}
    }

    if (defined($options{"i"})) {
	$immediate = 1;
    }
    if (defined($options{"f"})) {
	$frontend = 1;
    }
    if (defined($options{"p"})) {
	$pid = $options{"p"};

	if ($pid =~ /^([-\@\w]+)$/) {
	    $pid = $1;
	}
	else {
	    die("Bad data in argument: $pid.");
	}
    }
    if (defined($options{"e"})) {
	$eid = $options{"e"};

	if ($eid =~ /^([-\@\w]+)$/) {
	    $eid = $1;
	}
	else {
	    die("Bad data in argument: $eid.");
	}
    }
    if (defined($options{"g"})) {
	$gid = $options{"g"};

	if ($gid =~ /^([-\@\w]+)$/) {
	    $gid = $1;
	}
	else {
	    die("Bad data in argument: $gid.");
	}
    }
    if (defined($options{"x"})) {
	$expires = $options{"x"};
    }
    if (defined($options{"E"})) {
	$description = $options{"E"};
    }
    if (defined($options{"s"})) {
	$swappable = 1;
    }
    if (defined($options{"l"})) {
        $idleswap = 1;
	$idleswaptime = $options{"l"};
	(($idleswaptime =~ /^\d+$/) &&
         ($idleswaptime > 0)) or die("Bad idleswap time: '$idleswaptime'");
    }
    if (defined($options{"a"})) {
        $autoswap = 1;
	$autoswaptime = $options{"a"};
	(($autoswaptime =~ /^\d+$/) &&
         ($autoswaptime > 0)) or die("Bad autoswap time: '$autoswaptime'");
    }
    if (defined($options{"q"})) {
	$quiet = 1;
    }
    if (defined($options{"n"})) {
	if ($options{"n"} eq "low") {
	    $priority = TB_EXPTPRIORITY_LOW;
	}
	elsif ($options{"n"} eq "high") {
	    $priority = TB_EXPTPRIORITY_HIGH;
	}
	else {
	    usage();
	}
    }
}
