#!/usr/bin/perl -wT
#
# EMULAB-COPYRIGHT
# Copyright (c) 2000-2004 University of Utah and the Flux Group.
# All rights reserved.
#
use English;
use Getopt::Std;
use POSIX qw(isatty setsid);
use POSIX qw(strftime);

#
# Create an experiment. The experiment is either run immediately, or
# placed into the batch system to be run later. If no NS file is
# supplied, an experiment shell is created (this is currently an admin
# only option).
#
# TODO: Remove expt_expires and priority.
#       Add calls to check_slot() to verify inputs.
# 
# Exit codes are important; they tell the web page what has happened so
# it can say something useful to the user. Fatal errors are mostly done
# with die(), but expected errors use this routine. At some point we will
# use the DB to communicate the actual error.
#
# $status < 0 - Fatal error. Something went wrong we did not expect.
# $status = 0 - Everything okay.
# $status > 0 - Expected error. User not allowed for some reason. 
# 
sub usage()
{
    print(STDERR
	  "Usage: batchexp [-q] [-i [-w]] [-f] [-E description] [-g gid]\n".
	  "                [-S reason] [-L reason] [-a <time>] [-l <time>]\n".
	  "                -p <pid> -e <eid> <nsfile>\n".
	  "switches and arguments:\n".
	  "-i       - swapin immediately; by default experiment is batched\n".
	  "-w       - wait for non-batchmode experiment to preload or swapin\n".
	  "-f       - preload experiment (do not swapin or queue yet)\n".
	  "-q       - be less chatty\n".
	  "-S <str> - Experiment cannot be swapped; must provide reason\n".
	  "-L <str> - Experiment cannot be IDLE swapped; must provide reason\n".
	  "-a <nnn> - Auto swapout nnn minutes after experiment is swapped in\n".
	  "-l <nnn> - Auto swapout nnn minutes after experiment goes idle\n".
	  "-E <str> - A pithy sentence describing your experiment\n".
	  "-p <pid> - The project in which to create the experiment\n".
	  "-g <gid> - The group in which to create the experiment\n".
	  "-e <eid> - The experiment name (unique, alphanumeric, no blanks)\n".
	  "<nsfile> - NS file to parse for experiment.\n");
    exit(-1);
}

my $optlist = "iE:g:e:p:S:L:a:l:fwqt:";
my $batchmode= 1;
my $frontend = 0;
my $waitmode = 0;
my $quiet    = 0;
my $linktest = 0;	# non-zero means level to run at.

#
# Configure variables
#
my $TB       = "@prefix@";
my $PROJROOT = "/proj";
my $EVENTSYS = @EVENTSYS@;
my $TBOPS    = "@TBOPSEMAIL@";
my $TBLOGS   = "@TBLOGSEMAIL@";
my $TBDOCBASE = "@TBDOCBASE@";
my $TBBASE   = "@TBBASE@";

#
# Testbed Support libraries
#
use lib "@prefix@/lib";
use libdb;
use libtestbed;

my $parser   = "$TB/libexec/parse-ns";
my $mkexpdir = "$TB/libexec/mkexpdir";
my $tbbindir = "$TB/bin/";
my $errorstat=-1;
my $user_name;
my $user_email;
my $dbuid;

# Be careful not to exit on transient error; 0 means infinite retry.
$libdb::DBQUERY_MAXTRIES = 0;

# For the END block below.
my $cleaning = 0;
my $justexit = 1;
my $signaled = 0;

#
# Turn off line buffering on output
#
$| = 1;

#
# Set umask for start/swap. We want other members in the project to be
# able to swap/end experiments, so the log and intermediate files need
# to be 664 since some are opened for append.
#
umask(0002);

#
# Untaint the path
#
# un-taint path
$ENV{'PATH'} = '/bin:/usr/bin:/usr/local/bin';
delete @ENV{'IFS', 'CDPATH', 'ENV', 'BASH_ENV'};

my $eid;
my $pid;
my $gid;
my $description;
my $tempnsfile;
my $swappable    = 1;
my $noswap_reason;
my $idleswap     = 1;
my $idleswaptime = 60 * TBGetSiteVar("idle/threshold");
my $noidleswap_reason;
my $autoswap     = 0;
my $autoswaptime = 10 * 60;
my $idleignore   = 0;
my $priority     = TB_EXPTPRIORITY_LOW;
my $exptstate    = EXPTSTATE_NEW();
my $now          = localtime();
my $committed    = 0;

#
# Verify user and get his DB uid.
#
if (! UNIX2DBUID($UID, \$dbuid)) {
    die("*** $0:\n".
        "    You do not exist in the Emulab Database!\n");
}

#
# Get email info for user.
#
if (! UserDBInfo($dbuid, \$user_name, \$user_email)) {
    die("*** $0:\n".
        "    Cannot determine your name and email address.\n");
}

#
# Parse command arguments.
#
ParseArgs();

#
# Sanity check them.
#
if (!defined($pid) || !defined($eid)) {
    usage();
}
if (!defined($gid)) {
    $gid = $pid;
}
if (!defined($description)) {
    $description = "'Created by $dbuid'";
}
if (! $swappable && (!defined($noswap_reason) || $noswap_reason eq "")) {
    die("Must provide a reason with -S option (not swappable reason)!\n");
}
if (! $idleswap && (!defined($noidleswap_reason) || $noidleswap_reason eq "")) {
    die("Must provide a reason with -L option (no idleswap reason)!\n");
}
if (!defined($tempnsfile) && !TBAdmin($dbuid)) {
    die("*** $0:\n".
	"    Only admins can create experiments with no NS file\n");
}
my $nsfile  = "$eid.ns";
my $repfile = "$eid.report";

# Defaults for the DB and for the email message. 
$noswap_reason = "'None Given'"
    if (!defined($noswap_reason));
$noidleswap_reason = "'None Given'"
    if (!defined($noidleswap_reason));

#
# Make sure UID is allowed to create experiments in this project.
#
if (! TBProjAccessCheck($dbuid, $pid, $gid, TB_PROJECT_CREATEEXPT)) {
    die("*** $0:\n".
	"    You do not have permission to create experiments in $pid/$gid\n");
}

#
# If no NS file, then override swap/idle stuff. Again, might change
# when new forms installed
#
if (!defined($tempnsfile)) {
    $swappable     = 0;
    $idleswap      = 0;
}
elsif (! -f $tempnsfile || ! -r $tempnsfile || -z $tempnsfile) {
    # Exit so that user sees the error, not us.
    print STDERR "*** $0:\n".
	         "    $tempnsfile does not exist or is not a readable file!\n";
    exit(1);
}

#
# Batch jobs get a shorter idle time
#
my $swaptime = $idleswaptime;
if ($batchmode && TBSiteVarExists("idle/batch_threshold")) {
    my $batchidleswaptime = TBGetSiteVar("idle/batch_threshold");
    if ($swaptime > $batchidleswaptime) {
	$swaptime = $batchidleswaptime;
    }
}

#
# Grab me a secret key for accessing tar/rpm files via the web interface.
# Grab another secret key for the event system HMACs.
#
my $webkey   = TBGenSecretKey();
my $eventkey = TBGenSecretKey();

#
# In wait mode, block SIGINT until we spin off the background process.
#
if ($waitmode) {
    $SIG{QUIT} = 'IGNORE';
    $SIG{TERM} = 'IGNORE';
    $SIG{INT}  = 'IGNORE';
}

#
# Create an experiment record. The pid/eid has to be unique, so lock the
# table for the check/insert.
#
DBQueryFatal("lock tables experiments write, ".
	     "            experiment_stats write, ".
	     "            experiment_resources write, ".
	     "            testbed_stats read");

$query_result =
    DBQueryFatal("SELECT pid,eid FROM experiments ".
		 "WHERE eid='$eid' and pid='$pid'");

if ($query_result->numrows) {
    DBQueryWarn("unlock tables");
    die("*** $0:\n".
        "    Experiment $eid in project $pid already exists!\n");
}

#
# Grab the next highest index to use. We used to use an auto_increment
# field in the table, but if the DB is ever "dropped" and recreated,
# it will reuse indicies that are crossed referenced in the other two
# tables.
#
$query_result =
    DBQueryFatal("select MAX(exptidx) from experiment_stats");
my ($exptidx) = $query_result->fetchrow_array();
$exptidx++;

#
# Lets be really sure!
#
foreach my $table ("experiments", "experiment_stats", "experiment_resources",
		   "testbed_stats") {

    my $slot = (($table eq "experiments") ? "idx" : "exptidx");
	
    $query_result =
	DBQueryFatal("select * from $table where ${slot}=$exptidx");
    
    if ($query_result->numrows) {
	DBQueryWarn("unlock tables");
	die("*** $0:\n".
	    "    Experiment index $exptidx exists in $table; this is bad!\n");
    }
}

#
# Insert the record. This reserves the pid/eid for us. If its a batchmode
# experiment, we will update the record later so that the batch daemon
# will recognize it. We insert the record as locked and ACTIVATING so that
# no one can mess with the experiment until later. 
#
if (! DBQueryWarn("INSERT INTO experiments ".
		  "(idx, eid, pid, gid, expt_created, expt_name,".
		  " expt_head_uid,expt_swap_uid, state, priority, swappable,".
		  " idleswap, idleswap_timeout, autoswap, autoswap_timeout,".
		  " idle_ignore, keyhash, expt_locked, eventkey,".
		  " noswap_reason, noidleswap_reason, batchmode, ".
		  " linktest_level) ".
		  "VALUES ($exptidx, '$eid', '$pid', '$gid', now(), ".
		  "$description,'$dbuid', '$dbuid', '$exptstate', $priority, ".
		  "$swappable, $idleswap, '$swaptime', $autoswap, ".
		  "'$autoswaptime', $idleignore, '$webkey', ".
		  "now(), '$eventkey', $noswap_reason, ".
		  "$noidleswap_reason, $batchmode, $linktest)")) {
    DBQueryWarn("unlock tables");
    die("*** $0:\n".
	"    DB error inserting experiment record for $pid/$eid!\n");
}

#
# Create an experiment_resources record for the above record.
#
$query_result =
    DBQueryWarn("insert into experiment_resources (tstamp, exptidx) ".
		"values (now(), $exptidx)");

if (!$query_result) {
    DBQueryWarn("delete from experiments where pid='$pid' and eid='$eid'");
    DBQueryWarn("unlock tables");
    die("*** $0:\n".
	"    DB error inserting experiment resources record for $pid/$eid!");
}
my $rsrcidx = $query_result->insertid;

#
# Now create an experiment_stats record to match.
#
if (! DBQueryWarn("insert into experiment_stats ".
		  "(eid, pid, creator, gid, created, batch, exptidx, rsrcidx) ".
		  "values('$eid', '$pid', '$dbuid', '$gid', now(), ".
		  "$batchmode, $exptidx, $rsrcidx)")) {
    DBQueryWarn("delete from experiments where pid='$pid' and eid='$eid'");
    DBQueryWarn("delete from experiment_resources where idx=$rsrcidx");
    DBQueryWarn("unlock tables");
    die("*** $0:\n".
	"    DB error inserting experiment stats record for $pid/$eid!");
}

if (! DBQueryWarn("unlock tables")) {
    DBQueryWarn("delete from experiments where pid='$pid' and eid='$eid'");
    DBQueryWarn("delete from experiment_resources where idx=$rsrcidx");
    DBQueryWarn("delete from experiment_stats where exptidx=$exptidx");
    die("*** $0:\n".
	"    DB error unlocking tables!");
}

#
# At this point, we need to force a cleanup no matter how we exit.
# See the END block below.
#
$justexit = 0;

#
# Create a directory structure for the experiment.
#
if (system("$mkexpdir $pid $gid $eid") != 0) {
    fatal("$mkexpdir failed");
}

#
# Dump the eventkey into a file in the experiment directory. 
#
if ($EVENTSYS) {
    open(KEY, ">" . TBDB_EVENTKEY($pid, $eid)) or
	fatal("Could not create eventkey file: $!");
    print KEY $eventkey;
    close(KEY);
}

# And dump the web key too.
open(KEY, ">" . TBDB_WEBKEY($pid, $eid)) or
    fatal("Could not create webkey file: $!");
print KEY $webkey;
close(KEY);

#
# If no NS file, we are done. We must unlock it and reset its state
# appropriately. We leave the experiment in the "new" state so that
# the user is forced to do a modify first (to give it a topology). 
#
if (!defined($tempnsfile)) {
    TBUnLockExp($pid, $eid, EXPTSTATE_NEW());
    exit(0);
}

#
# Grab the working directory path, and thats where we work.
# The user's experiment directory is off in /proj space.
#
my $workdir = TBExptWorkDir($pid, $eid);
my $userdir = TBExptUserDir($pid, $eid);

chdir("$workdir") or
    fatal("Could not chdir to $workdir: $!");

#
# Now we can get the NS file!
#
if (system("/bin/cp", "$tempnsfile", "$nsfile")) {
    fatal("Could not copy $tempnsfile to $workdir/$nsfile");
}
chmod(0664, "$nsfile");

#
# Run parse in impotent mode on the NS file.  This has no effect but
# will display any errors.
#
if (system("$parser -n $pid $gid $eid $nsfile") != 0) {
    # Obey exit status protocol for web page.
    $errorstat = 1;
    fatal("NS Parse failed!");
}

#
# Gather statistics; start the clock ticking.
#
if ($frontend || $batchmode) {
    GatherSwapStats($pid, $eid, $dbuid, TBDB_STATS_PRELOAD, 0,
		    TBDB_STATS_FLAGS_START);
}
else {
    GatherSwapStats($pid, $eid, $dbuid, TBDB_STATS_START, 0,
		    TBDB_STATS_FLAGS_START);
}

#
# The rest of this goes into the background so that the user sees
# immediate response. We will send email later when the experiment
# is ready. In waitmode, we hold the parent waiting so that the user
# can script it. Must protect against async (^C) termination though.
#
my $logname = TBExptCreateLogFile($pid, $eid, "startexp");
TBExptSetLogFile($pid, $eid, $logname);
TBExptOpenLogFile($pid, $eid);
    
if (my $childpid = TBBackGround($logname)) {
    #
    # Parent exits normally, unless in waitmode. We have to set
    # justexit to make sure the END block below does not run.
    #
    $justexit = 1;
    
    if (!$waitmode) {
	print("Experiment $pid/$eid is now configuring\n".
 	      "You will be notified via email when the experiment is ".
	      "ready to use\n")
	    if (! $quiet);
	exit(0);
    }
    print("Waiting for " . ($batchmode ? "batch " : "") . "experiment $eid ".
	  "to finish " . ($frontend ? "preloading." : "swapping in.") . "\n")
	if (! $quiet);

    if (isatty(STDIN) && !$quiet) {
	print("You may type ^C at anytime; you will be notified via email.\n".
	      "You will not actually interrupt the experiment itself.\n");
    }

    # Give child a chance to run.
    select(undef, undef, undef, 0.25);
	
    #
    # Reset signal handlers. User can now kill this process, without
    # stopping the child.
    #
    $SIG{TERM} = 'DEFAULT';
    $SIG{QUIT} = 'DEFAULT';
    $SIG{INT}  = 'DEFAULT';

    #
    # Wait until child exits or until user gets bored and types ^C.
    #
    waitpid($childpid, 0);

    print("Done. Exited with status: $?\n")
	if (! $quiet);
    exit($? >> 8);
}
TBdbfork();

# We are committed now. Affects how fatal() operates.
$committed = 1;

#
# When in waitmode, must put ourselves in another process group so that
# an interrupt to the parent will not have any effect on the backend.
#
if ($waitmode) {
    POSIX::setsid();
}

#
# We need to catch TERM cause sometimes shit happens and we have to kill
# an experiment setup that is hung or otherwise scrogged. Rather then 
# trying to kill off the children one by one, lets arrange to catch it
# here and send a killpg to the children. This is not to be done lightly,
# cause it can leave things worse then they were before!
#
sub handler ($) {
    my ($signame) = @_;
    
    $SIG{TERM} = 'IGNORE';
    my $pgrp = getpgrp(0);
    kill('TERM', -$pgrp);
    sleep(1);
    $signaled = 1;
    fatal("Caught SIG${signame}! Killing experiment setup ...");
}
$SIG{TERM} = \&handler;
$SIG{QUIT} = 'DEFAULT';

#
# The guts of starting an experiment!
#
# A batch experiment is essentially preloaded (frontend mode) and then
# dropped into the batch queue, unless the user requested only preload.
#

#
# Run the various scripts. We want to propagate the error from tbprerun
# and tbrun back out, hence the bogus looking errorstat variable.
#
SetExpState($pid, $eid, EXPTSTATE_PRERUN)
    or fatal("Failed to set experiment state to " . EXPTSTATE_PRERUN());
print "Running 'tbprerun $pid $eid $nsfile'\n";
if (system("$tbbindir/tbprerun $pid $eid $nsfile") != 0) {
    $errorstat = $? >> 8;
    fatal("tbprerun failed!");
}
SetExpState($pid, $eid, EXPTSTATE_SWAPPED)
    or fatal("Failed to set experiment state to " . EXPTSTATE_SWAPPED());

#
# If not in frontend mode (preload only) continue to swapping exp in.
# 
if (! ($frontend || $batchmode)) {
    SetExpState($pid, $eid, EXPTSTATE_ACTIVATING)
	or fatal("Failed to set experiment state to ". EXPTSTATE_ACTIVATING());

    print "Running 'tbswap in $pid $eid'\n";
    if (system("$tbbindir/tbswap in $pid $eid") != 0) {
	$errorstat = $? >> 8;
	fatal("tbswap in failed!");
    }
    SetExpState($pid, $eid, EXPTSTATE_ACTIVE)
	or fatal("Failed to set experiment state to " . EXPTSTATE_ACTIVE());

    #
    # Look for the unsual case of more than 2 nodes and no vlans. Send a
    # warning message.
    #
    my @localnodes = ExpNodes($pid, $eid, 1);
    
    if (defined(@localnodes) && scalar(@localnodes) > 2) {
	my $vlans_result =
	    DBQueryFatal("select pid from virt_lans ".
			 "where pid='$pid' and eid='$eid'");
    
	if (!$vlans_result->numrows) {
	    SENDMAIL("$user_name <$user_email>",
		     "WARNING: Experiment Configuration: $pid/$eid",
		     "This experiment has zero network links defined.\n".
		     "Please check your NS file to verify this is what you ".
		     "want!\n",
		     "$user_name <$user_email>",
		     "Cc: $TBOPS", ($nsfile));
	}
    }
}

# We append this report in the email message below.
if (system("$tbbindir/tbreport -b $pid $eid 2>&1 > $repfile") != 0) {
    fatal("tbreport failed!");
}

#
# Try to copy off the files for testbed information gathering.
#
TBSaveExpLogFiles($pid, $eid);

#
# Make a copy of the work dir in the user visible space so the user
# can see the log files.
#
system("cp -Rfp $workdir/ $userdir/tbdata");

#
# Deal with linktest. If requested, swapping in or modifying, and experiment
# is indeed active, then run it!
#
# XXX - linktest uses files from $userdir/tbdata/, so the above cp must
#       happen first!
#
if ($linktest && ExpState($pid, $eid) eq EXPTSTATE_ACTIVE) {
    #
    # Run it. No worries about failures.
    #
    my $output = "linktest.$$";
    my $optarg = "-o $output";

    if ($linktest =~ /^(\d)$/) {
	$optarg .= " -l $1";
    }
    else {
	$optarg .= " -l 1";
    }
    
    print "Running 'linktest_control $optarg $pid $eid'\n";
    if (system("$TB/sbin/linktest_control $optarg $pid $eid") != 0) {
	system("cat $output")
	    if (-r $output);
	
	print STDERR "*** WARNING: ".
	             "Linktest run returned non-zero status!\n";
	
	SENDMAIL("$user_name <$user_email>",
		 "Linktest Failure: $pid/$eid",
		 "Failure in linktest (level $linktest); ".
		 "returned non-zero status",
		 "$user_name <$user_email>",
		 "Cc: $TBOPS",
		 ($output));
    }
}

#
# Gather statistics.
#
if ($frontend || $batchmode) {
    GatherSwapStats($pid, $eid, $dbuid, TBDB_STATS_PRELOAD, 0);
}
else {
    GatherSwapStats($pid, $eid, $dbuid, TBDB_STATS_START, 0);
}

#
# Close up the log file so the webpage stops.
#
TBExptCloseLogFile($pid, $eid);

#
# Must unlock and drop batch experiments into the queue before exit.
#
if ($batchmode && !$frontend) {
    TBUnLockExp($pid, $eid, EXPTSTATE_QUEUED());
}
else {
    TBUnLockExp($pid, $eid);
}

#
# Clear the cancel flag now that the operation is complete. Must be
# done after we change the experiment state (above).
#
TBSetCancelFlag($pid, $eid, EXPTCANCEL_CLEAR());

#
# Dump the report file and the log file to the user via email. 
#
# Yuck, we want the created time that mysql assigned at the insertion.
#
$query_result =
    DBQueryFatal("select expt_created from experiments ".
		 "where pid='$pid' and eid='$eid'");
my ($expt_created) = $query_result->fetchrow_array();
my $message;

if ($frontend) {
    $message =
	"Your experiment `$eid' in project `$pid' has been created.\n" .
	"You can check the web interface to see if it looks the way\n" .
	"you expected it to. If so, you may swap the experiment in,\n" .
	"or terminate it, at any time.\n" .
        "\n";
}
else {
    $message =
	"Your experiment `$eid' in project `$pid' has been started.\n" .
	"Here is the experiment summary detailing the nodes that were\n" .
	"allocated to you. You may use the `Qualified Name' to log on\n" .
	"to your nodes. See /etc/hosts on your nodes (when running\n" .
	"FreeBSD, Linux, or NetBSD) for the IP mapping on each node.\n" .
        "\n";
}
$message .=
    "User:        $user_name\n" .
    "EID:         $eid\n" .
    "PID:         $pid\n" .
    "GID:         $gid\n" .
    "Description: $description\n" .
    "Swappable:   " . ($swappable ? "Yes\n" :
		                    "No  (Reason: $noswap_reason)\n") .
    "Idle-Swap:   " . ($idleswap  ? "Yes, at " . $idleswaptime/60.0 . " hours\n":
		                    "No  (Reason: $noidleswap_reason)\n") .
    "Auto-Swap:   " . ($autoswap  ? "Yes, at " . $autoswaptime/60.0 . " hours\n":
		                    "No\n") .
    "Created:     $expt_created\n".
    "Directory:   $userdir\n".
    "\n".
    "Appended at the end is the output of the experiment setup. If you\n" .
    "have any questions or comments, please include the output below\n" .
    "in your message to $TBOPS";

SENDMAIL("$user_name <$user_email>",
	 "New Experiment " . (($frontend == 0) ? "Started" : "Created") .
	 ": $pid/$eid",
	 $message,
	 "$user_name <$user_email>",
	 "Bcc: $TBLOGS",
	 ($repfile, $logname, $nsfile));

# Done!
exit(0);

#
#
#
sub cleanup()
{
    #
    # Failed early (say, in parsing). No point in keeping any of the
    # stats or resource records. Just a waste of space since the
    # testbed_stats log indicates there was a failure and why (sorta,
    # via the exit code).
    # 
    if (!$committed) {
	#
	# Clear the experiment record and cleanup directories
	#
	TBExptDestroy($pid, $eid);

	#
	# Now we can clean up the stats records. 
	#
	DBQueryWarn("DELETE from experiment_resources ".
		    "WHERE idx=$rsrcidx");
	
	DBQueryWarn("DELETE from testbed_stats ".
		    "WHERE exptidx=$exptidx");

	# This must be last cause it provides the unique exptidx above.
	DBQueryWarn("DELETE from experiment_stats ".
		    "WHERE eid='$eid' and pid='$pid' and exptidx=$exptidx");

	return;
    }

    #
    # Gather statistics.
    #
    if ($frontend) {
	GatherSwapStats($pid, $eid, $dbuid, TBDB_STATS_PRELOAD, $errorstat);
    }
    else {
	GatherSwapStats($pid, $eid, $dbuid, TBDB_STATS_START, $errorstat);
    }

    #
    # Must clean up the experiment if it made it our of NEW state.
    #
    my $estate = ExpState($pid, $eid);
    if ($estate ne EXPTSTATE_NEW) {
	#
	# We do not know exactly where things stopped, so if the
	# experiment was activating when the signal was delivered,
	# run tbswap on it. 
	# 
	if ($estate eq EXPTSTATE_ACTIVE ||
	    ($estate eq EXPTSTATE_ACTIVATING && $signaled)) {
	    print "Running 'tbswap out -force $pid $eid'\n";
	    if (system("$tbbindir/tbswap out -force $pid $eid") != 0) {
		print "tbswap out failed!\n";
	    }
	    SetExpState($pid, $eid, EXPTSTATE_SWAPPED);
	}
	
	print "Running 'tbend -force $pid $eid'\n";
	if (system("$tbbindir/tbend -force $pid $eid") != 0) {
	    print "tbend failed!\n";
	}
    }
    SetExpState($pid, $eid, EXPTSTATE_TERMINATED);

    #
    # Okay, we *are* going to terminate the experiment.
    # 
    GatherSwapStats($pid, $eid, $dbuid, TBDB_STATS_TERMINATE, 0);

    # Clear the logfile so the webpage stops. 
    TBExptClearLogFile($pid, $eid);

    #
    # Send a message to the testbed list. 
    #
    SENDMAIL("$user_name <$user_email>",
	 "Experiment Configure Failure: $pid/$eid",
	 "Please look at the log below to see what happened. If the error\n".
	 "resulted from a lack of free nodes, you can use this web page to\n".
	 "get a summary of free nodes:\n\n".
	 "  ${TBBASE}/nodecontrol_list.php3\n".
	 "\n".
	 "Please do not try again until you see enough nodes free. Or, you\n".
	 "can use the batch system to swap your experiment in when enough\n".
	 "nodes are free:\n\n".
	 "  ${TBDOCBASE}/tutorial/docwrapper.php3?docname=tutorial.html".
	     "#BatchMode\n",
	 "$user_name <$user_email>",
	 "Cc: $TBOPS",
	 ($logname, "assign.log", "wanassign.log", $nsfile));

    #
    # Back up the work dir for post-mortem debugging. 
    #
    system("/bin/rm -rf  ${workdir}-failed");
    system("/bin/mv -f   $workdir ${workdir}-failed");

    #
    # Clear the record and cleanup.
    # 
    TBExptDestroy($pid, $eid);    
}

#
# Parse command arguments. Once we return from getopts, all that should
# left are the required arguments.
#
sub ParseArgs()
{
    my %options = ();
    if (! getopts($optlist, \%options)) {
	usage();
    }

    if (@ARGV > 1) {
	usage();
    }
    if (@ARGV == 1) {
	$tempnsfile = $ARGV[0];

	# Note different taint check (allow /).
	if ($tempnsfile =~ /^([-\w\.\/]+)$/) {
	    $tempnsfile = $1;
	}
	else {
	    die("*** $0:\n".
		"    Bad data in nsfile: $tempnsfile\n");
	}

	#
	# Called from ops interactively. Make sure NS file in /proj or /users.
	#
	# Use realpath to resolve any symlinks.
	#
	my $translated = `realpath $tempnsfile`;
	if ($translated =~ /^([-\w\.\/]+)$/) {
	    $tempnsfile = $1;
	}
	else {
	    die("*** $0:\n".
		"    Bad data returned by realpath: $translated\n");
	}

	#
	# The file must reside in /proj, /groups, or /users. Since this script
	# runs as the caller, regular file permission checks ensure its a file
	# the user is allowed to use. /tmp/$pid-$eid.nsfile.XXXXX also allowed
	# since this script is invoked directly from web interface.
	#
	if (! ($tempnsfile =~ /^\/tmp\/[-\w]+-\d+\.nsfile/) &&
	    ! ($tempnsfile =~ /^\/var\/tmp\/php\w+/) &&
	    ! ($tempnsfile =~ /^\/proj/) &&
	    ! ($tempnsfile =~ /^\/groups/) &&
	    ! ($tempnsfile =~ /^\/users/)) {
	    print STDERR
		"*** $0:\n".
		"    $tempnsfile does not resolve to an allowed directory!\n";
	    # Note positive status; so error goes to user not tbops.
	    exit(1);
	}
    }
    
    if (defined($options{"i"})) {
	$batchmode = 0;
    }
    if (defined($options{"f"})) {
	$frontend = 1;
    }
    if (defined($options{"q"})) {
	$quiet = 1;
    }

    #
    # pid,eid,gid get passed along as shell commands args; must taint check.
    # 
    if (defined($options{"p"})) {
	$pid = $options{"p"};

	if ($pid =~ /^([-\w]+)$/) {
	    $pid = $1;
	}
	else {
	    die("Bad data in argument: $pid.");
	}
    }
    if (defined($options{"e"})) {
	$eid = $options{"e"};

	if ($eid =~ /^([-\w]+)$/) {
	    $eid = $1;
	}
	else {
	    die("Bad data in argument: $eid.");
	}
	if (! TBcheck_dbslot($eid, "experiments", "eid",
			   TBDB_CHECKDBSLOT_WARN|TBDB_CHECKDBSLOT_ERROR)) {
	    die("Improper experiment name (id)!\n");
	}
    }
    if (defined($options{"g"})) {
	$gid = $options{"g"};

	if ($gid =~ /^([-\w]+)$/) {
	    $gid = $1;
	}
	else {
	    die("Bad data in argument: $gid.");
	}
    }
    if (defined($options{"E"})) {
	if (! TBcheck_dbslot($options{"E"}, "experiments", "expt_name",
			   TBDB_CHECKDBSLOT_WARN|TBDB_CHECKDBSLOT_ERROR)) {
	    die("Improper experiment description!\n");
	}
	$description = DBQuoteSpecial($options{"E"});
    }
    if (defined($options{"S"})) {
	if (! TBcheck_dbslot($options{"S"}, "experiments", "noswap_reason",
			   TBDB_CHECKDBSLOT_WARN|TBDB_CHECKDBSLOT_ERROR)) {
	    die("Improper noswap reason!\n");
	}
	$swappable     = 0;
	$noswap_reason = DBQuoteSpecial($options{"S"});
    }
    if (defined($options{"L"})) {
	if (! TBcheck_dbslot($options{"L"}, "experiments", "noidleswap_reason",
			   TBDB_CHECKDBSLOT_WARN|TBDB_CHECKDBSLOT_ERROR)) {
	    die("Improper noidleswap reason!\n");
	}
	$idleswap          = 0;
	$noidleswap_reason = DBQuoteSpecial($options{"L"});
    }
    if (defined($options{"l"})) {
	if (! TBcheck_dbslot($options{"l"}, "experiments", "idleswap_timeout",
			   TBDB_CHECKDBSLOT_WARN|TBDB_CHECKDBSLOT_ERROR)) {
	    die("Improper idleswap timeout!\n");
	}
        $idleswap     = 1;
	$idleswaptime = $options{"l"};
    }
    if (defined($options{"a"})) {
	if (! TBcheck_dbslot($options{"a"}, "experiments", "autoswap_timeout",
			   TBDB_CHECKDBSLOT_WARN|TBDB_CHECKDBSLOT_ERROR)) {
	    die("Improper autoswap timeout!\n");
	}
        $autoswap     = 1;
	$autoswaptime = $options{"a"};
    }
    if (defined($options{"t"})) {
	if (! TBcheck_dbslot($options{"t"}, "experiments", "linktest_level",
			   TBDB_CHECKDBSLOT_WARN|TBDB_CHECKDBSLOT_ERROR)) {
	    die("Improper linktest level!\n");
	}
	$linktest = $options{"t"};
    }
    if (defined($options{"w"})) {
	$waitmode = 1;
    }
}

#
# We need this END block to make sure that we clean up after a fatal
# exit in the library. This is problematic, cause we could be exiting
# cause the mysql server has gone whacky again. 
#
sub fatal($)
{
    my($mesg) = $_[0];

    print "*** $0:\n";
    print "    $mesg\n";
    print "Cleaning up and exiting with status $errorstat ...\n";

    #
    # This exit will drop into the END block below.
    # 
    exit($errorstat);
}

END {
    # Normal exit, nothing to do.
    if (!$? || $justexit) {
	return;
    }
    my $saved_exitcode = $?;
    
    if ($cleaning) {
	#
	# We are screwed; a recursive error. Someone will have to clean
	# up by hand. 
	#
	SENDMAIL(TBOPS, 
		 "Experiment Configure Failure: $pid/$eid",
		 "Recursive error in cleanup! This is very bad.");
	$? = $saved_exitcode;
	return;
    }
    $cleaning = 1;
    cleanup();
    $? = $saved_exitcode;
}

