#!/usr/bin/perl -wT
#
# EMULAB-COPYRIGHT
# Copyright (c) 2000-2008 University of Utah and the Flux Group.
# All rights reserved.
#
# Osload library. Basically the backend to the osload script, but also used
# where we need finer control of loading of nodes.
#
package libosload;

use strict;
use Exporter;
use vars qw(@ISA @EXPORT);

@ISA    = "Exporter";
@EXPORT = qw ( osload osload_wait osload_setupswapinfo );

# Must come after package declaration!
use lib '@prefix@/lib';
use libtestbed; # for TBGenSecretKey();
use libdb;
use libreboot;
use libtblog;
use Node;
use NodeType;
use Image;
use User;
use OSinfo;
use English;
use File::stat;
use IO::Handle;

# Configure variables
my $TB		= "@prefix@";
my $TESTMODE    = @TESTMODE@;
my $TBOPS       = "@TBOPSEMAIL@";
my $ELABINELAB  = @ELABINELAB@;
my $PROJROOT    = "@PROJROOT_DIR@";

# Max number of retries (per node) before its deemed fatal. This allows
# for the occasional pxeboot failure.
my $MAXRETRIES  = 1;

my $FRISBEELAUNCHER = "$TB/sbin/frisbeelauncher";
my $osselect	    = "$TB/bin/os_select";
my $TBUISP	    = "$TB/bin/tbuisp";

# Locals
my %imageinfo       = ();	# Per imageid DB info.
my $debug           = 0;
my %children        = ();	# Child pids in when asyncmode=1

sub osload ($$) {
    my ($args, $result) = @_;

    # These come in from the caller.
    my $imageid;
    my $waitmode    = 1;
    my @nodes       = ();
    my $noreboot    = 0;
    my $asyncmode   = 0;
    my $zerofree    = 0;
    my $swapinfo    = 0;

    # Locals
    my %retries	    = ();
    my $failures    = 0;
    my $usedefault  = 1;
    my $mereuser    = 0;
    my $rowref;
    my $image;
    my $this_user;

    if (!defined($args->{'nodelist'})) {
	tberror "Must supply a node list!"; # INTERNAL
	return -1;
    }
    @nodes = sort(@{ $args->{'nodelist'} });
    
    if (defined($args->{'waitmode'})) {
	$waitmode = $args->{'waitmode'};
    }
    if (defined($args->{'noreboot'})) {
	$noreboot = $args->{'noreboot'};
    }
    if (defined($args->{'debug'})) {
	$debug = $args->{'debug'};
    }
    if (defined($args->{'imageid'})) {
	$imageid    = $args->{'imageid'};
	$usedefault = 0;
    }
    if (defined($args->{'asyncmode'})) {
	$asyncmode = $args->{'asyncmode'};
    }
    if (defined($args->{'zerofree'})) {
	$zerofree = $args->{'zerofree'};
    }

    if (defined($args->{'swapinfo'})) {
	$swapinfo = $args->{'swapinfo'};
    }

    #
    # Start a new logging sub-process
    #
    my $old_env = \%ENV;
    local %ENV;
    copy_hash %ENV, $old_env;
    tblog_sub_process("osload", @nodes);

    #
    # Figure out who called us. Root and admin types can do whatever they
    # want. Normal users can only change nodes in experiments in their
    # own projects.
    #
    if ($UID) {
	$this_user = User->ThisUser();
	return -1
	    if (!defined($this_user));

	if (!$this_user->IsAdmin()) {
	    $mereuser = 1;

	    if (! TBNodeAccessCheck($UID, TB_NODEACCESS_LOADIMAGE, @nodes)) {
		tberror("Not enough permission to load images on one or ".
			"more nodes!");
		return -1;
	    }
	}
    }

    if (defined($imageid)) {
	$image = Image->Lookup($imageid);
	if (!defined($image)) {
	    tberror("Could not map $imageid to its object!");
	    return -1;
	}
    }

    #
    # Check permission to use the imageid.
    # 
    if (defined($image) && $mereuser &&
	! $image->AccessCheck($this_user, TB_IMAGEID_READINFO)) {
	tberror "You do not have permission to load $image";
	return -1;
    }

    #
    # If there's a maxiumum number of concurrent loads listed for the image,
    # check to see if we'll go over the limit, by checking to see how many
    # other nodes are currently booting thie image's default_osid. This is
    # NOT intended to be strong enforcement of license restrictions, just a
    # way to catch mistakes.
    #
    if (defined($image) &&
	!TBImageLoadMaxOkay($image->imageid(), scalar(@nodes), @nodes)) {
	tberror 
	    "Would exceed maxiumum concurrent instances ".
		"limitation for $image";
	return -1;
    }

    #
    # This is somewhat hackish. To promote parallelism during os_setup, we
    # want to fork off the osload from the parent so it can do other things.
    # The problem is how to return status via the results vector. Well,
    # lets do it with some simple IPC. Since the results vector is simply
    # a hash of node name to an integer value, its easy to pass that back.
    #
    # We return the pid to the caller, which it can wait on either directly
    # or by calling back into this library if it wants to actually get the
    # results from the child!
    # 
    if ($asyncmode) {
	#
	# Create a pipe to read back results from the child we will create.
	#
	my $PARENT_READER = new IO::Handle; # Need a new handle for each child
	if (! pipe($PARENT_READER, CHILD_WRITER)) {
	    tberror "creating pipe: $!";
	    return -1;
	}
	CHILD_WRITER->autoflush(1);

	if (my $childpid = fork()) {
	    close(CHILD_WRITER);
	    $children{$childpid} = [ $PARENT_READER, $result ];
	    return $childpid;
	}
	#
	# Child keeps going. 
	#
	close($PARENT_READER);
	TBdbfork();
    }

    # This will store information about each node, so that if we have to try
    # again later, we'll have it all.
    my %reload_info;

    # Loop for each node.
    foreach my $node (@nodes) {
	# All nodes start out as being successful; altered later as needed.
	$result->{$node} = 0;

	my $nodeobject = Node->Lookup($node);
	if (!defined($nodeobject)) {
	    tberror "$node: Could not map to object!";
	    goto failednode;
	}
	
	# Get default imageid for this node.
	my $default_imageid = $nodeobject->default_imageid();
	if (! defined($default_imageid)) {
	    tberror "$node: No default imageid defined!";
	    goto failednode;
	}
	my $default_image = Image->Lookup($default_imageid);
	if (!defined($default_image)) {
	    tberror("Could not map $default_imageid to its object!");
	    return -1;
	}
	
	if ($usedefault) {
	    $imageid = $default_imageid;
	    $image   = $default_image;
	}

	print STDERR "osload: Using $image for $node\n"
	    if $debug;

	#
	# We try to avoid repeated queries to DB for info that does not change
	# by caching the image info on the first use.  GetImageInfo() will
	# perform various one-time checks as well.
	# 
	if (!exists($imageinfo{$imageid}) && !GetImageInfo($image, $node)) {
	    goto failednode;
	}
	$rowref = $imageinfo{$imageid};
	if ($rowref eq 'BADIMAGE') {
	    goto failednode;
	}

	my $loadpart       = $rowref->{'loadpart'};
	my $loadlen        = $rowref->{'loadlength'};
	my $imagepath      = $rowref->{'path'};
	my $defosid        = $rowref->{'default_osid'};
	my $maxwait	   = $rowref->{'maxloadwait'};
	my $imagepid	   = $rowref->{'pid'};
	my $access_key	   = $rowref->{'access_key'};

	my $osinfo = OSinfo->Lookup($defosid);
	if (!defined($osinfo)) {
	    tberror("Could map map OSID $defosid to its object!");
	    goto failednode;
	}

	print "osload ($node): Changing default OS to $osinfo\n";
	if (!$TESTMODE) {
	    system("$osselect $defosid $node");
	    if ($?) {
		tberror "$node: os_select $defosid failed!";
		goto failednode;
	    }
	}

	#
	# If loading an image (which is not the default) then schedule
	# a reload for it so that when the experiment is terminated it
	# will get a fresh default image before getting reallocated to
	# another experiment.
	#
	if ($imageid ne $default_imageid &&
	    $nodeobject->SetSchedReload($default_image) != 0) {
	    tberror
		"$node: Could not schedule default reload";
	    goto failednode;
	}

	#
	# XXX assumes a DOS MBR, but this is ingrained in the DB schema
	# as well (i.e., the images.part[1234]_osid fields).
	#
	my $MINPART = 1;
	my $MAXPART = 4;

	#
	# Assign partition table entries for each partition in the image
	# that has an OSID associated with it.
	#
	# This is complicated by the fact that an image that covers only
	# part of the slices should only change the partition table entries
	# for the subset of slices that are written to disk...
	#
	# ...UNLESS, the new image requires a different version of the MBR
	# in which case we must invalidate all partitions except the ones we
	# are loading since the partition boundaries may have changed.
	#
	my $startpart = $loadpart == 0 ? $MINPART : $loadpart;
	my $endpart   = $startpart + $loadlen;
	
	for (my $i = $MINPART; $i <= $MAXPART; $i++) {
	    my $partname = "part${i}_osid";
	    my $dbresult;
	    
	    #
	    # Partition is outside the range affected by this image.
	    # Normally, we just leave it alone, unless a change of MBR
	    # is implied by the current image.
	    #
	    if ($i < $startpart || $i >= $endpart) {
		if (defined($rowref->{'mbr_version'})) {
		    $dbresult =
			DBQueryWarn("select mbr_version ".
				    " from partitions as p,images as i ".
				    " where p.imageid=i.imageid ".
				    " and node_id='$node' and partition='$i'");
		    if ($dbresult && $dbresult->numrows) {
			my ($pmbr) = $dbresult->fetchrow_array();
			if ($pmbr != $rowref->{'mbr_version'}) {
			    tbwarn("$node: Existing partition $i inconsistent".
				   " with new image partitioning,".
				   " invalidating existing partition");
			    $dbresult =
				DBQueryWarn("delete from partitions ".
					    "where node_id='$node' and ".
					    "partition='$i'");
			    if (!$dbresult) {
				tberror("$node: Could not update ".
					"partition table");
				goto failednode;
			    }
			}
		    }
		}
		next;
	    }

	    #
	    # This image has an OSID in the current partition,
	    # replace the partition table info.
	    #
	    if (defined($rowref->{$partname})) {
		my $osid = $rowref->{$partname};
		
		$dbresult =
		    DBQueryWarn("replace into partitions ".
				"(node_id,partition,osid,imageid,imagepid) ".
				"values ".
				"('$node','$i','$osid','$imageid','$imagepid')");
	    }
	    #
	    # Otherwise, if there is no OS for a particular image partition,
	    # clear any current partitions table info.
	    #
	    else {
		$dbresult =
		    DBQueryWarn("delete from partitions ".
				"where node_id='$node' and partition='$i'");
	    }
	    if (!$dbresult) {
		tberror "$node: Could not update partition table";
		goto failednode;
	    }
	}

	#
	# Setup swapinfo now after partitions have initialized but before
	# we setup the one-shot frisbee load.
	#
	if ($swapinfo) {
	    print "osload: Updating image signature.\n";
	    osload_setupswapinfo(undef, undef, $node);
	}

	#
	# Determine which mode to use for reloading this node (note: this may
	# become an entry in node_capabilities or something like that in the
	# future - that would be cleaner)
	#
	my $type  = $nodeobject->type();
	my $class = $nodeobject->class();
	my $reload_mode;
	my $reload_func;
	my $reboot_required;
	if ($class eq "mote") {
	    $reload_mode = "UISP";
	    $reload_func = \&SetupReloadUISP;
	    $reboot_required = 0; # We don't reboot motes to reload them
	    $zerofree = 0; # and we don't zero "the disk"
	} else {
	    $reload_mode = "Frisbee";
	    $reload_func = \&SetupReloadFrisbee;
	    $reboot_required = !$noreboot; # Reboot unless $noreboot flag set

	    # This is passed along so that remote node can request the file.
	    # Make sure the image object has an access key defined.
	    if ($nodeobject->isremotenode() && !defined($access_key)) {
		$access_key = TBGenSecretKey();

		$rowref->{'access_key'} = $access_key;
		if ($image->Update({'access_key' => $access_key}) != 0) {
		    tberror "$node: Could not initialize image access key";
		    goto failednode;
		}
	    }
	}

	#
	# Remember this stuff so that if we have to retry this node again
	# later, we'll know how to handle it
	#
	$reload_info{$node} = {
	    'node'    => $node,
	    'mode'    => $reload_mode,
	    'func'    => $reload_func,
	    'imageid' => $imageid,
	    'osid'    => $defosid,
	    'reboot'  => $reboot_required,
	    'zerofree'=> $zerofree,
	    'maxwait' => $maxwait
	};

	print "Setting up reload for $node (mode: $reload_mode)\n";

	if (!$TESTMODE) {
	    if (&$reload_func($reload_info{$node}) < 0) {
		tberror("$node: Could not set up reload. Skipping.");
		goto failednode;
	    }
	}
	next;
	
      failednode:
	$result->{$node} = -1;
	$failures++;
    }
    
    #
    # Remove any failed nodes from the list we are going to operate on.
    #
    my @temp = ();
    foreach my $node (@nodes) {
	push(@temp, $node)
	    if (! $result->{$node});
    }
    @nodes = @temp;

    # Exit if not doing an actual reload.
    if ($TESTMODE) {
	print "osload: Stopping in Testmode!\n";
	goto done;
    }

    if (! @nodes) {
	tbnotice "Stopping because of previous failures!";
	goto done;
    }

    # Fire off a mass reboot and quit if not in waitmode.
    if (! $waitmode) {
	my ($reboot_nodes, $noreboot_nodes)
	    = GetNodesRequiringReboot(\%reload_info, keys(%reload_info));
	if (@$reboot_nodes) {
	    print "osload: Rebooting nodes.\n";

	    my %reboot_args     = ();
	    my %reboot_failures = ();

	    $reboot_args{'debug'}    = $debug;
	    $reboot_args{'waitmode'} = 0;
	    $reboot_args{'nodelist'} = [ @$reboot_nodes ];

	    if (nodereboot(\%reboot_args, \%reboot_failures)) {
		foreach my $node (@$reboot_nodes) {
		    if ($reboot_failures{$node}) {
			$result->{$node} = $reboot_failures{$node};
			$failures++;
		    }
		}
	    }
	}
	goto done;
    }

    #
    # The retry vector is initialized to the number of retries we allow per
    # node, afterwhich its a fatal error.
    #
    foreach my $node (@nodes) {
	$retries{$node} = $MAXRETRIES;
    }
    
    while (@nodes) {
	my ($reboot_nodes, $noreboot_nodes)
	    = GetNodesRequiringReboot(\%reload_info, @nodes);
	if (@$reboot_nodes) {
	    # Reboot them all.
	    print "osload: Issuing reboot for @$reboot_nodes and then waiting ...\n";
	    
	    my %reboot_args     = ();
	    my %reboot_failures = ();

	    $reboot_args{'debug'}    = $debug;
	    $reboot_args{'waitmode'} = 0;
	    $reboot_args{'nodelist'} = [ @$reboot_nodes ];

	    if (nodereboot(\%reboot_args, \%reboot_failures)) {
		#
		# If we get any failures in the reboot, we want to
		# alter the list of nodes accordingly for the next phase.
		# 
		my @temp = ();
		
		foreach my $node (@$reboot_nodes) {
		    if ($reboot_failures{$node}) {
			$result->{$node} = $reboot_failures{$node};
			$failures++;
		    }
		    else {
			push(@temp, $node);
		    }
		}
		@nodes = (@temp,@$noreboot_nodes);
	    }
	}

	# Now wait for them.
	my $startwait   = time;
	my @failednodes = WaitTillReloadDone($startwait,
					     $waitmode,
					     \%reload_info, 
					     @nodes);
	@nodes=();
    
	while (@failednodes) {
	    my $node = shift(@failednodes);

	    if ($retries{$node}) {
		tbnotice "$node: Trying again ...";

		my $reload_info = $reload_info{$node};

		# Possible race with reboot?
		if (&{$reload_info->{'func'}}($reload_info) < 0) {
		    tberror("$node: Could not set up reload. Skipping.");
		    $result->{$node} = -1;
		    $failures++;
		    next;
		}
		push(@nodes, $node);

		# Retry until count hits zero.
		$retries{$node} -= 1;
	    }
	    else {
		tberror ({sublevel => -1}, 
			 "$node failed to boot too many times. Skipping!");
		$result->{$node} = -1;
		$failures++;
	    }
	}
    }
  done:
    print "osload: Done! There were $failures failures.\n";

    if ($asyncmode) {
	#
	# We are a child. Send back the results to the parent side
	# and *exit* with status instead of returning it.
	# 
	foreach my $node (keys(%{ $result })) {
	    my $status = $result->{$node};
	    
	    print CHILD_WRITER "$node,$status\n";
	}
	close(CHILD_WRITER);
	exit($failures);
    }
    return $failures;
}

#
# Fetch information for a specified image the first time it is used
# (for the indicated node).  This info is cached for use by all other
# nodes that require the image.  Returns 1 on success, 0 on failure.
#
sub GetImageInfo($;$)
{
    my ($image, $node) = @_;

    my $imageid = $image->imageid();
    my $rowref  = $image->DBData();
    if (!defined($rowref)) {
	tberror("No DBData for $image!");
	$imageinfo{$imageid} = 'BADIMAGE';
	return 0;
    }
    $imageinfo{$imageid} = $rowref;

    my $imagepath = $rowref->{'path'};

    #
    # Perform a few validity checks: imageid should have a file name
    # and that file should exist.
    #
    if (!defined($imagepath)) {
	tberror "No filename associated with $image!";
	$imageinfo{$imageid} = 'BADIMAGE';
	return 0;
    }

    if (! -R $imagepath) {
	if ($ELABINELAB) {
	    #
	    # Yuck. See if we can get it via frisbeelauncher before giving up.
	    #
	    system("$FRISBEELAUNCHER " . ($debug ? "-d ": "") . "$imageid");
	    if ($?) {
		tberror "Frisbeelauncher ($image) failed!";
		$imageinfo{$imageid} = 'BADIMAGE';
		return 0;
	    }
	    if (! -R $imagepath) {
		tberror	"Frisbeelauncher could not fetch $imagepath ($image)!";
		$imageinfo{$imageid} = 'BADIMAGE';
		return 0;
	    }
	}
	else {
	    tberror "$imagepath does not exist or cannot be read!";
	    $imageinfo{$imageid} = 'BADIMAGE';
	    return 0;
	}
    }

    my $sb = stat($imagepath);

    #
    # A zero-length image cannot be right and will result in much confusion
    # if allowed to pass: the image load will succeed, but the disk will be
    # unchanged, making it appear that os_load loaded the default image.
    #
    if ($sb->size == 0) {
	tberror "$imagepath is empty!";
	$imageinfo{$imageid} = 'BADIMAGE';
	return 0;
    }

    #
    # Compute a maxwait time based on the image size plus a constant
    # factor for the reboot cycle.  This is used later in
    # WaitTillReloadDone().  Arguably, this should be part of the
    # image DB state, so we store it in the imageinfo array too.
    #
    if (!defined($rowref->{'maxloadwait'})) {
	my $chunks = $sb->size >> 20; # size may be > 2^31, shift is unsigned

	$rowref->{'maxloadwait'} = int((($chunks / 100.0) * 65) + (5 * 60));
    }

    print STDERR
	"$image: loadpart=", $rowref->{'loadpart'},
	", loadlen=", $rowref->{'loadlength'},
	", imagepath=", $rowref->{'path'},
	", defosid=", $rowref->{'default_osid'},
	", maxloadwait=", $rowref->{'maxloadwait'}, "\n"
	    if ($debug);

    return 1;
}

# Wait for a reload to finish by watching its state
sub WaitTillReloadDone($$$@)
{
    my ($startwait, $waitmode, $reload_info, @nodes) = @_;
    my %done	= ();
    my $count   = @nodes;
    my @failed  = ();

    foreach my $node ( @nodes ) { $done{$node}  = 0; }

    print STDERR "Waiting for @nodes to finish reloading\n".`date` if $debug;

    # Start a counter going, relative to the time we rebooted the first
    # node.
    my $waittime  = 0;
    my $minutes   = 0;

    while ($count) {
	# Wait first to make sure reboot is done, and so that we don't
	# wait one more time after everyone is up.
	sleep(5);
	foreach my $node (@nodes) {
	    if (! $done{$node}) {
		my $maxwait;

		#
		# If we have to zero fill free space, then the
		# wait time has to be proportional to the disk
		# size.  In other words, a really, really, really
		# long time.  Lets assume 20MB/sec to blast zeros,
		# so 50 seconds/GB.  What the heck, lets call it
		# 1GB/minute.  Did I mention how this would take
		# a really long time?
		#
		if ($reload_info->{$node}{'zerofree'}) {
		    my $nodeobject = Node->Lookup($node);
		    my $disksize   = $nodeobject->disksize();

		    $disksize = 20
			if (!$disksize);
		    $maxwait = ($disksize * 60);
		} else {
		    $maxwait = $reload_info->{$node}{'maxwait'};
		}
		
		my $query_result =
		    DBQueryWarn("select * from current_reloads ".
				"where node_id='$node'");

		#
		# There is no point in quitting if this query fails. Just
		# try again in a little bit.
		# 
		if (!$query_result) {
		    tbwarn "$node: Query failed; waiting a bit.";
		    next;
		}

		#
		# We simply wait for stated to clear the current_reloads entry.
		#
		if (!$query_result->numrows) {
		    print STDERR "osload ($node): left reloading mode at ".`date`
			if ($debug);
		    
		    $count--;
		    $done{$node} = 1;
		    next;
		}
	
		# Soon we will have stated's timeouts take care of
		# rebooting once or twice if we get stuck during
		# reloading.
		$waittime = time - $startwait;
		if ($waittime > $maxwait) {
		    my $t = (int ($waittime / 60));
		    tbnotice "$node appears wedged; ".
			"it has been $t minutes since it was rebooted.";
		    TBNodeConsoleTail($node, *STDERR);

		    $count--;
		    $done{$node} = $waitmode;
		    push(@failed, $node);
		    next;
		}
		if (int($waittime / 60) > $minutes) {
		    $minutes = int($waittime / 60);
		    print STDERR "osload ($node): still waiting; ".
			"it has been $minutes minute(s)\n";
		}
	    }
	}
    }

    if ($waitmode > 1) {
	$count = @nodes - @failed;
	$startwait = time;
	while ($count) {
	    foreach my $node (@nodes) {
		print STDERR "osload ($node): waiting for node to finish ".
		    "booting\n";
		if ($done{$node} < $waitmode) {
		    my $actual_state;

		    if (!TBNodeStateWait($node,
					 $startwait,
					 (60*6),
					 \$actual_state,
					 (TBDB_NODESTATE_TBFAILED,
					  TBDB_NODESTATE_ISUP))) {
			$count--;
			$done{$node} = $waitmode;
		    }
		}
	    }
	}
    }

    return @failed;
}

# Setup a reload. 
sub SetupReloadFrisbee($)
{
    my $reload_info   = $_[0];
    my $node          = $reload_info->{'node'};
    my $imageid       = $reload_info->{'imageid'};
    my $zerofree      = $reload_info->{'zerofree'};
    my $osid          = TBNodeDiskloadOSID($node);

    #
    # Put it in the current_reloads table so that nodes can find out which
    # OS to load. See tmcd. 
    #
    my $query_result = 
	DBQueryWarn("replace into current_reloads ".
		    "(node_id, image_id, mustwipe) values ".
		    "('$node', '$imageid', $zerofree)");
    return -1
	if (!$query_result);

    system("$osselect -1 $osid $node");
    if ($?) {
	tberror "os_select $osid failed!";
	return -1;
    }
    system("$FRISBEELAUNCHER " . ($debug ? "-d ": "") . "$imageid");
    if ($?) {
	tberror "Frisbee Launcher ($imageid) failed!";
	return -1;
    }
    return 0;
}

#
# Setup a reload, using USIP (for motes), rather than Frisbee. Note that
# this differs from a Frisbee reload in one key way - it does the reload
# right here in this code, rather than setting up a reload for later.
#
sub SetupReloadUISP($)
{
    my $reload_info   = $_[0];
    my $node          = $reload_info->{'node'};
    my $imageid       = $reload_info->{'imageid'};
    my $osid          = $reload_info->{'osid'};

    #
    # Get the path to the image
    #
    my $query_result = DBQueryFatal("select path from images " .
	"where imageid='$imageid'");
    if ($query_result->num_rows() != 1) {
	tberror "Failed to get path for $imageid!";
	return -1;
    }
    my ($path) = $query_result->fetchrow();

    #
    # Tell stated that we're about to start reloading
    #
    TBSetNodeNextOpMode($node,TBDB_NODEOPMODE_RELOADMOTE);

    #
    # The mote goes 'down', then starts to reload
    #
    TBSetNodeEventState($node,TBDB_NODESTATE_SHUTDOWN);
    TBSetNodeEventState($node,TBDB_NODESTATE_RELOADING);

    #
    # Okay, just run tbuisp with that path
    #
    my $rv = system("$TBUISP upload $path $node");
    if ($rv) {
	tberror "$node: tbuisp failed";
	return -1;
    }

    #
    # Tell stated that we've finished reloading the node
    #
    TBSetNodeEventState($node,TBDB_NODESTATE_RELOADDONE);

    system("$osselect $osid $node");
    if ($?) {
	tberror "os_select $osid failed!";
	goto failednode;
    }

    #
    # 'Reboot' the node (from stated's perspective, anyway)
    # has been shutdown, so that the os_select will take effect
    #
    TBSetNodeEventState($node,TBDB_NODESTATE_SHUTDOWN);

    return 0;
}

#
# Return two array references (possbily empty) of:
# [all nodes requiring reboot, all nodes not requiring reboot]
#
sub GetNodesRequiringReboot($@) {
    my ($reload_info, @nodes) = @_;
    my (@reboot, @noreboot);
    foreach my $node (@nodes) {
	if ($reload_info->{$node}{'reboot'}) {
	    push @reboot, $node;
	} else {
	    push @noreboot, $node;
	}
    }
    return (\@reboot, \@noreboot);
}

#
# This gets called in the parent, to wait for an async osload that was
# launched earlier (asyncmode). The child will print the results back
# on the the pipe that was opened between the parent and child. They
# are stuffed into the original results array.
# 
sub osload_wait($)
{
    my ($childpid) = @_;

    if (!exists($children{$childpid})) {
	tberror "No such child pid $childpid!"; # INTERNAL
	return -1;
    }
    my ($PARENT_READER, $result) = @{ $children{$childpid}};

    #
    # Read back the results.
    # 
    while (<$PARENT_READER>) {
	chomp($_);

	if ($_ =~ /^([-\w]+),([-\d])+$/) {
	    $result->{$1} = $2;
	    print STDERR "reload ($1): child returned $2 status.\n";
	}
	else {
	    tberror "Improper response from child: $_"; # INTERNAL
	}
    }
    
    #
    # And get the actual exit status.
    # 
    waitpid($childpid, 0);
    return $? >> 8;
}

#
# Save signature files and boot partition info for all nodes in an experiment
# (or just the listed nodes).  We call this when swapping in an experiment or
# when reloading nodes in an experiment.
#
# Note that this is not strictly an os loading function, we do it on swapins
# of nodes which already have the correct OS as well.  But we stick it here
# because it is about os loading in principle.
#
sub osload_setupswapinfo($$;@)
{
    my ($pid, $eid, @nodelist) = @_;
    my %nodeinfo = ();
    my $allnodes;
    my $clause = "";

    if (!@nodelist) {
	@nodelist = ExpNodes($pid, $eid, 1, 0);
	$clause .= "r.pid='$pid' and r.eid='$eid'";
	$allnodes = 1;
    } else {
	$clause .= "r.node_id in (" . join(",", map("'$_'", @nodelist)) . ")";
	$allnodes = 0;
    }
    map { $nodeinfo{$_} = 0 } @nodelist;

    # XXX only know how to do this for local PCs right now
    $clause .= " and nt.class='pc' and nt.isremotenode=0";

    #
    # Note that we are using the def_boot_osid from the nodes table to identify
    # the image of interest.  This is because the osid field is set by stated
    # after a node has reached the BOOTING state the first time, and may be
    # set to an MFS at other times.
    #
    my $query_result = DBQueryWarn(
	"select r.node_id,r.vname,r.pid,r.eid,r.erole,n.osid,p.partition,p.imageid,p.imagepid,i.imagename,i.loadpart,e.savedisk ".
	"from reserved as r ".
	"left join nodes as n on n.node_id=r.node_id ".
	"left join node_types as nt on nt.type=n.type ".
	"left join partitions as p on p.node_id=n.node_id and p.osid=n.def_boot_osid ".
        "left join images as i on i.imageid=p.imageid ".
        "left join experiments as e on e.pid=r.pid and e.eid=r.eid ".
	"where $clause");
    if (!$query_result) {
	return 1;
    }

    while (my ($node, $vname, $rpid, $reid, $erole, $osid, $part, $imageid,
	       $imagepid, $imagename, $lpart, $savedisk) =
	   $query_result->fetchrow_array()) {

	my $nodeobject = Node->Lookup($node);

	# If the node is not imageable, skip it.
	next
	    if (! $nodeobject->imageable());
	
	my $dtype = $nodeobject->disktype();
	my $dunit = $nodeobject->bootdisk_unit();

	#
	# XXX not a disk-based OSID.  This can happen during frisbee loads
	#
	if (!defined($imageid)) {
	    print "*** swapinfo: OS $osid is not disk-based!?\n";
	    next
		if (!$allnodes);
	    return 1;
	}

	#
	# Weed out otherwise ineligible nodes:
	#	- from experiments that are not saving disk state
	#	- non-'node' role machines (i.e., delaynodes, virthosts)
	# They are removed from nodeinfo entirely so we do not complain about
	# them below.  This is the only reason we are doing this here rather
	# than as part of the above query.
	#
	if (!defined($savedisk) || $savedisk == 0 || $erole ne "node") {
	    delete $nodeinfo{$node};
	    next;
	}

	# Sanity checks
	if (!defined($nodeinfo{$node})) {
	    next
		if (!$allnodes);
	    print "*** swapinfo: Got partition info for invalid node $node!?\n";
	    return 1;
	}
	if ($nodeinfo{$node} != 0) {
	    print "*** swapinfo: Got redundant partition info for $node!?\n";
	    return 1;
	}

	my $disk = "$dtype$dunit";
	$nodeinfo{$node} =
	    [$vname, $rpid, $reid, $disk, $part, $imagepid, $imagename, $lpart];
    }

    #
    # Copy over the signature file for the image used on every node under
    # the name <vname>.sig.  Likewise, we record the partition that the
    # image resides in under <vname>.part.
    #
    # Note that we actually copy the signature over as <imagename>.sig and
    # then symlink the <vname>.sig's to it.  This not only saves space,
    # but makes it easier to determine what is loaded on each node.
    #
    # Finally note that we are using imagename rather than imageid (which
    # is a numeric UUID).  The latter is really closer to what we want, but
    # was added later and needs to be reconciled with our idea of 'unique'
    # (the signature).
    #
    my %gotsig = ();
    for my $node (keys(%nodeinfo)) {
	my $infop = $nodeinfo{$node};
	if ($infop == 0) {
	    print "*** swapinfo: WARNING: got no partition info for $node!\n";
	    next;
	}
	my ($vname, $rpid, $reid, $disk, $part, $imagepid, $imagename, $lpart) = @{$infop};

	#
	# If imageid is not "fully qualified" with the project name,
	# generate a name that is.
	#
	my $rimagename = $imagename;
	if ($rimagename !~ /^$imagepid-/) {
	    $rimagename = "$imagepid-$imagename";
	}

	# XXX backward compat
	my $infodir = "/$PROJROOT/$rpid/exp/$reid/swapinfo";
	if (! -d "$infodir" && !mkdir($infodir, 0770)) {
	    print "*** swapinfo: no swap info directory $infodir!\n";
	    next
		if (!$allnodes);
	    return 1;
	}

	#
	# First make sure we get rid of any old signature for the node
	# in case any of the following steps fail.
	#
	unlink("$infodir/$vname.sig", "$infodir/$vname.part");

	#
	# Now copy over the base signature if needed, either because
	# it doesn't exist in the swapinfo directory or is out of date.
	#
	my $mustcopy = 0;
	my ($sigdir, $signame);
	if ($imagepid eq TBOPSPID()) {
	    $sigdir = "$TB/images/sigs";
	} else {
	    $sigdir = "/$PROJROOT/$imagepid/images/sigs";
	}
	$signame = "$imagename.ndz.sig";
	$signame =~ s/^$imagepid-//;
	if (! -d $sigdir || ! -f "$sigdir/$signame") {
	    print "*** swapinfo: WARNING: ".
		"no image signature for $rimagename, ".
		"cannot save swapout state!\n";
	    next;
	}
	my $basesig = "$infodir/$rimagename.sig";
	if (! -r $basesig) {
	    $mustcopy = 1;
	} elsif (!defined($gotsig{$basesig})) {
	    my $fromtime = stat("$sigdir/$signame")->mtime;
	    my $totime = stat($basesig)->mtime;
	    if ($fromtime > $totime) {
		print "*** swapinfo: WARNING: ".
		    "$rimagename.sig out of date, updating...\n";
		$mustcopy = 1;
	    } elsif ($fromtime < $totime) {
		print "*** swapinfo: WARNING: ".
		    "$rimagename.sig newer than source $sigdir/$signame!\n";
	    }
	}
	if ($mustcopy) {
	    unlink($basesig);
	    if (system("/bin/cp -p $sigdir/$signame $basesig")) {
		print "*** swapinfo: WARNING: ".
		      "could not create signature $basesig, ".
		      "cannot save swapout state!\n";
		next;
	    }
	}
	$gotsig{$basesig} = 1;

	if (system("/bin/ln -s $rimagename.sig $infodir/$vname.sig")) {
	    print "*** swapinfo: WARNING: ".
		"could not create signature $infodir/$vname.sig, ".
		    "cannot save swapout state!\n";
	    next;
	}

	if (!open(FD, "> $infodir/$vname.part")) {
		print "*** swapinfo: WARNING: ".
		      "could not create partition file $infodir/$vname.part, ".
		      "cannot save swapout state!\n";
		unlink("$infodir/$vname.sig");
		next;
	}
	print FD "DISK=$disk ";
	print FD "LOADPART=$lpart ";
	print FD "BOOTPART=$part\n";
	close(FD);
    }

    #
    # Now get rid of usused signature files
    # Note that we can only use the gotsig hash if we are loading all nodes
    # in an experiment (else we don't know whether a sig is used or not).
    #
    if ($allnodes) {
	my $infodir = "/$PROJROOT/$pid/exp/$eid/swapinfo";
	my @allsigs = `ls $infodir/*.sig`;
	chomp(@allsigs);
	for my $sig (@allsigs) {
	    if (! -l $sig && !defined($gotsig{$sig})) {
		# untaint the file name
		if ($sig =~ /^($infodir\/[-\w\.\+]+\.sig)$/) {
		    $sig = $1;
		    print "removing unused signature file $sig ...\n";
		    unlink($sig);
		}
	    }
	}
    }
}

# _Always_ make sure that this 1 is at the end of the file...
1;
