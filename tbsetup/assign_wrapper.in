#!/usr/bin/perl -w

#
# EMULAB-COPYRIGHT
# Copyright (c) 2000-2003 University of Utah and the Flux Group.
# All rights reserved.
#

# This function as the main assign loop.  It converts the virtual
# topology into a top input including LAN and delay translation.  It
# then snapshots the current testbed physical state and runs assign,
# looping a couple times if assign fails.  When assign successfully
# completes it will interpret the results.  Attempt to match any
# existing portmap entries and then update the delays and vlans table.

# Syntax: assign_wrapper <pid> <eid>

#
# Return code:
#
# 0  - success
# 1+ - error (Add other values:)
# 2  - max_concurrent violation
# 4  - bandwidth violation
# 8  - linkusers violation
# 16 - desires violation
# 32 - unassigned
# 64 - Set to indicate 'recoverability'
#      (E.g., no db or physical state was modified
#       by the time the error occurred.)
#

# Caveats:
#  The support for direct and interswitch links has not been tested much.

# Settings
# delaythresh is the maximum delay in ms above which a delay node is needed.
#  (Note that the DB represents delays as floating point numbers)
# maxrun is maximum number of times we run assign.
# delaywithswitch if 1 will use the switch to delay when possible.  Currently
#  this only works for 10mbit links.
$delaythresh = 2;
$maxrun = 20;
$delaywithswitch=0;

#
# Some handy constants. Speed in Mbits/sec and Kbits/sec units.
# The conversion routine is to make explicit that we operate with two
# different sets of units. One is the topology, which is in Kbps now.
# The second is the physical description, which has been changed to
# Kbps in the DB (and in ptopgen).
#
# Its probably a good idea to leave portbw (current_speed) in Mbs, since
# those numbers are used at the switch and the interfaces, which really
# only think in Mbps.
#
my $S10Mbs  = 10;
my $S100Mbs = 100;
my $S10Kbs  = 10000;
my $S100Kbs = 100000;
sub BWConvert($) {
    #
    # Use this if physical units are in Mbs (used to be).
    #
    #my $bw = $_[0] / 1000;
    
    my $bw = $_[0];
    return $bw;
}

$DELAYCAPACITY = @DELAYCAPACITY@;
$TBROOT = "@prefix@";
$ENV{'PATH'} = "/usr/bin:$TBROOT/libexec:$TBROOT/sbin:$TBROOT/bin";

use lib '@prefix@/lib';
use libdb;
use libtestbed;
require exitonwarn;

#
# Turn off line buffering on output
#
$| = 1;

use Getopt::Std;

getopts('vu',\%opt);

sub usage {
	print "Usage: $0 [-v] pid eid\n";
	print "		-v enables verbose output\n";
	print "         -u enables update functionality\n";
	exit(-1);
}

sub fatal($$) {
    my $exitcode = shift;
    my $message  = shift;
    $message =~ s/\n$//;
    print STDERR "$message\n";
    exit($exitcode);
}

my $verbose = 0;
my $updating = 0;

if ($opt{v}) {
    $verbose = 1;
}

if ($opt{u}) {
    $updating = 1;
}

if (@ARGV != 2) {
    usage();
}

($pid,$eid) = @ARGV;

$ptopfile = "$pid-$eid-$$.ptop";

sub printdb {
    if ($verbose) {
	print $_[0];
    }
};

TBDebugTimeStamp("assign_wrapper started");

######################################################################
# Step 1 - Setup virtual topology
#
# Here we need to read the virtual topology in from the virt_nodes
# and virt_lans table.  We then need to add delay and lan nodes as
# necessary.
#
# Conversion details:
#   Let L be a LAN with N members.
#   If N == 2 
#      Let N1 be node 1
#      Let N2 be node 2
#      If L is delayed
#         Generate delay node D
#         Link N1 to D
#         Link N2 to D
#      Else
#         Link N1 to N2
#   Else
#      Generate lan node A
#      If L is delayed
#        Foreach node N in L
#           Generate delay node DN
#           Link A to DN
#           Link N to DN
#      Else
#        Foreach node N in L
#           Link N to A
#
# Datastructures:
#  nodes is indexed by virtual node and contains the node type.
#  isremotenode is indexed by virtual node and says whether the node is
#    is remote. We let wanassign deal with those nodes.
#  lannodes is indexed by physical name is the set of lan nodes.
#  portbw is indexed by virtual nodeport and contains the bandwidth
#    of that port. Note that port bandwidth in the interfaces table is
#    left in Mbps units for now. Thats inconsistent, I know. For LANs with
#    other bandwidths the port speed will be 100 and a delay node will
#    be inserted.
#  fixed_nodes is indexed by virtual node name and points to physical node
#   name.
#  vtypes is indexed by vtype name and is a list of {weight types}.
#
# Delay node names:
#  delay nodes are named tbdelayXX N > 2
#   and tbsdelayXX for N == 2.
# 
# Lan node nameS:
#  lan nodes are named lan/<virtual lan>
######################################################################

printdb "Generating TOP file.\n";
TBDebugTimeStamp("top started");

# Shark Hack
# For each LAN we replace all the sharks in the LAN with a single
# shark shelf node.  After this goes through assign we pull them
# all back out.
#
# sharkshelves is indexed by virtual shelf name and is a list of
# the virtual nodes in it.
# sharkshelfid is used to generate ids for shark shelves.
$sharkshelfid = 0;

# ips is indexed by node:port and contains the IP address for the port.
my %ips	      = ();

# lans is indexed by virtual lan and is a list of node:port members.
# memberof is indexed by node:port and holds the lan it is a member of.
# emulated is 1 if the link/lan is emulated (virtual). This is
# controlled by the a variable in the virt_lans table. It also gets
# set when one of the nodes in the lan is a virtnode (jail).
# useveth is 1 if the link/lan should us a veth device (virtual only).
# trivok is 1 if emulated link/lan can by colocated on same node. 
my %lans     = ();
my %memberof = ();
my %emulated = ();
my %useveth  = ();
my %trivok   = ();

# delayinfo stores the virt_lans info, and is indexed by virtual
# lan:node:port and is a list of delay, bandwidth, lossrate, rdelay,
# rbandwidth, rlossrate.  Where r* indicates switch->node and the
# others indicate node->switch.
my %delayinfo = ();

# queueinfo overlaps with delayinfo. It came later, and I added before
# I understood this stuff. It should be merged into delayinfo above.
# It holds the q_ stuff from virt_lans. 
my %queueinfo = ();

# delaylinks stores the actual link delay info, converted from the
# virt delay params above. It is indexed by link name and contains
# [delay,bw,loss] for each direction. 
my %delaylinks = ();

# delaynodes stores the names of delaynodes that we create on the
# fly using delayid. This is useful for doing isdelay? tests.
my %delaynodes = ();
my $delayid    = 0;

# nodedelays and linkdelays are the final (!) representation. Indexed by
# integer id, they store the physical node info and the delay info. 
my %nodedelays = ();
my %linkdelays = ();

# Set this when forcing linkdelays instead of delay nodes. Set in the NS
# file with a tb-compat directive. The force directive says to set up a
# link delay, even when no delay would otherwise be inserted.
# usewatunnels is also set in the NS, and can be used to turn them off. 
# The multiplex_factor is to override node_types table for virtnode.
my $uselinkdelays   = 0;
my $forcelinkdelays = 0;
my $usewatunnels    = 1;
my $multiplex_factor;

# And the per-lan controls, based on the above two variables, and
# per-lan variable in the virt_lans table. Indexed by lan name.
# The nobwshaping flag is used in conjunction with emulated links
# to turn off actual bw traffic shaping on an emulated link. This allows
# assign to match the specified bws, but not force them to be such
# with delay nodes (leaves it up to the user to moderate the bw). 
my %uselinkdelay    = ();
my %nobwshaping     = ();

# OSID for each node in the virt_nodes table. We set this when we read
# virt_nodes. Eventually, this should be part of a larger data structure
# of per-vnode info. This allows us to map it early, and bail if over
# max_concurrent. 
my %virtnodeosids   = ();

#
# This is for stats gathering. It might duplicate other stuff, but
# thats okay.
#
my %expt_stats = (# pnodes include jailnodes and delaynodes.
		  # We let the wrapper determine pnodes once the
		  # experiment is fully swapped in so that the record
		  # is not "committed" until successful swapin.
		  jailnodes   => 0,
		  vnodes      => 0,
                  # vnodes include wanodes.
		  wanodes     => 0,
		  simnodes    => 0,
		  delaynodes  => 0,
		  linkdelays  => 0,
		  links       => 0,
		  walinks     => 0,
		  lans        => 0,
		  shapedlinks => 0,
		  shapedlans  => 0,
		  minlinks    => 100000,
		  # includes emulated links. Maybe thats wrong.
		  maxlinks    => 0,
);

my $query_result =
    DBQueryFatal("SELECT uselinkdelays,forcelinkdelays,".
		 "       multiplex_factor,usewatunnels ".
		 " from experiments ".
		 "where pid='$pid' and eid='$eid'");
($uselinkdelays,$forcelinkdelays,$multiplex_factor,$usewatunnels) =
    $query_result->fetchrow_array();

# Figure out what kind of links we have. Indexed by bandwidth and is
# just a set.
my %okbandwidths = ();

$query_result =
    DBQueryFatal("SELECT type,max_speed from interface_types");

while (($type,$bandwidth) = $query_result->fetchrow_array()) {
    $okbandwidths{$bandwidth} = 1;
}

# Load delay osids and default osids for types
my %delayosids   = ();
my %jailosids    = ();
my %defaultosids = ();

$query_result =
    DBQueryFatal("SELECT type,delay_osid,osid from node_types");

while (($type,$delayosid,$defosid) = $query_result->fetchrow_array()) {
    $delayosids{$type}   = $delayosid;
    $jailosids{$type}    = "emulab-ops-FBSD47-UPDATE";
    $defaultosids{$type} = $defosid;
}

# XXX NSE hack: List of simulated nodes. All these are gonna go
# into one pc850. Needs to change in distributed nse
my @simnodelist;
my %simnode_iplist = ();
my %iptonodemap    = ();
my $nsenode_id     = 0;

# XXX Remote/Virt node hacks. Turns out to be similar to NSE.
my %isremotenode = ();
my %isvirtnode   = ();
my $remotecount  = 0;
my $virtcount    = 0;
my $virtnode_id  = 0;

my %alreadyAllocated = ();

if ($updating) {
    printdb "Fixing previously allocated nodes.\n";
	$result = 
	    DBQueryFatal("SELECT vname, node_id ".
			 "FROM reserved ".
			 "WHERE pid='$pid' AND eid='$eid'");
    
    while (($vname,$reserved) = $result->fetchrow_array) {
	$reserved_nodes{$vname} = $reserved;
	$fixed_nodes{$vname}    = $reserved;    
	$alreadyAllocated{$reserved} = "unused";
    }
    $result->finish;
}


printdb "Loading virt_nodes.\n";
$result =
    DBQueryFatal("select distinct vn.vname,vn.ips,vn.type,vn.fixed,vn.osname,".
		 " nt.isremotenode,nt.isvirtnode ".
		 " from virt_nodes as vn ".
		 "left join node_types as nt on ".
		 " nt.type=vn.type or nt.class=vn.type ".
		 "where vn.pid='$pid' and vn.eid='$eid' ".
		 "order by vn.vname");

while (($vname,$ips,$type,$fixed,$osname,$isremote,$isvirt) = 
        $result->fetchrow_array){
    if (defined($fixed) && $fixed eq "") {
	undef($fixed);
    }
    
    # REMOTENODE HACK
    #
    # if its a vtype, no entry in node_types. vtypes break remote nodes.
    # Need to look inside the vtype and make sure no mixing of vnodes and
    # physnodes. Later ...
    #
    if (! defined($isremote)) {$isremote = 0;}
    if (! defined($isvirt)) {$isvirt = 0;}
    
    printdb "  $vname $type $ips";
    printdb " " . (defined($fixed) ? $fixed : "") . " $isremote\n";
    
    # We need to check the names to make sure they won't clash with
    # our internal delay node names.
    if (($vname =~ /^tbdelay\d+/) ||
	($vname =~ /^tbsdelay\d+/)) {
	print STDERR "Warning: $vname is a reserved name.  Working around.\n";
	($num) = ($vname =~ /(\d+)/);
	$delayid = $num + 1;
    }
    $nodes{$vname} = $type;

    if( $type eq "sim" ) {
      push( @simnodelist, $vname );
      $simnode_iplist{$vname} = [];
    }    
    # REMOTENODE HACK
    # 
    $isremotenode{$vname} = $isremote;
    $remotecount++
	if ($isremote);

    # stats
    my @iplist  = split(" ", $ips);
    my $ipcount = scalar(@iplist);

    $expt_stats{"maxlinks"} = $ipcount
	if ($ipcount > $expt_stats{"maxlinks"});
    $expt_stats{"minlinks"} = $ipcount
	if ($ipcount < $expt_stats{"minlinks"});

    foreach $ipinfo (@iplist) {
	($port,$ip) = split(":",$ipinfo);
	$ips{"$vname:$port"} = $ip;
	if( $type eq "sim" ) {
	  push(@{$simnode_iplist{$vname}}, $ip);
	}
	$iptonodemap{$ip} = $vname;
    }
    $isvirtnode{$vname} = $isvirt;
    $virtcount++
	if ($isvirt);

    if (defined($fixed)) {
	$fixed_nodes{$vname} = $fixed;
    }

    #
    # Map the osname to an OSID now so that we can check max_concurrent.
    # This also avoids the work and *check* later after we have done 90%
    # of assign_wrapper. If no osname was specified, we have to wait and
    # use the default for the type of phys node that assign picks.
    #
    if (defined($osname) && $osname ne "") {
	my $osid;

	if (! ($osid = TBOSID($pid, $osname)) &&
	    ! ($osid = TBOSID(TB_OPSPID, $osname))) {
	    fatal(1, "*** $0:\n".
		     "    Invalid OS $osname in project $pid!\n");
	}
	$virtnodeosids{$vname} = $osid;
    }
}

# Check Max Concurrent
CheckMaxConcurrent();

# Stats
$expt_stats{"vnodes"}   = $virtcount;
$expt_stats{"wanodes"}  = $remotecount;
$expt_stats{"simnodes"} = scalar(@simnodelist);

printdb "Loading virt_lans.\n";
$result =
    DBQueryFatal("select vname,member,delay,bandwidth,lossrate," .
		 "rdelay,rbandwidth,rlossrate,widearea, ".
		 "emulated,uselinkdelay,nobwshaping,usevethiface,trivial_ok " .
		 "from virt_lans where pid='$pid' and eid='$eid' ".
                 "order by vname,member");

#
# REMOTENODE HACK: Remote nodes are special.
#
# A list of all lans that have remote nodes as members,
my %rnodelans = ();
# A list of all the tunnels we need to build. Each list member is a list
# of the nodes in the tunnel.
my %tunnels   = ();

#
# Process the virt_lans table.
# 
while (my ($vname,$member,$delay,$bandwidth,$lossrate,
	   $rdelay,$rbandwidth,$rlossrate,$widearea,
	   $isemulated,$uselinkdelay,$nobwshaping,$useveth,$trivial_ok)
       = $result->fetchrow_array) {
    my ($node,$port) = split(":",$member);

    #
    # REMOTENODE HACK: 
    #
    # If its a duplex link involving a remotenode, skip it. 
    # We do not want to have assign deal with these. The nodes are
    # allocated as unconnected by another program, and we deal with
    # it later by creating tunnels.
    # 
    if ($widearea) {
	#
	# If the user requested that no tunnels be created, so not bother
	# with this. wanassign stills does the right thing, but we do not
	# set up the tunnels (see below). 
	#
	if ($usewatunnels) {
	    if (! defined($tunnels{$vname})) {
		$tunnels{$vname} = [];
	    }
	    push(@{$tunnels{$vname}},$member);
	    $rnodelans{$vname} = 1;
	    printdb "    Added $member to tunnels of $vname\n";
	}
	$expt_stats{"walinks"} += 1;
	next;
    }
    
    if (! defined($lans{$vname})) {
	$lans{$vname} = [];
    }
    push(@{$lans{$vname}},$member);
    $memberof{$member} = $vname;
    $delayinfo{"$vname:$member"} = [$delay,$bandwidth,$lossrate,
				    $rdelay,$rbandwidth,$rlossrate];

    #
    # Grab the Q stuff from virt_lans. I'm keeping this separate for
    # now until I understand whats going on. There are no "r" params
    # either. I have no idea how do to this stuff for lans, and for
    # duplex links the "r" params are not necessary. Each virt_lans
    # entry gives the params towards the switch, which equal the
    # reverse params for the other member. 
    #
    $query_result =
	DBQueryFatal("select q_limit,q_maxthresh,q_minthresh,q_weight, ".
		     "       q_linterm,q_qinbytes,q_bytes,q_meanpsize, ".
		     "       q_wait,q_setbit,q_droptail,q_red,q_gentle ".
		     "from virt_lans ".
		     "where pid='$pid' and eid='$eid' and ".
		     "      vname='$vname' and member='$member'");
    
    my ($q_limit,$q_maxthresh,$q_minthresh,$q_weight,$q_linterm,
	$q_qinbytes,$q_bytes,$q_meanpsize,$q_wait,$q_setbit,
	$q_droptail,$q_red,$q_gentle) = $query_result->fetchrow_array;
    
    $queueinfo{"$vname:$member"} =
	[$q_limit,$q_maxthresh,$q_minthresh,$q_weight,$q_linterm,
	 $q_qinbytes,$q_bytes,$q_meanpsize,$q_wait,$q_setbit,
	 $q_droptail,$q_red,$q_gentle];

    if ($q_red) {
	$mustdelay{$vname} = 1;
    }
    $emulated{$vname} = $isemulated;
    $uselinkdelay{$vname} = $uselinkdelay;
    $nobwshaping{$vname} = $nobwshaping;
    $useveth{$vname} = $useveth;
    $trivok{$vname} = $trivial_ok;

    #
    # XXX - Whenever a delay node is inserted, port speeds are set to
    #       100Mbs, even if they requested exactly 10Mbs. This is a
    #       simplification. At some point we might want to force all the
    #       ports along the way to 10Mbs, and have the delay node worry
    #       about delay only, and not bandwidth. That will be harder to
    #       to do in this mess. See companion XXX below where the delays
    #       table is initialized. Initially, we set the speed to 10Mbs,
    #       if a delay node is insterted below, it resets this to 100Mbs.
    # 
    if ($bandwidth == $S10Kbs && $delaywithswitch) {
	$portbw{$member} = $S10Mbs;
    } else {
	$portbw{$member} = $S100Mbs;
    }
    printdb "  portbw of $member = $portbw{$member}\n";
    printdb "  $vname $member - $delay $bandwidth $lossrate $rdelay $rbandwidth $rlossrate\n";
    printdb "   $port:$vname is a lan of $node\n";
}
$result->finish;

#
# Check event list. Anytime we find an event to control a link, we need
# to drop a delay node in. start/stop especially, since thats the easiest
# way to do that, even if the link has no other traffic shaping in it. 
# 
printdb "Checking events for LINK commands.\n";
$result =
    DBQueryFatal("select distinct vname from eventlist as ex ".
		 "left join event_eventtypes as et on ex.eventtype=et.idx ".
		 "left join event_objecttypes as ot on ex.objecttype=ot.idx ".
		 "where ot.type='LINK' and ex.pid='$pid' and ex.eid='$eid'");
while (($vname) = $result->fetchrow_array) {
    $mustdelay{$vname} = 1;
}

# Shark hack
foreach $lan (keys(%lans)) {
    $realmembers = [];
    $sharks = [];
    $hassharks = 0;
    foreach $member (@{$lans{$lan}}) {
	($node) = (split(":",$member))[0];
	if (($nodes{$node} eq "shark") || ($nodes{$node} eq "dnard")) {
	    push(@$sharks,$member);
	    $hassharks = 1;
	} else {
	    push(@$realmembers,$member);
	}
    }
    if ($hassharks) {
	$shelfid = "sharkshelf$sharkshelfid";
	printdb "  Creating shark shelf: $shelfid (" . 
	    join(" ",@$sharks) . ")\n";
	$sharkshelfid++;
	$sharkshelves{$shelfid} = $sharks;
	$delayinfo{"$lan:$shelfid:uplink"} = [0,$S100Kbs,0.0,
					      0,$S100Kbs,0.0];
	push(@$realmembers,"$shelfid:uplink");
	$nodes{$shelfid} = "shark-shelf";
    }
    $lans{$lan} = $realmembers;
}
# End shark hack

# Load virt types
printdb "Loading virt_vtypes.\n";
$result = DBQueryFatal("SELECT name,weight,members from virt_vtypes" .
		       " where pid=\"$pid\" and eid=\"$eid\"");
while (($name,$weight,$types) = $result->fetchrow_array) {
    printdb "  $name $weight $types\n";
    $vtypes{$name} = "$weight $types";
}

# Open the TOP file
$topfile = "$eid.top";
open(TOPFILE,"> $topfile") || do {
    fatal(65,"*** $0:\n".
	    "    Could not open $topfile.\n");
};

# Print out vtypes
foreach $vtype (keys(%vtypes)) {
    print TOPFILE "make-vclass $vtype $vtypes{$vtype}\n";
}

$nodes=0;

foreach $node (keys(%nodes)) {
    # Shark hack
    if (($nodes{$node} ne "shark") &&
	($nodes{$node} ne "dnard") && !$isremotenode{$node}) {
	print TOPFILE "node $node $nodes{$node}\n";
	if ($nodes{$node} ne "shark-shelf") {
	    $nodes++;
	}
    }
    # End Shark hack
}

# lans that have simulated nodes
my %simnodelans = ();

foreach $lan (keys(%lans)) {
    @members = @{$lans{$lan}};
    printdb "$lan - " . join(" ",@members) . "\n";
    # Shark hack for rvr
    $sharks = 0;
    $nonsharks = 0;
    $simnodes = 0;
    $realnodes = 0;
    $virtnodes = 0;
    my $emulated = $emulated{$lan};
    my $uselinkdelay = $uselinkdelay{$lan};
    my $mustdelay = $mustdelay{$lan};
    my $isdelayed = 0;
    my $nobwshaping = $nobwshaping{$lan};
    $trivial_ok = 0;
    foreach $member (@members) {
	($node) = (split(":",$member))[0];
	if ($nodes{$node} eq "shark-shelf") {
	    $sharks++;
	} elsif ($nodes{$node} eq "sim") {
	    $simnodes++;
	    $simnodelans{$lan} = 1;
	} else {
	    # We always use an emulated link when its a virtnode. An emulated
	    # link can use a trivial link too, if the user wanted it. 
	    if ($isvirtnode{$node}) {
		$virtnodes++;
		$emulated = 1;
		$emulated{$lan} = 1;
		$trivial_ok = $trivok{$lan};
		#
		# An emulated link/lan between containing any
		# virtnodes always uses veth devices. Note that remote
		# virtual nodes never go through this path cause they
		# get tunnels, so its only local virtual nodes. 
		#
		$useveth{$lan} = 1
		    if ($isvirtnode{$node});
	    }
	    $nonsharks++;
	    $realnodes++;
	}
    }
    #
    # Hmm, no emulated lans for now. 
    #
    if ($emulated && (@members > 2) && ($virtnodes != scalar(@members))) {
	fatal(65,"*** $0:\n".
	        "    Emulated lans ($lan) not allowed yet! Only links.\n");
    }
    if ($simnodes > 0 && $realnodes == 0 && $sharks == 0) {
	$trivial_ok = 1;
    }
    if ($#members == 1) {
	$expt_stats{"links"} += 1;
	($nodeport0,$nodeport1) = @members;
	$node0 = (split(":",$nodeport0))[0];
	$node1 = (split(":",$nodeport1))[0];
	($delay0,$bw0,$loss0,
	 $rdelay0,$rbw0,$rloss0) = @{$delayinfo{"$lan:$nodeport0"}};
	($delay1,$bw1,$loss1,
	 $rdelay1,$rbw1,$rloss1) = @{$delayinfo{"$lan:$nodeport1"}};
	# Here the r's aregoing to be 1->0 and the others 0->1
	$delay = $delay0+$rdelay1;
	$loss = 1-(1-$loss0)*(1-$rloss1);
	$bw = &min($bw0,$rbw1);
	$rdelay = $rdelay0+$delay1;
	$rloss = 1-(1-$rloss0)*(1-$loss1);
	$rbw = &min($rbw0,$bw1);
	$bandwidth = &getbandwidth(&min($bw0,$rbw1));
	$rbandwidth = &getbandwidth(&min($rbw0,$bw1));
	if (((($delay >= $delaythresh) ||
	      (!$nobwshaping &&
	       ((($bw != $S100Kbs) && ($bw != $S10Kbs)) ||
		(($delaywithswitch == 0) && 
		 (($bw != $S100Kbs) &&
		  (($sharks == 0) || ($nonsharks > 1)))))) || 
	      ($loss != 0)) ||
	     (($rdelay >= $delaythresh) ||
	      (!$nobwshaping &&
	       ((($rbw != $S100Kbs) && ($rbw != $S10Kbs)) ||
		(($delaywithswitch == 0) && !$nobwshaping &&
		 (($rbw != $S100Kbs) &&
		  (($sharks == 0) || ($nonsharks > 1)))))) || 
	      ($rloss != 0)) ||
	     # Link must be shaped for other reasons (q_red).
	     $mustdelay ||
	     # Global force, or per-link force. 
	     $forcelinkdelays || $uselinkdelay) &&
	    # XXX simulated nodes hack. We don't want to put delay nodes
	    # between simulated nodes. If there is a link between a
	    # simulated and a real node, we might need to put in delay
	    # nodes
	    ($realnodes != 0)) {
	    $isdelayed = 1;
	    #
	    # We use a linkdelay if the link is emulated, globally forced,
	    # globally preferred if the link is shaped, or if the per-link
	    # flag was set (which means to put in a link delay regardless
	    # of whether the link is shaped).
	    #
	    if ($emulated ||
		$forcelinkdelays || $uselinkdelays || $uselinkdelay) {
		my $plink = "linksimple/$lan/$nodeport0,$nodeport1";
		
		print(TOPFILE "link $plink $node0 $node1 ".
		      max($bw,$rbw) . " 0 0" .
		      ($emulated ? " emulated" : "") .
		      ($trivial_ok ? " trivial_ok\n" : "\n"));

		#
		# We allow users to oversubscribe by letting them turn
		# off the bandwidth shaping. If however, the link was
		# shaped for some other reason (like a delay), then
		# turn off just the bw shaping part by setting them to 0.
		# This is special; means no limits in ipfw.
		#
		if ($nobwshaping) {
		    $bw = $rbw = 0;
		}
		$delaylinks{$plink} = [$nodeport0,$delay,$bw,$loss,
				       $nodeport1,$rdelay,$rbw,$rloss];
	    
		printdb "Delay link $plink = " . 
		    join(" ",@{$delaylinks{$plink}}) . "\n";
	    }
	    else {
		my $delayname = "tbsdelay" . $delayid++;
		my $plink     = "linksdelaysrc/$lan/$nodeport0,$nodeport1";
		
		$delaylinks{$plink} = [$nodeport0,$delay,$bw,$loss,
				       $nodeport1,$rdelay,$rbw,$rloss];

		print TOPFILE "node $delayname delay\n";
		print TOPFILE "link linksdelaysrc/$lan/$nodeport0,$nodeport1 ".
		    "$node0 $delayname $bandwidth 0 0\n";
		print TOPFILE "link linksdelaydst/$lan/$nodeport1,$nodeport0 ".
		    "$node1 $delayname $bandwidth 0 0\n";

		$delaynodes{$delayname} = $delayname;
		
		printdb "Delay node $plink ($delayname) = " . 
		    join(" ",@{$delaylinks{$plink}}) . "\n";
	    }
	    #
	    # Ports are set to 100Mbs when a link gets a delay node.
	    # This can override initialization above cause we could not
	    # tell earlier if the link was going to get a real delay node
	    # or just a delaywithswitch.
	    #
	    $portbw{$nodeport0} = $S100Mbs;	    
	    $portbw{$nodeport1} = $S100Mbs;	    
	} else {
	    print TOPFILE "link linksimple/$lan/$nodeport0,$nodeport1 ".
		"$node0 $node1";
	    if ($emulated) {
		print TOPFILE " " . max($bw,$rbw) . " 0 0 emulated";
	    }
	    else {
		print TOPFILE " $bandwidth 0 0";
	    }
	    if ($trivial_ok) {
		print TOPFILE " trivial_ok";
	    }
	    print TOPFILE "\n";
	}
	$expt_stats{"shapedlinks"} += $isdelayed;
    } elsif ($#members != 0) {
	print TOPFILE "node lan/$lan lan\n";
	$expt_stats{"lans"} += 1;
	$lannodes{"lan/$lan"} = 1;
	foreach $member (@members) {
	    ($delay,$bw,$loss,
	     $rdelay,$rbw,$rloss) = @{$delayinfo{"$lan:$member"}};
	    $bandwidth = &getbandwidth($bw);
	    $rbandwidth = &getbandwidth($rbw);
	    ($node) = (split(":",$member))[0];
# XXX The expression below should be modified for better bandwidth support.
# Probably needs to happen post assign somehow.
	    if (((($delay >= $delaythresh) ||
		  (($bw != $S100Kbs) && ($bw != $S10Kbs))  ||
		  (($delaywithswitch == 0) && 
		   (($bw != $S100Kbs) && (($sharks == 0) ||
					  ($nonsharks > 1)))) ||
		  ($loss != 0)) || 
		 (($rdelay >= $delaythresh) ||
		  (($rbw != $S100Kbs) && ($rbw != $S10Kbs))  ||
		  (($delaywithswitch == 0) && 
		   (($rbw != $S100Kbs) && (($sharks == 0) ||
					   ($nonsharks > 1)))) ||
		  ($rloss != 0)) ||
		 # Link must be shaped for other reasons (q_red).
		 $mustdelay ||
		 # Global force, or per-lan force. 
		 $forcelinkdelays || $uselinkdelay) &&
		# if we have 1 real node in the LAN, we may need to create
		# a lan
		($realnodes != 0)) {
		$isdelayed = 1;
		#
		# We use a linkdelay if the link is emulated, globally forced,
		# globally preferred if the link is shaped, or if the per-link
		# flag was set (which means to put in a link delay regardless
		# of whether the link is shaped).
		#
		# NB: Emulated lans not supported at this time. Caught above.
		#
		if ($emulated ||
		    $forcelinkdelays || $uselinkdelays || $uselinkdelay) {
		    my $plink = "linklan/$lan/$member";
		    
		    $delaylinks{$plink} =
			[$member,$delay,$bw,$loss,
			 $member,$rdelay,$rbw,$rloss];

		    print(TOPFILE "link $plink $node lan/$lan " .
			  max($bw,$rbw) . " 0 0" .
			  ($emulated ? " emulated" : "") .
			  ($trivial_ok ? " trivial_ok\n" : "\n"));

		    printdb "Delay link $plink = " .
			    join(" ", @{$delaylinks{$plink}}) . "\n";
		}
		else {
		    my $delayname = "tbdelay" . $delayid++;
		    my $plink     = "linkdelaysrc/$lan/$member";

		    $delaylinks{$plink} =
			[$member,$delay,$bw,$loss,
			 $member,$rdelay,$rbw,$rloss];
		    
		    print TOPFILE "node $delayname delay\n";
		    print TOPFILE "link linkdelaysrc/$lan/$member" .
			" $node $delayname $bandwidth 0 0\n";
		    print TOPFILE "link linkdelaydst/$lan/$member" .
			" lan/$lan $delayname $bandwidth 0 0\n";
		    
		    $delaynodes{$delayname} = $delayname;

		    printdb "Delay node $plink ($delayname) = " .
			    join(" ", @{$delaylinks{$plink}}) . "\n";
		}
		#
		# Port is set to 100Mbs when the link gets a delay node.
		# This can override initialization above cause we could not
		# tell earlier if the link was going to get a real delay node
		# or just a delaywithswitch.
		#
		$portbw{$member} = $S100Mbs;	    
	    } else {
		print TOPFILE "link linklan/$lan/$member $node lan/$lan" .
		    " $bandwidth 0 0";
		if ($emulated) {
		    print TOPFILE " emulated";
		}
		if ($trivial_ok) {
		    print TOPFILE " trivial_ok";
		}
		print TOPFILE "\n";
	    }
	}
	$expt_stats{"shapedlans"} += $isdelayed;
    }
    # If a LAN has only one member we don't do anything.
}

# XXX NSE hack
# Will find a free randomly chosen pc850 and fix sim nodes to it
# Assign's scoring needs to be fixed so that the solution has
# as many sim nodes on a phy node as possible while maxing out
# its interfaces. Currently having sim:N where N is a large
# number in the ptop file does not guarantee that all these
# get mapped to a single phy node even when that mapping has no
# violations and a low score. distributed nse will fix this
#$result =
#  DBQueryFatal("select a.node_id,a.type from nodes as a ".
#	   "left join reserved as b on a.node_id=b.node_id ".
#	   "left join reserved as m on a.phys_nodeid=m.node_id ".
#	   "where b.node_id is null and (a.role='testnode' and ".
#	   "      a.type='pc850' and ".
#	   "       (m.node_id is null or ".
#	   "        m.pid!='$DEADPID' or m.eid!='$DEADEID'))");
if( scalar(@simnodelist) > 0 ) {
  open(AVAIL,"$TBROOT/sbin/avail type=pc rand |")
    or fatal(65, "*** $0:\n".
                "    avail failed\n");

  my $num = 0;
  while (<AVAIL>) {
    if (! /^\|/) {next};
    if (/node_id/) {next;}
    ($fixednode,$type) = /^\|([-a-zA-Z0-9]+)\s*\|(\w+)\s*\|(\w+)\s*\|$/;    
    $num++;
    last;
  }
  close(AVAIL);
  
  if( $num == 0 ) {
    fatal(65, "$0: *** Insufficient PCs available.\n");
  }

  foreach $simnode (@simnodelist) {
    print TOPFILE "fix-node $simnode $fixednode\n";
  }
}

# Print out fixed nodes
# But _not_ nodes which aren't in the experiment any more.
# CRB you can only fix nodes and delaynodes, right?
$reused_count = 0;

foreach $fixed (keys(%fixed_nodes)) {
    if (!$isremotenode{$fixed} && 
	(exists $nodes{$fixed} || exists $delaynodes{$fixed}) ) {
	print TOPFILE "fix-node $fixed $fixed_nodes{$fixed}\n";
	if ($reserved_nodes{$fixed}) { $reused_count++; }
    }
}

close TOPFILE;

# Set estimations
$minimum_nodes = $nodes + keys(%delaynodes)/$DELAYCAPACITY - $reused_count;
$maximum_nodes = $nodes + keys(%delaynodes) - $reused_count;
DBQueryFatal("UPDATE experiments set maximum_nodes=$maximum_nodes, " .
	 "minimum_nodes=$minimum_nodes where pid=\"$pid\" and eid=\"$eid\"");
print "Minimum nodes = $minimum_nodes\n";
print "Maximum nodes = $maximum_nodes\n";

TBDebugTimeStamp("top finished");

######################################################################
# Step 2 - Assign Loop
# 
# Here we loop up to maxrun times.  In each loop we snapshot the
# current testbed state into a ptop file.  We then run assign.  If
# assign succeeds we attempt to reserve the resources.  If that works
# we're done with step 2 otherwise we loop again.
#
# v2pmap is indexed by virtual and contains the physical node.
# p2vmap is indexed by physical and contains one or more virtual nodes
# plinks is indexed by virtual name and contains 
#  (pnodeportA,pnodeportB) .  If one is a delay node it is always
#  the second.
#######################################################################

TBDebugTimeStamp("assign_loop started");
$currentrun = 1;
while (1) {
    print "Assign Run $currentrun\n";

    # Violation counts
    $unassigned = -1;
    $linkusers = -1;
    $bandwidth = -1;
    $desires = -1;

    # Clear v2pmap, p2vmap, and plinks
    undef %v2pmap;
    undef %p2vmap;
    undef %plinks;
    undef %toreserve;
    undef %virtnodes;
    
    TBDebugTimeStamp("ptopgen started");
    # Snapshot
    #
    # if updating (-u), include any resources that may already be
    # allocated to experiment in the PTOP results.
    #
    my $ptopargs = "";
    $ptopargs   .= "-e $pid/$eid "
	if ($updating);
    $ptopargs   .= "-m $multiplex_factor "
	if (defined($multiplex_factor));
    system("ptopgen $ptopargs > $ptopfile");

    TBDebugTimeStamp("ptopgen finished");

    # Get number of nodes
    my $numnodes_result = 
	DBQueryFatal("select a.node_id,a.type from" .
		     " nodes as a left join reserved as b" .
		     " on a.node_id=b.node_id" .
		     " where b.node_id is null" .
		     " and a.role='testnode' and a.type!='dnard'");
    $numnodes = $numnodes_result->numrows;
    
    if ($numnodes < $minimum_nodes) {
	fatal(65, "$0: *** Insufficient nodes available.\n");
    }

    TBDebugTimeStamp("assign started");
    # Run assign
    $fail = 0;
    my $cmdargs = "$ptopfile $topfile";
    $cmdargs = "-p $cmdargs"
	if ($virtcount);
    print "assign $cmdargs\n";
    if (-1 == system "assign $cmdargs > assign.log") {
	fatal(65, "*** Couldn't run assign!");
    }
    
    $violations = 0;
    $score = -1;
    $assignexitcode = $? >> 8;

    open(ASSIGNFP, "assign.log")
	or fatal(65, "*** Couldn't open assign logfile!");

    if ($assignexitcode == 0)
    {
	# read output
	# Header
	printdb "Reading assign results.\n";
	while (<ASSIGNFP>) {
	    chop;
	    /No physical nodes of type (.+)$/ && do {
		$score=-2;
		print $_ . "\n";
	    };
	    /^With ([0-9]+) violations$/ && do {
		$violations = $1;
		last;
	    };
	    /^[ \t]+BEST SCORE: [ \t]+([0-9]+(\.[0-9]+)?)/ && ($score=$1);
	}
	if ($score == -2) {
	    # Type error
	    fatal(65, "Giving up.\n" );
	}
	printdb "Found score $score, violations $violations.\n";
    }

    # We don't bother reading anything else if violations occured.
    if (($violations == 0) && ($score != -1)) {
	# read nodes section
	while (<ASSIGNFP> !~ /^Nodes:/) {}
	printdb "Nodes:\n";
	while (<ASSIGNFP>) {
	    chop;
	    /^End Nodes$/ && last;
	    @info = split;
	    ($virtual,$physical) = @info[0,1];

	    # We don't care about LAN nodes anymore.
	    if (defined($lannodes{$virtual})) {
		next;
	    }

	    if ($alreadyAllocated{$physical}) {
		#
		# Mark node as being reused.
		#
		# Look at virtual node being mapped to node;
		# if it wasn't in the previous map, mark node for reboot.
		# 
		if (! exists $reserved_nodes{$virtual} ||
		    $reserved_nodes{$virtual} ne $physical ||
		    $alreadyAllocated{$physical} eq "reboot") {
		    $alreadyAllocated{$physical} = "reboot";
		} else {
		    $alreadyAllocated{$physical} = "reused";
		}
	    } else {
		#
		# This is a new node; we'll have to reserve it.
		#
		$toreserve{$physical} = 1;	    
	    }
	    
	    if ($isvirtnode{$virtual}) {
		#
		# If mapping a virtual node, then record that, since we need
		# to allocate the virtnodes on that physnode, later.
		#
		if (!defined($virtnodes{$physical})) {
		    $virtnodes{$physical} = [];
		}
		push(@{$virtnodes{$physical}}, $virtual);
	    }
	    $v2pmap{$virtual} = $physical;
	    if( ! defined($p2vmap{$physical}) ) {
		$p2vmap{$physical} = [];
	    }
	    push(@{$p2vmap{$physical}}, $virtual);
	    printdb "  $virtual $physical\n";
	}

	# read Edges
	# By convention, in plinks, the delay node is always the second
	# entry.
	while (<ASSIGNFP> !~ /^Edges:/) { }
	printdb "Edges:\n";
	EDGEWHILE: while (<ASSIGNFP>) {
	    /^End Edges$/ && last EDGEWHILE;
	    @info = split;
	    $line = $_;
	    $_ = $info[1]; # type
	  SWITCH1: {
	      /^intraswitch$/ && do {
		  ($vlink,$rawA,$rawB) = @info[0,3,5];
		  last SWITCH1;
	      };
	      /^interswitch$/ && do {
		  ($vlink,$rawA,$rawB) = @info[0,3,$#info];
		  last SWITCH1;
	      };
	      /^direct$/ && do {
		  fatal(65, "*** $0:\n".
			   "    Unsupported link type: direct.\n");
	      };
	      /^trivial$/ && do {
		  # we don't have plinks for trivial links
		  $vlink = $info[0];
		  $plinks{$vlink} = [];
		  next EDGEWHILE;
	      };
	      print "Found garbage: $line\n";
	  }
	    $nodeportA = &getnodeport($rawA);
	    $nodeportB = &getnodeport($rawB);
	    $nodeportA =~ s/\//:/;
	    $nodeportB =~ s/\//:/;
	    $plinks{$vlink} = [$nodeportA,$nodeportB];
	    printdb "  $vlink " . join(" ",@{$plinks{$vlink}}) . "\n";
	}
    } else {
	# spit out up to nodes
	print "ASSIGN FAILED: \n";       
	while (<ASSIGNFP>) {
	    if (/link_users:\s*(\d+)$/) {
		$linkusers = $1;
	    } elsif (/bandwidth:\s*(\d+)$/) {
		$bandwidth = $1;
	    } elsif (/unassigned:\s*(\d+)$/) {
		$unassigned = $1;
	    } elsif (/desires:\s*(\d+)$/) {
		$desires = $1;
	    }
	    if (/^Nodes:/) {last;}
	    print "$_";
	}
	$fail = 1;
    }
    while (<ASSIGNFP>) { } # Read anything left in the pipe before closing
    close(ASSIGNFP);
    TBDebugTimeStamp("assign finished");

    # Reserve resources
    if (!$fail) {
	TBDebugTimeStamp("reserving started");

	if (system("nalloc $pid $eid " . join(" ", keys(%toreserve)))) {
	    print "Failed to reserve nodes. Trying again.\n";
	} else {
	    print "Successfully reserved physical nodes\n";

	    foreach $node (keys(%toreserve)) {
		# in future, this will be a fully enforced state machine.
		TBSetNodeAllocState( $node, TBDB_ALLOCSTATE_RES_INIT_DIRTY() );
	    }

	    TBDebugTimeStamp("reserving finished");

	    my %tolose = ();
	    foreach $node (keys(%alreadyAllocated)) {
		if ($alreadyAllocated{$node} eq "unused") {
		    #
		    # Node was used in previous incarnation, but not any more.
		    #
		    $tolose{$node} = 1;
		} elsif ($alreadyAllocated{$node} eq "reboot") {
		    #
		    # Node is being reused, but for a different purpose, so
		    # it should be rebooted.
		    #
		    TBSetNodeAllocState( $node, TBDB_ALLOCSTATE_RES_INIT_DIRTY() );
		}
	    }
	    
	    if ((keys %tolose) > 0) {
		if (system("nfree $pid $eid " . join(" ", keys(%tolose)))) {
		    print "Failed to free no-longer-needed nodes!";
		}
	    }

	    last;
	}
    }

    # Check for exit
    if ($assignexitcode == 2 || $currentrun >= $maxrun) {
	$exitcode = 65;
	if ($bandwidth > 0) {
	    $exitcode += 4;
	}
	if ($linkusers > 0) {
	    $exitcode += 8;
	}
	if ($desires > 0) {
	    $exitcode += 16;
	}
	if ($unassigned > 0) {
	    $exitcode += 32;
	}

	if ($assignexitcode == 2) {
	    fatal($exitcode, "*** $0:\n".
		     "    Unretriable error. Giving up.\n");
	} else {
	    fatal($exitcode, "*** $0:\n".
		     "    Reached run limit. Giving up.\n");
	}
    }
    print "Waiting 5 seconds and trying again...\n";
    sleep(5);

    $currentrun++;
}

TBDebugTimeStamp("assign_loop finished");

###########################################################################
# Step 2A
#
# We run the wanassigner to allocate remote nodes. We do this after cause
# it takes so long. We run it just once.
#
# wanassign does its own nalloc.
#
###########################################################################

#
# VIRTNODES HACK: physical nodes (from the nodes table) might really
# be a virtual node :-) Must record the underlying phys_nodeid and an
# indicator for jail.
#
my %jailed = ();

# Now allocate the remote nodes. 
if (scalar(keys(%isremotenode))) {
    my $success  = 0;
    my $doremote = 0;
    
    foreach my $value (values(%isremotenode)) {
	if ($value) {
	    $doremote = 1;
	}
    }
    
    if ($doremote) {
	print "Running 'wanassign -d $pid $eid'\n";
	open(WANFP,"wanassign -d $pid $eid 2>&1 | tee wanassign.log |") or
	    fatal(65, "*** $0:\n".
		     "    Failed to start wanassign: $!\n");

	printdb "Reading wanassign results.\n";
	while (<WANFP>) {
	    chop;
	    if ($_ =~ /(\S+) mapsto (\S+)/) {
		$v2vmap{$1} = $2;
		printdb "  $1 $2\n";
	    }
	    if ($_ =~ /^Success/) {
		$success = 1;
	    }
	    # Skip other output. Usually its debugging output.
	}
	close(WANFP) or
	    fatal(65, "*** $0:\n".
		     "    wanassign: " . $? ? "exited with status: $?.\n" :
		                         "error closing pipe: $!\n");

	if (!$success) {
	    fatal(65,"*** $0:\n".
		    "    wanassign could not find a solution!\n");
	}
	foreach my $virtual (keys(%v2vmap)) {
	    my $physical = $v2vmap{$virtual};
	    my $jailflag;
	    my $phys_nodeid;

	    TBIsNodeVirtual($physical, \$jailflag);
	    TBPhysNodeID($physical, \$phys_nodeid);
	    
	    $v2pmap{$virtual} = $phys_nodeid;
	    if ( !defined($p2vmap{$phys_nodeid})) {
		$p2vmap{$phys_nodeid} = [];
	    }
	    push(@{$p2vmap{$phys_nodeid}}, $virtual);

	    $jailed{$virtual}  = $jailflag;
	}
	TBDebugTimeStamp("wanassign finished");
    }
}

#
# Recoverability ends.
# (All fatal() calls from this point do not have
# the recoverable '64' bit set.)
#

#
# For update, wipe old interfaces in DB (normally done by nfree.)
# These will get rebuilt soon.
#
if ($updating) {
    foreach $node (keys(%alreadyAllocated)) {
	my $result = DBQueryFatal("select nt.control_net ".
				  "from nodes as n ".
				  "left join node_types as nt ".
				  "on nt.type=n.type ".
				  "where n.node_id='$node'");

	my ($control) = $result->fetchrow_array();

	my $pred = "1";

	if (defined $control) {
	    $pred = "(card != '$control')";
	}

	DBQueryFatal("update interfaces set IP='' " .
		     "where node_id='$node' and $pred");
    }
}


#
# VIRTNODES HACK: Local virtnodes have to be mapped now. This is a little
# hokey in that the virtnodes just need to be allocated from the pool that
# is on the real node. We know they are free, but we should go through
# nalloc anyway.
#
foreach my $pnode (keys(%virtnodes)) {
    my @vlist = @{$virtnodes{$pnode}};
    my @plist = ();

    #
    # Run avail to get the list of virtnodes on the phys node. We already
    # know there are enough, since assign knows that.
    #
    my $num  = @vlist;
    
    open(AVAIL,"$TBROOT/sbin/avail virtonly=$pnode rand limit=$num |")
	or fatal(1, "*** $0:\n".
		    "    avail failed\n");

    while (<AVAIL>) {
	next
	    if (! /^\|/);
	next
	    if (/node_id/);
	
	my ($nodeid) = /^\|([-a-zA-Z0-9]+)\s*\|(\w+)\s*\|(\w+)\s*\|$/;
	push(@plist, $nodeid);
    }
    close(AVAIL);

    if (scalar(@vlist) != scalar(@plist)) {
	fatal(1, "*** $0:\n".
	         "Could not map some virtual nodes on $pnode\n");
    }

    #
    # Try to allocate. Note, if this fails we are done for. Okay for now
    # since it is never the case that it should fail!
    #
    print "Reserving @plist ...\n";
    if (system("nalloc $pid $eid @plist")) {
	fatal(1, "*** $0:\n".
	         "Failed to reserve @plist (on $pnode)\n");
    }
    while (@plist) {
	my $physical = pop(@plist);
	my $virtual  = pop(@vlist);

	$v2vmap{$virtual}  = $physical;
	printdb "  Mapping $virtual to $physical on $pnode\n";

	my $jailflag;
	my $phys_nodeid;

	TBIsNodeVirtual($physical, \$jailflag);
	
	$jailed{$virtual}  = $jailflag;
    }
}

TBExptSetPortRange();

######################################################################
# Step 3 - Convert to vlans, delays, and portmap
# 
# Here we convert the plinks into vlans, delays, and portmap.  We
# convert them first into internal datastructure.  After Step 4
# when we do some port swapping we'll upload the modified versions
# of these structures into the database.
#
# delays is indexed by an internal ID and contains:
#  [pnode, int0, int1, vname, delay, bandwidth, lossrate]
# portmap is indexed by <virtual node>:<virtual port> and contains
#  the physical port.
# vethmap is indexed by <virtual node>:<virtual port> and contains
#  the veth physical port if the portmap entry is a veth device.
#
# vlan ids
#  vlan ids are increasing integers in the case of node<->delay connections.
#  In the case of actual LANs either of real node or of delay nodes
#  they are indexed by virtual lan name.
# delay ids
#  delay ids are increasing integers.  We could have used a list of
# delays just as well.  Having it as an array may prove useful for
# future changes however.
######################################################################

$delayid = 0;

printdb "Interpreting results.\n";
TBDebugTimeStamp("interpreting started");
foreach $plink (keys(%plinks)) {
    # trivial links do not have physical links, so no delay nodes. But,
    # we *do* use trivial links for intranode links, and thus there could
    # be link delays (ie: two jailed nodes on a link/lan assigned to the
    # same phys node).
    my $trivial = 0;

    if (scalar(@{$plinks{$plink}})) {
	($nodeportA,$nodeportB) = @{$plinks{$plink}};
	($nodeA,$portA) = split(":", $nodeportA);
	($nodeB,$portB) = split(":", $nodeportB);
	printdb "plink $plink - $nodeportA $nodeportB\n";
    }
    else {
	$trivial = 1;
	printdb "plink $plink - trivial\n";
    }
    
    if (($lan,$virtA,$virtC) = ($plink =~ m|^linksdelaysrc/(.+)/(.+),(.+)$|)) {
	# trivial links do not have physical links, so no delay nodes.
	if ($trivial) {
	    next;
	}
	# Node has a single entry in lan.
	# Node is nodeportA
	# Delay node is nodeportB
	# Other end of delay node will be given by corresponding plink
	#   linksdelaydst/lan/virtC,virtA where nodeportA will be the other 
	#   node in the virtual LAN and nodeportB will be the other end of the
	#   delay node.
	($nodeportC,$nodeportD) =
	    @{$plinks{"linksdelaydst/$lan/$virtC,$virtA"}};
	($nodeC,$portC) = split(":",$nodeportC);
	($nodeD,$portD) = split(":",$nodeportD);
	printdb "LINK delay: other end = $nodeportC $nodeportD\n";

	# assert nodeB == nodeD

	printdb "  VLANS:\n";
	AddVlan("link", "$lan" . "-delaysrc", $nodeportA, $nodeportB);
	AddVlan("link", "$lan" . "-delaydst", $nodeportC, $nodeportD);
	
	my ($member0,$delay,$bandwidth,$lossrate,
	    $member1,$rdelay,$rbandwidth,$rlossrate) = @{$delaylinks{$plink}};
	
	$nodedelays{$delayid++} = [$nodeB,$portB,$portD,$lan,
			       $member0,$delay,$bandwidth,$lossrate,
			       $member1,$rdelay,$rbandwidth,$rlossrate];
	printdb "  Delay: \[$nodeB,$portB,$portD,$lan," .
	    "$delay,$bandwidth,$lossrate,$rdelay,$rbandwidth," .
	    "$rlossrate,$nodeportA,$nodeportC\]\n";

	#
	# Setup portmap using virt members in plink name.
	#
	$portmap{$virtA} = $portA;
	$portmap{$virtC} = $portC;
	printdb "  Portmap:\n";
	printdb "    $virtA = $portA\n";
	printdb "    $virtC = $portC\n";
    }
    elsif (($lan,$virtA) = ($plink =~ m|^linkdelaysrc/([^/]+)/(.+)$|)) {
	# trivial links do not have physical links, so no delay nodes.
	if ($trivial) {
	    next;
	}
	# Node may have multiple entries in lan.
	# Delay node is nodeB and portB.
	# Other end of delay node will be given by corresponding plink
	#  linkdelaydst/lan/node where nodeportA will the LAN node and
	#  nodeportB will be the other end of the delay node.
	
	($nodeportC,$nodeportD) = @{$plinks{"linkdelaydst/$lan/$virtA"}};
	($nodeC,$portC) = split(":",$nodeportC);
	($nodeD,$portD) = split(":",$nodeportD);
	printdb "LAN delay src: other end = $nodeportC $nodeportD\n";

	printdb "  VLANS:\n";
	AddVlan("link", $lan . "-delay" . $nodeA, $nodeportA, $nodeportB);
	AddVlan("lan",  $lan, $nodeportD);
	
	my ($member0,$delay,$bandwidth,$loss,
	    $member1,$rdelay,$rbandwidth,$rloss) = @{$delaylinks{$plink}};
	
	$nodedelays{$delayid++} = [$nodeB,$portB,$portD,$lan,
				   $member0,$delay,$bandwidth,$loss,
				   $member1,$rdelay,$rbandwidth,$rloss];
	printdb "  Delays: \[$nodeB,$portB,$portD,$lan," .
	    "$delay,$bandwidth,$loss,$rdelay,$rbandwidth,$rloss," .
	    "$nodeportA,$nodeportC\]\n";

	$portmap{$virtA} = $portA;
	printdb "  Portmap:\n";
	printdb "    $virtA = $portA\n";
    }
    elsif (($lan,$virtA,$virtB) = ($plink =~ m|^linksimple/(.+)/(.+),(.+)$|)) {
	#
	# nodeportA and nodeportB are the only two nodes in the LAN.
	# If the link is delayed, its with endpoint delays, not a delay node.
	#
	printdb "  Link:";

	#
	# trivial links do not have physical links, but could be using
	# virtual interfaces on the same node. 
	#
	if (! $trivial) {
	    AddVlan("link", $lan, $nodeportA, $nodeportB);

	    if ($useveth{$lan}) {
		#
		# Create some new veth devices.
		# 
		$portA = NewVethIface($virtA, $nodeA, $portA);
		$portB = NewVethIface($virtB, $nodeB, $portB);
	    }
	}
	else {
	    # No phys mapping. We create a veth, but there is no phys mapping
	    # for the port.
	    $nodeA = $v2pmap{(split(":", $virtA))[0]};
	    $nodeB = $v2pmap{(split(":", $virtB))[0]};
	    $portA = NewVethIface($virtA, $nodeA);
	    $portB = NewVethIface($virtB, $nodeB);
	}
	#
	# Setup portmap using virt members in plink name.
	#
	$portmap{$virtA} = $portA;
	$portmap{$virtB} = $portB;
	printdb "  Portmap:\n";
	printdb "    $virtA = $portA\n";
	printdb "    $virtB = $portB\n";
	
	if ($delaylinks{$plink}) {
	    my ($member0,$delay,$bandwidth,$loss,
		$member1,$rdelay,$rbandwidth,$rloss) =
		    @{$delaylinks{$plink}};

	    #
	    # Two entries, one for each side of the duplex link.
	    #
	    $linkdelays{$delayid++} = [$nodeA,$portA,$lan,$member0,
				       $delay,$bandwidth,$loss,
				       undef,undef,undef,0];
	    
	    $linkdelays{$delayid++} = [$nodeB,$portB,$lan,$member1,
				       $rdelay,$rbandwidth,$rloss,
				       undef,undef,undef,0];
	    
	    printdb "  LinkDelay: \[$nodeA,$portA,$nodeB,$portB," .
		"$lan,$delay,$bandwidth,$loss,$rdelay,$rbandwidth,$rloss\]\n";
	}
    }
    elsif (($lan,$virtA) = ($plink =~ m|^linklan/([^/]+)/(.+)$|)) {
	# node may be the LAN multiple times.
	# nodeportA is the node.
	# nodeportB is the LAN
	# No delays
	printdb "  LAN:";

	#
	# trivial links do not have physical links, but could be using
	# virtual interfaces on the same node. 
	#
	if (! $trivial) {
	    AddVlan("lan", $lan, $nodeportA);

	    if ($useveth{$lan}) {
		#
		# Create some new veth devices, and store the mapping
		# in vethmap so we know the veth->iface mapping later.
		# 
		$portA = NewVethIface($virtA, $nodeA, $portA);
	    }
	}
	else {
	    # No phys mapping. We create a veth, but there is no phys port.
	    $nodeA = $v2pmap{(split(":", $virtA))[0]};
	    $portA = NewVethIface($virtA, $nodeA);
	}
	$portmap{$virtA} = $portA;
	printdb "  Portmap:\n";
	printdb "    $virtA = $portA\n";
	
	if ($delaylinks{$plink}) {
	    my ($member0,$delay,$bandwidth,$loss,
		$member1,$rdelay,$rbandwidth,$rloss) =
		    @{$delaylinks{$plink}};

	    #
	    # One entry, comprising each side of the link to lan.
	    #
	    $linkdelays{$delayid++} = [$nodeA,$portA,$lan,$member0,
				       $delay,$bandwidth,$loss,
				       $rdelay,$rbandwidth,$rloss,1];
	    
	    printdb "  LinkDelay: \[$nodeA,$portA," .
		"$lan,$delay,$bandwidth,$loss,$rdelay,$rbandwidth,$rloss\]\n";
	}
    }
    elsif ($plink =~ m|^linkdelaydst/([^/]+)/(.+)$| ||
	   $plink =~ m|^linksdelaydst/(.+)/(.+),(.+)$|) {
	next;
    }
    else {
	warn("Bad plink: $plink\n");
    }
}
TBDebugTimeStamp("interpreting finished");

######################################################################
# Step 4 - Upload to DB
#
# Nothing fancy.
######################################################################
printdb "Uploading to DB\n";
TBDebugTimeStamp("uploading started");

# Write the vlans to the DB.
UploadVlans();

#
# Clean the virt_agents table.
# Yuck. There should be an agents table instead of munging virt_agents.
#
my $virt_agents =
    DBQueryFatal("select vname,vnode from virt_agents as v ".
		 "left join event_objecttypes as e on e.idx=v.objecttype ".
		 "where e.type='LINK' and pid='$pid' and eid='$eid'");

while (my ($vname,$vnode) = $virt_agents->fetchrow_array()) {
    DBQueryFatal("delete from virt_agents ".
		 "where pid='$pid' and eid='$eid' and ".
		 " vname='$vname' and vnode='$vnode'");
}

my $pipeid = 100;

foreach $delayid (keys(%nodedelays)) {
    # So r* indicates int1->int0 and others are int0->int1
    my ($pnode,$int0,$int1,$vname,
	$member0,$delay,$bandwidth,$lossrate,
	$member1,$rdelay,$rbandwidth,$rlossrate) = @{$nodedelays{$delayid}};

    # ipfw pipe number so we can control it remotely.
    my $pipe0 = $pipeid;
    my $pipe1 = $pipeid + 10;
    $pipeid += 100;

    my ($vnode0) = split(":", $member0);
    my ($vnode1) = split(":", $member1);

    #
    # We need to find the queue info. If its a member of a lan, there
    # is just one queue, towards the lan. A duplex link has two queues,
    # one for each member (outgoing side).
    #
    my @members = @{$lans{$vname}};
    if (@members == 2) {
	my ($q0_limit,$q0_maxthresh,$q0_minthresh,$q0_weight,$q0_linterm,
	    $q0_qinbytes,$q0_bytes,$q0_meanpsize,$q0_wait,$q0_setbit,
	    $q0_droptail,$q0_red,$q0_gentle) =
		@{$queueinfo{"$vname:$member0"}};

	my ($q1_limit,$q1_maxthresh,$q1_minthresh,$q1_weight,$q1_linterm,
	    $q1_qinbytes,$q1_bytes,$q1_meanpsize,$q1_wait,$q1_setbit,
	    $q1_droptail,$q1_red,$q1_gentle) =
		          @{$queueinfo{"$vname:$member1"}};
    
	DBQueryFatal("insert into delays " .
	     " (pid,eid,node_id,vname,iface0,iface1" .
	     ",vnode0,pipe0,delay0,bandwidth0,lossrate0" .
	     ",vnode1,pipe1,delay1,bandwidth1,lossrate1" .
	     ",q0_limit,q0_maxthresh,q0_minthresh,q0_weight,q0_linterm" .
	     ",q0_qinbytes,q0_bytes,q0_meanpsize,q0_wait,q0_setbit" .
	     ",q0_droptail,q0_red,q0_gentle" .
	     ",q1_limit,q1_maxthresh,q1_minthresh,q1_weight,q1_linterm" .
	     ",q1_qinbytes,q1_bytes,q1_meanpsize,q1_wait,q1_setbit" .
	     ",q1_droptail,q1_red,q1_gentle)" .
	     " values ('$pid','$eid','$pnode','$vname','$int0','$int1'".
	     ",'$vnode0',$pipe0,$delay,$bandwidth,$lossrate".
	     ",'$vnode1',$pipe1,$rdelay,$rbandwidth,$rlossrate".
	     ",$q0_limit,$q0_maxthresh,$q0_minthresh,$q0_weight,$q0_linterm".
	     ",$q0_qinbytes,$q0_bytes,$q0_meanpsize,$q0_wait,$q0_setbit".
	     ",$q0_droptail,$q0_red,$q0_gentle".
  	     ",$q1_limit,$q1_maxthresh,$q1_minthresh,$q1_weight,$q1_linterm".
	     ",$q1_qinbytes,$q1_bytes,$q1_meanpsize,$q1_wait,$q1_setbit".
	     ",$q1_droptail,$q1_red,$q1_gentle)");
    }
    else {
	my ($q0_limit,$q0_maxthresh,$q0_minthresh,$q0_weight,$q0_linterm,
	    $q0_qinbytes,$q0_bytes,$q0_meanpsize,$q0_wait,$q0_setbit,
	    $q0_droptail,$q0_red,$q0_gentle) =
		@{$queueinfo{"$vname:$member0"}};

	#
	# Obviously, its implied that the q0 params are towards the lan,
	# For the reverse side, force the queue to 2 slots (should be 1
	# but dummynet not quite precise enough) to avoid excess queuing
	# delay since the traffic should already be at the proper bandwidth
	# when it gets to the node.
	#
	DBQueryFatal("insert into delays" .
	     " (pid,eid,node_id,vname,iface0,iface1," .
	     "  vnode0,pipe0,delay0,bandwidth0,lossrate0," .
	     "  vnode1,pipe1,delay1,bandwidth1,lossrate1," .
	     "  q0_limit,q0_maxthresh,q0_minthresh,q0_weight,q0_linterm," .
	     "  q0_qinbytes,q0_bytes,q0_meanpsize,q0_wait,q0_setbit," .
	     "  q0_droptail,q0_red,q0_gentle,q1_limit,q1_qinbytes) " .
	     " values ('$pid','$eid','$pnode','$vname','$int0','$int1',".
	     "  '$vnode0',$pipe0,$delay,$bandwidth,$lossrate,".
	     "  '$vnode1',$pipe1,$rdelay,$rbandwidth,$rlossrate,".
	     "  $q0_limit,$q0_maxthresh,$q0_minthresh,$q0_weight,$q0_linterm,".
	     "  $q0_qinbytes,$q0_bytes,$q0_meanpsize,$q0_wait,$q0_setbit,".
	     "  $q0_droptail,$q0_red,$q0_gentle,2,0)");
    }

    #
    # Delay nodes require that we augment the virt_agents list. We used to
    # specify the node where the agent was running, but that will not work
    # for lans, where we need to direct the event to the agent running on
    # behalf of that node. So, we will do two things.  First, specify a
    # "wildcard" for the vnode; a "*" for the vnode will be treated
    # specially by the event scheduler, and no ipaddr will be inserted into
    # the event. Second, add pseudo agents, one for each member of the link
    # (or just one if a lan). The objname is lan-vnode, and allows us to
    # send an event to just the agent controlling that link (or lan node
    # delay). The delay-agent will subscribe to these additional names when
    # it starts up.
    #
    DBQueryFatal("replace into virt_agents ".
		 " (pid, eid, vname, vnode, objecttype) ".
		 " select '$pid', '$eid', '$vname', '*', ".
		 "   idx from event_objecttypes where ".
		 "   event_objecttypes.type='LINK'");

    DBQueryFatal("replace into virt_agents ".
		 " (pid, eid, vname, vnode, objecttype) ".
		 " select '$pid', '$eid', '${vname}-${vnode0}', '*', ".
		 "   idx from event_objecttypes where ".
		 "   event_objecttypes.type='LINK'");

    if (@members == 2) {
	DBQueryFatal("replace into virt_agents ".
		     " (pid, eid, vname, vnode, objecttype) ".
		     " select '$pid', '$eid', '${vname}-${vnode1}', '*', ".
		     "   idx from event_objecttypes where ".
		     "   event_objecttypes.type='LINK'");
    }

    #
    # We used to post-pass the eventlist to set the vnode where the agent
    # would be running, but this is no longer needed since the virt_agents
    # entry above will be used by the event scheduler to direct the event
    # to the proper place.
    # 

    #
    # XXX - Whenever a delay node is inserted, port speeds are set to
    #       100Mbs on the delay node ports. This is to ensure that
    #       they get a valid number instead of something left over, but
    #       also because this is a simplification.
    #       At some point we might want to force all the
    #       ports along the way to 10Mbs, and have the delay node worry
    #       about delay only, and not bandwidth. That will be harder to
    #       to do in this mess. See companion XXX above where portbw hash
    #       is set.
    #
    DBQueryFatal("update interfaces set " .
		 "current_speed='$S100Mbs' " .
		 "where node_id='$pnode' and ".
		 "(iface='$int0' or iface='$int1')");
}

#
# Link delays. These are done differently than delays since the above stuff
# is not quite right for doing link side delays. That may change as I
# better understand all this stuff. Anyway, a link delay is a delay that is
# established at the endpoints of the link, instead of on a delay node. So,
# in a duplex link, there would be a traffic shaping rule on each output
# side of the link. On a lan, there are two rules, one for traffic to the
# switch, and one for traffic from the switch. Like above, there are also
# queues associated with output side (to the switch) of a link.
#
foreach $delayid (keys(%linkdelays)) {
    my ($pnode,$iface,$lan,$member,
	$delay,$bandwidth,$lossrate,
	$rdelay,$rbandwidth,$rlossrate,$islan) = @{$linkdelays{$delayid}};

    # ipfw pipe numbers so we can control it remotely.
    my $pipe  = $pipeid;
    my $rpipe = $pipeid + 10;
    $pipeid += 100;

    my $ip      = $ips{$member};
    my ($vnode) = split(":", $member);
	
    #
    # We need to find the queue info. If its a member of a lan, there
    # is just one queue, *towards* the lan. A duplex link has two queues,
    # one for each member (outgoing side).
    #
    my ($q_limit,$q_maxthresh,$q_minthresh,$q_weight,$q_linterm,
	$q_qinbytes,$q_bytes,$q_meanpsize,$q_wait,$q_setbit,
	$q_droptail,$q_red,$q_gentle) =
	    @{$queueinfo{"$lan:$member"}};

    printdb("linkdelay ($vnode,$iface): lan = $lan, member = $member\n");

    DBQueryFatal("insert into linkdelays " .
		 " (node_id,iface,type,ip,pid,eid,vlan,vnode, ".
		 "  pipe,delay,bandwidth,lossrate, ".
		 "  q_limit,q_maxthresh,q_minthresh,q_weight, ".
		 "  q_linterm,q_qinbytes,q_bytes,q_meanpsize, ".
		 "  q_wait,q_setbit,q_droptail,q_red,q_gentle) ".
		 " values " .
		 " ('$pnode','$iface','simplex','$ip','$pid','$eid','$lan', ".
		 "  '$vnode',$pipe,$delay,$bandwidth,$lossrate, ".
		 "  $q_limit,$q_maxthresh,$q_minthresh,$q_weight, ".
		 "  $q_linterm,$q_qinbytes,$q_bytes,$q_meanpsize, ".
		 "  $q_wait,$q_setbit,$q_droptail,$q_red,$q_gentle)");

    #
    # If its a lan, add the from-switch stuff. On the node, the ipfw
    # pipe that is built for this will need to specify a queue size of 1.
    #
    if ($islan) {
	DBQueryFatal("update linkdelays set ".
		     " rpipe=$rpipe,rdelay=$rdelay,rbandwidth=$rbandwidth, ".
		     " rlossrate=$rlossrate,type='duplex' ".
		     "where node_id='$pnode' and ".
		     "      vlan='$lan' and vnode='$vnode'");
    }

    #
    # Link delays also require that we augment the virt_agents list, and
    # like delay nodes above we need to specify a "wildcard" for the vnode;
    # a "*" for the vnode will be treated specially by the event scheduler,
    # and no ipaddr will be inserted into the event. Second, add a pseudo
    # agent for the member of the link (or lan node). The objname is
    # lan-vnode, and allows us to send an event to just the agent
    # controlling that link (or lan node delay). The delay-agent will
    # subscribe to these additional names when it starts up.
    #
    DBQueryFatal("replace into virt_agents ".
		 " (pid, eid, vname, vnode, objecttype) ".
		 " select '$pid', '$eid', '$lan', '*', ".
		 "   idx from event_objecttypes where ".
		 "   event_objecttypes.type='LINK'");

    DBQueryFatal("replace into virt_agents ".
		 " (pid, eid, vname, vnode, objecttype) ".
		 " select '$pid', '$eid', '${lan}-${vnode}', '*', ".
		 "   idx from event_objecttypes where ".
		 "   event_objecttypes.type='LINK'");

    $expt_stats{"linkdelays"} += 1;

    #
    # We used to post-pass the eventlist to set the vnode where the agent
    # would be running, but this is no longer needed since the virt_agents
    # entry above will be used by the event scheduler to direct the event
    # to the proper place.
    # 
}

# NSE hack: list of ip addresses of simulated nodes that
# have an external link/lan and therefore have the corresponding
# ip on the interface of the physical node
my %simnode_extips = ();

# For recording IP aliases. see below.
my %IPaliases = ();

foreach $vnodeport (keys(%portmap)) {
    my ($vnode,$vport) = split(":",$vnodeport);
    my $pport = $portmap{$vnodeport};
    my $lan   = $memberof{$vnodeport};
    
    if ($nodes{$vnode} eq "shark-shelf") {
	# Shark Hack
	$shelf = $v2pmap{$vnode};
	$i = 1;
	foreach $shark (@{$sharkshelves{$vnode}}) {
	    DBQueryFatal("update interfaces set IPalias=\"$ips{$shark}\" " .
		    "where node_id = \"$shelf-$i\"");
	    $i++;
	}
	# End Shark Hack
    }
    if ($useveth{$lan}) {
	#
	# Emulated links on local virtual nodes use the new veth device.
	# This is still fuzzy. What about connections to non-bsd nodes?
	#
	# See NewVethIface() calls. Everything was set up then.
	#
	my $pnode = $v2pmap{$vnode};
	my $ip    = $ips{$vnodeport};

	printdb("IP: $pnode:$pport $ip\n");
    }
    else {
	#
	# Use ipaliases to catch if we have inserted an entry for this
	# pnode/iface yet. If not, insert a normal entry. If so, we want to
	# add a new ipalias for the interface. Thats cause assign can cause
	# an interface to be shared between multiple links, and so we need
	# ipaliases on the client side.
	#
	my $pnode = $v2pmap{$vnode};
	my $ip    = $ips{$vnodeport};

	if (! defined($IPaliases{"$pnode:$pport"})) {
	    printdb("IP: $pnode:$pport $ip\n");

	    DBQueryFatal("update interfaces set IP='$ip',IPaliases=NULL " .
			 "where node_id='$pnode' and iface='$pport'");

	    #
	    # If a sim node do something special? Avoid IP aliases too.
	    #
	    # XXX This appears to mean that in a sim node, the IP
	    # address in the interface table is constantly overwritten?
	    #
	    if ($nodes{$vnode} eq "sim") {
		if (! defined( $simnode_extips{$vnode})) {
		    $simnode_extips{$vnode} = [];
		}
		push(@{$simnode_extips{$vnode}}, $ips{$vnodeport});
	    }
	    else {
		$IPaliases{"$pnode:$pport"} = 1;
	    }
	}
	else {
	    printdb("IP: $pnode:$pport $ip (alias)\n");
	    
	    DBQueryFatal("update interfaces set ".
			 " IPaliases=CONCAT_WS(',', '$ip', IPaliases) ".
			 "where node_id='$pnode' and iface='$pport'");
	}
    }
}

# XXX NSE hack: We'll load the virt_routes table so as to
# calculate next physical hop info for sim nodes.

# This has a list of routes per node
my %noderoutes = ();
# This has routes based on node:dstip
my %routes = ();

my $res = DBQueryFatal("SELECT vname,dst,dst_type,dst_mask,nexthop " .
		       "from virt_routes where pid='$pid' and eid='$eid'");
while (($vname,$dstip,$dst_type,$dst_mask,$nexthop) = $res->fetchrow_array) {
  if( ! defined($noderoutes{$vname}) ) {
    $noderoutes{$vname} = [];
  }
  push(@{$noderoutes{$vname}}, [$dstip,$dst_type,$dst_mask,$nexthop]);
  $routes{"$vname:$dstip"} = $nexthop;
}

# contains routes for sim nodes that have external links
# This is again used to append to nseconfigs
my %modified_simroutes = ();
  
# These hacks wont work in the distributed nse case. Needs fixing...
# The algorithm traverses each route on the border sim node (i.e.
# nodes that capture and inject packets into real links) to its
# destination untill the hop is not a simulated node. 
foreach $simnode (keys(%simnode_extips)) {
  $modified_simroutes{$simnode} = [];
  foreach $route (@{$noderoutes{$simnode}}) {
    
    my ($dstip,$dst_type,$dst_mask,$nexthop) =
      @{$route}[0,1,2,3];

    printdb "on simnode $simnode $dstip -> $nexthop with $dst_mask\n";
    my $nhopip = $nexthop;
    my $nhopnode = $iptonodemap{$nhopip};
    while( 1 ) {

      if( $nodes{$nhopnode} ne "sim" ) {
	push( @{$modified_simroutes{$simnode}}, [$dstip, $dst_mask, $nhopip]);
	last;
      }

      # store prev values
      my $phopip = $nhopip;
      my $phopnode = $nhopnode;
      $nhopip = $routes{"$nhopnode:$dstip"};
      if( ! defined($nhopip) || $nhopip eq "" ) {
	# No route exists. Shouldn't have come till 
	# here coz staticroutes would have croaked first
	last;
      }
      $nhopnode = $iptonodemap{$nhopip};

      # break if we loop around to the same node
      if( $nhopnode eq $simnode ) {
	last;
      }
    }
  }
}

# NSE hack: need to update the ipaddrlist for sim nodes that
# have links to the external world
# Needs fix when we get distributed nse coz nseconfigs is per
# nse physical node. Currently we only have one
my $nseconfigs = "";

foreach $simnode (keys(%simnode_iplist)) {
  $nseconfigs .= "\$$simnode set ipaddrlist_ \[list ";
  foreach $ipaddr (@{$simnode_iplist{$simnode}}) {
    $nseconfigs .= "$ipaddr ";
  }
  $nseconfigs .= "\]\n";
}

foreach $simnode (keys(%simnode_extips)) {
  # update nseconfigs
  $nseconfigs .= "\$$simnode set nsenode_ipaddrlist \[list ";
  foreach $ipaddr (@{$simnode_extips{$simnode}}) {
    $nseconfigs .= "$ipaddr ";
  }
  $nseconfigs .= "\]\n";

  if( scalar(@{$modified_simroutes{$simnode}}) ) {
    $nseconfigs .= "\$$simnode set routes \{";
  }
  # appending routes for these sim nodes with external links
  foreach $route (@{$modified_simroutes{$simnode}}) {
    ($dstip, $dst_mask, $nhopip) = @{$route}[0,1,2];
    printdb "installing routes on simnode $simnode - $dstip -> $nhopip\n";
    $nseconfigs .= "DST=$dstip DST_MASK=$dst_mask NEXTHOP=$nhopip\n";
  }

  if( scalar(@{$modified_simroutes{$simnode}}) ) {
    $nseconfigs .= "\}\n\n";
  }
      
  
}

if( $nseconfigs ne "" ) {
  $nseconfigs .= "set simcode_present 1\n";
}

#
# Init each pnode.
# 
foreach $pnode (keys(%p2vmap)) {
    if (defined($sharkshelves{$p2vmap{$pnode}[0]})) {
	$i = 1;
	foreach $sharknodeport (@{$sharkshelves{$p2vmap{$pnode}[0]}}) {
	    $shark = (split(":",$sharknodeport))[0];
	    InitPnode("$pnode-$i", $shark);
	    $i++;
	}
    }
    else {
	# XXX NSE hack.
	#
	# For pnodes that have sim nodes, we just take the first. We
	# can decide the osid etc. based on the fact that the vnode is
	# a sim node For all other pnodes, there is a one-to-one
	# mapping between pnode and vnode. [0]th element is therefore
	# the vnode.
	InitPnode($pnode,$p2vmap{$pnode}[0]);
    }
}
#
# Ditto for the virtnodes that were allocated.
#
foreach $vnode (keys(%v2vmap)) {
    my $pnode = $v2vmap{$vnode};

    InitPnode($pnode, $vnode);
}

foreach $vnodeport (keys(%portbw)) {
    my ($vnode) = split(":",$vnodeport);
    # SHARK HACK
    # NSE hack: additional checks coz portbw is defined
    #
    if (defined($v2pmap{$vnode}) && defined($portmap{$vnodeport}) &&
	defined($portbw{$vnodeport}) ) {
	$pnode = $v2pmap{$vnode};
	$pport = $portmap{$vnodeport};
	DBQueryFatal("update interfaces set " .
		" current_speed=\"$portbw{$vnodeport}\"" .
		" where node_id=\"$pnode\" and iface=\"$pport\"");
    }
}

#
# Set the sshd ports. Its complicated by the fact that a single experiment
# could have multiple jailed nodes on the same physical node, and so a
# per-experiment wide sshd port is not going to work unless there happens
# to be just one jail per node, but thats not likely in the local area case.
# What would be the point.
#
foreach my $vnode (keys(%v2pmap)) {
    my $pnode  = $v2pmap{$vnode};
    my $vvnode = $v2vmap{$vnode};

    if ($isvirtnode{$vnode} && $jailed{$vnode}) {
	my $sshdport = nextipportnum($pnode);

	printdb("sshdport: $vnode $pnode $vvnode $sshdport\n");

	DBQueryFatal("update nodes set sshdport=$sshdport ".
		     "where node_id='$vvnode'");
    }
}

#
# Upload the tunnels table. These are built for remote node links.
#
# First need to assign ports to the servers. To do that need to figure
# out who is a server! We put the server on a real emulab node if
# possible, and otherwise one of the virtual nodes. Also, we want to share
# the server amongst more than one link, if possible, since a server can
# handle more than one tunnel. So, make sure that only one port is assigned
# per server node.
#
my %lantotunnelserver = ();
my %rnodetotunnelport = ();
my $secretkey;

foreach $lan (keys(%rnodelans)) {
    my $server;
    my ($vnode,$vport);

    #
    # Pick one of the members to be the server.
    # 
    foreach $member (@{$tunnels{$lan}}) {
	($vnode,$vport) = split(":",$member);

	if (! $isremotenode{$vnode} &&
	    ! defined($lantotunnelserver{$lan})) {
	    $server = $vnode;
	}
    }
    # If no one qualified, pick the last one.
    if (! defined($server)) {
	$server = $vnode;
    }
    $lantotunnelserver{$lan} = $server;

    # Assign a port, but only the first time chosen.
    if (! $rnodetotunnelport{$server}) {
	$rnodetotunnelport{$server} = nextipportnum($v2pmap{$server});
    }
}

printdb "Tunnels\n";
foreach $lan (keys(%rnodelans)) {
    printdb " LAN: $lan\n";

    my @members = @{$tunnels{$lan}};
    if (@members != 2) {
	fatal(1, "*** $0:\n".
	         "    Too many members for a tunnel!\n");
    }
    my $server = $lantotunnelserver{$lan};
    my $ipport = $rnodetotunnelport{$server};

    # So we can figure out the peer ip.
    my ($member0,$member1) = @members;
    my $node0  = (split(":",$member0))[0];
    my $node1  = (split(":",$member1))[0];
    
    foreach $member (@members) {
	my ($vnode,$vport) = split(":",$member);
	my $isserver  = ($server eq $vnode ? 1 : 0);
	my $peervnode = ($vnode eq $node0 ? $node1 : $node0);
	my $vvnode;
	my $peervvnode;
	my $ip;

	#
	# Note, if either side of the tunnel is on the local side, it
	# is connected to the physical node (pcxxx), even if its talking
	# to a local virtual node (say, a jail). Obviously, both sides
	# cannot be local. This is of course inconsistent.
	#
	if ($isremotenode{$vnode}) {
	    $vvnode= $v2vmap{$vnode};
	}
	else {
	    $vvnode= $v2pmap{$vnode};
	}
	if ($isremotenode{$peervnode}) {
	    $peervvnode= $v2vmap{$peervnode};
	}
	else {
	    $peervvnode= $v2pmap{$peervnode};
	}

	#
	# Need to map the server to the control net interface of the
	# physical node.
	#
	if (! TBControlNetIP($peervvnode, \$ip)) {
	    fatal(1, "*** $0:\n".
		     "    No Control Network IP for $peervvnode!\n");
	}
	
        printdb "  vnode:$vnode port:$ipport isserver:$isserver peer_ip:$ip ".
	        "inet:$ips{$member}\n";

	if (!defined($secretkey)) {
	    $secretkey = TBGenSecretKey();
	}
	
	DBQueryFatal("insert into tunnels ".
		     " (pid, eid, node_id, vname, isserver, ".
		     "  port, peer_ip, assigned_ip, password) ".
		     "values ('$pid', '$eid', '$vvnode', '$lan', $isserver, ".
		     "         $ipport, '$ip', '$ips{$member}','$secretkey')");
    }
}

#
# Must post pass the trafgens list to make sure no ip port collisions.
#
$query_result =
    DBQueryFatal("select vnode,vname,port,target_vnode,target_vname ".
		 "from virt_trafgens where pid='$pid' and eid='$eid'");

if ($query_result->numrows) {
    while (my ($vnode,$vname,$port,$target_vnode,$target_vname) =
	   $query_result->fetchrow_array()) {

	my $pnode    = $v2pmap{$vnode};
	my $ipport   = nextipportnum($pnode);

	DBQueryFatal("update virt_trafgens set port=$ipport ".
		     "where pid='$pid' and eid='$eid' and ".
		     " vnode='$vnode' and vname='$vname'");
	
	DBQueryFatal("update virt_trafgens set target_port=$ipport ".
		     "where pid='$pid' and eid='$eid' and ".
		     " vnode='$target_vnode' and vname='$target_vname'");
    }
}

#
# Adding to the v2pmap table
#
foreach my $vnode (keys(%v2pmap)) {
    my $pnode;

    #
    # If a virtual node, the pnode is the virtual node, not the underlying
    # physical node. The only place I know that cares about this table is
    # dohosts() in tmcd.c, which gets the host table wrong inside a jail
    # cause the pnode is not set properly.
    #
    if ($isvirtnode{$vnode}) {
	$pnode = $v2vmap{$vnode};
    }
    else {
	$pnode = $v2pmap{$vnode};
    }

    DBQueryFatal("insert into v2pmap (pid,eid,vname,node_id) values " .
		 "('$pid','$eid','$vnode','$pnode')");
}
UploadStats();
TBDebugTimeStamp("uploading finished");

TBDebugTimeStamp("assign_wrapper finished");
exit 0;

######################################################################
# Subroutines
######################################################################

# min(a,b)
# Returns the minimum of a and b.
sub min {
    my ($a,$b) = @_;
    return ($a < $b ? $a : $b);
};

# max(a,b)
# Returns the minimum of a and b.
sub max {
    my ($a,$b) = @_;
    return ($a > $b ? $a : $b);
};

# getbandwidth(bw)
# Returns the lowest ok bandwidth that is greater than or equal to
# the one passed.
sub getbandwidth {
    my $targetbandwidth= BWConvert($_[0]);
    my $bandwidth;
    my $best = 10000000000;
    foreach $bandwidth (keys(%okbandwidths)) {
	if (($bandwidth >= $targetbandwidth) && ($bandwidth < $best)) {
	    $best = $bandwidth;
	}
    }
    return $best;
};

# getnodeport(s)
# Takes a ports result from assign (mac0,mac1) and returns the
# first non-null one.
sub getnodeport {
    $macstring=$_[0];
    ($A,$B) = ($macstring =~ /^\(([^,]+),([^,]+)\)$/);
    if ($A ne "(null)") {
	return $A;
    } else {
	return $B;
    }
};

sub InitPnode($pnode, $vnode)
{
    my ($pnode,$vnode) = @_;
    my $vname = $vnode;
    my $osid;
    
    my $query_result =
	DBQueryFatal("SELECT type from nodes where node_id='$pnode'");
    my ($type) = $query_result->fetchrow_array();

    $query_result =
	DBQueryFatal("SELECT cmd_line,rpms,deltas, " .
		     " startupcmd,tarfiles,failureaction,routertype " .
		     "from virt_nodes where pid='$pid'" .
		     " and eid='$eid' and vname='$vnode'");

    # XXX NSE hack: if the vnode is simulated, we just
    # choose FBSD-STD and static routing
    if (defined($nodes{$vnode}) && $nodes{$vnode} eq "sim") {
	$osid = TBOSID("emulab-ops", "FBSD45-NSE" );
	
	DBQueryFatal("UPDATE nodes set def_boot_cmd_line=''," .
		     " startstatus='none'," .
		     " bootstatus='unknown'," .
		     " ready=0," .
		     " rpms=''," .
		     " deltas=''," .
		     " tarballs=''," .
		     " startupcmd=''," .
		     " failureaction=''," .
		     " routertype='static'" .
		     " where node_id='$pnode'");

	$vname = "nsenode${nsenode_id}";
	DBQueryFatal("update reserved set vname='$vname'" .
		     "where node_id='$pnode'");
	$nsenode_id++;

	# Right now, we have only one row for nseconfigs per experiment.
	# This will change in the distributed nse case. Also reparsing of
	# nseconfigs will have to be done for the distributed case
	DBQueryFatal("update nseconfigs set vname='$vname' " .
		     "where pid='$pid' and eid='$eid'");

	# also append stuff to nse configs with ipaddr info for border nodes
	# nseconfigs will be per nse physical node in the distributed
	# case. needs fix later
	if ($nseconfigs ne "") {
	    DBQueryFatal("update nseconfigs set ".
			 " nseconfig=CONCAT(nseconfig, '$nseconfigs') ".
			 "where pid='$pid' and eid='$eid' and ".
			 "      vname='$vname'");
	}
    }
    elsif ($isremotenode{$vnode} && $v2vmap{$vnode} ne $pnode) {
	#
	# We never allocate remote pnodes (always allocated), so skip.
	#
	return;
    }
    elsif (defined($virtnodes{$pnode})) {
	# A pnode hosting jails. At the moment, we force these to a
	# hardwired osid.
	$osid = $jailosids{$type};
	
	DBQueryFatal("UPDATE nodes set startstatus=\"none\"," .
		     " bootstatus=\"unknown\"," .
		     " ready=0" .
		     " where node_id=\"$pnode\"");

	#
	# A local pnode hosting jails. Set the vname to something useful.
	#
	$vname = "vhost-" . $virtnode_id;
	$virtnode_id++;

	DBQueryFatal("update reserved set vname='$vname' " .
		     "where node_id='$pnode'");

	$expt_stats{"jailnodes"} += 1;
    }
    else {
	#
	# We want to skip nodes that belong to the experiment but aren't
	# user defined nodes. I.e. delay nodes.
	#
	if (($cmdline,$rpms,$deltas,$startupcmd,$tarfiles,
	     $failureaction,$routertype) = $query_result->fetchrow_array()) {

	    # If no OSID defined, then use type-default.
	    if (defined($virtnodeosids{$vnode})) {
		$osid = $virtnodeosids{$vnode};
	    }
	    else {
		$osid = $defaultosids{$type};
	    }

	    DBQueryFatal("UPDATE nodes set def_boot_cmd_line='$cmdline'," .
			 " startstatus='none'," .
			 " bootstatus='unknown'," .
			 " ready=0," .
			 " rpms='$rpms'," .
			 " deltas='$deltas'," .
			 " tarballs='$tarfiles'," .
			 " startupcmd='$startupcmd'," .
			 " failureaction='$failureaction'," .
			 " routertype='$routertype'" .
			 " where node_id='$pnode'");

	    DBQueryFatal("update reserved set vname='$vname' " .
			 "where node_id='$pnode'");
	}
	elsif (! defined($lannodes{$p2vmap{$pnode}[0]})) {
	    # Delay node
	    $osid = $delayosids{$type};
	    
	    DBQueryFatal("UPDATE nodes set startstatus=\"none\"," .
			 " bootstatus=\"unknown\"," .
			 " ready=0" .
			 " where node_id=\"$pnode\"");

	    DBQueryFatal("update reserved set vname='$vname' " .
			 "where node_id='$pnode'");

	    $expt_stats{"delaynodes"} += 1;
	}
    }
    printdb("reserved vname: $pnode $vname\n");
    
    #
    # Now call os_select.
    #
    if (defined($osid)) {
	printdb("os_select $osid $pnode\n");
	system("os_select $osid $pnode");
    }
    return 0;
}

#
# Indexed by phys node. If there are no virtual nodes, then there
# is no port sharing, and it makes no difference, as long as there are
# no collisions on a node. If there are virtual nodes, then assign a
# port range for the experiment, and all port allocations need to be
# shared within that range on each phys node. That is, if there are 2
# virtual nodes on physical node, then must allocated from the one range.
# There is never any overlap between experiements of course.
# 
my %portnext	= ();
my %porthigh    = ();

sub TBExptSetPortRange {
    my @nodelist = ();
    
    #
    # See if any virtual nodes. If not, no need to do anything since
    # all port allocations will come from physical node. 
    #
    foreach my $vnode (keys(%v2pmap)) {
	my $pnode  = $v2pmap{$vnode};

	if ($isvirtnode{$vnode}) {
	    push(@nodelist, $pnode);
	}
	else {
	    # Same big port range for all phys nodes. 
	    $portnext{$pnode} = TBDB_LOWVPORT;
	    $porthigh{$pnode} = TBDB_MAXVPORT;
	}
    }
    if (! @nodelist) {
	return 0;
    }

    #
    # Otherwise find a free slot in the table.
    #
    DBQueryFatal("lock tables ipport_ranges write");

    my $range_result =
	DBQueryFatal("select low,high from ipport_ranges order by low");

    my $newlow;
    my $newhigh;
    my $lastlow;
    my $lasthigh;
    
    if (!$range_result->num_rows) {
	$newlow = TBDB_LOWVPORT;
    }
    else {
	($lastlow, $lasthigh) = $range_result->fetchrow_array();

	# A hole at the bottom of the range ...
	if ($lastlow >= TBDB_LOWVPORT + TBDB_PORTRANGE) {
	    $newlow = TBDB_LOWVPORT;
	}
	# Else, find a free hole. 
	else {
	    while (my ($thislow,$thishigh) = $range_result->fetchrow_array()) {
		if ($thislow != $lasthigh + 1 &&
		    $thislow - $lasthigh > TBDB_PORTRANGE) {
		    $newlow = $lasthigh + 1;
		    last;
		}
		$lasthigh = $thishigh;
	    }
	}
    }
    if (!defined($newlow)) {
	# No holes, tack onto the end. 
	$newlow = $lasthigh + 1;
    }
    if ($newlow >= TBDB_MAXVPORT) {
	DBQueryFatal("unlock tables");
	return -1;
    }
    $newhigh = $newlow + TBDB_PORTRANGE - 1;
	
    DBQueryFatal("insert into ipport_ranges ".
		 " (pid, eid, low, high) ".
		 "values ('$pid', '$eid', $newlow, $newhigh)");
    DBQueryFatal("unlock tables");
    printdb "Setting ipport range to $newlow,$newhigh\n";

    #
    # Now set the port range for those nodes hosting virtual nodes.
    # This prevents overlap with other vnodes from other experiments
    # on that nodes. Since you cannot share a node unless you are using
    # virtual nodes, there is no need to worry about phys nodes that
    # are dedicated. That might change of course. 
    #
    foreach my $pnode (@nodelist) {
	$portnext{$pnode} = $newlow + 10;
	$porthigh{$pnode} = $newhigh;

	DBQueryFatal("update nodes set ipport_low=$newlow, ".
		     " ipport_next=ipport_low+1, ipport_high=$newhigh ".
		     "where node_id='$pnode'");
    }
    return 0;
}

#
# Bump and return the IP port number for a node. This is
# required for multiplexing virtual nodes on a physical node. It has
# to be done after node assignment of course.
#
# returns port on success, dies if no more ports.
# 
sub nextipportnum($) {
    my ($pnode)  = @_;
    my $port     = $portnext{$pnode};

    if ($port >= $porthigh{$pnode}) {
	fatal(1, "*** $0:\n".
	         "    No more dynamic ports available for $pnode!\n");
    }
    $portnext{$pnode}++;
    return $port;
}

#
# Vlan stuff.
#
my %vlantable  = ();
my $vlanid     = 0;

#
# Add a vlan to the list. We have to watch for duplicates that can result
# when doing emulated links. There are two kinds of vlans; one for duplex
# links, which always have two members, and another for lans which can have
# one or more members. 
#
sub AddVlan($$$;$)
{
    my ($type, $lan, $nodeportA, $nodeportB) = @_;

    if ($type eq "lan") {
	# Start a list of nodeports in the vlan.
	if (! defined($vlantable{$lan})) {
	    $vlantable{$lan} = [$nodeportA];
	    printdb "  $lan, \[" . $nodeportA . "\]\n";
	    return;
	}
	
	#
	# Make sure we add only unique nodeport entries to the lan. 
	#
	if (! grep {$_ eq $nodeportA} @{$vlantable{$lan}}) {
	    push(@{$vlantable{$lan}}, $nodeportA);
	}
	printdb "  $lan, \[" . join(" ",@{$vlantable{$lan}}) . "\]\n";
    }
    elsif ($emulated{$lan}) {
	#
	# Like above, except that in this case, its a bunch of vlinks
	# sharing a smaller set of physical links. Just mark is differently
	# here. See UploadVlans() below; these vlans will be merged to
	# into one big supervlan since a nodeport can be in just one vlan
	# at a time.
	#
	# Make up a name for the "super" vlan.
	#
	my $newid = "s$lan:" . $vlanid++;
	
	$vlantable{$newid} = [$nodeportA, $nodeportB];

	printdb "  $newid (SVLAN), \[$nodeportA, $nodeportB\]\n";	
    }
    else {
	#
	# Generate a new vlan of two members.
	# 
	$vlantable{$lan} = [$nodeportA, $nodeportB];

	printdb "  $lan, \[$nodeportA, $nodeportB\]\n";	
    }
}

#
# Write the vlans table to the DB.
#
sub UploadVlans()
{
    #
    # Emulated vlans will result in node:port pairs being in more than
    # one vlan since that link is shared for several lans. The hardware
    # cannot support that of course, so we have to build merge the
    # vlans into "supervlans". Must be done iteratively of course.
    # 
    printdb "Merging vlans.\n";
  again:
    foreach my $keyA (keys(%vlantable)) {
	my @membersA = @{$vlantable{$keyA}};

	foreach my $keyB (keys(%vlantable)) {
	    my @membersB = @{$vlantable{$keyB}};

	    if ($keyA ne $keyB) {
		foreach my $memberA (@membersA) {
		    if (grep {$_ eq $memberA} @membersB) {
			foreach my $memberB (@membersB) {
			    if (! grep {$_ eq $memberB} @membersA) {
				push(@{$vlantable{$keyA}}, $memberB);
			    }
			}
			delete($vlantable{$keyB});
			goto again;
		    }
		}
	    }
	}
    }
    
    printdb "Uploading vlans table.\n";
    
    foreach my $lanid (keys(%vlantable)) {
	my $lan        = (split(":", $lanid))[0];
	my $memberlist = join(" ", @{$vlantable{$lanid}});
    
	printdb "  $lanid - $memberlist\n";
    
	DBQueryFatal("insert into vlans (id,pid,eid,virtual,members) ".
		     "values (0, '$pid', '$eid', '$lan', '$memberlist')");
    }
}

#
# Check max concurrent to see if there are already the maximum allowed
# nodes running each image. This check is fuzzy since there is no
# atomicity, but there is another check later in os_load which might
# catch it to. But this will get it most of the time and prevent
# failures much later in the swapin process.
#
sub CheckMaxConcurrent()
{
    my %counts	= ();

    # First get counts of each usage.
    foreach my $osid (values(%virtnodeosids)) {
	$counts{$osid} = 0
	    if (!defined($counts{$osid}));
	$counts{$osid}++;
    }

    # Now check.
    foreach my $osid (keys(%counts)) {
	my $count = $counts{$osid};

	if (!TBOSLoadMaxOkay($osid, $count)) {
	    fatal(2|1|64,
		  "*** $0:\n".
		  "    Cannot load $osid on one or more nodes.\n".
		  "    Too many nodes are already running this OSID!");
	}
    }
}

#
# Write the stats record to the DB. 
#
sub UploadStats()
{
    GatherAssignStats($pid, $eid, %expt_stats);
}

#
# Create a new veth interface. This sets up the entire veth slot,
# including IP and mac.
#
sub NewVethIface($$;$)
{
    my ($vnodeport, $pnode, $pport) = @_;
    my ($vnode) = split(":", $vnodeport);
    my $ip      = $ips{$vnodeport};
    my $vvnode  = "NULL";

    # Null pport means no phys port.
    if (!defined($pport)) {
	$pport = "NULL";
    }
    else {
	$pport = "'$pport'";
    }

    # Mark as being a jail interface be establishing a connection
    # to the nodes table entry for the virtnode. 
    if ($isvirtnode{$vnode} && $jailed{$vnode}) {
	$vvnode = "'$v2vmap{$vnode}'";
    }

    #
    # Not sure about the MAC yet. We need to create something, and
    # for now it will be helpful for debugging if I use the IP.
    # 
    my $mac   = sprintf "0000%.2x%.2x%.2x%.2x", split(/\./, $ip);

    #
    # Insert, and then get the id so we can form the name of the veth device. 
    # 
    my $query_result = 
	DBQueryFatal("insert into veth_interfaces ".
		     "(node_id, veth_id, mac, IP, iface, vnode_id) ".
		     "values ('$pnode', 0, '$mac', '$ip', $pport, $vvnode)");

    return "veth" . $query_result->insertid;
}
