#!/usr/bin/perl -w
#
# EMULAB-COPYRIGHT
# Copyright (c) 2004 University of Utah and the Flux Group.
# All rights reserved.
#

#
# Some ElabInElab support for managing vlans via outer boss node.
#
package snmpit_remote;

use Exporter;
@ISA = ("Exporter");
@EXPORT = qw( RemoteDoVlansFromTables RemoteDoReset
		RemoteDoTrunking RemoteDoList);

# Must come after package declaration!
use lib '@prefix@/lib';
use English;
use libdb;
use libtestbed;
use snmpit_lib;
use libxmlrpc;

# Configure variables
my $TB		= "@prefix@";
my $TBOPS       = "@TBOPSEMAIL@";
my $RPCSERVER   = "@OUTERBOSS_NODENAME@";
my $RPCPORT     = "@OUTERBOSS_XMLRPCPORT@";
my $RPCCERT     = "@OUTERBOSS_SSLCERTNAME@";

# Locals
my $didsetup	= 0;

#
# Configure xmlrpc library to talk to outer boss.
#
sub ConfigXMLRPC()
{
    return 0
	if ($didsetup);
    
    libxmlrpc::Config({"server"  => $RPCSERVER,
		       "verbose" => 1,
		       "cert"    => $RPCCERT,
		       "portnum" => $RPCPORT});

    $didsetup = 1;
    return 0;
}
#
# All of these routines end in exactly the same way
# differing only in what the "op", and "arg" value of the hashes are.
#

sub commonTail($$)
{
    my $op = shift();
    my $arg = shift();

    ConfigXMLRPC();

    # sklower is temporarily going to way violate layering
    # and reach down into the internals of libxmlrpc to
    # grab the returned output string, until he can figure out
    # the proper python for returning a blob.

    my $response = libxmlrpc::CallMethod0("elabinelab", "vlans",
				     {"op"    => $op, "arg"   => $arg});

    if (($config{"verbose"} || $response->{"code"}) &&
	defined($response->{"output"}) && $response->{"output"} ne "") {
	print $response->{"output"};
    }
    return ($response->{"code"}) ? undef : $response->{"output"};
}


#
# Ask outer boss to setup a bunch of vlans for an experiment.
#
sub RemoteDoVlansFromTables(@)
{
    my @vlans     = @_;
    my $vlantable = {};

    return 0
	if (! @vlans);

    my $prefix = "" ;
    TBGetSiteVar("federation/localprefix",\$prefix);

    my $result =
	DBQueryFatal("select virtual,members,id from vlans where " .
		     # Join "id='foo'" with ORs
		     join(' OR ', map("id='$_'",@vlans)));

    return 0
	if (! $result->numrows);
    
    while (my ($virtual,$members,$id) = $result->fetchrow()) {
	# $members is a space-seprated list

	$vlantable->{$id} = {};
	$vlantable->{$id}->{"virtual"} = $virtual;
	$vlantable->{$id}->{"members"} = {};
	
	foreach my $port (split /\s+/,$members) {
	    # Due to the inconsistent nature of our tables (curses!), we
	    # have to do some conversion here
	    $port =~ /^(.+):(.+)/;
	    my ($node,$iface) = ($1,$2);
	    if (!defined($node) || !defined($iface)) {
		warn "WARNING: Bad node in VLAN: $port - skipping\n";
		next;
	    }
	    my $result =
		DBQueryFatal("select current_speed,duplex from interfaces " .
			     "where node_id='$node' and iface='$iface'");
	    if (!$result->num_rows()) {
		warn "WARNING: Bad node/iface pair in VLAN: $port - skipping\n";
		next;
	    }
	    my ($speed,$duplex) = $result->fetchrow();

	    if ($prefix ne "") {
		$port =~ s/$prefix// ;
	    }

	    $vlantable->{$id}->{"members"}->{$port} = {};
	    $vlantable->{$id}->{"members"}->{$port}->{"speed"} = $speed;
	    $vlantable->{$id}->{"members"}->{$port}->{"duplex"} = $duplex;
	}
    }
    return 0
	if (! keys(%$vlantable));

    my $errors = 0;
    my $xmlback =  commonTail("setup",$vlantable);

    if (defined($xmlback)) {
	foreach my $vlres (split ',', $xmlback) {
	    my ($name, $num) = split '#', $vlres;
	    $result =
		DBQuery("update vlans set tag=$num where id='" . $name . "'");
	    if (!defined($result)) {
		print STDERR "couldn't set vlan tag from returned vlan map " .
		   "for vlan $name\n";
		    $errors++;
	    }
	}
    } else { $errors = 1; }
    return $errors;
}

#
# Ask outer boss to tear down a bunch of vlans for an experiment.
#
sub RemoteDoReset(@)
{
    my @vlans     = @_;
    
    return 0
	if (! @vlans);
    my $res = commonTail("destroy", join(",", @vlans));
    return !defined($res);
}

#
# Ask outer boss to set a port into trunk mode (snmpit -T or -E )
# 1st arg (mode) is "-T" (dual), "-E" (regular i.e. normal or equal)
# or "-U" to reset to the usual un-trunked mode.
#
sub RemoteDoTrunking($$@)
{
    my $arg = {};
    $arg->{"mode"} = shift();
    my $port = shift();
    my @vlans     = @_;

    $arg->{"vlans"} = @vlans ?  join(",", @vlans) : "";
    
    my $prefix = "" ;
    TBGetSiteVar("federation/localprefix",\$prefix);
    if ($prefix ne "") {
	$port =~ s/$prefix// ;
    }
    $arg->{"port"} = $port;

    my $res = commonTail("trunk", $arg);
    return !defined($res);
}

#
# Ask outer boss to send the vlan names , numbers , and members
# snmpit -l -w (or restrict to a specific list of vlans)
# Result is returned in the format as if it were from a switch module.
#
sub RemoteDoList(@)
{
    my @vlans     = @_;
    my %Names = ();
    my %Members = ();
    my @list = ();
    my $arg = @vlans ? join(",", @vlans) : "";

    my $xmlback = commonTail("list",$arg);
    if (!defined($xmlback)) { return @list; }

    my $prefix = "" ;
    TBGetSiteVar("federation/localprefix",\$prefix);
    #
    #  Walk the table for the VLAN members
    #
    foreach my $vlres (split ',', $xmlback) {
	my ($name, $num, $mems) = split '#', $vlres;
	$Names{$num} = $name;
        @{$Members{$num}} = ();
	foreach my $mem (split " ", $mems) {
	    push @{$Members{$num}}, $prefix . $mem;
	}
    }

    #
    # Build a list from the name and membership lists
    #
    foreach my $vlan_id (sort keys %Names) {
	if ($vlan_id !=  1) {
	    push @list, [$Names{$vlan_id},$vlan_id,$Members{$vlan_id}];
	}
    }
    return @list;
}

# End with true
1;
