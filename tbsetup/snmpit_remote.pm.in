#!/usr/bin/perl -w
#
# EMULAB-COPYRIGHT
# Copyright (c) 2004-2008 University of Utah and the Flux Group.
# All rights reserved.
#

#
# Some ElabInElab support for managing vlans via outer boss node.
#
package snmpit_remote;

use Exporter;
@ISA = ("Exporter");
@EXPORT = qw( RemoteDoVlansFromTables RemoteDoReset
		RemoteDoTrunking RemoteDoList);

# Must come after package declaration!
use lib '@prefix@/lib';
use English;
use libdb;
use libtestbed;
use snmpit_lib;
use Lan;
use libxmlrpc;

# Configure variables
my $TB		= "@prefix@";
my $TBOPS       = "@TBOPSEMAIL@";
my $RPCSERVER   = "@OUTERBOSS_NODENAME@";
my $RPCPORT     = "@OUTERBOSS_XMLRPCPORT@";
my $RPCCERT     = "@OUTERBOSS_SSLCERTNAME@";

# Locals
my $didsetup	= 0;

#
# Configure xmlrpc library to talk to outer boss.
#
sub ConfigXMLRPC()
{
    return 0
	if ($didsetup);
    
    libxmlrpc::Config({"server"  => $RPCSERVER,
		       "verbose" => 1,
		       "cert"    => $RPCCERT,
		       "portnum" => $RPCPORT});

    $didsetup = 1;
    return 0;
}
#
# All of these routines end in exactly the same way
# differing only in what the "op", and "arg" value of the hashes are.
#

sub commonTail($$)
{
    my $op = shift();
    my $arg = shift();

    ConfigXMLRPC();

    # sklower is temporarily going to way violate layering
    # and reach down into the internals of libxmlrpc to
    # grab the returned output string, until he can figure out
    # the proper python for returning a blob.

    my $response = libxmlrpc::CallMethod0("elabinelab", "vlans",
				     {"op"    => $op, "arg"   => $arg});

    if (($config{"verbose"} || $response->{"code"}) &&
	defined($response->{"output"}) && $response->{"output"} ne "") {
	print $response->{"output"};
    }
    return ($response->{"code"}) ? undef : $response->{"output"};
}


#
# Ask outer boss to setup a bunch of vlans for an experiment.
#
sub RemoteDoVlansFromTables(@)
{
    my @vlanids   = @_;
    my $vlantable = {};
    my %vlans     = ();

    return 0
	if (! @vlanids);

    my $prefix = "" ;
    TBGetSiteVar("federation/localprefix",\$prefix);

    foreach my $vlanid (@vlanids) {
	my $vlan = VLan->Lookup($vlanid);
	return -1
	    if (!defined($vlanid));
	$vlans{"$vlanid"} = $vlan;
    }

    foreach my $id (keys(%vlans)) {
	my $vlan = $vlans{"$id"};
	my @members;

	$vlantable->{$id} = {};
	$vlantable->{$id}->{"virtual"} = $vlan->vname();
	$vlantable->{$id}->{"members"} = {};

	if ($vlan->MemberList(\@members) != 0) {
	    warn "WARNING: Could not get members for $vlan\n";
	    return -1;
	}
	foreach my $member (@members) {
	    my $node;
	    my $iface;

	    if ($member->GetNodeIface(\$node, \$iface) != 0) {
		warn "WARNING: Could not get nodeport for $member\n";
		return -1;
	    }
	    if (!defined($node) || !defined($iface)) {
		warn "WARNING: Bad node in VLAN member: $member - skipping\n";
		next;
	    }
	    my $node_id = $node->node_id();
	    my $port    = "$node_id:$iface";
	    
	    my $result =
		DBQueryFatal("select current_speed,duplex from interfaces " .
			     "where node_id='$node_id' and iface='$iface'");
	    if (!$result->num_rows()) {
		warn "WARNING: Bad node/iface pair in VLAN: $port - skipping\n";
		next;
	    }
	    my ($speed,$duplex) = $result->fetchrow();

	    if ($prefix ne "") {
		$port =~ s/$prefix// ;
	    }

	    $vlantable->{$id}->{"members"}->{$port} = {};
	    $vlantable->{$id}->{"members"}->{$port}->{"speed"} = $speed;
	    $vlantable->{$id}->{"members"}->{$port}->{"duplex"} = $duplex;
	}
    }
    return 0
	if (! keys(%$vlantable));

    my $errors = 0;
    my $xmlback =  commonTail("setup",$vlantable);

    if (defined($xmlback)) {
	foreach my $vlres (split ',', $xmlback) {
	    my ($vlanid, $tag) = split '#', $vlres;
	    
	    if (!exists($vlans{$vlanid})) {
		print STDERR "Ban vlanid $vlanid in returned vlan map\n";
		$errors++;
	    }
	    my $vlan = $vlans{$vlanid};

	    if ($vlan->SetTag($tag) != 0) {
		print STDERR "could not set vlan tag for $vlan\n";
		$errors++;
	    }
	}
    }
    else {
	$errors = 1;
    }
    return $errors;
}

#
# Ask outer boss to tear down a bunch of vlans for an experiment.
#
sub RemoteDoReset(@)
{
    my @vlans     = @_;
    
    return 0
	if (! @vlans);
    my $res = commonTail("destroy", join(",", @vlans));
    return !defined($res);
}

#
# Ask outer boss to set a port into trunk mode (snmpit -T or -E )
# 1st arg (mode) is "-T" (dual), "-E" (regular i.e. normal or equal)
# or "-U" to reset to the usual un-trunked mode.
#
sub RemoteDoTrunking($$@)
{
    my $arg = {};
    $arg->{"mode"} = shift();
    my $port = shift();
    my @vlans     = @_;

    $arg->{"vlans"} = @vlans ?  join(",", @vlans) : "";
    
    my $prefix = "" ;
    TBGetSiteVar("federation/localprefix",\$prefix);
    if ($prefix ne "") {
	$port =~ s/$prefix// ;
    }
    $arg->{"port"} = $port;

    my $res = commonTail("trunk", $arg);
    return !defined($res);
}

#
# Ask outer boss to send the vlan names , numbers , and members
# snmpit -l -w (or restrict to a specific list of vlans)
# Result is returned in the format as if it were from a switch module.
#
sub RemoteDoList(@)
{
    my @vlans     = @_;
    my %Names = ();
    my %Members = ();
    my @list = ();
    my $arg = @vlans ? join(",", @vlans) : "";

    my $xmlback = commonTail("list",$arg);
    if (!defined($xmlback)) { return @list; }

    my $prefix = "" ;
    TBGetSiteVar("federation/localprefix",\$prefix);
    #
    #  Walk the table for the VLAN members
    #
    foreach my $vlres (split ',', $xmlback) {
	my ($name, $num, $mems) = split '#', $vlres;
	$Names{$num} = $name;
        @{$Members{$num}} = ();
	foreach my $mem (split " ", $mems) {
	    push @{$Members{$num}}, $prefix . $mem;
	}
    }

    #
    # Build a list from the name and membership lists
    #
    foreach my $vlan_id (sort keys %Names) {
	if ($vlan_id !=  1) {
	    push @list, [$Names{$vlan_id},$vlan_id,$Members{$vlan_id}];
	}
    }
    return @list;
}

# End with true
1;
