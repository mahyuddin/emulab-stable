#!/usr/bin/python

#
# EMULAB-LGPL
# Copyright (c) 2012 University of Utah and the Flux Group.
# All rights reserved.
#

#
# Daemon server running on Arista switch side for snmpit_arista.
#

import PyClient
import SimpleXMLRPCServer
import sys

RPC_PORT = @ARISTA_SWITCH_XMLRPCPORT@
BIND_ADDR = "@ARISTA_SWITCH_BIND_ADDRESS@"

VLAN_ID_PREFIX = "EV_"
DEFAULT_VLAN_NUM = 1

# Global SysDB client and configuration root
sysdbroot = None
sysdbclient = None

debug_level = 1;

def debug(msg, level = 1):
    if level <= debug_level:
        print("[DEBUG %d]: %s"%(level, msg))

#
# The Arista Python library uses exceptions to handle errors,
# so it doesn't work if we just depend on return values.
#

def initSession():
    pc = PyClient.PyClient("ar", "Sysdb")
    sysdb = pc.agentRoot()
    return (pc, sysdb)

def getBridgingConfig(sysdb):
    return sysdb['bridging']['input']['config']['cli']


def vlanExists(sysdb, vlan_num):
    bc = getBridgingConfig(sysdb)
    rt = bc.vlanConfig.get(vlan_num)
    if rt:
        return True
    else:
        return False

    
def tagPort(sysdb, tags, native_vlan, port):
    bc = getBridgingConfig(sysdb)
    pbc = bc.switchIntfConfig.newMember(port)
    pbc.switchportMode = 'trunk'
    pbc.enabled = True
    pbc.trunkAllowedVlans = tags
    pbc.trunkNativeVlan = int(native_vlan)
   
def initRPCServer(bind_addr, port, funcs):
    s = SimpleXMLRPCServer.SimplerXMLRPCServer((bind_addr, port))
    for f in funcs:
        s.register_function(f[0], f[1])
    return s

#
# XML-RPC method functions
#

#
# Return "1" if succeed, error string otherwise
# 
def _createVlan(vlan_id, vlan_num):
    bc = getBridgingConfig(sysdbroot)
    nv = bc.vlanConfig.newMember(int(vlan_num))
    nv.configuredName = VLAN_ID_PREFIX + str(vlan_id)
    return "1"

#
# Return 1 on success, error string on failure.
#
def _removeVlan(vlan_num):
    bc = getBridgingConfig(sysdbroot)
    if vlanExists(sysdbroot, int(vlan_num)):
        del bc.vlanConfig[int(vlan_num)]
        return 1
    else:
        return "VLAN #%d not exists."%(int(vlan_num),)

#
# Assign ports to a VLAN, and enable them.
#
# Return #errors.
# 
def _setPortVlan(vlan_num, ports):
    bc = getBridgingConfig(sysdbroot)
    errors = 0

    if not vlanExists(sysdbroot, vlan_num):
        debug("setPortVlan: VLAN #%d not exists."%(int(vlan_num),))
        return 0
    
    for p in ports:
        try:
            pbc = bc.switchIntfConfig.newMember(p)
        except:
            debug("setPortVlan: Errors when getting port %s, %s"
                  %(str(p), str(sys.exc_info()[1])))
            errors += 1
        else:
            pbc.switchportMode = 'access'
            pbc.enabled = True
            pbc.accessVlan = int(vlan_num)
    return errors

#
# Return #errors.
# If ports is empty, remove all ports from the VLAN.
#
def _removePortsFromVlan(vlan_num, ports):
    bc = getBridgingConfig(sysdbroot)
    errors = 0
    
    if vlanExists(sysdbroot, int(vlan_num)):
        if len(ports) == 0:
            ports = bc.switchIntfConfig.keys()

        for p in ports:
            try:
                pbc = bc.switchIntfConfig.newMember(p)
            except:
                debug("removePortsFromVlan: Errors when getting port %s, %s"
                      %(str(p), str(sys_exc_info()[1])))
                errors += 1
            else:
                if pbc.accessVlan == int(vlan_num):
                    pbc.accessVlan = DEFAULT_VLAN_NUM

    return errors


#
# Return 1 if exists, 0 otherwise
#
def _vlanTagExist(tag):
    try:
        bc = getBridgingConfig(sysdbroot)
        if bc.vlanConfig.has_key(int(tag)):
            return 1
    except:
        print("_vlanTagExist(", str(tag), ") error: ", str(sys.exc_info()))
    
    return 0


#
# Get name -> tag mappings of given VLAN names, if vnames is empty,
# return mappings for all experiment VLANs
#
def _getVlanName2TagMappings(vnames):
    mps = dict()
    try:
        vc = getBridgingConfig(sysdbroot).vlanConfig
        
        for vlan in vc.keys():
            vid = vc[vlan].configuredName
            if vid.startswith(VLAN_ID_PREFIX):
                if len(vnames) == 0 or vid[len(VLAN_ID_PREFIX):] in vnames:
                    mps[vid[len(VLAN_ID_PREFIX):]] = vc[vlan].vlanId
    except:
        print("_getVlanName2TagMappings(",
              str(vnames), ") error: ", str(sys.exc_info()))        

    return mps

#
# Return 1 if has ports, 0 otherwise.
#
def _vlanHasPorts(vlan_num):
    try:
        vs = sysdbroot['bridging']['vlan']['status'].vlanStatus

        #
        # If there is sub-dir under vlanStatus, then this VLAN has at least on port.
        # Otherwise this VLAN is empty.
        #
        if vs.has_key(int(vlan_num)):
            return 1
    except:
        print("_vlanHasPorts(", str(vlan_num), ") error: ", str(sys.exc_info()))

    return 0

#
# List all experiment VLANs.
#
# Return list of list object: [vid, vnum, list of ports].
#
def _listVlans():
    vlans = []
    try:
        vs = sysdbroot['bridging']['vlan']['status'].vlanStatus
        vc = getBridgingConfig(sysdbroot).vlanConfig

        vnums = []
        for vnum in vc.keys():
            if vc[vnum].configuredName.startswith(VLAN_ID_PREFIX):
                vnums.append(vnum)
                
                for vn in vnums:
                    ports = []
                    if vs.has_key(vn):
                        ports = vs[vn].vlanPortStatus.keys()
                        
                    vid = vc[vn].configuredName[len(VLAN_ID_PREFIX):]
                    vlans.append([vid, vn, ports])
    except:        
        print("_listVlans() error: ", str(sys.exc_info()))
                        
    return vlans

#
# Enable port's trunk mode.
#
# Note: First clear all existing allowed VLANs, then
#       set port mode, and set nativeVlan or allowedVlans.
#
# TODO: Is there any other thing as third?
#
def _enablePortTrunking(port, native_vlan_num, tag_native):
    try:
        pc = getBridgingConfig(sysdbroot).switchIntfConfig.newMember(str(port))
        
        pc.switchportMode = 'trunk'
        if int(tag_native) == 1:
            pc.trunkNativeVlan = 0
        else:
            pc.trunkNativeVlan = int(native_vlan_num)
            pc.trunkAllowedVlans = str(native_vlan_num)
        pc.enabled = True
    except:
        print("_enablePortTrunking(", str(port), ",", str(native_vlan_num),
              ",", str(tag_native), ") error: ", str(sys.exc_info()))
        return 0
    else:
        return 1

#
# Set allowed VLANs on trunked port.
#
# usage: 
#
def _setAllowedVlansOnTrunkedPort(port, allow, vnums):
    try:
        pc = getBridgingConfig(sysdbroot).switchIntfConfig.newMember(str(port))

        if pc.switchportMode == 'access':
            native_vlan = pc.accessVlan
            pc.switchportMode = 'trunk'
            if native_vlan != 1:
                pc.trunkNativeVlan = native_vlan
                pc.trunkAllowedVlans = str(native_vlan)
            else:
                pc.trunkNativeVlan = 0
                pc.trunkAllowedVlans = ''
        else:
            pass
        
        # TODO: fix VLAN range
        if int(allow) == 1:
            if pc.trunkAllowedVlans != "":
                pc.trunkAllowedVlans += "," + ",".join(map(str, vnums))
            else:
                pc.trunkAllowedVlans = ",".join(map(str, vnums))
        else:
            pc.trunkAllowedVlans = exceptVlans(pc.trunkAllowedVlans, map(int, vnums))

#
# Exported methods list
#
funcs = [(_createVlan, "createVlan"),
         (_removeVlan, "removeVlan"),
         (_setPortVlan, "setPortVlan"),
         (_removePortsFromVlan, "removePortsFromVlan"),
         (_vlanTagExist, "vlanTagExist"),
         (_getVlanName2TagMappings, "getVlanName2TagMappings"),
         (_vlanHasPorts, "vlanHasPorts"),
         (_listVlans, "listVlans"),
         (_enablePortTrunking, "enablePortTrunking")
         ]

s = initRPCServer(BIND_ADDR, RPC_PORT, funcs)
sysdbclient, sysdbroot = initSession()
s.serve_forever()
