#!/usr/bin/python

#
# EMULAB-LGPL
# Copyright (c) 2012 University of Utah and the Flux Group.
# All rights reserved.
#

#
# Deamon server running on Arista switch side for snmpit_arista.
#

import PyClient
import Tac
import EntityManager
import SimpleXMLRPCServer

RPC_PORT = @ARISTA_SWITCH_XMLRPCPORT@
BIND_ADDR = "@ARISTA_SWITCH_BIND_ADDRESS@"

sysdbroot = None
sysdbclient = None

#
# The Arista Python library uses exceptions to handle errors,
# so it doesn't work if we just depend on return values.
#

def initSession():
    pc = PyClient.PyClient("ar", "Sysdb")
    sysdb = pc.agentRoot()
    return (pc, sysdb)

def getBridgingConfig(sysdb):
    return sysdb['bridging']['input']['config']['cli']

def createVlan(sysdb, vlan_num, vlan_id):
    bc = getBridgingConfig(sysdb)
    nv = bc.vlanConfig.newMember(vlan_num)
    nv.name = vlan_id

def vlanExist(sysdb, vlan_num):
    bc = getBridgingConfig(sysdb)
    rt = bc.vlanConfig.get(vlan_num)
    if rt:
        return True
    else:
        return False

def removeVlan(sysdb, vlan_num):
    bc = getBridgingConfig(sysdb)
    if vlanExists(sysdb, vlan_num):
        del bc.vlanConfig[vlan_num]
    return True
    
def putPortInVlan(sysdb, vlan_num, port):
    bc = getBridgingConfig(sysdb)
    pbc = bc.switchIntfConfig.newMember(port)
    pbc.switchportMode = 'access'
    pbc.enabled = True
    pbc.accessVlan = int(vlan_num)
    return True

def delPortFromVlan(sysdb, vlan_num, port):
    bc = getBridgingConfig(sysdb)
    pbc = bc.switchIntrConfig[port]
    pbc.accessVlan = 0
    return True

def tagPort(sysdb, tags, native_vlan, port):
    bc = getBridgingConfig(sysdb)
    pbc = bc.switchIntfConfig.newMember(port)
    pbc.switchportMode = 'trunk'
    pbc.enabled = True
    pbc.trunkAllowedVlans = tags
    pbc.trunkNativeVlan = int(native_vlan)
   
def initRPCServer(bind_addr, port, funcs):
    s = SimpleXMLRPCServer.SimplerXMLRPCServer((bind_addr, port))
    for f in funcs:
        s.register_function(f[0], f[1])
    return s

#
# XML-RPC method functions
#

#
# Return "1" if succeed, error string otherwise
# 
def _createVlan(vlan_id, vlan_num):
    createVlan(sysdbroot, vlan_id, vlan_num)
    return "1"

def _removeVlan(vlan_num):
    pass

def _setPortsVlan(vlan_num, ports):
    pass

def _removePortsFromVlan(vlan_num, ports):
    pass

def _vlanExist(vlan_num):
    pass

def _setVlanPortTags(vlan_num, tags, ports):
    pass

def _getVlanPorts(vlan_num):
    pass

def _getPortVlan(port):
    pass

def _getAllVlans():
    pass

#
# Return 1 if exists, 0 otherwise
#
def _vlanTagExist(tag):
    bc = getBridgingConfig(sysdbroot)
    if bc.vlanConfig.has_key(tag):
        return 1
    else:
        return 0


#
# Get name -> tag mappings of given VLAN names, if vnames is empty,
# return mappings for all experiment VLANs
#
def _getVlanName2TagMappings(vnames):
    pass


#
# Exported methods list
#
funcs = [(_createVlan, "createVlan"),
         (_removeVlan, "removeVlan"),
         (_setPortsVlan, "setPortsVlan"),
         (_removePortsFromVlan, "removePortsFromVlan"),
         (_vlanExist, "vlanExist"),
         (_setVlanPortTag, "setVlanPortTags"),
         (_getVlanPorts, "getVlanPorts"),
         (_getPortVlan, "getPortVlan"),
         (_getAllVlans, "getAllVlans"),
         (_vlanTagExist, "vlanTagExist"),
         (_getVlanName2TagMappings, "getVlanName2TagMappings")
         ]

s = initRPCServer(BIND_ADDR, RPC_PORT, funcs)
sysdbclient, sysdbroot = initSession()
s.serve_forever()
