#!/usr/bin/perl -w
#
# EMULAB-COPYRIGHT
# Copyright (c) 2000-2010 University of Utah and the Flux Group.
# All rights reserved.
#
package libossetup;

use strict;
use Exporter;
use vars qw(@ISA @EXPORT $AUTOLOAD $LOADIMAGE $RECONFIG $REBOOT);

@ISA    = "Exporter";
@EXPORT = qw (die_noretry $LOADIMAGE $RECONFIG $REBOOT);

use libdb;
use libtestbed;
use libreboot;
use libosload;
use Node;
use libtblog;
use English;
use Data::Dumper;

# Configure variables
my $TB		= "@prefix@";
my $TBOPS       = "@TBOPSEMAIL@";
my $NODEREBOOT  = "$TB/bin/node_reboot";

# Flags
$LOADIMAGE  = 0x01;
$RECONFIG   = 0x02;
$REBOOT     = 0x04;

#
# Used to die with a -1 return code, to indicate to caller (tbswap)
# that the failure is not likely to be fixed with another attempt.
#
sub die_noretry($;$)
{
    my $parms = {};
    $parms = shift if ref $_[0] eq 'HASH';
    my ($mesg) = shift;
    tberror($parms, $mesg);
    KillChildren();
    exit(-1);
}

#
# The point of this is to create a data structure that we can
# pass around. 
#
sub New($$$@)
{
    my ($class, $user, $experiment, @nodelist) = @_;

    my $self              = {};
    $self->{'USER'}       = $user;
    $self->{'EXPT'}       = $experiment;
    $self->{'HASH'}       = {};
    $self->{'NODES'}      = {};
    $self->{'WAITLIST'}   = {};
    $self->{'FAILED'}     = {};
    $self->{'OSMAP'}      = {};
    $self->{'TYPECACHE'}  = {};

    # For informing users of failed nodes.
    $self->{'INFORM_USER'}       = {};
    $self->{'INFORM_TBOPSWARN'}  = {};
    $self->{'INFORM_TBOPSFATAL'} = {};

    foreach my $node (@nodelist) {
	$self->{'NODES'}->{$node->node_id()} = $node;
    }

    bless($self, $class);
    # XXX
    $self->noretry(0);
    $self->failed(0);
    return $self;
}
# Break circular reference someplace to avoid exit errors.
sub DESTROY {
    my $self = shift;

    foreach my $key (keys(%{ $self })) {
	$self->{$key} = undef;
    }
}
sub nodelist($)		{ return $_[0]->{'NODES'}; }
sub failedlist($)	{ return $_[0]->{'FAILED'}; }
sub waitlist($)		{ return $_[0]->{'WAITLIST'}; }
sub virtnodes($)        { return $_[0]->{'VIRTNODES'}; }
sub physnodes($)        { return $_[0]->{'PHYSNODES'}; }
sub geninodes($)        { return $_[0]->{'GENINODES'}; }
sub sharednodes($)      { return $_[0]->{'SHAREDNODES'}; }
sub user($)		{ return $_[0]->{'USER'}; }
sub experiment($)	{ return $_[0]->{'EXPT'}; }


# Grab a node by node_id.
sub node($$)
{
    my ($self, $node_id) = @_;

    return undef
	if (!exists($self->{'NODES'}->{$node_id}));

    return $self->{'NODES'}->{$node_id};
}

# Get/Set the osid->osinfo mapping. Nice to keep this to avoid lookups.
sub osmap($$;$)
{
    my ($self, $osid, $osinfo) = @_;

    if (defined($osinfo)) {
	return $self->{'OSMAP'}->{$osid} = $osinfo;
    }
    elsif (exists($self->{'OSMAP'}->{$osid})) {
	return $self->{'OSMAP'}->{$osid};
    }
    return undef;
}

# To avoid writting out all the methods.
sub AUTOLOAD {
    my $self = shift;
    my $type = ref($self) or die("$self is not an object\n");

    my $name = $AUTOLOAD;
    $name =~ s/.*://;   # strip fully-qualified portion

    if (@_) {
	return $self->{'HASH'}->{$name} = shift;
    }
    elsif (exists($self->{'HASH'}->{$name})) {
	return $self->{'HASH'}->{$name};
    }
    print STDERR "$self: tried to access unknown slot $name\n";
    return undef;
}

#
# Stub; this will eventually figure out real dependencies.
#
sub NextOperationList($)
{
    my ($self) = @_;
    
    return [ values(%{ $self->{'TYPECACHE'} }) ];
}

#
# Setup a reload of a node if we can find an image.
# This goo constructs a hashed array of lists.
#
sub SetupReload($$$)
{
    my ($self, $node, $osinfo) = @_;
    my $type = $node->type();

    #
    # We use a special type, "pcvm", for *any* subOS that can boot on a vnode.
    # For now, we're not going to mess with vnode types -- type checking is 
    # pretty pointless for this, since what we really want to check for a subOS
    # is whether it can boot on a specific parentOS.
    # So, users who make subOSes have to select that they can boot on type
    # pcvm and that's all that's necessary.
    #
    if ($node->isvirtnode()) {
	$type = "pcvm";
    }

    if ((my $image = $osinfo->MapToImage($type))) {
	# Mark this node as needing this image. 
	$node->_loadimage($image);
	$node->_setupoperation($LOADIMAGE);
    }
    else {
	die_noretry({type => 'primary', severity => SEV_ERROR,
		     error => ['file_not_found', 'image', $osinfo, $node]},
		    "No image can be found for $osinfo on $node ($type)!");
    }
}

#
# keep track of the failed nodes of all types.
#   values = ['boot'|'osload', 'fatal'|'nonfatal']
#
sub add_failed_node_fatal($$) {
    $_[0]->{'FAILED'}->{$_[1]} = ['boot', 'fatal'];
}
sub add_failed_node_nonfatal($$) {
    $_[0]->{'FAILED'}->{$_[1]} = ['boot', 'nonfatal'];
}
sub add_failed_node_reload($$) {
    $_[0]->{'FAILED'}->{$_[1]} = ['reload', 'fatal'];
}
#
# Add node to lists for email messages.
#
sub add_failed_node_inform_user($$) {
    $_[0]->{'INFORM_USER'}->{$_[1]} = $_[1];
}
sub add_failed_node_inform_tbopswarn($$) {
    $_[0]->{'INFORM_TBOPSWARN'}->{$_[1]} = $_[1];
}
sub add_failed_node_inform_tbopsfatal($$) {
    $_[0]->{'INFORM_TBOPSFATAL'}->{$_[1]} = $_[1];
}
sub ClearInformLists($)
{
    $_[0]->{'INFORM_USER'}       = {};
    $_[0]->{'INFORM_TBOPSWARN'}  = {};
    $_[0]->{'INFORM_TBOPSFATAL'} = {};
}

#
# Spam time! Send mail to the user and testbed-ops about failures.
#
sub InformUser($)
{
    my ($self) = @_;
    my $pid    = $self->experiment()->pid();
    my $eid    = $self->experiment()->eid();
    my $name   = $self->user()->name();
    my $email  = $self->user()->email();

    my @nodelist = keys(%{ $self->{'INFORM_USER'} });
    my $count    = scalar(@nodelist);
    if ($count > 0) {
	SENDMAIL("$name <$email>", "$count nodes are down",
		 "Nodes:\n".
		 "  " . join(" ", @nodelist) . "\n".
		 "in pid/eid $pid/$eid appear to be dead.\n\n".
		 "Your experiment will continue to run since these failures\n".
		 "are nonfatal, although you might encounter other problems\n".
		 "if your experiment depends explicitly on these nodes.\n".
		 "You should terminate this experiment if it cannot ".
		 "tolerate these failures.\n\n".
		 "Testbed Operations has also been notified.\n\n".
		 "Thanks\n".
		 "Testbed Operations\n",
		 0,
		 "Cc: $TBOPS");
    }
}

sub InformTBopsFatal($)
{
    my ($self) = @_;
    my $pid    = $self->experiment()->pid();
    my $eid    = $self->experiment()->eid();
    my $name   = $self->user()->name();
    my $email  = $self->user()->email();

    my @nodelist = keys(%{ $self->{'INFORM_TBOPSFATAL'} });
    my $count    = scalar(@nodelist);
    if ($count > 0) {
	SENDMAIL($TBOPS, "$count nodes are down",
		 "Nodes:\n".
		 "  " . join(" ", @nodelist) . "\n".
		 "in pid/eid $pid/$eid appear to be dead.\n\n".
		 "The nodes have been moved into hardware checkup.\n",
		 "$name <$email>");
    }
}

sub InformTBopsWarn($)
{
    my ($self) = @_;
    my $pid    = $self->experiment()->pid();
    my $eid    = $self->experiment()->eid();
    my $name   = $self->user()->name();
    my $email  = $self->user()->email();

    my @nodelist = keys(%{ $self->{'INFORM_TBOPSWARN'} });
    my $count    = scalar(@nodelist);
    if ($count > 0) {
	SENDMAIL($TBOPS, "$count nodes are down",
		 "Nodes:\n".
		 "  " . join(" ", @nodelist) . "\n".
		 "in pid/eid $pid/$eid failed to boot after loading OS.\n\n".
		 "The nodes have been freed.\n",
		 "$name <$email>");
    }
}

#
# Set the OS that needs to boot on a node, and mark it.
#
sub SetOS($$)
{
    my ($self, $node) = @_;
    my $node_id       = $node->node_id();
    my $imageable     = $node->imageable();
    my $osid          = $node->def_boot_osid();
    my $osinfo        = OSinfo->Lookup($osid);
    my $experiment    = $self->experiment();
    my $pid           = $experiment->pid();
    # Do we use def_boot_path anymore?
    my $bootpath      = $node->def_boot_path() && 
	$node->def_boot_path() ne "";

    die_noretry("Could not map $osid to its object!")
	if (!defined($osinfo));

    # Lets remember the osinfo for later.
    $self->osmap($osid, $osinfo);

    # Set the canfail bit.
    $node->_canfail($node->failureaction() eq NODEFAILMODE_FATAL() ? 0 : 1);

    #
    # If a virtnode is running a subOS, we set $imageable because it
    # really is going to be reloaded... even though virtnode types are
    # not typically imageable.
    #
    if ($node->isvirtnode() && $osinfo->def_parentosid()) {
	$imageable = 1;
    }

    if (!$bootpath && $imageable) {
	#
	# These checks are not necessary if the front end and web page
	# are doing the right thing, but lets be careful anyway.
	#
	if (! $osinfo) {
	    die_noretry("$node has no bootpath and no def_boot_osid set!");
	}
	#
	# If there is an actual path, its an OSKit kernel not an image.
	#
	if (! defined($osinfo->path()) || $osinfo->path() eq "") {
	    my $nextosinfo;
	    
	    #
	    # Not an OSKit kernel.
	    #
	    if ($osinfo->IsGeneric()) {
		#
		# Map generic OSID to the specific one.
		#
		$nextosinfo = $osinfo->ResolveNextOSID($experiment);
		if (!defined($nextosinfo)) {
		    die_noretry("No next mapping for $osinfo on $node!\n");
		}
		print "Mapping $osinfo on $node_id to $nextosinfo\n";
		$osinfo = $nextosinfo;
	    }
	    #
	    # Make sure this OSID is actually loaded on the machine.
	    #
	    my $isloaded = $node->IsOSLoaded($osinfo);
	    if ($isloaded < 0) {
		die_noretry("Error determining if $osinfo ".
			    "is loaded on $node\n");
	    }
	    if ($isloaded) {
		#
		# OSID is loaded, but might need to be cleaned.
		#
		if ($self->dolastload() &&
		    defined($node->last_reservation()) &&
		    $node->last_reservation() ne $pid) {
		    $self->SetupReload($node, $osinfo);
		}
		elsif ($nextosinfo) {
		    #
		    # Seems like a bad place for this; if the OS was
		    # mapped to something else that is already on the
		    # disk, need to reset def_boot_osid.
		    #
		    if ($self->impotent()) {
			print STDERR "$node_id:def_boot_osid --> $osinfo\n"
			    if ($self->debug());
		    }
		    elsif ($node->OSSelect($osinfo, "def_boot_osid", 0)) {
			die_noretry("Could not set boot OS to ".
				    "$osinfo for $node");
		    }
		}
	    }
	    else {
		#
		# OS not loaded.
		#
		$self->SetupReload($node, $osinfo);
	    }
	    # Remember this for later. 
	    $node->_bootosinfo($osinfo);
	}
    }
    print STDERR "$node_id - $osinfo\n"
	if ($self->debug());
}

#
# Take a list of nodes and fire off the required reloads/reboots/reconfigs
# in parallel, then wait for finish.
#
sub LightUpNodes($@)
{
    my ($self, @nodelist) = @_;
    my @children = ();
    my @failed   = ();;

    #
    # Set up lists of what we are going to do.
    #
    my %reloads   = ();
    my %reboots   = ();
    my %reconfigs = ();
    my %rebooted  = ();

    foreach my $node (@nodelist) {
	my $node_id = $node->node_id();
	my $op      = $node->_setupoperation();
	my $action;

	if ($op == $LOADIMAGE) {
	    my $image = $node->_loadimage();
		
	    if (!exists($reloads{$image->imageid()})) {
		$reloads{$image->imageid()} = [];
	    }
	    push(@{ $reloads{$image->imageid()} }, $node);
	    $action = "reloaded with $image";
	}
	elsif ($op == $REBOOT) {
	    $reboots{$node_id} = $node;
	    $action = "rebooted";
	}
	elsif ($op == $RECONFIG) {
	    $reconfigs{$node_id} = $node;
	    $action = "reconfiged";
	}
	print STDERR "$node_id will be $action\n"
	    if ($self->debug());
    }

    # XXX Caller wants a list. 
    return ()
	if ($self->impotent());
    
    #
    # Now fire them off.
    #
    foreach my $imageid ( keys(%reloads) ) {
	my @nlist = @{ $reloads{$imageid} };
	my @list  = ();
	my %nodeflags = ();

	foreach my $node (@nlist) {
	    my $node_id = $node->node_id();
	    # The osload library gets ids.
	    push(@list, $node_id);
	    
	    #
	    # vnodes only get rebooted if this is a modify and we need
	    # to reload them (otherwise they will get rebooted because
	    # of presence in %reboots).
	    #
	    if ($node->isvirtnode()) {
		if (defined($node->allocstate()) &&
		    $node->allocstate() eq TBDB_ALLOCSTATE_RES_INIT_CLEAN()) {
		    $nodeflags{$node_id}{'noreboot'} = 1;
		}
	    }

	    #
	    # osload should not wait for shared vnodes.  We need
	    # vnode_setup to boot/reboot them since the underlying pnode
	    # won't be booting.  So for them, osload just sets up the
	    # reload and finishes.
	    #
	    if ($node->isvirtnode() && $node->_onsharednode()) {
		$nodeflags{$node_id}{'noreboot'} = 1;
		$nodeflags{$node_id}{'nowait'} = 1;
	    }

	    $node->SetAllocState(TBDB_ALLOCSTATE_RES_RELOAD());
	    # No point in reboot/reconfig obviously, since node will reboot!
	    delete $reboots{$node_id};
	    delete $reconfigs{$node_id};
	    $rebooted{$node_id} = 1;
	}

	my %reload_args     = ();
	my $reload_failures = {};

	$reload_args{'debug'}     = $self->debug();
	$reload_args{'asyncmode'} = 1;
	$reload_args{'imageid'}   = $imageid;
	$reload_args{'nodelist'}  = [ @list ];
	$reload_args{'nodeflags'} = \%nodeflags;

	my $pid = osload(\%reload_args, $reload_failures);
	push(@children, [ $pid, \&osload_wait,
			  [ @list ], $reload_failures ]);
	sleep(5);
    }

    #
    # Fire off the reboots.
    # 
    if (keys(%reboots)) {
	foreach my $node_id (keys(%reboots)) {
	    my $node = $self->node($node_id);

	    if (defined($node->allocstate()) &&
		$node->allocstate() eq TBDB_ALLOCSTATE_RES_INIT_CLEAN()) {
		$node->SetAllocState(TBDB_ALLOCSTATE_RES_REBOOT_CLEAN());
	    }
	    else {
		$node->SetAllocState(TBDB_ALLOCSTATE_RES_REBOOT_DIRTY());
	    }
	    # Needed for vnode_setup.
	    $rebooted{$node_id} = 1;
	}

	my @list            = keys(%reboots);
	my %reboot_args     = ();
	my $reboot_failures = {};

	$reboot_args{'debug'}     = $self->debug();
	$reboot_args{'waitmode'}  = 0;
	$reboot_args{'asyncmode'} = 1;
	$reboot_args{'nodelist'}  = [ @list ];

	my $pid = nodereboot(\%reboot_args, $reboot_failures);
	push(@children, [ $pid, \&nodereboot_wait,
			  [ @list ], $reboot_failures ]);
	sleep(2);
    }

    #
    # Fire off the reconfigs.
    #
    if (keys(%reconfigs)) {
	my @list            = keys(%reconfigs);
	my %reboot_args     = ();
	my $reboot_failures = {};

	$reboot_args{'debug'}     = $self->debug();
	$reboot_args{'waitmode'}  = 0;
	$reboot_args{'asyncmode'} = 1;
	$reboot_args{'reconfig'}  = 1;
	$reboot_args{'nodelist'}  = [ @list ];

	my $pid = nodereboot(\%reboot_args, $reboot_failures);
	push(@children, [ $pid, \&nodereboot_wait,
			  [ @list ], $reboot_failures ]);
    }

    #
    # Wait for all of the children to exit. We look at the $pid to know if
    # command failed/ended immediately; otherwise we need to wait on it.
    # For any failures, record the node failures for later so that we do
    # not wait for them needlessly.
    #
    while (@children) {
	my ($pid, $waitfunc, $listref, $hashref) = @{ pop(@children) };

	# This is not likely to happen.
	next
	    if ($pid == 0);

	if ($pid > 0) {
	    next
		if (! &$waitfunc($pid));
	}
	
	#
	# Failure. Record the failures for later. If the $pid<0 then the
	# entire list failed. Otherwise, have to scan the return hash to
	# find the failures.
	#
	my @nlist = ();
	
	if ($pid < 0) {
	    @nlist = @{ $listref };
	}
	else {
	    foreach my $node_id (keys(%{ $hashref })) {
		push(@nlist, $node_id)
		    if ($hashref->{$node_id});
	    }
	}

	#
	# These errors are unusal enough that we do not want to retry
	# or keep going even if canfail is set. Better to stop and let
	# someone look at what happened.
	#
	$self->noretry(1);

	foreach my $node_id (@nlist) {
	    my $node = $self->node($node_id);
	    
	    tbnotice("Not waiting for $node_id since reload/reboot failed!\n");
	    push(@failed, $node);
	    $self->failed($self->failed() + 1);
	    $self->add_failed_node_reload($node_id);
	    $node->SetAllocState(TBDB_ALLOCSTATE_DOWN());
	}
    }
    return @failed;
}

#
# Create a type (or class) specific object to handle those nodes.
#
sub NewType($$)
{
    my ($self, $type) = @_;
    my $packname = "libossetup_${type}";
    my $newtype  = eval { $packname->New($self); };
    # Not loaded?
    if ($@) {
	#print STDERR $@;
	return undef;
    }
    $self->{'TYPECACHE'}->{$type} = $newtype;
    
    print STDERR "Created type object $type\n"
	if ($self->debug());
    
    return $newtype;
}
#
# Return the cached type object.
#
sub TypeCache($$)
{
    my ($self, $node) = @_;

    return $self->{'TYPECACHE'}->{$node->type()}
        if (exists($self->{'TYPECACHE'}->{$node->type()}));

    return $self->{'TYPECACHE'}->{$node->class()}
        if (exists($self->{'TYPECACHE'}->{$node->class()}));

    return undef;
}

#
# Wrapper class for the type/class specific packages below.
#
package libossetup_handler;
use vars qw(@ISA);
@ISA = qw(libossetup);

use libdb;
use libtestbed;
use libossetup;
use libtblog;
use Node;
use English;
use Data::Dumper;

sub New($$$)
{
    my ($class, $type, $parent) = @_;

    my $self            = {};
    $self->{'TYPE'}     = $type;
    $self->{'NODES'}    = {};
    $self->{'PARENT'}   = $parent;

    bless($self, $class);
    return $self;
}
# Access methods for the objects defined below, which are 
sub type($)		{ return $_[0]->{'TYPE'}; }
sub parent($)		{ return $_[0]->{'PARENT'}; }
sub nodelist($)         { return values(%{ $_[0]->{'NODES'} }); }

#
# Generic function to light up the nodes.
#
sub LightUpNodes($)
{
    my ($self) = @_;
    my @failed = $self->parent()->LightUpNodes($self->nodelist());

    #
    # If some nodes failed to start reboot/reload, then remove them
    # from the nodelist; we do not want to wait for them. 
    #
    foreach my $node (@failed) {
	delete($self->{'NODES'}->{$node->node_id()});
    }
    return scalar(@failed);
}

#
# Generic waiting function for a list of nodes.
#
sub WaitForNodes($@)
{
    my ($self, @waitstates) = @_;
    my $parent = $self->parent();
    my %nodes = ();

    # Maybe all nodes failed to light up?
    return 0
	if (! $self->nodelist());

    # Copy of the array. 
    foreach my $node ($self->nodelist()) {
	$nodes{$node->node_id()} = $node;
    }

    #
    # Start a counter going, relative to the time we rebooted the first
    # node.
    #
    my $waittime  = 0;
    my $minutes   = 0;
    my $canceled  = 0;

    #
    # Wait for the nodes to finish booting, as recorded in database
    #
    while (keys(%nodes)) {
	#
	# Check for cancelation. Do not want to retry if swap was canceled.
	#
	if (!$canceled) {
	    $canceled = $parent->experiment()->canceled();
	    if ($canceled) {
		tbnotice({cause => 'canceled', severity => SEV_IMMEDIATE,
			  error => ['cancel_flag']},
			 "Swap canceled; will terminate os_setup early!");
	    }
	}
	
	foreach my $node (values(%nodes)) {
	    my $node_id = $node->node_id();
	    my $state;

	    if ($node->GetEventState(\$state)) {
		print STDERR "*** Error getting event state for $node_id.\n";
		$node->_bootstatus(TBDB_NODESTATE_UNKNOWN);
		delete($nodes{$node_id});
		next;
	    }
	    if (grep {$_ eq $state} @waitstates) {
		$node->_bootstatus($state);
		print "$node_id has reported state $state\n";
		delete($nodes{$node_id});
		next;
	    }
	    $waittime = time() - $node->_waitstart();
	    if ($waittime > $node->_maxwait()) {
		$minutes = int($waittime / 60);
		if ($canceled ||
		    $parent->noretry() || !$node->_retrycount()) {
		    tbnotice("*** Giving up on $node_id ($state) - ".
			     "it's been $minutes minute(s).\n");

		    $node->_bootstatus($state);
		    delete($nodes{$node_id});
		}
		else {
		    tbnotice("Rebooting $node_id and waiting again ...\n");

		    if (system("$NODEREBOOT $node_id") == 0) {
			$node->_retrycount($node->_retrycount() - 1);
			$node->_waitstart(time());
		    }
		    else {
			$node->_bootstatus($state);
			delete($nodes{$node_id});
		    }
		}
		next;
	    }
	    if (int($waittime / 60) > $minutes) {
		$minutes = int($waittime / 60);
		tbnotice("Still waiting for $node_id ($state) - ".
			 "it's been $minutes minute(s).\n");
	    }
	}
	sleep(5);
    }
    return 0;
}


#####################################################################
#
# Generic handler for local cluster nodes that do not require much
# special handling.
#
package libossetup_pc;
use vars qw(@ISA);
@ISA = qw(libossetup_handler);

use libdb;
use libtestbed;
use libossetup;
use libtblog;
use Node;
use English;
use Data::Dumper;

#
# A constructor for an object to handle all nodes of this type.
#
sub New($$) {
    my ($class, $parent) = @_;

    my $self = $class->SUPER::New("pc", $parent);
    bless($self, $class);
    return $self;
}

sub AddNode($$)
{
    my ($self, $node) = @_;
    my $node_id = $node->node_id();

    $self->{'NODES'}->{$node_id} = $node;

    #
    # XXX Inner elab nodes should never report in to us.
    # If they do, make sure they wind up in PXEWAIT.
    #
    if ($node->_iseinenode()) {
	print "Will skip reload/reboot of inner elab node: $node_id.\n";
	$node->ClearOsids();
	return 0;
    }

    if ($node->allocstate() eq TBDB_ALLOCSTATE_RES_RECONFIG()) {
	$node->_setupoperation($libossetup::RECONFIG);
    }
    elsif ($node->allocstate() ne TBDB_ALLOCSTATE_RES_READY()) {
	# only reboot node if assign_wrapper just pulled it into expt.
	# (e.g. it isnt ALLOCSTATE_RES_READY)
	$node->_setupoperation($libossetup::REBOOT);
    }

    return 0;
}

#
# Local cluster node waiting function.
#
sub WaitForNodes($)
{
    my ($self) = @_;
    my $parent     = $self->parent();
    my $experiment = $parent->experiment();
    my $pid        = $experiment->pid();
    my $eid        = $experiment->eid();
    my $failed     = 0;
    
    #
    # Wait for nodes. Why do we wait in the face of previous errors? So
    # that they enter a reasonably known state before we try to tear
    # things down. Otherwise we could end up power cycling nodes a lot
    # more often.  This should probably be handled in other ways, say
    # via stated or the alloc state machine.
    #
    my @nodelist = $self->nodelist();
    return 0
	if (!@nodelist);

    print "Waiting for local testbed nodes to finish rebooting ...\n";

    #
    # Go through the list and set up the retry count and the waittime.
    #
    foreach my $node (@nodelist) {
	my $waittime = (60 * 7);	# The default.
	my $osinfo   = $node->_bootosinfo();

	# Compute actual waittime.
	if (defined($node->bios_waittime()) &&
	    defined($osinfo->reboot_waittime())) {
	    $waittime = ($node->bios_waittime() +
			 $osinfo->reboot_waittime()) * 2;
	}
	$node->_retrycount(1);
	$node->_maxwait($waittime);
	$node->_waitstart(time());
	$node->_bootstatus(TBDB_NODESTATE_UNKNOWN);
    }

    TBDebugTimeStamp("Local node waiting started");
    # This always returns success. Have to look at the node status.
    $self->SUPER::WaitForNodes((TBDB_NODESTATE_TBFAILED,
				TBDB_NODESTATE_ISUP));

    foreach my $node (@nodelist) {
	my $node_id    = $node->node_id();
	my $bootstatus = $node->_bootstatus();

	if ($bootstatus eq TBDB_NODESTATE_ISUP()) {
	    print "$node_id is alive and well\n";
	    $node->SetBootStatus(NODEBOOTSTATUS_OKAY);
	    $node->SetAllocState(TBDB_ALLOCSTATE_RES_READY());
	    next;
	}
	# Fall through on failure.	
	if ($bootstatus eq TBDB_NODESTATE_TBFAILED()) {
	    tbwarn("$node_id reported a TBFAILED event\n");
	}
	else {
	    tbwarn("$node_id failed to boot\n");
	}
	$node->SetBootStatus(NODEBOOTSTATUS_FAILED);

	if ($node->_canfail() &&
	    !($experiment->canceled() || $parent->noretry())) {

	    $parent->add_failed_node_inform_user($node_id);
	    $parent->add_failed_node_nonfatal($node_id);
	    tbnotice("Continuing with experiment setup anyway ...\n");
	    next;
	}

	#
	# If the user has picked a standard image and it fails to boot,
	# something is wrong, so reserve it to checkup experiment. If the
	# image belongs to the user, then we assume its the image at fault,
	# and allow it to be returned to the pool (caller, tbswap will end
	# doing the nfree on nodes with a DOWN allocstate).
	#
	my $osinfo = $node->_bootosinfo();
	if (! defined($osinfo->pid()) || $osinfo->pid() eq TBOPSPID()) {
	    $node->MarkAsIll();
	    $node->InsertNodeLogEntry($parent->user(),
				      TB_DEFAULT_NODELOGTYPE(),
				      "'Moved to hwcheckup by os_setup; ".
				      "failed to boot image for $osinfo " .
				      "in $pid/$eid'");

	    $parent->add_failed_node_inform_tbopsfatal($node_id);
	}
	else {
	    $parent->add_failed_node_inform_tbopswarn($node_id);
	}
	$node->SetAllocState(TBDB_ALLOCSTATE_DOWN());
	$failed++;
	$parent->add_failed_node_fatal($node_id);
    }
    return $failed;
}

#####################################################################
#
#
package libossetup_pcvm;
use vars qw(@ISA);
@ISA = qw(libossetup_handler);

use libdb;
use libtestbed;
use libossetup;
use Node;
use English;
use Data::Dumper;

#####################################################################
#
# This is a catchall for virtnodes that do not have a type handler.
#
package libossetup_virtnode;
use vars qw(@ISA);
@ISA = qw(libossetup_handler);

use libdb;
use libtestbed;
use libossetup;
use Node;
use English;
use Data::Dumper;

#####################################################################
#
# This is a catchall for subnodes that do not have a type handler.
#
package libossetup_subnode;
use vars qw(@ISA);
@ISA = qw(libossetup_handler);

use libdb;
use libtestbed;
use libossetup;
use Node;
use English;
use Data::Dumper;

#####################################################################
#
# Virtualized protogeni nodes.
# 
package libossetup_pcfed;
use vars qw(@ISA);
@ISA = qw(libossetup_handler);

use libdb;
use libtestbed;
use libossetup;
use Node;
use English;
use Data::Dumper;

#####################################################################
#
# Physical protogeni nodes.
# 
package libossetup_pcfedphys;
use vars qw(@ISA);
@ISA = qw(libossetup_handler);

use libdb;
use libtestbed;
use libossetup;
use Node;
use English;
use Data::Dumper;
