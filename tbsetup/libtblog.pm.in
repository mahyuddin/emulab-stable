#!/usr/bin/perl -w

#
# EMULAB-COPYRIGHT
# Copyright (c) 2005 University of Utah and the Flux Group.
# All rights reserved.
#

#
# libtblog: Logging library for testbed
#
# The very act of including libtblog in a perl script will activate
# the logging subsystem.  Also, all output to STDOUT and STDERR will,
# by default, be captured and turned into log messages, in addition to
# being printed.  Handlers are also installed for die/warn.
# To turn this feature off use tblog_stop_capture(..).
#
# Although the logging subsystem is activated automatically, the pid,
# eid, and uid can not be determined automatically.  Thus the function
# tblog_set_info(...) needs to be called to set this info.
#
# To create a log entry use tblog(...) or one of the shortcut function:
# tberror, tberr, tbwarn, tbwarning, tbnotice, tbinfo, and tbdebug.
#
# To attempt and figure out what went wrong during a session use
# tblog_find_error(..).
# 
# To turn off the database logging set the environmental variable
# TBLOG_OFF to a true value.
#

package libtblog;
use Exporter;

@ISA = "Exporter";
@EXPORT = qw (tblog tberror tberr tbwarn tbwarning tbnotice tbinfo tbdebug 
	      tbdie tblog_set_info tblog_sub_process tblog_find_error
	      tblog_capture tblog_stop_capture
	      tblog_new_process tblog_init_process tblog_exit
	      copy_hash
	      TBLOG_EMERG TBLOG_ALERT TBLOG_CRIT TBLOG_ERR 
	      TBLOG_WARNING TBLOG_NOTICE TBLOG_INFO TBLOG_DEBUG);
@EXPORT_OK = qw (dblog *SOUT *SERR);

# After package decl.
use English;
use POSIX qw(isatty setsid);
use File::Basename;
use IO::Handle;
use Text::Wrap;

use strict;

#
# Testbed Support libraries
#
use lib "@prefix@/lib";
use libtestbed;
use libdb;

sub if_defined($$);

my %PRIORITY_MAP_TO_NUM;
my %PRIORITY_MAP_TO_STR;

my $REAL_SCRIPTNAME = basename($PROGRAM_NAME);

#
# Duplicate STDOUT and STDERR to SOUT and SERR respectfully, since
# tblog_capture() will redirect the real STDOUT and STDERR
#

open SOUT ,">&=STDOUT"; # Must be "&=" not "&" to avoid creating a
                        # new low level file descriper as the
                        # interacts strangly with the fork in swapexp.
autoflush SOUT 1;
open SERR ,">&=STDERR"; # Ditto
autoflush SERR 1;

#
# Make constants for the error level, the sub, prefixed with TBLOG_,
# are exported, the non-prefixed variables are used internally
#

sub TBLOG_EMERG   {000} my $EMERG   = 000;
sub TBLOG_ALERT   {100} my $ALRET   = 100;
sub TBLOG_CRIT    {200} my $CRIT    = 200;
sub TBLOG_ERR     {300} my $ERR     = 300;
sub TBLOG_WARNING {400} my $WARNING = 400;
sub TBLOG_NOTICE  {500} my $NOTICE  = 500;
sub TBLOG_INFO    {600} my $INFO    = 600;
sub TBLOG_DEBUG   {700} my $DEBUG   = 700;

#
# Internal Utility Functions
#

sub check_env_def ( $ )
{
  die "Environment variable \"$_[0]\" not defined." unless defined $_[0];
}

sub check_env_num ( $ )
{
    check_env_def $_[0];
    die "Environment variable \"$_[0]\" not a positive integer." 
	unless $ENV{$_[0]} =~ /^[0-9]+$/;
}

sub check_env ()
{
    check_env_num 'TBLOG_LEVEL';
    check_env_num 'TBLOG_SESSION';
    check_env_num 'TBLOG_PIDX';
    check_env_num 'TBLOG_INVOCATION';
    check_env_num 'TBLOG_PARENT_INVOCATION';
    check_env_num 'TBLOG_UID';
    check_env_num 'TBLOG_SCRIPTNUM';
    check_env_def 'TBLOG_SCRIPTNAME';
    check_env_def 'TBLOG_BASE_SCRIPTNAME';
}

sub if_defined ($$) {
    return $_[0] if defined $_[0];
    return $_[1] if defined $_[1];
    return '';
}

sub oneof ($@) {
    my ($to_find) = shift;
    my @res = grep {$to_find eq $_} @_;
    return @res > 0;
}

#
# Like DBQueryFatal but also fail if the query didn't return any results
#
sub DBQuerySingleFatal ( $ )
{
    my ($query) = @_;
    my $query_result = DBQueryFatal $query;
    DBFatal("DB Query \"$query\" didn't return any results") 
	unless $query_result->numrows > 0;
    my @row = $query_result->fetchrow_array();
    return $row[0];
}

#
# Forward Decals
#

sub dblog ( $$@ );
sub tblog ( $@ );
sub tblog_new_process(@);
sub tblog_init_process(@);
sub informative_scriptname();

#
# tblog_init(): Called automatically when a script starts.
#
# Will: Get the priority mapping (string -> int) from the database and
# than call tblog_new_process
#
sub tblog_init() {
    # Get priority mapping

    my $query_result = DBQueryFatal "SELECT * FROM priorities";
    for (my $i = 0; $i < $query_result->num_rows; $i++) {
        my ($n,$v) = $query_result->fetchrow_array();
	$PRIORITY_MAP_TO_STR{$n} = $v;
	$PRIORITY_MAP_TO_NUM{uc $v} = $n;
	$PRIORITY_MAP_TO_NUM{lc $v} = $n;
    }

    tblog_new_process(if_defined($main::FAKE_SCRIPTNAME,
				 $REAL_SCRIPTNAME),
		      @ARGV);
};


#
# tblog_new_process($cmd, @argv): enter a new (possible fake) process
# calls tblog_init_process
#
# If used to start a new fake process it is advised to make a local
# copy of %ENV using perl "local".  See tblog_sub_process for an
# explanation.
#
sub tblog_new_process(@) {
    delete $ENV{TBLOG_BASE_SCRIPTNAME};
    tblog_init_process(@_);
}

#
# tblog_init_process($cmd, @argv): init a new process
#
# Will: (1) Get the unique ID for the script name,  (2) Creating an
# "entring" log message in the database, (3) get the session id and
# set up the environmental variables if they are not already set,
# (4) Get the invocation id, and (5) increment the level
#
# NOTE: Everything is currently stored in the %ENV hash.
#
sub tblog_init_process(@) {
    my ($script, @argv) = @_;

    # Get script name

    $ENV{TBLOG_SCRIPTNAME} = $script;
    $ENV{TBLOG_BASE_SCRIPTNAME} = $script unless defined $ENV{TBLOG_BASE_SCRIPTNAME};

    # Get script number

    my $query_result = DBQueryFatal
	sprintf("select script from scripts where script_name=%s",
		DBQuoteSpecial $ENV{TBLOG_SCRIPTNAME});
    if ($query_result->num_rows > 0) {
	$ENV{TBLOG_SCRIPTNUM} = ($query_result->fetchrow_array())[0];
    } else {
	DBQueryFatal 
	    sprintf("insert into scripts (script_name) values (%s)",
		    DBQuoteSpecial $ENV{TBLOG_SCRIPTNAME});
	$ENV{TBLOG_SCRIPTNUM} = DBQuerySingleFatal 'select LAST_INSERT_ID()';
    }

    # ...

    if (defined $ENV{'TBLOG_SESSION'}) {
	check_env();
	$ENV{TBLOG_LEVEL}++;
	$ENV{TBLOG_PARENT_INVOCATION} = $ENV{TBLOG_INVOCATION};
	dblog($NOTICE, {type => 'entering'},
	      'Entering "', join(' ', informative_scriptname(), @argv), '"')
	  or die;
	my $id = DBQuerySingleFatal 'select LAST_INSERT_ID()';
	$ENV{TBLOG_INVOCATION} = $id;
	DBQueryFatal("update log set invocation=$id where seq=$id");
    } else {
	$ENV{TBLOG_SESSION} = 0;
	$ENV{TBLOG_INVOCATION} = 0;
	$ENV{TBLOG_PARENT_INVOCATION} = 0;
	$ENV{TBLOG_LEVEL} = 0;
	$ENV{TBLOG_PIDX} = 0;
	$ENV{TBLOG_UID} = 0;
	dblog($NOTICE, {type => 'entering'},
	      'Entering "', join(' ', informative_scriptname(), @ARGV), '"')
	  or die;
	my $id = DBQuerySingleFatal 'select LAST_INSERT_ID()';
	# set SESSION in database
	$ENV{TBLOG_SESSION} = $id;
	$ENV{TBLOG_INVOCATION} = $id;
	DBQueryFatal("update log set session=$id,invocation=$id where seq=$id");
    }

}

#
# Began a sub process.  It is advised to make a local copy of %ENV using
# perl "local".  This can be done with:
#   local %ENV = %ENV
# however due to a bug in perl 5.005_03 if "-T" is used than the above will 
# taint the path, instead use:
#   my $old_env = \%ENV
#   local %ENV;
#   copy_hash %ENV, $old_env
# See perlsub(1) 1 for more info on "local"
#
sub tblog_sub_process($@) {
    my $name = shift;
    tblog_init_process("$ENV{TBLOG_BASE_SCRIPTNAME}-$name",
		       @_);
}

#
# copy_hash(%dest, \%src)
#
sub copy_hash(\%$) {
    my ($new, $old) = @_;
    foreach (keys %$old) {
	$new->{$_} = $old->{$_};
    }
}

#
# tblog_set_info(pid, eid, uid): Sets info in the database which can't
#   be derived automatically with init.  Needs to be called at least
#   once during a session.
#
sub tblog_set_info ( $$$ )
{
    check_env();
    my ($pid, $eid, $uid) = @_;
    $ENV{'TBLOG_PIDX'} = 
	DBQuerySingleFatal("select idx from experiments where pid='$pid' and eid='$eid'");
    $ENV{'TBLOG_UID'} = $uid;
    DBQueryFatal
	sprintf('update log set pidx=%d,uid=%s where session=%s',
		$ENV{TBLOG_PIDX}, $ENV{TBLOG_UID}, $ENV{TBLOG_SESSION});
}

#
# tblog_exit(): Called automatically when a script exits, or explistly
# when a fake process exits.  
#
sub tblog_exit() {
    return unless defined $ENV{'TBLOG_SESSION'};
    check_env();
    dblog($INFO, {type=>'exiting'}, "Leaving \"", informative_scriptname(), 
	  " ...\"");
}

#
# informative_scriptname()
#
sub informative_scriptname() {
    if ($ENV{TBLOG_BASE_SCRIPTNAME} eq $REAL_SCRIPTNAME) {
	return $ENV{TBLOG_SCRIPTNAME};
    } else {
	return "$ENV{TBLOG_SCRIPTNAME} (but really $REAL_SCRIPTNAME)";
    }
}


#
# dblog(priority, {parm=>value,...}, mesg, ...)
#   Internal function.  Logs a message to the database.  Doesn't print
#   anything. Will not die, instead return 0 on error, with the error
#   message in $@.
#   Valid parms: sublevel, cause, type, fatal
#
my $in_dblog = 0; # Used to avoid an infinite recursion when
                  # DBQueryFatal fails as a log entry is made to
                  # record the failure, which will than likely cause
                  # another failure and so on
sub dblog( $$@ ) {
    my ($priority, $parms, @mesg) = @_;
    my $mesg = join('',@mesg);
    #print SERR "===$priority $parms @mesg\n";
    return if $ENV{TBLOG_OFF} || $in_dblog;
    $in_dblog = 1;
    eval {
	check_env();
	my $query = 
	  sprintf('insert into log (stamp,pidx,uid,session,parent,invocation,script,level,sublevel,priority,inferred,cause,type,mesg) '. 
		  'VALUES (UNIX_TIMESTAMP(now()),%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%s,%s,%s)',
		  $ENV{TBLOG_PIDX}, 
		  $ENV{TBLOG_UID},
		  $ENV{TBLOG_SESSION}, 
		  $ENV{TBLOG_PARENT_INVOCATION}, 
		  $ENV{TBLOG_INVOCATION},
		  $ENV{TBLOG_SCRIPTNUM}, 
		  $ENV{TBLOG_LEVEL},
		  if_defined($parms->{sublevel}, 0),
		  $priority,
		  if_defined($parms->{inferred}, 0),
		  DBQuoteSpecial if_defined($parms->{cause}, ''),
		  DBQuoteSpecial if_defined($parms->{type}, 'normal'),
		  DBQuoteSpecial $mesg);
	my $result = DBQuery($query);
	if (!$result && DBErr() == 1100) {
	    DBQueryFatal("LOCK TABLE log WRITE");
	    $result = DBQuery($query)
	}
	DBFatal("DB Query failed") unless $result;
    };
    $in_dblog = 0;
    # Print a warning on failure but don't log the results to stdout
    # as that is likely to fail also
    print SERR format_message($WARNING, $@) if $@;
    return 0 if $@;
    return 1;
}

#
# tblog(priority, mesg, ...)
# tblog(priority, {parm=>value,...}, mesg, ...)

#   The main log function.  Logs a message to the database and print
#   the message to STDERR with an approate prefix depending on the
#   severity of the error.  If more than one string is given for the
#   message than they will concatenated.  If the env. var. TBLOG_OFF
#   is set to a true value than nothing will be written to the
#   database, but the message will still be written to STDOUT.  
#   Useful parms: sublevel, cause, type
#
sub tblog( $@ ) {
    my ($priority) = shift;
    my $parms = {};
    $parms = shift if ref $_[0] eq 'HASH';
    my $mesg = join('',@_);

    if (exists $PRIORITY_MAP_TO_STR{$priority}) {
      # $priority already a valid priority number
    } elsif (exists $PRIORITY_MAP_TO_NUM{$priority}) {
      # $priority a priority string, convert to num
      $priority = $PRIORITY_MAP_TO_NUM{$priority}
    } else {
      die "Unknown Priority \"$priority\"" unless defined $priority;
    }

    my $res = dblog($priority, $parms, $mesg) unless $mesg =~ /^\s+$/;
    
    print SERR format_message($priority, $mesg);

    return $res;
}


# Useful alias functions

sub tberror( @ ) {&tblog($ERR, @_)}
sub tberr( @ ) {&tblog($ERR, @_)}
sub tbwarn( @ ) {&tblog($WARNING, @_)}
sub tbwarning( @ ) {&tblog($WARNING, @_)}
sub tbnotice( @ ) {&tblog($NOTICE, @_)}
sub tbinfo( @ ) {&tblog($INFO, @_)}
sub tbdebug( @ ) {&tblog($DEBUG, @_)}

#
# Log the message to the database as an error and than die.  An
# optional set of paramaters may be specified as the first paramater.
# Not exactly like die as the message bust be specified.
#
sub tbdie( @ ) {
    my $parms = {};
    $parms = shift if ref $_[0] eq 'HASH';
    my $mesg = join('',@_);

    dblog($ERR, $parms, $mesg);
    tblog_stop_capture();
    die format_message($ERR, $mesg);
}

#
# Format the message based on $priority
#
sub format_message ( $$ ) {
    my ($priority, $mesg) = @_;

    $mesg =~ s/\s+$//;

    my $header;

    if ($mesg =~ /\s*\*\*\*/) {
	# do nothing
    } elsif ($priority <= $ERR ) {
	$header = "$ENV{TBLOG_SCRIPTNAME}";
    } elsif ($priority == $WARNING) {
	$header = "$ENV{TBLOG_SCRIPTNAME}: WARNING";
    } elsif ($priority == $NOTICE) {
	$header = "$ENV{TBLOG_SCRIPTNAME}";
    } 
    
    my $text;

    my @mesg = split /\n/, $mesg;
    if (@mesg == 1) {
	$mesg[0] =~ s/^\s+//;
	$mesg = $mesg[0];
    }
    if ($header) {
	my $line = "*** $header: $mesg[0]";
	if (@mesg > 1 || length($line) > $Text::Wrap::columns) {
	    $line = "*** $header:\n";
	    if (@mesg == 1) { # NOTE: $mesg[0] eq $mesg
		$mesg =~ s/^\s+//;
		$line .= wrap('    ','    ', $mesg, "\n");
	    } else {
		foreach (@mesg) {
		    s/\s+$//;
		    $line .= "    $_\n";
		}
	    }
	    return $line;
	} else {
	    return "$line\n";
	}
    } else {
	if (@mesg == 1) {
	    return wrap ('', '    ', $mesg, "\n");
	} else {
	    return "$mesg\n";
	}
    }
}

#
# tblog_find_error([session],[store]): attempts to find the relevant error.  
# 
# Parameters:
#   session: Session id to use. Defaults to the current as given by 
#       $ENV{TVLOG_SESSION}.
#   store: If set store the results into the database and act in
#       a way that is safe to use in an END block, that is 
#       (1) never die, (2) don't modify the exit code,  Will also
#       print the results to and some additional info to STDERR
#       for diagnosis purposed.  If not set simply print the results to
#       STDERR.  Defaults to true unless the "session" parameter is also
#       given, in which case default to false.
#
# To retrieve the results from the database:
#   select ... where session = <Session ID> AND type = 'thecause' form log
# The relevant errors are also flagged using "relevant" flag:
#   select ... where session = <Session ID> AND relevant != 0 form log
#
sub tblog_find_error ( ;$$ ) {

    my ($session,$store) = @_;
    my $saved_exitcode = $?;

    if (not defined $session) {
        check_env();
	$store = 1;
	$session = $ENV{TBLOG_SESSION};
    }

    $store = 0 unless defined $store;

    eval {

	#
	# Build the Tree
	#
	# Tree data structure:
	# invocation = {invocation => INT, parent => INT, 
	#		[{seq => int ...} || {seq => int, child => invox}]}
	
	my $root = {invocation => 0, log => []};
	my %lookup = (0 => $root);
	my @log;
	
	my $query_result = DBQueryFatal "select seq,parent,invocation,sublevel,priority,mesg,script_name,type from log natural join scripts where session = $session and priority <= $NOTICE order by seq";
	
	for (my $i = 0; $i < $query_result->num_rows; $i++) {
	    
	    my ($seq, $parent, $invocation, $sublevel, $priority, $mesg, $script, $type) 
		= $query_result->fetchrow;
	    
	    if (not exists $lookup{$invocation}) {
		
		my $p = $lookup{$parent};
		die "Parent Doesn't Exists!" unless defined $p;
		$lookup{$invocation} = {invocation => $invocation, 
					parent => $parent, 
					script=>$script, 
					log => []};
		push @{$p->{log}}, {seq => $invocation, 
				    child => $lookup{$invocation}};
		
	    }
	    
	    push @{$lookup{$invocation}{log}}, {seq => $seq, 
						invocation=>$invocation, 
						sublevel=> $sublevel,
						priority => $priority,
						type => $type,
						mesg => $mesg};
	    
	}

	my $handle_sublevels;
	$handle_sublevels = sub {

	    my ($tree) = @_;

	    my $log = $tree->{log};
	    return unless defined $log;

	    # normalize sublevels
	    my $min_sublevel = 200;
	    foreach (@$log) {
		$min_sublevel = $_->{sublevel} 
		    if exists $_->{sublevel} && $_->{sublevel} < $min_sublevel;
	    }

	    for (my $i = 0; $i < @$log; $i++) {

		local $_ = $log->[$i];

		if (exists $_->{sublevel} && $_->{sublevel} > $min_sublevel) {

		    my @sublog = ($_);
		    my $j = $i + 1;
		    while ($j < @$log && 
			   exists $log->[$j]->{sublevel} &&
			   $log->[$j]->{sublevel} > $min_sublevel) {
			push @sublog, $log->[$j];
			$j++;
		    }
		    my $repl = {
			child => {log => [@sublog]}
		    };
		    splice(@$log, $i, $j - $i, $repl);
		    $handle_sublevels->($repl->{child})

		} elsif (exists $_->{child}) {

		    $handle_sublevels->($_->{child});

		}
	    }

	};

	$handle_sublevels->($root);


	#
	# Now find the relevant errors.
	#
	
	my $find_relevant;
	$find_relevant = sub {

	    my ($tree) = @_;

	    my @posib_errs;
	    my @extra_info;

	    foreach (reverse @{$tree->{log}}) {

		if (exists $_->{child}) {
		    
		    my @errs = $find_relevant->($_->{child});
		    if (@errs) {
			return (reverse(@extra_info),@errs);
		    } 
		    
		} elsif ($_->{priority} <= $ERR) {
		    
		    push @posib_errs, $_;

		    if ($_->{type} eq 'summary') {
			last;
		    } elsif ($_->{type} eq 'extra') {
			push @extra_info, $_;
		    }
		    
		}
		
	    }

	    return reverse @posib_errs;
	};

	my @relevant = $find_relevant->($root);

	# 
	# Finally print/store the relevant errors
	#
	
	my $error = '';
	
	my $prev;
	foreach (@relevant) {
	    # avoid printing the exact same error twice
	    next if (defined $prev && $prev->{mesg} eq $_->{mesg});

	    $error .= "\n" if defined $prev;

	    if ($_->{mesg} !~ /\n/) {
		$error .= wrap('  ','  ',
			       "$_->{mesg} ($lookup{$_->{invocation}}->{script})\n");
	    } else {
		# if multiline don't reformat
		foreach (split /\s*\n/, $_->{mesg}) {
		    $error .= "  $_\n";
		}
		$error .= "  ($lookup{$_->{invocation}}->{script})\n";
	    }
	    $prev = $_;
	}
	$error = "No clue as to what went wrong!\n" unless length $error > 0;
	
	if ($store) {
	    print SERR "**** Experimental information, please ignore ****\n";
	    print SERR "Session ID = $ENV{TBLOG_SESSION}\n";
	    print SERR "Likely Cause of the Problem:\n";
	    print SERR $error;
	    print SERR "**** End experimental information ****\n";
	    chop $error;
	    dblog $NOTICE, {type=>'thecause'}, $error;
	    DBQueryFatal(sprintf("update log set relevant=1 where seq in (%s)",
				 join(',', map {$_->{seq}} @relevant))) if @relevant;
	} else {
	    print SERR $error;
	}
    };

    if ($@) {
	my $err = $@;
	eval {SENDMAIL(TB_OPSEMAIL, "tblog_find_error failed",
		       "Experiment: $ENV{TBLOG_PIDX}\n".
		       "User: $ENV{TBLOG_UID}\n".
		       "Session: $ENV{TBLOG_SESSION}\n".
		       "Script: $ENV{TBLOG_SCRIPTNAME}\n".
		       "\n".
		       "$err\n")};
	if ($store) {
	    eval {tblog $WARNING, {type=>'thecause'}, 
		    "tblog_find_error failed: $err" };
	} else {
	    $? = $saved_exitcode;
	    die;
	}
    }
    $? = $saved_exitcode;
}

#
# Perl Tie Methods, see perltie(1)
#

sub TIEHANDLE {
    my ($classname, $glob) = @_;
    bless \$glob, $classname;
}

sub PRINT {
    my $this = shift;
    print {$$this} @_;
    local $_ = join '', @_; # NOTE: This doesn't take into account "$,"
                            # or output_field_separator
    s/\n$//;
    if (/warning:/i) {
      dblog $WARNING, {inferred=>2}, $_;
    } elsif (/\*\*\*/) {
      dblog $ERR, {inferred=>2}, $_;
    } else {
      dblog $INFO, {inferred=>3}, $_;
    }
}

sub PRINTF {
    my ($this,$format) = (shift, shift);
    &PRINT($this, sprintf($format, @_));
}

#
# tblog_start_capture(): Capture all output to STDOUT and STDERR and turn
#   them into log messages.  Use SOUT and SERR to print to the real
#   STDOUT and STDERR respectfully.  Does NOT capture output of
#   subprocesses.  Will also install handlers for "die" and "warn";
#
# Implementation node: tie is used to catch prints to STDOUT and
#  STDERR as that seams to be the only sane way to do it.  "print" is
#  a special function in perl and can not be overridden normally.
#  Using "*print = &myprint" or even "*IO::Handle::print = &myprint"
#  will only catch the calls to print without a file handle.  Although
#  it may be possible to catch the other type of call to print I don't
#  know how.
#
sub tblog_start_capture( ;@ ) {
    my (@what) = @_;
    @what = qw(stdout stderr die warn) unless @what;
    foreach (@what) {
	if ($_ eq 'stdout') {
	    tie *STDOUT, 'libtblog', \*SOUT;
	} elsif ($_ eq 'stderr') {
	    tie *STDERR, 'libtblog', \*SERR;
	} elsif ($_ eq 'die') {
	    # Should not need to worry about parser errors since the
	    # handlers will be set only after parsing is done
	    $SIG{__DIE__} = sub {
		return if $^S; # In Eval Block
		tblog_stop_capture();
		local $_ = $_[0];
		s/\n$//;
		dblog($ERR, {inferred=>1}, $_);
		die format_message($ERR, $_);
	    };
	} elsif ($_ eq 'warn') {
	    # Should not need to worry about parser errors since the
	    # handlers will be set only after parsing is done
	    $SIG{__WARN__} = sub {
		local $_ = $_[0];
		s/\n$//;
		dblog($WARNING, {inferred=>1}, $_);
		print SERR "$_\n";
	    };
	} else {
	    tbwarn "Unknown flag in tblog_start_capture: $_";
	}
    }
}

#
# tblog_stop_capture(): stop capture of STDOUT and STDERR, and remove 
# handles for die and warn
#
sub tblog_stop_capture( ;@ ) {
    my (@what) = @_;
    @what = qw(stdout stderr die warn) unless @what;
    foreach (@what) {
	if    ($_ eq 'stdout') {untie *STDOUT}
	elsif ($_ eq 'stderr') {untie *STDERR}
	elsif ($_ eq 'die')    {$SIG{__DIE__}  = ''}  
	elsif ($_ eq 'warn')   {$SIG{__WARN__} = ''}
	else 
	  {warn "Unknown flag in tblog_stop_capture: $_"}
    }
}

#
# BEGIN
#

tblog_init();
tblog_start_capture();

#
# END
#

END {
    # Save, since shell commands will alter it.
    my $exitstatus = $?;

    tblog_exit();

    $? = $exitstatus;
}

1;
