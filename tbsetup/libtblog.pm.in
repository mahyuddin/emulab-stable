#!/usr/bin/perl -w

#
# EMULAB-COPYRIGHT
# Copyright (c) 2005, 2006 University of Utah and the Flux Group.
# All rights reserved.
#

=head1 NAME

libtblog - Logging library for testbed

=head1 BASIC USAGE

See the REFERENCE section for detailed descriptions of any of the
functions mentioned here.

=head2 Quick Start

Every perl script that can possible report a testbed related error
should use libtblog.  This should be done in the same place that
the other testbed libraries are included:

    use lib "@prefix@/lib";
    ...
    use libtblog;
    ...

This will activate the logging subsystem.  All output to STDOUT
and STDERR will, by default, be captured and turned into log
messages, in addition to being printed.  Handlers are also installed
for die/warn.  To turn this feature off use tblog_stop_capture(...).

If the script may be used at a top level than tblog_set_info(...)
should be used.

Than all output should use one of the tb* functions calls as follows:

    tberror("message")   # to report an error
    tbwarn("message")    # to report a warning
    tbnotice("message")  # to report important information that not
                         # really a warning.
    tbinfo("message")    # for normal log messages

    tbdie("message")     # to report an error than die using perl "die"

The tb* log functions (except for tbinfo) will automatically prefix
the message with "***" and other appropriate formatting so don't
include any.  However, multiline messages are okay.

Normal perl "die" can and should still be used when reporting an
internal error such as calling a function incorrectly.  The message
will still be logged but it will be flagged as an internal error.

For basic usage that it.

=head2 Associating a Cause With An Error

One of the goals of this system is to be able to determine the cause
of an error.  The current causes are:

    temp - resources temp unavailable
    user - user error
    internal - software bug, should not happen
    software - software problem, like a bad image
    hardware - hardware problem
    unknown - default

(Note, that at the moment, internal is the same as software, but in
the future that might change)

The cause for an error can be set directly when calling tberror by passing
in the "cause" parameter.  For example:

    tberror({cause => 'temp'}, "message")

Or, a default cause can be set for a script using
"tblog_set_default_cause", for example:

    tblog_set_default_cause ('temp')

The cause is only relevant for errors.  For that reason
tblog_set_default_cause will only set the default cause for errors.

When using the normal perl C<die> or C<warn> the cause is always set
to "internal", since they may come from perl itself.

=head2 Finding the Cause of the Error

Use tblog_find_error.

=head1 ADVANCE USAGE

=head2 Understanding How tblog_find_error Works

When something goes wrong tblog_find_error will reconstruct a trace of
what script called what.  Of all the scripts which reported errors, it
will then use the last one at the deepest level.

For example consider the following:

    e (top)
       * (a)
       e (b)
          e (1)
       * (c)
       e (d)
          E (2)
       * (e)

In this example "top" called script "a", "b", "c", "d", "e".  When it
called "b" something went wrong but it continued anyway, it than
called "d" which failed.  However script "d" also called "2" which
also failed.  Thus libtblog will report the errors coming from "2",
the fact that "e" was called after "d" is irrelevant, since it didn't
report any errors.

However, this strategy doesn't always work.  The rest of this section
will deal with the cases when it doesn't and how to help it.

=head2 Extra, and Summary Log Messages

In the case when an error message provides I<extra> information, that
the user should know about, on what just happened with a script at a
lower level, the "type" parameter should be used to set the message
type to "extra":

    tberror {type => 'extra'}, ...

A good example of using the "extra" type to good effect is in
assign_wrapper:

    fatal({type=>'extra', cause=>'user'},
          "Experiment can not be run on an empty testbed. ".
          "Please fix the experiment.");

Where C<fatal> here just calls tberror and then exists.

In the case when the error message provides a useful I<summary> of the
errors at the lower level, and should replace them, the message type
should be set to "summary":

    tberror {type => 'summary'}, ...

=head2 Using Sublevels

In some cases a script does more than one abstract thing such that
when one thing fails it will report an error than latter on report
that X failed.  Since both errors are coming from the same script
both will be reported, but in reality only the error
from the first thing should be reported.  To correct this situation
the "sublevel" parameter should be used.  This parameter tweaks the
call trace so that some errors are at a deeper level than others, even
though they are coming form the same script.  The default sublevel is
0.  Negative sublevels can be used.

For example, consider the following code:

    $res = do_something()

    tbdie "do_something failed!" unless $res;

    sub do_something() {
        ...
        tberror "foo not responding!";
        return 0;
       ...
    }

Without using sublevel the reported errors will be:

    foo not responding!
    do_something failed!

However, the second error is not needed.  To fix this, the sublevel
parameter should be added to one of the tb* calls.  This can either be
accomplished by setting the sublevel to 1 on the "foo not
responding!" error, or -1 on the "do_something failed!" error.  Since
do_something may have many errors it is often easier to set the
sublevel on the "do_something failed!" error:

    ...
    tbdie {sublevel => -1}, do_something failed!" unless $res;
    ...

=head2 Sub Processes

In some cases, such as when forking children to run in parallel,
simply using the sublevel parameter is not enough.  In this case
a new sub-process should be started with tblog_sub_process.

=head1 OTHER SCRIPTS

Currently libtblog is only usable from perl scripts running on boss.
To get errors coming form non-perl programs, or scripts running on ops,
into the system the output should be parsed for errors.  For examples
of this see F<assign_wrapper2> and F<parse-ns>.

=head1 REFERENCE

=over

=cut

package libtblog;
use Exporter;

@ISA = "Exporter";
@EXPORT = qw (tblog tberror tberr tbwarn tbwarning tbnotice tbinfo tbdebug 
	      tbdie tblog_set_info tblog_set_default_cause
	      tblog_sub_process tblog_find_error
	      tblog_start_capture tblog_stop_capture
	      tblog_new_process tblog_init_process tblog_exit
	      copy_hash
	      TBLOG_EMERG TBLOG_ALERT TBLOG_CRIT TBLOG_ERR 
	      TBLOG_WARNING TBLOG_NOTICE TBLOG_INFO TBLOG_DEBUG);
@EXPORT_OK = qw (dblog *SOUT *SERR);

# After package decl.
# DO NOT USE "use English" in this module
use POSIX qw(isatty setsid);
use File::Basename;
use IO::Handle;
use Text::Wrap;
use Carp;

use strict;

#
# Testbed Support libraries
#
use lib "@prefix@/lib";
use libtestbed;
use libdb qw(NewTBDBHandle DBQueryN DBQueryWarnN DBQueryFatalN
	     DBQuoteSpecial $DBQUERY_MAXTRIES DBWarn DBFatal);
use libtblog_simple;

my $REAL_SCRIPTNAME = $SCRIPTNAME;
undef $SCRIPTNAME; # signal to use $ENV{TBLOG_SCRIPTNAME}

my $DB;

#
# Internal Utility Functions
#

sub check_env_def ( $ )
{
  croak "Environment variable \"$_[0]\" not defined" unless defined $_[0];
}

sub check_env_num ( $ )
{
    check_env_def $_[0];
    croak "Environment variable \"$_[0]\" not a positive integer" 
	unless $ENV{$_[0]} =~ /^[0-9]+$/;
}

sub check_env ()
{
    check_env_num 'TBLOG_LEVEL';
    check_env_num 'TBLOG_SESSION';
    check_env_num 'TBLOG_PIDX';
    check_env_num 'TBLOG_INVOCATION';
    check_env_num 'TBLOG_PARENT_INVOCATION';
    check_env_num 'TBLOG_UID';
    check_env_num 'TBLOG_SCRIPTNUM';
    check_env_def 'TBLOG_SCRIPTNAME';
    check_env_def 'TBLOG_BASE_SCRIPTNAME';
}

my %CAUSE_MAP = (# Don't notify testbed-ops
		 temp => 'temp', # resources temp unavailable
		 user => 'user', # user error
		 # Notify testbed-ops
		 internal => 'software', # software bug, should not happen
		 software => 'software', # software problem, like a bad image
		 hardware => 'hardware', # hardware problem
		 unknown => '');

sub normalize_cause ( $ ) {
    my $cause = $CAUSE_MAP{$_[0]};
    croak "Unknown cause \"$cause\"" unless defined $cause;
    return $cause;
}

#
#
#


#
# Standard DBQuery functions from dblog but use private database handle
#
sub DBQuery ( $ )      {return DBQueryN($DB, $_[0]);}
sub DBQueryFatal ( $ ) {return DBQueryFatalN($DB, $_[0]);}
sub DBQueryWarn ( $ )  {return DBQueryWarnN($DB, $_[0]);}

#
# Like DBQueryFatal but also fail if the query didn't return any results
#
sub DBQuerySingleFatal ( $ )
{
    my ($query) = @_;
    my $query_result = DBQueryFatalN($DB, $query);
    DBFatal("DB Query \"$query\" didn't return any results") 
	unless $query_result->numrows > 0;
    my @row = $query_result->fetchrow_array();
    return $row[0];
}

#
# Forward Decals
#

sub dblog ( $$@ );
sub tblog ( $@ );
sub tblog_new_process(@);
sub tblog_init_process(@);
sub informative_scriptname();


#
# tblog_init
#
# Called automatically when a script starts.
#
# Will: Get the priority mapping (string -> int) from the database and
# than call tblog_new_process
#
sub tblog_init() {
    # Connect to database

    $DB = NewTBDBHandle();

    # Reset default cause

    $ENV{TBLOG_CAUSE} = '';

    # ...

    tblog_new_process(if_defined($main::FAKE_SCRIPTNAME,
				 $REAL_SCRIPTNAME),
		      @ARGV);
};

#
# tblog_new_process CMD, ARGV
#
# Enter a new (possible fake) process, calls tblog_init_process
#
# If used to start a new fake process it is advised to make a local
# copy of %ENV using perl "local".  See tblog_sub_process for an
# explanation.
#
sub tblog_new_process(@) {
    delete $ENV{TBLOG_BASE_SCRIPTNAME};
    tblog_init_process(@_);
}

#
# tblog_init_process CMD, ARGV
#
# Init a new process
#
# Will: (1) Get the unique ID for the script name,  (2) Creating an
# "entring" log message in the database, (3) get the session id and
# set up the environmental variables if they are not already set,
# (4) Get the invocation id, and (5) increment the level
#
# NOTE: Everything is currently stored in the %ENV hash.
#
sub tblog_init_process(@) {
    my ($script, @argv) = @_;
    local $DBQUERY_MAXTRIES = 3;

    # Get script name

    $ENV{TBLOG_SCRIPTNAME} = $script;
    $ENV{TBLOG_BASE_SCRIPTNAME} = $script unless defined $ENV{TBLOG_BASE_SCRIPTNAME};

    # Get script number

    my $query_result = DBQueryFatal
	sprintf("select script from scripts where script_name=%s",
		DBQuoteSpecial $ENV{TBLOG_SCRIPTNAME});
    if ($query_result->num_rows > 0) {
	$ENV{TBLOG_SCRIPTNUM} = ($query_result->fetchrow_array())[0];
    } else {
	DBQueryFatal 
	    sprintf("insert into scripts (script_name) values (%s)",
		    DBQuoteSpecial $ENV{TBLOG_SCRIPTNAME});
	$ENV{TBLOG_SCRIPTNUM} = DBQuerySingleFatal 'select LAST_INSERT_ID()';
    }

    # ...

    if (defined $ENV{'TBLOG_SESSION'}) {
	check_env();
	$ENV{TBLOG_LEVEL}++;
	$ENV{TBLOG_PARENT_INVOCATION} = $ENV{TBLOG_INVOCATION};
	dblog($NOTICE, {type => 'entering'},
	      'Entering "', join(' ', informative_scriptname(), @argv), '"')
	  or die;
	my $id = DBQuerySingleFatal 'select LAST_INSERT_ID()';
	$ENV{TBLOG_INVOCATION} = $id;
	DBQueryFatal("update log set invocation=$id where seq=$id");
    } else {
	$ENV{TBLOG_SESSION} = 0;
	$ENV{TBLOG_INVOCATION} = 0;
	$ENV{TBLOG_PARENT_INVOCATION} = 0;
	$ENV{TBLOG_LEVEL} = 0;
	$ENV{TBLOG_PIDX} = 0;
	$ENV{TBLOG_UID} = 0;
	dblog($NOTICE, {type => 'entering'},
	      'Entering "', join(' ', informative_scriptname(), @ARGV), '"')
	  or die;
	my $id = DBQuerySingleFatal 'select LAST_INSERT_ID()';
	# set SESSION in database
	$ENV{TBLOG_SESSION} = $id;
	$ENV{TBLOG_INVOCATION} = $id;
	DBQueryFatal("update log set session=$id,invocation=$id where seq=$id");
    }

}


=item tblog_sub_process NAME, ARGV

Began a sub process.  It is advised to make a local copy of %ENV using
perl "local".  This can be done with:

    local %ENV = %ENV

however due to a bug in perl 5.005_03 if "-T" is used than the above will
taint the path, instead use:

    my $old_env = \%ENV
    local %ENV;
    copy_hash %ENV, $old_env

See perlsub(1) for more info on "local"

=cut

sub tblog_sub_process($@) {
    my $name = shift;
    tblog_init_process("$ENV{TBLOG_BASE_SCRIPTNAME}-$name",
		       @_);
}


=item copy_hash %DEST, \%SRC

Utility function, see tblog_sub_process

=cut

sub copy_hash(\%$) {
    my ($new, $old) = @_;
    foreach (keys %$old) {
	$new->{$_} = $old->{$_};
    }
}

=item tblog_set_info PID, EID, UID

Sets info in the database which can't be derived automatically with
init.  Needs to be called at least once during a session.

=cut

sub tblog_set_info ( $$$ )
{
    check_env();
    my ($pid, $eid, $uid) = @_;
    local $DBQUERY_MAXTRIES = 3;
    $ENV{'TBLOG_PIDX'} = 
	DBQuerySingleFatal("select idx from experiments where pid='$pid' and eid='$eid'");
    $ENV{'TBLOG_UID'} = $uid;
    DBQueryFatal
	sprintf('update log set pidx=%d,uid=%s where session=%s',
		$ENV{TBLOG_PIDX}, $ENV{TBLOG_UID}, $ENV{TBLOG_SESSION});
}

=item tblog_set_default_cause CAUSE

Set the default cause.

=cut

sub tblog_set_default_cause ( $ )
{
    check_env();
    $ENV{TBLOG_CAUSE} = $_[0];
}

=item tblog_exit

Exits a script or sub-process.  Generally called automatically when a
script exists but may be called explistly when ending a sub-process.

=cut

sub tblog_exit() {
    return unless defined $ENV{'TBLOG_SESSION'};
    check_env();
    dblog($INFO, {type=>'exiting'}, "Leaving \"", informative_scriptname(), 
	  " ...\"");
}

#
# informative_scriptname()
#
sub informative_scriptname() {
    if ($ENV{TBLOG_BASE_SCRIPTNAME} eq $REAL_SCRIPTNAME) {
	return $ENV{TBLOG_SCRIPTNAME};
    } else {
	return "$ENV{TBLOG_SCRIPTNAME} (but really $REAL_SCRIPTNAME)";
    }
}


=item tblog PRIORITY, MESG, ...

=item tblog PRIORITY, {PARM=>VALUE,...}, MESG, ...

The main log function.  Logs a message to the database and print
the message to STDERR with an approate prefix depending on the
severity of the error.  If more than one string is given for the
message than they will concatenated.  If the env. var. TBLOG_OFF
is set to a true value than nothing will be written to the
database, but the message will still be written to STDERR.

Useful parms: sublevel, cause, type

=item tberror [{PARM=>VALUE,...},] MESG, ...

=item tberr [{PARM=>VALUE,...},] MESG, ...

=item tbwarn [{PARM=>VALUE,...},] MESG, ...

=item tbwarning [{PARM=>VALUE,...},] MESG, ...

=item tbnotice [{PARM=>VALUE,...},] MESG, ...

=item tbinfo [{PARM=>VALUE,...},] MESG, ...

=item tbdebug [{PARM=>VALUE,...},] MESG, ...

Usefull alias functions.  Will call tblog with the appropriate priority.

=item tbdie [{PARM=>VALUE,...},] MESG, ...

Log the message to the database as an error and than die.  An
optional set of paramaters may be specified as the first argument.
not exactly like die as the message must be specified.

=cut

#
# NOTE: tblog (and friends) defined in libtblog_simple
#

#
# dblog(priority, {parm=>value,...}, mesg, ...)
#   Internal function.  Logs a message to the database.  Doesn't print
#   anything. Will not die, instead return 0 on error, with the error
#   message in $@.
#   Valid parms: sublevel, cause, type
#
my $in_dblog = 0; # Used to avoid an infinite recursion when
                  # DBQueryFatal fails as a log entry is made to
                  # record the failure, which will than likely cause
                  # another failure and so on
sub dblog_real ( $$@ ) {
    my ($priority, $parms, @mesg) = @_;
    my $mesg = join('',@mesg);
    #print SERR "===$priority $parms @mesg\n";
    return if $ENV{TBLOG_OFF} || $in_dblog;
    $in_dblog = 1;
    eval {
	check_env();

	my $cause;
	$cause = normalize_cause($parms->{cause}) 
	  if defined $parms->{cause};
	$cause = $priority <= $WARNING ? $ENV{TBLOG_CAUSE} : '' 
	  unless defined $cause;

	my $query = 
	  sprintf('insert into log (stamp,pidx,uid,session,parent,invocation,script,level,sublevel,priority,inferred,cause,type,mesg) '. 
		  'VALUES (UNIX_TIMESTAMP(now()),%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%s,%s,%s)',
		  $ENV{TBLOG_PIDX}, 
		  $ENV{TBLOG_UID},
		  $ENV{TBLOG_SESSION}, 
		  $ENV{TBLOG_PARENT_INVOCATION}, 
		  $ENV{TBLOG_INVOCATION},
		  $ENV{TBLOG_SCRIPTNUM}, 
		  $ENV{TBLOG_LEVEL},
		  if_defined($parms->{sublevel}, 0),
		  $priority,
		  if_defined($parms->{inferred}, 0),
		  DBQuoteSpecial $cause,
		  DBQuoteSpecial if_defined($parms->{type}, 'normal'),
		  DBQuoteSpecial $mesg);

	if ($priority <= $NOTICE) {
	    local $DBQUERY_MAXTRIES = 3;
	    my $result = DBQuery($query);
	    DBWarn("Could not log entry to DB, tblog_find_error may report incorrect results") unless $result;
	} else {
	    my $result = DBQuery($query);
	    DBWarn("Could not log entry to DB", 1) unless $result;
	}
    };
    $in_dblog = 0;
    # Print a warning on failure but don't log the results to the database
    # as that is likely to fail also
    print SERR format_message(scriptname(), $WARNING, $@) if $@;
    return 0 if $@;
    return 1;
}
{
  local $^W = 0;
  *dblog = \&dblog_real;
}


=item tblog_find_error [[SESSION], STORE]

Attempts to find the relevant error.

Parameters:

=over

=over

=item session

Session id to use. Defaults to the current as given by 
$ENV{TVLOG_SESSION}.

=item store

If set store the results into the database and act in
a way that is safe to use in an END block, that is 
(1) never die, (2) don't modify the exit code,  Will also
print the results to and some additional info to STDERR
for diagnosis purposed.  If not set simply print the results to
STDERR.  Defaults to true unless the "session" parameter is also
given, in which case default to false.

=back

=back

To retrieve the results from the database:

    SELECT ... WHERE session = <Session ID>
                 AND type = 'thecause' form log

The relevant errors are also flagged using "relevant" flag:

    SELECT ... WHERE session = <Session ID>
                 AND relevant != 0 form log

=cut

sub tblog_find_error ( ;$$ ) {

    my ($session,$store) = @_;
    my $saved_exitcode = $?;

    local $DBQUERY_MAXTRIES = 3;

    if (not defined $session) {
        check_env();
	$store = 1;
	$session = $ENV{TBLOG_SESSION};
    }

    $store = 0 unless defined $store;

    eval {

	#
	# Build the Tree
	#
	# Tree data structure:
	# invocation = {invocation => INT, parent => INT, 
	#		[{seq => int ...} || {seq => int, child => invox}]}
	
	my $root = {invocation => 0, log => []};
	my %lookup = (0 => $root);
	my @log;
	
	my $query_result = DBQueryFatal "select seq,parent,invocation,sublevel,priority,mesg,cause,script_name,type from log natural join scripts where session = $session and priority <= $NOTICE order by seq";
	
	for (my $i = 0; $i < $query_result->num_rows; $i++) {
	    
	    my ($seq, $parent, $invocation, $sublevel, $priority, $mesg, $cause, $script, $type) 
		= $query_result->fetchrow;
	    
	    if (not exists $lookup{$invocation}) {
		
		my $p = $lookup{$parent};
		die "Parent Doesn't Exists!" unless defined $p;
		$lookup{$invocation} = {invocation => $invocation, 
					parent => $parent, 
					script=>$script, 
					log => []};
		push @{$p->{log}}, {seq => $invocation, 
				    child => $lookup{$invocation}};
		
	    }
	    
	    push @{$lookup{$invocation}{log}}, {seq => $seq, 
						invocation=>$invocation, 
						sublevel=> $sublevel,
						priority => $priority,
						type => $type,
						cause => $cause,
						mesg => $mesg};
	    
	}

	my $handle_sublevels;
	$handle_sublevels = sub {

	    my ($tree) = @_;

	    my $log = $tree->{log};
	    return unless defined $log;

	    # normalize sublevels
	    my $min_sublevel = 200;
	    foreach (@$log) {
		$min_sublevel = $_->{sublevel} 
		    if exists $_->{sublevel} && $_->{sublevel} < $min_sublevel;
	    }

	    for (my $i = 0; $i < @$log; $i++) {

		local $_ = $log->[$i];

		if (exists $_->{sublevel} && $_->{sublevel} > $min_sublevel) {

		    my @sublog = ($_);
		    my $j = $i + 1;
		    while ($j < @$log && 
			   exists $log->[$j]->{sublevel} &&
			   $log->[$j]->{sublevel} > $min_sublevel) {
			push @sublog, $log->[$j];
			$j++;
		    }
		    my $repl = {
			child => {log => [@sublog]}
		    };
		    splice(@$log, $i, $j - $i, $repl);
		    $handle_sublevels->($repl->{child})

		} elsif (exists $_->{child}) {

		    $handle_sublevels->($_->{child});

		}
	    }

	};

	$handle_sublevels->($root);


	#
	# Now find the relevant errors.
	#
	
	my $find_relevant;
	$find_relevant = sub {

	    my ($tree) = @_;

	    my @posib_errs;
	    my @extra_info;

	    foreach (reverse @{$tree->{log}}) {

		if (exists $_->{child}) {
		    
		    my @errs = $find_relevant->($_->{child});
		    if (@errs) {
			return (reverse(@extra_info),@errs);
		    } 
		    
		} elsif ($_->{priority} <= $ERR) {
		    
		    push @posib_errs, $_;

		    if ($_->{type} eq 'summary') {
			last;
		    } elsif ($_->{type} eq 'extra') {
			push @extra_info, $_;
		    }
		    
		}
		
	    }

	    return reverse @posib_errs;
	};

	my @relevant = $find_relevant->($root);
	
	#
	# Get the most relevent script
	#
	my $script = '';
	if (@relevant) {
	    $script = $lookup{$relevant[0]->{invocation}}->{script};
	}

	#
	# From script determine confidence 
	#
	my $confidence = 0.5;
	if ($script =~ /^(assign|parse)/) {
	    $confidence = 0.9;
	} elsif ($script =~ /^(os_setup)/) {
	    $confidence = 0.2;
	}

	#
	# Figure out the cause;
	#
	my $cause = '';
	my $type = '';

	# Assumes that 'extra' info will come first
	
	foreach (@relevant) {
	    if (!$cause && $_->{cause}) {
		$cause = $_->{cause};
		$type = $_->{type};
	    } elsif ($_->{cause} && 
		     $_->{type} eq $type && $_->{cause} ne $cause) {
		$cause = 'unknown';
	    }
	}
	$cause = 'unknown' unless $cause;

	# 
	# Finally print/store the relevant errors
	#
	
	my $error = '';
	
	my $prev;
	foreach (@relevant) {
	    # avoid printing the exact same error twice
	    next if (defined $prev && $prev->{mesg} eq $_->{mesg});

	    $error .= "\n" if defined $prev;

	    if ($_->{mesg} !~ /\n/) {
		$error .= wrap('  ','  ',
			       "$_->{mesg} ($lookup{$_->{invocation}}->{script})\n");
	    } else {
		# if multiline don't reformat
		foreach (split /\s*\n/, $_->{mesg}) {
		    $error .= "  $_\n";
		}
		$error .= "  ($lookup{$_->{invocation}}->{script})\n";
	    }
	    $prev = $_;
	}
	$error = "No clue as to what went wrong!\n" unless length $error > 0;
	
	if ($store) {
	    $error .= "Cause: $cause\n";
	    $error .= "Confidence: $confidence\n";
	    print SERR "**** Experimental information, please ignore ****\n";
	    print SERR "Session ID = $ENV{TBLOG_SESSION}\n";
	    print SERR "Likely Cause of the Problem:\n";
	    print SERR $error;
	    print SERR "**** End experimental information ****\n";
	    chop $error;
	    dblog $NOTICE, {type=>'thecause'}, $error;
	    DBQueryFatal(sprintf("update log set relevant=1 where seq in (%s)",
				 join(',', map {$_->{seq}} @relevant))) if @relevant;
	} else {
	    print SERR $error;
	}
    };

    if ($@) {
	my $err = $@;
	eval {SENDMAIL(TB_OPSEMAIL, "tblog_find_error failed",
		       "Experiment: $ENV{TBLOG_PIDX}\n".
		       "User: $ENV{TBLOG_UID}\n".
		       "Session: $ENV{TBLOG_SESSION}\n".
		       "Script: $ENV{TBLOG_SCRIPTNAME}\n".
		       "\n".
		       "$err\n")};
	if ($store) {
	    eval {tblog $WARNING, {type=>'thecause'}, 
		    "tblog_find_error failed: $err" };
	} else {
	    $? = $saved_exitcode;
	    die;
	}
    }
    $? = $saved_exitcode;
}

#
# Perl Tie Methods, see perltie(1)
#

sub TIEHANDLE {
    my ($classname, $glob) = @_;
    bless \$glob, $classname;
}

sub PRINT {
    my $this = shift;
    print {$$this} @_;
    local $_ = join '', @_; # NOTE: This doesn't take into account "$,"
                            # or output_field_separator
    s/\n$//;
    if (/warning:/i) {
      dblog $WARNING, {inferred=>2}, $_;
    } elsif (/\*\*\*/) {
      dblog $ERR, {inferred=>2}, $_;
    } else {
      dblog $INFO, {inferred=>3}, $_;
    }
}

sub PRINTF {
    my ($this,$format) = (shift, shift);
    &PRINT($this, sprintf($format, @_));
}

sub FILENO {
    my $this = shift;
    fileno($$this);
}

sub OPEN {
    my $this = shift;
    my ($caller_package) = caller;
    # The open must be executed in the callers package becuase of
    # things like "open FH, '>&LOG'" will fail if open is executed in
    # the libtblog package since "LOG" is in the callers package.
    # Since package is a compile time directive, the only way to do
    # this is to do an eval on a string.
    eval("package $caller_package;".
	 '@_ == 1 ? open($$this, $_[0]) : open($$this, $_[0], $_[1])');
}

sub CLOSE {
    # Don't do anything: If we really close $$this than we will lose
    # the fact that SOUT and STDOUT have the same underlying fileno
    # (ditto for SERR and STDERR)
}

=item tblog_start_capture [LIST]

Capture all output to STDOUT and STDERR and turn them into log
messages.  Use SOUT and SERR to print to the real STDOUT and STDERR
respectfully.  Does NOT capture output of subprocesses.  Will also
install handlers for "die" and "warn".

If LIST is present than only capture the parts present in list, can be
any one of "stdout", "stderr", "die", or "warn".

=cut

#
# Implementation node: tie is used to catch prints to STDOUT and
#  STDERR as that seams to be the only sane way to do it.  "print" is
#  a special function in perl and can not be overridden normally.
#  Using "*print = &myprint" or even "*IO::Handle::print = &myprint"
#  will only catch the calls to print without a file handle.  Although
#  it may be possible to catch the other type of call to print I don't
#  know how.
#
sub tblog_start_capture( ;@ ) {
    my (@what) = @_;
    @what = qw(stdout stderr die warn) unless @what;
    foreach (@what) {
	if ($_ eq 'stdout') {
	    tie *STDOUT, 'libtblog', \*SOUT;
	} elsif ($_ eq 'stderr') {
	    tie *STDERR, 'libtblog', \*SERR;
	} elsif ($_ eq 'die') {
	    # Should not need to worry about parser errors since the
	    # handlers will be set only after parsing is done
	    $SIG{__DIE__} = sub {
		return if $^S; # In Eval Block
		tblog_stop_capture();
		local $_ = $_[0];
		s/\n$//;
		dblog($ERR, {inferred=>1, cause=>'internal'}, $_);
		die format_message(scriptname(), $ERR, $_);
	    };
	} elsif ($_ eq 'warn') {
	    # Should not need to worry about parser errors since the
	    # handlers will be set only after parsing is done
	    $SIG{__WARN__} = sub {
		local $_ = $_[0];
		s/\n$//;
		dblog($WARNING, {inferred=>1, cause=>'internal'}, $_);
		print SERR "$_\n";
	    };
	} else {
	    carp "Unknown flag in tblog_start_capture: $_";
	}
    }
}

=item tblog_stop_capture [LIST]

Stop capture of STDOUT and STDERR, and remove handles for die and
warn.

If LIST is present than only stop capture of the parts present in
list, can be any one of "stdout", "stderr", "die", or "warn".

=cut

sub tblog_stop_capture( ;@ ) {
    my (@what) = @_;
    @what = qw(stdout stderr die warn) unless @what;
    foreach (@what) {
	if    ($_ eq 'stdout') {untie *STDOUT}
	elsif ($_ eq 'stderr') {untie *STDERR}
	elsif ($_ eq 'die')    {$SIG{__DIE__}  = ''}  
	elsif ($_ eq 'warn')   {$SIG{__WARN__} = ''}
	else 
	  {carp "Unknown flag in tblog_stop_capture: $_"}
    }
}

#
# BEGIN
#

tblog_init();
tblog_start_capture();

#
# END
#

END {
    # Save, since shell commands will alter it.
    my $exitstatus = $?;

    tblog_exit();

    $? = $exitstatus;
}

1;

=pod

=back

=head1 ENVIRONMENT

To turn off the database logging set the environmental variable
TBLOG_OFF to a true value.

A number of environmental variables are used by libtblog, all of which
start with "TBLOG_".  They should generally not be set directory.

=head1 SEE ALSO

The file F<libtblog.sql> in the F<sql/> directory in the source describes
the tables used by libtblog.

libtblog_simple, which is a special version of libtblog.

=cut
