#!/usr/bin/perl -w

#
# EMULAB-COPYRIGHT
# Copyright (c) 2005 University of Utah and the Flux Group.
# All rights reserved.
#

#
# libtblog: Logging library for testbed
#
# The very act of including libtblog in a perl script will activate
# the logging subsystem.  Also, all output to STDOUT and STDERR will,
# by default, be captured and turned into log messages, in addition to
# being printed.  Handlers are also installed for die/warn.
# To turn this feature off use tblog_stop_capture(..).
#
# Although the logging subsystem is activated automatically, the pid,
# eid, and uid can not be determined automatically.  Thus the function
# tblog_set_info(...) needs to be called to set this info.
#
# To create a log entry use tblog(...) or one of the shortcut function:
# tberror, tberr, tbwarn, tbwarning, tbnotice, tbinfo, and tbdebug.
#
# To attempt and figure out what went wrong during a session use
# tblog_find_error(..).
# 
# To turn off the database logging set the environmental variable
# TBLOG_OFF to a true value.
#

package libtblog;
use Exporter;

@ISA = "Exporter";
@EXPORT = qw (tblog tberror tberr tbwarn tbwarning tbnotice tbinfo tbdebug 
	      tbdie tblog_set_info tblog_set_default_cause
	      tblog_sub_process tblog_find_error
	      tblog_capture tblog_stop_capture
	      tblog_new_process tblog_init_process tblog_exit
	      copy_hash
	      TBLOG_EMERG TBLOG_ALERT TBLOG_CRIT TBLOG_ERR 
	      TBLOG_WARNING TBLOG_NOTICE TBLOG_INFO TBLOG_DEBUG);
@EXPORT_OK = qw (dblog *SOUT *SERR);

# After package decl.
# DO NOT USE "use English" in this module
use POSIX qw(isatty setsid);
use File::Basename;
use IO::Handle;
use Text::Wrap;
use Carp;

use strict;

#
# Testbed Support libraries
#
use lib "@prefix@/lib";
use libtestbed;
use libdb qw(NewTBDBHandle DBQueryN DBQueryWarnN DBQueryFatalN
	     DBQuoteSpecial $DBQUERY_MAXTRIES DBWarn DBFatal);
use libtblog_simple;

my $REAL_SCRIPTNAME = $SCRIPTNAME;
undef $SCRIPTNAME; # signal to use $ENV{TBLOG_SCRIPTNAME}

my $DB;

#
# Internal Utility Functions
#

sub check_env_def ( $ )
{
  croak "Environment variable \"$_[0]\" not defined" unless defined $_[0];
}

sub check_env_num ( $ )
{
    check_env_def $_[0];
    croak "Environment variable \"$_[0]\" not a positive integer" 
	unless $ENV{$_[0]} =~ /^[0-9]+$/;
}

sub check_env ()
{
    check_env_num 'TBLOG_LEVEL';
    check_env_num 'TBLOG_SESSION';
    check_env_num 'TBLOG_PIDX';
    check_env_num 'TBLOG_INVOCATION';
    check_env_num 'TBLOG_PARENT_INVOCATION';
    check_env_num 'TBLOG_UID';
    check_env_num 'TBLOG_SCRIPTNUM';
    check_env_def 'TBLOG_SCRIPTNAME';
    check_env_def 'TBLOG_BASE_SCRIPTNAME';
}

my %CAUSE_MAP = (# Don't notify testbed-ops
		 temp => 'temp', # resources temp unavailable
		 user => 'user', # user error
		 # Notify testbed-ops
		 internal => 'software', # software bug, should not happen
		 software => 'software', # software problem, like a bad image
		 hardware => 'hardware', # hardware problem
		 unknown => '');

sub normalize_cause ( $ ) {
    my $cause = $CAUSE_MAP{$_[0]};
    croak "Unknown cause \"$cause\"" unless defined $cause;
    return $cause;
}

#
#
#


#
# Standard DBQuery functions from dblog but use private database handle
#
sub DBQuery ( $ )      {return DBQueryN($DB, $_[0]);}
sub DBQueryFatal ( $ ) {return DBQueryFatalN($DB, $_[0]);}
sub DBQueryWarn ( $ )  {return DBQueryWarnN($DB, $_[0]);}

#
# Like DBQueryFatal but also fail if the query didn't return any results
#
sub DBQuerySingleFatal ( $ )
{
    my ($query) = @_;
    my $query_result = DBQueryFatalN($DB, $query);
    DBFatal("DB Query \"$query\" didn't return any results") 
	unless $query_result->numrows > 0;
    my @row = $query_result->fetchrow_array();
    return $row[0];
}

#
# Forward Decals
#

sub dblog ( $$@ );
sub tblog ( $@ );
sub tblog_new_process(@);
sub tblog_init_process(@);
sub informative_scriptname();

#
# tblog_init(): Called automatically when a script starts.
#
# Will: Get the priority mapping (string -> int) from the database and
# than call tblog_new_process
#
sub tblog_init() {
    # Connect to database

    $DB = NewTBDBHandle();

    # Reset default cause

    $ENV{TBLOG_CAUSE} = '';

    # ...

    tblog_new_process(if_defined($main::FAKE_SCRIPTNAME,
				 $REAL_SCRIPTNAME),
		      @ARGV);
};


#
# tblog_new_process($cmd, @argv): enter a new (possible fake) process
# calls tblog_init_process
#
# If used to start a new fake process it is advised to make a local
# copy of %ENV using perl "local".  See tblog_sub_process for an
# explanation.
#
sub tblog_new_process(@) {
    delete $ENV{TBLOG_BASE_SCRIPTNAME};
    tblog_init_process(@_);
}

#
# tblog_init_process($cmd, @argv): init a new process
#
# Will: (1) Get the unique ID for the script name,  (2) Creating an
# "entring" log message in the database, (3) get the session id and
# set up the environmental variables if they are not already set,
# (4) Get the invocation id, and (5) increment the level
#
# NOTE: Everything is currently stored in the %ENV hash.
#
sub tblog_init_process(@) {
    my ($script, @argv) = @_;
    local $DBQUERY_MAXTRIES = 3;

    # Get script name

    $ENV{TBLOG_SCRIPTNAME} = $script;
    $ENV{TBLOG_BASE_SCRIPTNAME} = $script unless defined $ENV{TBLOG_BASE_SCRIPTNAME};

    # Get script number

    my $query_result = DBQueryFatal
	sprintf("select script from scripts where script_name=%s",
		DBQuoteSpecial $ENV{TBLOG_SCRIPTNAME});
    if ($query_result->num_rows > 0) {
	$ENV{TBLOG_SCRIPTNUM} = ($query_result->fetchrow_array())[0];
    } else {
	DBQueryFatal 
	    sprintf("insert into scripts (script_name) values (%s)",
		    DBQuoteSpecial $ENV{TBLOG_SCRIPTNAME});
	$ENV{TBLOG_SCRIPTNUM} = DBQuerySingleFatal 'select LAST_INSERT_ID()';
    }

    # ...

    if (defined $ENV{'TBLOG_SESSION'}) {
	check_env();
	$ENV{TBLOG_LEVEL}++;
	$ENV{TBLOG_PARENT_INVOCATION} = $ENV{TBLOG_INVOCATION};
	dblog($NOTICE, {type => 'entering'},
	      'Entering "', join(' ', informative_scriptname(), @argv), '"')
	  or die;
	my $id = DBQuerySingleFatal 'select LAST_INSERT_ID()';
	$ENV{TBLOG_INVOCATION} = $id;
	DBQueryFatal("update log set invocation=$id where seq=$id");
    } else {
	$ENV{TBLOG_SESSION} = 0;
	$ENV{TBLOG_INVOCATION} = 0;
	$ENV{TBLOG_PARENT_INVOCATION} = 0;
	$ENV{TBLOG_LEVEL} = 0;
	$ENV{TBLOG_PIDX} = 0;
	$ENV{TBLOG_UID} = 0;
	dblog($NOTICE, {type => 'entering'},
	      'Entering "', join(' ', informative_scriptname(), @ARGV), '"')
	  or die;
	my $id = DBQuerySingleFatal 'select LAST_INSERT_ID()';
	# set SESSION in database
	$ENV{TBLOG_SESSION} = $id;
	$ENV{TBLOG_INVOCATION} = $id;
	DBQueryFatal("update log set session=$id,invocation=$id where seq=$id");
    }

}

#
# Began a sub process.  It is advised to make a local copy of %ENV using
# perl "local".  This can be done with:
#   local %ENV = %ENV
# however due to a bug in perl 5.005_03 if "-T" is used than the above will 
# taint the path, instead use:
#   my $old_env = \%ENV
#   local %ENV;
#   copy_hash %ENV, $old_env
# See perlsub(1) 1 for more info on "local"
#
sub tblog_sub_process($@) {
    my $name = shift;
    tblog_init_process("$ENV{TBLOG_BASE_SCRIPTNAME}-$name",
		       @_);
}

#
# copy_hash(%dest, \%src)
#
sub copy_hash(\%$) {
    my ($new, $old) = @_;
    foreach (keys %$old) {
	$new->{$_} = $old->{$_};
    }
}

#
# tblog_set_info(pid, eid, uid): Sets info in the database which can't
#   be derived automatically with init.  Needs to be called at least
#   once during a session.
#
sub tblog_set_info ( $$$ )
{
    check_env();
    my ($pid, $eid, $uid) = @_;
    local $DBQUERY_MAXTRIES = 3;
    $ENV{'TBLOG_PIDX'} = 
	DBQuerySingleFatal("select idx from experiments where pid='$pid' and eid='$eid'");
    $ENV{'TBLOG_UID'} = $uid;
    DBQueryFatal
	sprintf('update log set pidx=%d,uid=%s where session=%s',
		$ENV{TBLOG_PIDX}, $ENV{TBLOG_UID}, $ENV{TBLOG_SESSION});
}

#
# tblog_set_default_cause(cause)
#
sub tblog_set_default_cause ( $ )
{
    check_env();
    $ENV{TBLOG_CAUSE} = $_[0];
}


#
# tblog_exit(): Called automatically when a script exits, or explistly
# when a fake process exits.  
#
sub tblog_exit() {
    return unless defined $ENV{'TBLOG_SESSION'};
    check_env();
    dblog($INFO, {type=>'exiting'}, "Leaving \"", informative_scriptname(), 
	  " ...\"");
}

#
# informative_scriptname()
#
sub informative_scriptname() {
    if ($ENV{TBLOG_BASE_SCRIPTNAME} eq $REAL_SCRIPTNAME) {
	return $ENV{TBLOG_SCRIPTNAME};
    } else {
	return "$ENV{TBLOG_SCRIPTNAME} (but really $REAL_SCRIPTNAME)";
    }
}


#
# dblog(priority, {parm=>value,...}, mesg, ...)
#   Internal function.  Logs a message to the database.  Doesn't print
#   anything. Will not die, instead return 0 on error, with the error
#   message in $@.
#   Valid parms: sublevel, cause, type, fatal
#
my $in_dblog = 0; # Used to avoid an infinite recursion when
                  # DBQueryFatal fails as a log entry is made to
                  # record the failure, which will than likely cause
                  # another failure and so on
sub dblog_real ( $$@ ) {
    my ($priority, $parms, @mesg) = @_;
    my $mesg = join('',@mesg);
    #print SERR "===$priority $parms @mesg\n";
    return if $ENV{TBLOG_OFF} || $in_dblog;
    $in_dblog = 1;
    eval {
	check_env();

	my $cause;
	$cause = normalize_cause($parms->{cause}) 
	  if defined $parms->{cause};
	$cause = $priority <= $WARNING ? $ENV{TBLOG_CAUSE} : '' 
	  unless defined $cause;

	my $query = 
	  sprintf('insert into log (stamp,pidx,uid,session,parent,invocation,script,level,sublevel,priority,inferred,cause,type,mesg) '. 
		  'VALUES (UNIX_TIMESTAMP(now()),%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%s,%s,%s)',
		  $ENV{TBLOG_PIDX}, 
		  $ENV{TBLOG_UID},
		  $ENV{TBLOG_SESSION}, 
		  $ENV{TBLOG_PARENT_INVOCATION}, 
		  $ENV{TBLOG_INVOCATION},
		  $ENV{TBLOG_SCRIPTNUM}, 
		  $ENV{TBLOG_LEVEL},
		  if_defined($parms->{sublevel}, 0),
		  $priority,
		  if_defined($parms->{inferred}, 0),
		  DBQuoteSpecial $cause,
		  DBQuoteSpecial if_defined($parms->{type}, 'normal'),
		  DBQuoteSpecial $mesg);

	if ($priority <= $NOTICE) {
	    local $DBQUERY_MAXTRIES = 3;
	    my $result = DBQuery($query);
	    DBWarn("Could not log entry to DB, tblog_find_error may report incorrect results") unless $result;
	} else {
	    my $result = DBQuery($query);
	    DBWarn("Could not log entry to DB", 1) unless $result;
	}
    };
    $in_dblog = 0;
    # Print a warning on failure but don't log the results to the database
    # as that is likely to fail also
    print SERR format_message(scriptname(), $WARNING, $@) if $@;
    return 0 if $@;
    return 1;
}
{
  local $^W = 0;
  *dblog = \&dblog_real;
}

#
# tblog_find_error([session],[store]): attempts to find the relevant error.  
# 
# Parameters:
#   session: Session id to use. Defaults to the current as given by 
#       $ENV{TVLOG_SESSION}.
#   store: If set store the results into the database and act in
#       a way that is safe to use in an END block, that is 
#       (1) never die, (2) don't modify the exit code,  Will also
#       print the results to and some additional info to STDERR
#       for diagnosis purposed.  If not set simply print the results to
#       STDERR.  Defaults to true unless the "session" parameter is also
#       given, in which case default to false.
#
# To retrieve the results from the database:
#   select ... where session = <Session ID> AND type = 'thecause' form log
# The relevant errors are also flagged using "relevant" flag:
#   select ... where session = <Session ID> AND relevant != 0 form log
#
sub tblog_find_error ( ;$$ ) {

    my ($session,$store) = @_;
    my $saved_exitcode = $?;

    local $DBQUERY_MAXTRIES = 3;

    if (not defined $session) {
        check_env();
	$store = 1;
	$session = $ENV{TBLOG_SESSION};
    }

    $store = 0 unless defined $store;

    eval {

	#
	# Build the Tree
	#
	# Tree data structure:
	# invocation = {invocation => INT, parent => INT, 
	#		[{seq => int ...} || {seq => int, child => invox}]}
	
	my $root = {invocation => 0, log => []};
	my %lookup = (0 => $root);
	my @log;
	
	my $query_result = DBQueryFatal "select seq,parent,invocation,sublevel,priority,mesg,cause,script_name,type from log natural join scripts where session = $session and priority <= $NOTICE order by seq";
	
	for (my $i = 0; $i < $query_result->num_rows; $i++) {
	    
	    my ($seq, $parent, $invocation, $sublevel, $priority, $mesg, $cause, $script, $type) 
		= $query_result->fetchrow;
	    
	    if (not exists $lookup{$invocation}) {
		
		my $p = $lookup{$parent};
		die "Parent Doesn't Exists!" unless defined $p;
		$lookup{$invocation} = {invocation => $invocation, 
					parent => $parent, 
					script=>$script, 
					log => []};
		push @{$p->{log}}, {seq => $invocation, 
				    child => $lookup{$invocation}};
		
	    }
	    
	    push @{$lookup{$invocation}{log}}, {seq => $seq, 
						invocation=>$invocation, 
						sublevel=> $sublevel,
						priority => $priority,
						type => $type,
						cause => $cause,
						mesg => $mesg};
	    
	}

	my $handle_sublevels;
	$handle_sublevels = sub {

	    my ($tree) = @_;

	    my $log = $tree->{log};
	    return unless defined $log;

	    # normalize sublevels
	    my $min_sublevel = 200;
	    foreach (@$log) {
		$min_sublevel = $_->{sublevel} 
		    if exists $_->{sublevel} && $_->{sublevel} < $min_sublevel;
	    }

	    for (my $i = 0; $i < @$log; $i++) {

		local $_ = $log->[$i];

		if (exists $_->{sublevel} && $_->{sublevel} > $min_sublevel) {

		    my @sublog = ($_);
		    my $j = $i + 1;
		    while ($j < @$log && 
			   exists $log->[$j]->{sublevel} &&
			   $log->[$j]->{sublevel} > $min_sublevel) {
			push @sublog, $log->[$j];
			$j++;
		    }
		    my $repl = {
			child => {log => [@sublog]}
		    };
		    splice(@$log, $i, $j - $i, $repl);
		    $handle_sublevels->($repl->{child})

		} elsif (exists $_->{child}) {

		    $handle_sublevels->($_->{child});

		}
	    }

	};

	$handle_sublevels->($root);


	#
	# Now find the relevant errors.
	#
	
	my $find_relevant;
	$find_relevant = sub {

	    my ($tree) = @_;

	    my @posib_errs;
	    my @extra_info;

	    foreach (reverse @{$tree->{log}}) {

		if (exists $_->{child}) {
		    
		    my @errs = $find_relevant->($_->{child});
		    if (@errs) {
			return (reverse(@extra_info),@errs);
		    } 
		    
		} elsif ($_->{priority} <= $ERR) {
		    
		    push @posib_errs, $_;

		    if ($_->{type} eq 'summary') {
			last;
		    } elsif ($_->{type} eq 'extra') {
			push @extra_info, $_;
		    }
		    
		}
		
	    }

	    return reverse @posib_errs;
	};

	my @relevant = $find_relevant->($root);
	
	#
	# Get the most relevent script
	#
	my $script = '';
	if (@relevant) {
	    $script = $lookup{$relevant[0]->{invocation}}->{script};
	}

	#
	# From script determine confidence 
	#
	my $confidence = 0.5;
	if ($script =~ /^(assign|parse)/) {
	    $confidence = 0.9;
	} elsif ($script =~ /^(os_setup)/) {
	    $confidence = 0.2;
	}

	#
	# Figure out the cause;
	#
	my $cause = '';
	my $type = '';

	# Assumes that 'extra' info will come first
	
	foreach (@relevant) {
	    if (!$cause && $_->{cause}) {
		$cause = $_->{cause};
		$type = $_->{type};
	    } elsif ($_->{cause} && 
		     $_->{type} eq $type && $_->{cause} ne $cause) {
		$cause = 'unknown';
	    }
	}
	$cause = 'unknown' unless $cause;

	# 
	# Finally print/store the relevant errors
	#
	
	my $error = '';
	
	my $prev;
	foreach (@relevant) {
	    # avoid printing the exact same error twice
	    next if (defined $prev && $prev->{mesg} eq $_->{mesg});

	    $error .= "\n" if defined $prev;

	    if ($_->{mesg} !~ /\n/) {
		$error .= wrap('  ','  ',
			       "$_->{mesg} ($lookup{$_->{invocation}}->{script})\n");
	    } else {
		# if multiline don't reformat
		foreach (split /\s*\n/, $_->{mesg}) {
		    $error .= "  $_\n";
		}
		$error .= "  ($lookup{$_->{invocation}}->{script})\n";
	    }
	    $prev = $_;
	}
	$error = "No clue as to what went wrong!\n" unless length $error > 0;
	
	if ($store) {
	    print SERR "**** Experimental information, please ignore ****\n";
	    print SERR "Session ID = $ENV{TBLOG_SESSION}\n";
	    print SERR "Likely Cause of the Problem:\n";
	    print SERR $error;
	    print SERR "Cause: $cause\n";
	    print SERR "Confidence: $confidence\n";
	    print SERR "**** End experimental information ****\n";
	    chop $error;
	    dblog $NOTICE, {type=>'thecause'}, $error;
	    DBQueryFatal(sprintf("update log set relevant=1 where seq in (%s)",
				 join(',', map {$_->{seq}} @relevant))) if @relevant;
	} else {
	    print SERR $error;
	}
    };

    if ($@) {
	my $err = $@;
	eval {SENDMAIL(TB_OPSEMAIL, "tblog_find_error failed",
		       "Experiment: $ENV{TBLOG_PIDX}\n".
		       "User: $ENV{TBLOG_UID}\n".
		       "Session: $ENV{TBLOG_SESSION}\n".
		       "Script: $ENV{TBLOG_SCRIPTNAME}\n".
		       "\n".
		       "$err\n")};
	if ($store) {
	    eval {tblog $WARNING, {type=>'thecause'}, 
		    "tblog_find_error failed: $err" };
	} else {
	    $? = $saved_exitcode;
	    die;
	}
    }
    $? = $saved_exitcode;
}

#
# Perl Tie Methods, see perltie(1)
#

sub TIEHANDLE {
    my ($classname, $glob) = @_;
    bless \$glob, $classname;
}

sub PRINT {
    my $this = shift;
    print {$$this} @_;
    local $_ = join '', @_; # NOTE: This doesn't take into account "$,"
                            # or output_field_separator
    s/\n$//;
    if (/warning:/i) {
      dblog $WARNING, {inferred=>2}, $_;
    } elsif (/\*\*\*/) {
      dblog $ERR, {inferred=>2}, $_;
    } else {
      dblog $INFO, {inferred=>3}, $_;
    }
}

sub PRINTF {
    my ($this,$format) = (shift, shift);
    &PRINT($this, sprintf($format, @_));
}

#
# tblog_start_capture(): Capture all output to STDOUT and STDERR and turn
#   them into log messages.  Use SOUT and SERR to print to the real
#   STDOUT and STDERR respectfully.  Does NOT capture output of
#   subprocesses.  Will also install handlers for "die" and "warn";
#
# Implementation node: tie is used to catch prints to STDOUT and
#  STDERR as that seams to be the only sane way to do it.  "print" is
#  a special function in perl and can not be overridden normally.
#  Using "*print = &myprint" or even "*IO::Handle::print = &myprint"
#  will only catch the calls to print without a file handle.  Although
#  it may be possible to catch the other type of call to print I don't
#  know how.
#
sub tblog_start_capture( ;@ ) {
    my (@what) = @_;
    @what = qw(stdout stderr die warn) unless @what;
    foreach (@what) {
	if ($_ eq 'stdout') {
	    tie *STDOUT, 'libtblog', \*SOUT;
	} elsif ($_ eq 'stderr') {
	    tie *STDERR, 'libtblog', \*SERR;
	} elsif ($_ eq 'die') {
	    # Should not need to worry about parser errors since the
	    # handlers will be set only after parsing is done
	    $SIG{__DIE__} = sub {
		return if $^S; # In Eval Block
		tblog_stop_capture();
		local $_ = $_[0];
		s/\n$//;
		dblog($ERR, {inferred=>1, cause=>'internal'}, $_);
		die format_message(scriptname(), $ERR, $_);
	    };
	} elsif ($_ eq 'warn') {
	    # Should not need to worry about parser errors since the
	    # handlers will be set only after parsing is done
	    $SIG{__WARN__} = sub {
		local $_ = $_[0];
		s/\n$//;
		dblog($WARNING, {inferred=>1, cause=>'internal'}, $_);
		print SERR "$_\n";
	    };
	} else {
	    carp "Unknown flag in tblog_start_capture: $_";
	}
    }
}

#
# tblog_stop_capture(): stop capture of STDOUT and STDERR, and remove 
# handles for die and warn
#
sub tblog_stop_capture( ;@ ) {
    my (@what) = @_;
    @what = qw(stdout stderr die warn) unless @what;
    foreach (@what) {
	if    ($_ eq 'stdout') {untie *STDOUT}
	elsif ($_ eq 'stderr') {untie *STDERR}
	elsif ($_ eq 'die')    {$SIG{__DIE__}  = ''}  
	elsif ($_ eq 'warn')   {$SIG{__WARN__} = ''}
	else 
	  {carp "Unknown flag in tblog_stop_capture: $_"}
    }
}

#
# BEGIN
#

tblog_init();
tblog_start_capture();

#
# END
#

END {
    # Save, since shell commands will alter it.
    my $exitstatus = $?;

    tblog_exit();

    $? = $exitstatus;
}

1;
