#!/usr/bin/perl -wT

#
# EMULAB-COPYRIGHT
# Copyright (c) 2000-2003 University of Utah and the Flux Group.
# All rights reserved.
#

use English;
use Getopt::Std;

#
# Mark nodes for update. At the moment all kinds of things will get
# updated (mounts, accounts, tarballs, rpms). At some point these
# should be split up.
#
# XXX There is an inherent race condition with using this script. What if
# nodes are released while it is running?
#
sub usage()
{
    print STDOUT "Usage: node_update [-b] pid eid [node ...]\n".
	"Update user accounts and NFS mounts on nodes in your project.\n".
	"Use -b to use batch operation (place in background, send email).\n";
    exit(-1);
}
my  $optlist = "b";

#
# Exit codes are important; they tell the web page what has happened so
# it can say something useful to the user. Fatal errors are mostly done
# with die(), but expected errors use this routine. At some point we will
# use the DB to communicate the actual error.
#
# $status < 0 - Fatal error. Something went wrong we did not expect.
# $status = 0 - Proceeding in the background. Notified later.
# $status > 0 - Expected error. User not allowed for some reason. 
#

#
# Configure variables
#
my $TB		= "@prefix@";
my $TESTMODE    = @TESTMODE@;
my $TBOPS       = "@TBOPSEMAIL@";
my $TBLOGS      = "@TBLOGSEMAIL@";

my $expsetup    = "$TB/sbin/exports_setup";
my $batchmode   = 0;
my @nodes       = ();
my $user_name;
my $user_email;
my $logname;
my $failed	= 0;
my $dbuid;
my $estate;

#
# Load the Testbed support stuff. 
#
use lib "@prefix@/lib";
use libdb;
use libtestbed;

# un-taint path
$ENV{'PATH'} = '/bin:/usr/bin:/usr/local/bin';
delete @ENV{'IFS', 'CDPATH', 'ENV', 'BASH_ENV'};

# Turn off line buffering on output
$| = 1; 

#
# Parse command arguments. Once we return from getopts, all that should be
# left are the required arguments.
#
%options = ();
if (! getopts($optlist, \%options)) {
    usage();
}
if (defined($options{"b"})) {
    $batchmode = 1;
}
if (@ARGV < 2) {
    usage();
}
my $pid   = shift(@ARGV);
my $eid   = shift(@ARGV);

#
# Untaint the arguments.
#
if ($pid =~ /^([-\@\w]+)$/) {
    $pid = $1;
}
else {
    die("*** Bad data in pid: $pid\n");
}	
if ($eid =~ /^([-\@\w]+)$/) {
    $eid = $1;
}
else {
    die("*** Bad data in eid: $eid\n");
}

#
# If more args, they are node names.
#
if (@ARGV) {
    # Untaint the nodes.
    foreach my $node ( @ARGV ) {
	if ($node =~ /^([-\w]+)$/) {
	    $node = $1;
	}
	else {
	    die("*** Bad node name: $node.");
	}

	push(@nodes, $node);
    }
}

#
# Verify actual user and get his DB uid.
#
if (! UNIX2DBUID($UID, \$dbuid)) {
    die("*** $0:\n".
	"    You do not exist in the Emulab Database.\n");
}

if (! UserDBInfo($dbuid, \$user_name, \$user_email)) {
    die("*** $0:\n".
        "    Cannot determine your name and email address.\n");
}

#
# Verify that this person is allowed to do this.
#
if (!TBAdmin() &&
    ! TBExptAccessCheck($UID, $pid, $eid, TB_EXPT_UPDATE)) {
    die("*** $0:\n".
	"    You not have permission to update nodes in $pid/$eid!\n");
}

#
# Check state. Only ACTIVE experiments. 
#
$estate = ExpState($pid, $eid);
if ($estate ne EXPTSTATE_ACTIVE) {
    print STDERR "Experiment $pid/$eid is not ACTIVE!\n";
    # For web page.
    exit(1);
}

#
# Get the list of nodes that need to be "updated." We already have the
# exerpiment locked, so if we have a problem, must unlock it.
#
if (! scalar(@nodes)) {
    @nodes = ExpNodes($pid, $eid);
}
else {
    #
    # Must verify that user supplied node names are really in the
    # experiment.
    #
    my @allnodes = ExpNodes($pid, $eid);

    foreach my $n1 (@nodes) {
	if (! grep {$_ eq $n1} @allnodes) {
	    die("*** $0:\n".
		"    Node $n1 is not allocated to $pid/$eid!\n");
	}
    }
}
if (! scalar(@nodes)) {
    print STDERR "There are no nodes allocated to experiment $pid/$eid\n";
    # For web page.
    exit(1);
}

#
# Batchmode (as from the web interface) goes to background and reports
# later via email.
# 
if ($batchmode) {
    #
    # Create a temporary name for a log file.
    #
    $logname = `mktemp /tmp/node_update-$pid-$eid.XXXXXX`;
    chop($logname);
    
    if (TBBackGround($logname)) {
	#
	# Parent exits normally
	#
	print STDOUT
	    "Node Update for $pid/$eid is now in progress.\n".
	    "You will be notified via email when the is complete.\n";
	exit(0);
    }
}

#
# Currently, we just need to update the mount points.
#
if (system("$expsetup")) {
    fatal("Exports Setup Failed");
}
# Give ops a chance to react.
sleep(2);

#
# Mark the nodes for auto update. Nodes may not respect this field
# (old local images), but its harmless. 
#
foreach my $node ( @nodes ) {
    if (! DBQueryWarn("update nodes set ".
		      "update_accounts=GREATEST(update_accounts,1) ".
		      "where node_id='$node'")) {
	fatal("DB Error!");
    }
}

print STDOUT "Waiting a while for nodes to auto update ...\n";
for (my $i = 0; $i < 10; $i++) {
    sleep(30);

    my $firstnode = pop(@nodes);
    my $querystr  = "node_id='$firstnode' ";

    while (@nodes) {
	my $node = pop(@nodes);

	$querystr .= "or node_id='$node' ";
    }
	
    my $query_result =
	DBQueryFatal("select node_id,update_accounts from nodes ".
		     "where ($querystr)");

    while (my ($node,$notdone) = $query_result->fetchrow_array) {
	if ($notdone) {
	    push(@nodes, $node);
	}
	else {
	    print STDOUT "$node updated.\n";
	}
    }
    last
	if (! @nodes);
    print STDOUT "Still waiting for nodes to auto update ...\n";
}
foreach my $node ( @nodes ) {
    print STDOUT "Node update failed on $node.\n";
    $failed++;
}

TBUnLockExp($pid, $eid, BATCHSTATE_RUNNING);
NotifyUser("Node Update Complete", $failed);
if (defined($logname)) {
    unlink($logname);
}
exit($failed);

sub NotifyUser($$)
{
    my($mesg, $iserr) = @_;
    my($subject, $from, $to, $hdrs);

    print STDOUT "$mesg\n";

    if (! $batchmode) {
	return;
    }

    if ($iserr) {
	$subject = "Node Update Failed $pid/$eid";
    }
    else {
	$subject = "Node Update Success $pid/$eid";
    }
    $from  = $TBOPS;
    $hdrs  = "Reply-To: $TBOPS";
    
    #
    # Message goes to user. If a failure, TBOPS also gets it, otherwise
    # it goes into the logs.
    #
    $to    = "$user_name <$user_email>";    
    
    if ($iserr) {
	$hdrs = "Cc: $TBOPS\n".
	        "$hdrs";
    }
    else {
	$hdrs = "Bcc: $TBLOGS\n".
	        "$hdrs";
    }

    #
    # Send a message to the testbed list. Append the logfile.
    #
    SENDMAIL($to, $subject, $mesg, $from, $hdrs, ($logname));
}

sub fatal($) {
    my($mesg) = @_;

    TBUnLockExp($pid, $eid, BATCHSTATE_RUNNING());
    NotifyUser($mesg, 1);
    if (defined($logname)) {
	unlink($logname);
    }
    exit(1);
}

