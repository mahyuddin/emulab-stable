#!/usr/local/bin/perl -w

### Really run with -T
###
### mkacct - Makes accounts for all users in this experiment's project.
### Adds accounts to currently booted OS only.
###

use Mysql;

my $d = 0;			#debug flag
if ($#ARGV < 0) { 
    die("Usage: mkacct <eid>\n".
	"Makes accounts for all users in an experiment's project.\n");
}
my $eid = $ARGV[0];
if ( !($eid =~ /^[A-Za-z0-9\.\-\_ ]+$/) ) { 
    die("Invalid eid '$eid' contains illegal characters.\n"); 
}

##
## Check for valid user
##
print "Checking for valid user.\n";
open(WHO,"/usr/bin/whoami 2>&1 |");
chop($_ = <WHO>);
close(WHO);
if ($_ ne "root") { die("This won't work unless you're root.\n"); }

##
## Open database
##
my $dbh = Mysql->connect("localhost","tbdb","script","none");

##
## Check that we have a valid EID. If the EID
## doesn't exist, it's invalid.
##
print "Checking that $eid is a valid EID\n";
my $cmd = "select eid from experiments where eid='$eid'";
my $sth = $dbh->query($cmd);
my $rows =0;
## Must put in check that $sth defined. May be undefined if
## command above is syntactically incorrect.
while ($sth->fetchrow_array) {
    $rows += 1;
}
if ( $rows != 1 ) { die("Invalid eid '$eid' (not in database).\n"); }


##
## Select user parameters for users in given experiment.
## Join: exp.pid -> p.pid
##
print "Selecting users.\n";
$cmd = 
  "select u.uid,u.usr_pswd,u.unix_uid,u.usr_name ".
  "from experiments as e ".
  "left join projects as p on e.pid = p.pid ".
  "left join proj_memb as pm on p.pid = pm.pid ".
  "left join users as u on u.uid = pm.uid ".
  "where e.eid = '$eid'";
$sth = $dbh->query($cmd);
my %passwd = ();
my %unix_uid = ();
my %fullname = ();
while (@row = $sth->fetchrow_array) {
    $passwd{$row[0]} = $row[1];
    $unix_uid{$row[0]} = $row[2];
    $fullname{$row[0]} = $row[3];
}

##
## Select group ID for experiment.
##
print "Selecting group ID for experiment.\n";
$cmd = 
  "select unix_gid from groups as g ".
  "left join proj_grps as pg on g.gid = pg.gid ".
  "left join projects as p on pg.pid = p.pid ".
  "left join experiments as e on e.pid = p.pid ".
  "where e.eid = '$eid'";
$sth = $dbh->query($cmd);
my $unix_gid = 65533;		# "nogroup"...
if (@row = $sth->fetchrow_array) {
    $unix_gid = $row[0];
}

##
## Select machines.
##
print "Selecting machines.\n";
$cmd = 
  "select IP from interfaces as ip ".
  "left join reserved as r on r.node_id=ip.node_id ".
  "left join experiments as e on r.eid = e.eid ".
  "where e.eid = '$eid'";
$sth = $dbh->query($cmd);
my @nodes = ();
while (@row = $sth->fetchrow_array) {
    push(@nodes,$row[0]);
}

##
## For each machine, ping to see if its alive.
## If alive, determine if its FreeBSD or Linux and
## create the user accounts. 
##

my $last = "";
my $OS = "";
my $IP = "";
foreach $IP (@nodes) {
    ## If this machine is not the same as the last one, get the OS
    ## Check also that the IP address is valid (some interfaces might
    ## not have an IP address. Do we really have to check that the node
    ## is not the same node as in last iteration? -lkw
    if ( $IP ne $last && $IP =~ /[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+/) {
        $last = $IP;
        if (-e "/bin/ping") {
            open(PING,"/bin/ping -c 1 $IP 2>&1 |");
        } else {
            open(PING,"/sbin/ping -c 1 $IP 2>&1 |");
        }
        do { } until ( <PING> =~ /transmitted, (\d+) packets received/ );
	close(PING); 

        if ( $1 > 0 ) {
            open(UNAME,"su1 ssh $IP uname -a 2>&1 |");
            $_ = <UNAME>;
	    close(UNAME);
	    ## FreeBSD says "155.99.214.129: Connection refused"
	    ##    and can also say "Host key doesn't match..."  
            if ( ($_=~/^Sorry/) || ($_=~/^$IP/) || ($_=~/^Host key/) ) { 
		die("Uname failed on $IP:$_\n"); 
	    } else { 
		@temp = split(" ",$_); 
		$OS = $temp[0]; 
	    }
        } else {
	    print "Couldn't ping machine $IP\n";
	}

        print "OS for $IP is $OS\n" if $d;
        if ($OS eq "Linux") {  
	    
	    ## 1) Use groupadd to add group
	    ## 2) Use useradd to add users
	    ##
	    ## Rather than use useradd's defaults (which are normally)
	    ## fine, we're explicit.

	    print "Creating group $unix_gid on $IP.\n";
	    open(GROUPADD, "ssh $IP /usr/sbin/groupadd -g $unix_gid $eid 2>&1 |");
	    while (<GROUPADD>) { print "$_"; }
	    close(GROUPADD); 
	    my $i = 1;
	    foreach my $user (keys %passwd) {

		print "Creating user $ser on $IP.\n";
		open(USERADD, "ssh $IP /usr/sbin/useradd -c \"$fullname{$user}\" -d /home/$user -g $unix_gid -m -p $passwd{$user} -s /bin/tcsh -u $unix_uid{$user}  $user 2>&1 |");
		while (<USERADD>) { print "$_"; }
		close(USERADD);
	    }

	} elsif ($OS eq "FreeBSD") { 

	    ## 1) Append new account info to master.passwd
	    ## 2) Create secure (spwd.db) and insecure (pwd.db) password 
	    ##    databases and
	    ## 3) Create passwd entries
	    ## 4) Create home directories

	    my $addon = "";
	    foreach my $name (keys %passwd) {
		$addon = "$addon$user:$passwd{$user}:$unix_uid{$user}:$unix_gid:$fullname{$user}:/home/$user:/bin/tcsh\n";

		print $addon;
	    }

	    open(SCP, "scp -p $IP:/etc/master.passwd /tmp/master.passwd.$IP");
	    open(OUT, ">>/etc/master.passwd");
	    print OUT $addon;
	    close(OUT);
	    open(SCP, "scp -p /tmp/master.passwd.$IP $IP:/etc/master.passwd");
	    close(SCP); # this closes above SCP
 
	    ## Create secure and insecure databases (/etc/[s]*pwd.db)
#	    open (MKDB, "ssh $IP /usr/sbin/pwd_mkdb /etc/master.passwd 2>&1 |");
	    ## Update /etc/passwd (this closes above MKDB)
#	    open (MKDB, "ssh $IP /usr/sbin/pwd_mkdb -p /etc/master.passwd 2>&1 |");
#	    close(MKDB); 

#/usr/sbin/pwd_mkdb: corrupted entry
#/usr/sbin/pwd_mkdb: at line #14
#/usr/sbin/pwd_mkdb: /etc/master.passwd: Inappropriate file type or format
		
	} else {  
	    print "$IP is unreachable or has an unknown OS ($OS).\n";
	}
    }
}











