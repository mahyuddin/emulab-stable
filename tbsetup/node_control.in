#!/usr/bin/perl -wT
use English;
use Getopt::Std;

#
# usage: node_control [options] node [node ...]
#        node_control [options] -e pid,eid
#
# XXX def_boot_osid and virt_nodes osname are not handled properly. 
#
sub usage()
{
    print("Usage: node_control name=value [name=value ...] node [node ...]\n".
	  "       node_control -e pid,eid name=value [name=value ...]\n".
	  "       node_control -l\n".
	  "For multiword values, use name='word0 ... wordN'\n".
	  "Use -l to get a list of operational parameters you can change.\n".
	  "Use -e to change parameters of all nodes in an experiment.\n");
    exit(-1);
}
my  $optlist = "de:l";

#
# Array of allowed names. All of these values are text, so no need to
# worry about distinguishing numeric stuff.
#
# XXX This should be in the library.
#
my %controlset =
(
 #
 #  Symbolic name   =>  Admin, Multi args, nodes DB field, virt_nodes DB field
 #
 default_boot_osid	=> [0, 0, "def_boot_osid",	undef],
 default_boot_path	=> [0, 0, "def_boot_path",	undef],
 default_boot_cmdline	=> [0, 0, "def_boot_cmd_line",  "cmd_line"],
 startup_command	=> [0, 0, "startupcmd",		"startupcmd"],
 tarfiles		=> [0, 1, "tarballs",		"tarfiles"],
 rpms			=> [0, 1, "rpms",		"rpms"],
 deltas			=> [0, 1, "deltas",		"deltas"],
 next_boot_osid		=> [1, 0, "next_boot_osid",	undef],
 next_boot_path		=> [1, 0, "next_boot_path",	undef],
 next_boot_cmdline	=> [1, 0, "next_boot_cmd_line",	undef],
 pxe_boot_path          => [1, 0, "pxe_boot_path",	undef],
 next_pxe_boot_path     => [1, 0, "next_pxe_boot_path",	undef],
 bios_version		=> [1, 0, "bios_version",	undef],
);
  
#
# Configure variables
#
my $TB		= "@prefix@";
my $TBOPS       = "@TBOPSEMAIL@";
my $TBLOGS      = "@TBLOGSEMAIL@";

my $ssh		= "$TB/bin/sshtb -n";
my @nodes       = ();
my %controls    = ();
my $eidmode	= 0;
my $debug       = 0;
my $errors	= 0;
my $pid;
my $eid;
my $dbuid;

#
# Load the Testbed support stuff. 
#
use lib "@prefix@/lib";
use libdb;
use libtestbed;

my $IsAdmin    = TBAdmin($UID);

# un-taint path
$ENV{'PATH'} = '/bin:/usr/bin:/usr/local/bin';
delete @ENV{'IFS', 'CDPATH', 'ENV', 'BASH_ENV'};

# Turn off line buffering on output
$| = 1; 

#
# Parse command arguments. Once we return from getopts, all that should be
# left are the required arguments.
#
%options = ();
if (! getopts($optlist, \%options)) {
    usage();
}
if (defined($options{"d"})) {
    $debug = 1;
}
if (defined($options{"l"})) {
    foreach my $option (keys(%controlset)) {
	my ($admin, $multi, $dbkey) = @{ $controlset{$option} };
	
	printf("  %-25s ", $option);
	if ($multi || $admin) {
	    print "- ";
	}
	if ($multi) {
	    print "(multiple options allowed) ";
	}
	if ($admin) {
	    print "(administrators only)";
	}
	print "\n";
    }
    exit(0);
}

if (defined($options{"e"})) {
    $eidmode = $options{"e"};
    if ($eidmode =~ /([-\w]*),([-\w]*)/) {
	$pid = $1;
	$eid = $2;
    }
    else {
	usage();
    }
}

if (! @ARGV) {
    usage();
}

#
# Shift off the set strings (name=value). Verify that each one is in the
# proper format.
#
while (@ARGV) {
    my $string = $ARGV[0];

    if (! ($string =~ /([-\w]*)=[\']?([^\']*)[\']?/)) {
	last;
    }
    shift;

    if (! defined($controlset{$1})) {
	die("*** $0:\n".
	    "    Illegal control setting: $1='$2'. Try the -l option!\n");
    }
    my ($admin, $multi, $dbkey) = @{ $controlset{$1} };

    if ($admin && ! $IsAdmin) {
	die("*** $0:\n".
	    "    You do not have permission to set $1. Try the -l option!\n");
    }

    if ($multi && defined($controls{$1})) {
	$controls{$1} = "$controls{$1}:$2";
    }
    else {
	$controls{$1} = "$2";
    }
}

if ($debug) {
    foreach my $option (keys(%controls)) {
	print "Will set $option to '$controls{$option}'\n";
    }
}

#
# In eidmode, check the access permission for the experiment, and then
# get the nodes. Otherwise, check access for each node given on the
# command line.
#
if ($eidmode) {
    # Permission check.
    if ($UID && !TBAdmin($UID) &&
	! TBExptAccessCheck($UID, $pid, $eid, TB_EXPT_MODIFY)) {
	die("*** $0:\n".
	    "    You do not have permission to control nodes in $pid/$eid!\n");
    }

    if (! (@nodes = ExpNodes($pid, $eid))) {
	die("*** $0:\n".
	    "    There are no nodes in $pid/$eid!\n");
    }
}
else {
    if (! @ARGV) {
	usage();
    }
    
    # Untaint the nodes.
    foreach my $node ( @ARGV ) {
	if ($node =~ /^([-\@\w]+)$/) {
	    $node = $1;
	}
	else {
	    die("Bad node name: $node.");
	}
    
	push(@nodes, $node);
    }
}

#
# Create an update clause for all of the specified values.
#
my $physnodes_updatestr;
my $virtnodes_updatestr;

foreach my $option (keys(%controls)) {
    my ($admin, $multi, $physdbkey, $virtdbkey) = @{ $controlset{$option} };
    my $value = $controls{$option};

    if (defined($physnodes_updatestr)) {
	$physnodes_updatestr = "$physnodes_updatestr, $physdbkey='$value'";
    }
    else {
	$physnodes_updatestr = "$physdbkey='$value'";
    }

    if (defined($virtdbkey)) {
	if (defined($virtnodes_updatestr)) {
	    $virtnodes_updatestr = "$virtnodes_updatestr, $virtdbkey='$value'";
	}
	else {
	    $virtnodes_updatestr = "$virtdbkey='$value'";
	}
    }
}
if (! defined($physnodes_updatestr) && ! defined($virtnodes_updatestr)) {
    exit(0);
}

if ($debug) {
    if (defined($physnodes_updatestr)) {
	print "Phys update will be '$physnodes_updatestr'\n";
    }
    if (defined($virtnodes_updatestr)) {
	print "Virt update will be '$virtnodes_updatestr'\n";
    }
}

#
# Now do it for every node. Do the permission check here to reduce the
# race condition window. Should probably lock instead, but thats a pain.
#
foreach my $node (@nodes) {
    my $node_pid;
    my $node_eid;
    my $node_vname;

    #
    # We need the vname for the node so that we can update the virt_nodes
    # table. This implies that we cannot update the virt_nodes unless the
    # experiment is swapped in (so we can map from phys node name to virt
    # node name). At some point, maybe we want to provide a way to change
    # the params of a swapped out experiment by having the user specify
    # the vname?
    #
    if (! NodeidToExp($node, \$node_pid, \$node_eid, \$node_vname)) {
	print("*** $0:\n".
	      "    Node $node is not a member of a swapped in experiment!\n");
	$errors++;
	next;
    }
    
    if (defined($physnodes_updatestr)) {
	if ($UID && !$IsAdmin &&
	    ! TBNodeAccessCheck($UID, TB_NODEACCESS_MODIFYINFO, $node)) {
	    print("*** $0:\n".
		  "    You do not have permission to modify physical ".
		  "parameters for $node!\n");
	    
	    $errors++;
	    next;
	}
	DBQueryFatal("update nodes set $physnodes_updatestr ".
		     "where node_id='$node'");
    }

    if (defined($node_vname) && defined($virtnodes_updatestr)) {
	if ($UID && !$IsAdmin &&
	    ! TBExptAccessCheck($UID, $node_pid, $node_eid, TB_EXPT_MODIFY)) {
	    print("*** $0:\n".
		  "    You do not have permission to modify virtual ".
		  "parameters for $node!\n");
	    
	    $errors++;
	    next;
	}
	DBQueryFatal("update virt_nodes set $virtnodes_updatestr ".
		     "where pid='$node_pid' and eid='$node_eid' ".
		     " and vname='$node_vname'");
    }
}

exit($errors);
