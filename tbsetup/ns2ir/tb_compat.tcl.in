# -*- tcl -*-
#
# EMULAB-COPYRIGHT
# Copyright (c) 2000-2003 University of Utah and the Flux Group.
# All rights reserved.
#

# This is the tb_compact.tcl that deals with all the TB specific commands.
# It should be loaded at the beginning of any ns script using the TB commands.

# We set up some helper stuff in a separate namespace to avoid any conflicts.
namespace eval TBCOMPAT {
    var_import ::GLOBALS::DB
    var_import ::GLOBALS::pid
    var_import ::GLOBALS::eid

    # This is regular expression that matches slightly more than valid
    # IP addresses.  The only thing it doesn't check is that IP 
    # addresses are in range (i.e. 0-255).
    variable IP {^([0-9]{1,3}\.){3,3}[0-9]{1,3}$}

    # This is an RE to match a floating point number.
    variable FLOAT {(^[0-9]+(\.[0-9]+)?$)|(^\.[0-9]+$)}

    # This is the default weight for a soft vtype.
    variable default_soft_vtype_weight 0.5

    # This is the default weight for a hard vtype.
    variable default_hard_vtype_weight 1.0

    # This is a general procedure that takes a node, an object (lan or link)
    # it is connected to, and an IP address, and sets the IP address
    # for the node on that object.  It checks both the validity of the
    # IP addresses and the fact that the node is actually a member of the
    # lan/link.
    proc set-ip {node obj ip} {
	variable IP
	set caller [lindex [info level -1] 0]
	if {[regexp $IP $ip] == 0} {
	    perror "$caller - $ip is not a valid IP address."
	    return
	}
	set port [$node find_port $obj]
	if {$port == -1} {
	    perror "$caller - $node is not connected to $obj."
	    return
	}
	$node ip $port $ip
    }

    # Let's set up a hwtypes table that contains all valid hardware types.
    variable hwtypes
    variable isremote
    variable isvirt

    # NSE hack: sim type is not in DB. Just adding it now
    set hwtypes(sim) 1
    set isremote(sim) 0
    set isvirt(sim) 0

    # The permissions table. Entries in this table indicate who is allowed
    # to use nodes of a particular type. No entries means anyone can use it.
    #
    # We omit this check in anonymous mode.
    #
    variable nodetypeXpid_permissions
    
    # And a os table with valid OS Descriptor names. While we still call
    # them "osids", we are using the user level name not the internal,
    # globally unique name. We leave it to a later phase to deal with it.
    #
    # We omit this check in anonymous mode.
    #
    variable osids

    # The default OSID for the node type. 
    variable default_osids

    # A mapping of event objects and types.
    variable objtypes
    variable eventtypes

    # Existing (reserved nodes).
    variable reserved_list
    variable reserved_type
    variable reserved_node
    set reserved_list {}
}

# IP addresses routines.  These all do some checks and convert into set-ip
# calls.
proc tb-set-ip {node ip} {
    $node instvar portlist
    if {[llength $portlist] != 1} {
	perror "\[tb-set-ip] $node does not have a single connection."
	return
    }
    ::TBCOMPAT::set-ip $node [lindex $portlist 0] $ip
}
proc tb-set-ip-interface {src dst ip} {
    set sim [$src set sim]
    set reallink [$sim find_link $src $dst]
    if {$reallink == {}} {
	perror \
	    "\[tb-set-ip-interface] No connection between $src and $dst."
	return
    }
    ::TBCOMPAT::set-ip $src $reallink $ip
}
proc tb-set-ip-lan {src lan ip} {
    if {[$lan info class] != "Lan"} {
	perror "\[tb-set-ip-lan] $lan is not a LAN."
	return
    }
    ::TBCOMPAT::set-ip $src $lan $ip
}
proc tb-set-ip-link {src link ip} {
    if {[$link info class] != "Link"} {
	perror "\[tb-set-ip-link] $link is not a link."
	return
    }
    ::TBCOMPAT::set-ip $src $link $ip
}

# Node state routines.
proc tb-set-hardware {node type args} {
    var_import ::TBCOMPAT::hwtypes
    var_import ::TBCOMPAT::isremote
    var_import ::TBCOMPAT::isvirt
    var_import ::GLOBALS::vtypes
    if {(! [info exists hwtypes($type)]) &&
	(! [info exists vtypes($type)])} {
	perror "\[tb-set-hardware] Invalid hardware type $type."
	return
    }
    if {! ${GLOBALS::anonymous} && ! ${GLOBALS::passmode}} {
	var_import ::TBCOMPAT::nodetypeXpid_permissions
	var_import ::GLOBALS::pid
	set allowed 1
	
	if {[info exists nodetypeXpid_permissions($type)]} {
	    set allowed 0
	    foreach allowedpid $nodetypeXpid_permissions($type) {
		if {$allowedpid == $pid} {
		    set allowed 1
		}
	    }
	}
	if {! $allowed} {
	    perror "\[tb-set-hardware] No permission to use type $type."
	    return
	}
    }
    set remote 0
    if {[info exists isremote($type)]} {
	set remote $isremote($type)
    }
    set isv 0
    if {[info exists isvirt($type)]} {
	set isv $isvirt($type)
    }
    $node set_hwtype $type $remote $isv
}

proc tb-set-node-os {node os} {
    if {! ${GLOBALS::anonymous} && ! ${GLOBALS::passmode}} {
	var_import ::TBCOMPAT::osids
	if {! [info exists osids($os)]} {
	    perror "\[tb-set-node-os] Invalid osid $os."
	    return
	}
    }
    $node set osid $os
}
proc tb-set-node-cmdline {node cmdline} {
    $node set cmdline $cmdline
}
proc tb-set-node-rpms {node args} {
    if {$args == {}} {
	perror "\[tb-set-node-rpms] No rpms given."
	return
    }
    $node set rpms [join $args :]
}
proc tb-set-node-startup {node cmd} {
    $node set startup $cmd
}
proc tb-set-node-tarfiles {node args} {
    if {$args == {}} {
	perror "\[tb-set-node-tarfiles] tb-set-node-tarfiles <node> (<dir> <tar>)+"
	return
    }
    if {[expr [llength $args] % 2] != 0} {
	perror "\[tb-set-node-tarfiles] Arguments should be node and series of pairs."
	return
    }
    set tarfiles {}
    while {$args != {}} {
	lappend tarfiles [join [lrange $args 0 1]]
	set args [lrange $args 2 end]
    }
    $node set tarfiles [join $tarfiles :]
}
proc tb-set-node-deltas {node args} {
    if {$args == {}} {
	perror "\[tb-set-node-deltas] No deltas given."
	return
    }
    $node set deltas [join $args :]
}
proc tb-set-ip-routing {type} {
    var_import ::GLOBALS::default_ip_routing_type

    if {$type == {}} {
	perror "\[tb-set-ip-routing] No type given."
	return
    }
    if {($type != "none") &&
	($type != "ospf")} {
	perror "\[tb-set-ip-routing] Type is not one of none|ospf"
	return
    }
    set default_ip_routing_type $type
}

# Lan/Link state routines.

# This takes two possible formats:
# tb-set-link-loss <link> <loss>
# tb-set-link-loss <src> <dst> <loss>
proc tb-set-link-loss {srclink args} {
    var_import ::TBCOMPAT::FLOAT
    if {[llength $args] == 2} {
	set dst [lindex $args 0]
	set lossrate [lindex $args 1]
	set sim [$srclink set sim]
	set reallink [$sim find_link $srclink $dst]
	if {$reallink == {}} {
	    perror "\[tb-set-link-loss] No link between $srclink and $dst."
	    return
	}
    } else {
	set reallink $srclink
	set lossrate [lindex $args 0]
    }
    if {([regexp $FLOAT $lossrate] == 0) ||
	($lossrate > 1.0)} {
	perror "\[tb-set-link-loss] $lossrate is not a valid loss rate."
    }
    $reallink instvar loss
    $reallink instvar rloss
    set adjloss [expr 1-sqrt(1-$lossrate)]
    foreach pair [array names loss] {
	set loss($pair) $adjloss
	set rloss($pair) $adjloss
    }
}

proc tb-set-lan-loss {lan lossrate} {
    var_import ::TBCOMPAT::FLOAT
    if {[$lan info class] != "Lan"} {
	perror "\[tb-set-lan-loss] $lan is not a lan."
	return
    }
    if {([regexp $FLOAT $lossrate] == 0) ||
	($lossrate > 1.0)} {
	perror "\[tb-set-lan-loss] $lossrate is not a valid loss rate."
    }
    $lan instvar loss
    $lan instvar rloss
    set adjloss [expr 1-sqrt(1-$lossrate)]
    foreach pair [array names loss] {
	set loss($pair) $adjloss
	set rloss($pair) $adjloss
    }
}

proc tb-set-node-lan-delay {node lan delay} {
    if {[$node info class] != "Node"} {
	perror "\[tb-set-node-lan-delay] $node is not a node."
	return
    }
    if {[$lan info class] != "Lan"} {
	perror "\[tb-set-node-lan-delay] $lan is not a lan."
	return
    }
    set port [$lan get_port $node]
    if {$port == {}} {
	perror "\[tb-set-node-lan-delay] $node is not in $lan."
	return
    }
    $lan set delay([list $node $port]) [parse_delay $delay]
    $lan set rdelay([list $node $port]) [parse_delay $delay]
}
proc tb-set-node-lan-bandwidth {node lan bw} {
    if {[$node info class] != "Node"} {
	perror "\[tb-set-node-lan-delay] $node is not a node."
	return
    }
    if {[$lan info class] != "Lan"} {
	perror "\[tb-set-node-lan-delay] $lan is not a lan."
	return
    }
    set port [$lan get_port $node]
    if {$port == {}} {
	perror "\[tb-set-node-lan-delay] $node is not in $lan."
	return
    }
    $lan set bandwidth([list $node $port]) [parse_bw $bw]
    $lan set rbandwidth([list $node $port]) [parse_bw $bw]
}
proc tb-set-node-lan-loss {node lan loss} {
    var_import ::TBCOMPAT::FLOAT
    if {[$node info class] != "Node"} {
	perror "\[tb-set-node-lan-delay] $node is not a node."
	return
    }
    if {[$lan info class] != "Lan"} {
	perror "\[tb-set-node-lan-delay] $lan is not a lan."
	return
    }
    set port [$lan get_port $node]
    if {$port == {}} {
	perror "\[tb-set-node-lan-delay] $node is not in $lan."
	return
    }
    if {([regexp $FLOAT $loss] == 0) ||
	($loss > 1.0)} {
	perror "\[tb-set-link-loss] $loss is not a valid loss rate."
    }
    $lan set loss([list $node $port]) $loss
    $lan set rloss([list $node $port]) $loss
}
proc tb-set-node-lan-params {node lan delay bw loss} {
    tb-set-node-lan-delay $node $lan $delay
    tb-set-node-lan-bandwidth $node $lan $bw
    tb-set-node-lan-loss $node $lan $loss
}

proc tb-set-node-failure-action {node type} {
    if {[$node info class] != "Node"} {
	perror "\[tb-set-node-failure-action] $node is not a node."
	return
    }
    if {[lsearch -exact {fatal nonfatal ignore} $type] == -1} {
	perror "\[tb-set-node-failure-action] type must be one of fatal|nonfatal|ignore."
	return
    }
    $node set failureaction $type
}

proc tb-fix-node {vnode pnode} {
    if {[$vnode info class] != "Node"} {
	perror "\[tb-fix-node] $vnode is not a node."
	return
    }
    $vnode set_fixed $pnode
}

proc tb-make-soft-vtype {name types} {
    var_import ::TBCOMPAT::hwtypes
    var_import ::TBCOMPAT::isremote
    var_import ::GLOBALS::vtypes
    var_import ::TBCOMPAT::default_soft_vtype_weight

    foreach type $types {
	if {! [info exists hwtypes($type)]} {
	    perror "\[tb-make-soft-vtype] Invalid hardware type $type."
	}
	if {$isremote($type)} {
	    perror "\[tb-make-soft-vtype] Remote type $type not allowed."
	}
    }
    set vtypes($name) [Vtype $name $default_soft_vtype_weight $types]
}

proc tb-make-hard-vtype {name types} {
    var_import ::TBCOMPAT::hwtypes
    var_import ::TBCOMPAT::isremote
    var_import ::GLOBALS::vtypes
    var_import ::TBCOMPAT::default_hard_vtype_weight

    foreach type $types {
	if {! [info exists hwtypes($type)]} {
	    perror "\[tb-make-hard-vtype] Invalid hardware type $type."
	}
	if {$isremote($type)} {
	    perror "\[tb-make-hard-vtype] Remote type $type not allowed."
	}
    }
    set vtypes($name) [Vtype $name $default_hard_vtype_weight $types]
}

proc tb-make-weighted-vtype {name weight types} {
    var_import ::TBCOMPAT::hwtypes
    var_import ::TBCOMPAT::isremote
    var_import ::GLOBALS::vtypes
    var_import ::TBCOMPAT::FLOAT

    foreach type $types {
	if {! [info exists hwtypes($type)]} {
	    perror "\[tb-make-weighted-vtype] Invalid hardware type $type."
	}
	if {$isremote($type)} {
	    perror "\[tb-make-weighted-vtype] Remote type $type not allowed."
	}
    }
    if {([regexp $FLOAT $weight] == 0) ||
	($weight <= 0) || ($weight >= 1.0)} {
	perror "\[tb-make-weighted-vtype] $weight is not a valid weight. (0 < weight < 1)."
    }
    set vtypes($name) [Vtype $name $weight $types]
}

proc tb-set-link-simplex-params {link src delay bw loss} {
    var_import ::TBCOMPAT::FLOAT
    if {[$link info class] != "Link"} {
	perror "\[tb-set-link-simplex-params] $link is not a link."
	return
    }
    if {[$src info class] != "Node"} {
	perror "\[tb-set-link-simplex-params] $src is not a link."
	return
    }
    set port [$link get_port $src]
    if {$port == {}} {
	perror "\[tb-set-link-simplex-params] $src is not in $link."
	return
    }
    if {([regexp $FLOAT $loss] == 0) || ($loss > 1.0)} {
	perror "\[tb-set-link-simplex-params] $loss is not a valid loss rate."
	return
    }
    set adjloss [expr 1-sqrt(1-$loss)]
    set np [list $src $port]
    foreach nodeport [$link set nodelist] {
	if {$nodeport != $np} {
	    set onp $nodeport
	}
    }

    set realdelay [parse_delay $delay]
    set realbw [parse_bw $bw]
    $link set delay($np) [expr $realdelay / 2.0]
    $link set rdelay($onp) [expr $realdelay / 2.0]
    $link set bandwidth($np) $realbw
    $link set rbandwidth($onp) $realbw
    $link set loss($np) [expr $adjloss]
    $link set rloss($onp) [expr $adjloss]
}

proc tb-set-lan-simplex-params {lan node todelay tobw toloss fromdelay frombw fromloss} {
    var_import ::TBCOMPAT::FLOAT
    if {[$node info class] != "Node"} {
	perror "\[tb-set-node-lan-delay] $node is not a node."
	return
    }
    if {[$lan info class] != "Lan"} {
	perror "\[tb-set-node-lan-delay] $lan is not a lan."
	return
    }
    set port [$lan get_port $node]
    if {$port == {}} {
	perror "\[tb-set-node-lan-delay] $node is not in $lan."
	return
    }
    if {([regexp $FLOAT $toloss] == 0) || ($toloss > 1.0)} {
	perror "\[tb-set-link-loss] $toloss is not a valid loss rate."
    }
    if {([regexp $FLOAT $fromloss] == 0) || ($fromloss > 1.0)} {
	perror "\[tb-set-link-loss] $fromloss is not a valid loss rate."
    }

    set realtodelay [parse_delay $todelay]
    set realfromdelay [parse_delay $fromdelay]
    set realtobw [parse_bw $tobw]
    set realfrombw [parse_bw $frombw]

    $lan set delay([list $node $port]) $realtodelay
    $lan set rdelay([list $node $port]) $realfromdelay
    $lan set loss([list $node $port]) $toloss
    $lan set rloss([list $node $port]) $fromloss
    $lan set bandwidth([list $node $port]) $realtobw
    $lan set rbandwidth([list $node $port]) $realfrombw
}

proc tb-set-uselatestwadata {onoff} {
    var_import ::GLOBALS::uselatestwadata

    if {$onoff != 0 && $onoff != 1} {
	perror "\[tb-set-uselatestwadata] $onoff must be 0/1"
	return
    }

    set uselatestwadata $onoff
}

proc tb-set-usewatunnels {onoff} {
    var_import ::GLOBALS::usewatunnels

    if {$onoff != 0 && $onoff != 1} {
	perror "\[tb-set-usewatunnels] $onoff must be 0/1"
	return
    }

    set usewatunnels $onoff
}

proc tb-use-endnodeshaping {onoff} {
    var_import ::GLOBALS::uselinkdelays

    if {$onoff != 0 && $onoff != 1} {
	perror "\[tb-use-endnodeshaping] $onoff must be 0/1"
	return
    }

    set uselinkdelays $onoff
}

proc tb-force-endnodeshaping {onoff} {
    var_import ::GLOBALS::forcelinkdelays

    if {$onoff != 0 && $onoff != 1} {
	perror "\[tb-force-endnodeshaping] $onoff must be 0/1"
	return
    }

    set forcelinkdelays $onoff
}

proc tb-set-wasolver-weights {delay bw plr} {
    var_import ::GLOBALS::wa_delay_solverweight
    var_import ::GLOBALS::wa_bw_solverweight
    var_import ::GLOBALS::wa_plr_solverweight

    if {($delay < 0) || ($bw < 0) || ($plr < 0)} {
	perror "\[tb-set-wasolver-weights] Weights must be postive integers."
	return
    }
    if {($delay == {}) || ($bw == {}) || ($plr == {})} {
	perror "\[tb-set-wasolver-weights] Must provide delay, bw, and plr."
	return
    }

    set wa_delay_solverweight $delay
    set wa_bw_solverweight $bw
    set wa_plr_solverweight $plr
}

#
# Control emulated for a link (lans not allowed yet). 
# 
proc tb-set-multiplexed {link onoff} {
    if {[$link info class] != "Link"} {
	perror "\[tb-set-multiplexed] $link is not a link."
	return
    }
    $link set emulated $onoff
}

#
# For emulated links, allow bw shaping to be turned off
# 
proc tb-set-noshaping {link onoff} {
    if {[$link info class] != "Link"} {
	perror "\[tb-set-noshaping] $link is not a link."
	return
    }
    $link set nobwshaping $onoff
}

#
# For emulated links, allow veth device to be used. Not a user option.
# 
proc tb-set-useveth {link onoff} {
    if {[$link info class] != "Link"} {
	perror "\[tb-set-useveth] $link is not a link."
	return
    }
    $link set useveth $onoff
}

#
# Control linkdelays for lans and links
# 
proc tb-set-endnodeshaping {lanlink onoff} {
    if {[$lanlink info class] != "Link" && [$lanlink info class] != "Lan"} {
	perror "\[tb-set-endnodeshaping] $lanlink is not a link or a lan."
	return
    }
    $lanlink set uselinkdelay $onoff
}

#
# Crude control of colocation of virt nodes. Will be flushed when we have
# a real story. Sets it for the entire link or lan. Maybe set it on a
# per node basis?
#
proc tb-set-allowcolocate {lanlink onoff} {
    if {[$lanlink info class] != "Link" && [$lanlink info class] != "Lan"} {
	perror "\[tb-set-allowcolocate] $lanlink is not a link or a lan."
	return
    }
    $lanlink set trivial_ok $onoff
}

#
# Another crude control. Allow override of multiplex factor that is listed
# in the node_types table. 
#
proc tb-set-colocate-factor {factor} {
    var_import ::GLOBALS::multiplex_factor

    if {$factor < 1 || $factor > 100} {
	perror "\[tb-set-colocate-factor] factor must be 1 <= factor <= 100"
	return
    }

    set multiplex_factor $factor
}
