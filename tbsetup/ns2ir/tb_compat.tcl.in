# This is the tb_compact.tcl that deals with all the TB specific commands.
# It should be loaded at the beginning of any ns script using the TB commands.

# We set up some helper stuff in a separate namespace to avoid any conflicts.
namespace eval TBCOMPAT {
    var_import ::GLOBALS::DB
    var_import ::GLOBALS::pid
    var_import ::GLOBALS::eid

    # This is regular expression that matches slightly more than valid
    # IP addresses.  The only thing it doesn't check is that IP 
    # addresses are in range (i.e. 0-255).
    variable IP {^([0-9]{1,3}\.){3,3}[0-9]{1,3}$}

    # This is an RE to match a floating point number.
    variable FLOAT {(^[0-9]+(\.[0-9]+)?$)|(^\.[0-9]+$)}

    # This is the default weight for a soft vtype.
    variable default_soft_vtype_weight 0.5

    # This is the default weight for a hard vtype.
    variable default_hard_vtype_weight 1.0

    # This is a general procedure that takes a node, an object (lan or link)
    # it is connected to, and an IP address, and sets the IP address
    # for the node on that object.  It checks both the validity of the
    # IP addresses and the fact that the node is actually a member of the
    # lan/link.
    proc set-ip {node obj ip} {
	variable IP
	set caller [lindex [info level -1] 0]
	if {[regexp $IP $ip] == 0} {
	    perror "$caller - $ip is not a valid IP address."
	    return
	}
	set port [$node find_port $obj]
	if {$port == -1} {
	    perror "$caller - $node is not connected to $obj."
	    return
	}
	$node ip $port $ip
    }

    # Let's set up a hwtypes table that contains all valid hardware types.
    variable hwtypes
    variable isremote
    sql query $DB "select type,isremotenode from node_types"
    while {[set row [sql fetchrow $DB]] != ""} {
	set type  [lindex $row 0]
	set isrem [lindex $row 1]

	set hwtypes($type) 1
	set isremote($type) $isrem
    }
    sql endquery $DB
    sql query $DB "select class,isremotenode from node_types"
    while {[set row [sql fetchrow $DB]] != ""} {
	set type  [lindex $row 0]
	set isrem [lindex $row 1]

	set hwtypes($type) 1
	set isremote($type) $isrem
    }
    sql endquery $DB

    # The permissions table. Entries in this table indicate who is allowed
    # to use nodes of a particular type. No entries means anyone can use it.
    #
    # We omit this check in anonymous mode.
    #
    if {!${GLOBALS::anonymous}} {
	variable nodetypeXpid_permissions
    
	sql query $DB "select type,pid from nodetypeXpid_permissions"
	while {[set row [sql fetchrow $DB]] != ""} {
	    set type  [lindex $row 0]
	    set allow [lindex $row 1]

	    if {([info exists nodetypeXpid_permissions($type)])} {
		lappend nodetypeXpid_permissions($type) $allow
	    } else {
		set nodetypeXpid_permissions($type) [list $allow]
	    }
	}
	sql endquery $DB
    }

    # And a os table with valid OS Descriptor names. While we still call
    # them "osids", we are using the user level name not the internal,
    # globally unique name. We leave it to a later phase to deal with it.
    #
    # We omit this check in anonymous mode.
    if {!${GLOBALS::anonymous}} {
	variable osids
	sql query $DB \
	    "select osname from os_info where shared=1 or pid='$pid'"
	while {[set row [sql fetchrow $DB]] != ""} {
	    set osids($row) 1
	}
	sql endquery $DB
    }
}

# IP addresses routines.  These all do some checks and convert into set-ip
# calls.
proc tb-set-ip {node ip} {
    $node instvar portlist
    if {[llength $portlist] != 1} {
	perror "\[tb-set-ip] $node does not have a single connection."
	return
    }
    ::TBCOMPAT::set-ip $node [lindex $portlist 0] $ip
}
proc tb-set-ip-interface {src dst ip} {
    set sim [$src set sim]
    set reallink [$sim find_link $src $dst]
    if {$reallink == {}} {
	perror \
	    "\[tb-set-ip-interface] No connection between $src and $dst."
	return
    }
    ::TBCOMPAT::set-ip $src $reallink $ip
}
proc tb-set-ip-lan {src lan ip} {
    if {[$lan info class] != "Lan"} {
	perror "\[tb-set-ip-lan] $lan is not a LAN."
	return
    }
    ::TBCOMPAT::set-ip $src $lan $ip
}
proc tb-set-ip-link {src link ip} {
    if {[$link info class] != "Link"} {
	perror "\[tb-set-ip-link] $link is not a link."
	return
    }
    ::TBCOMPAT::set-ip $src $link $ip
}

# Node state routines.
proc tb-set-hardware {node type args} {
    var_import ::TBCOMPAT::hwtypes
    var_import ::TBCOMPAT::isremote
    var_import ::GLOBALS::vtypes
    if {(! [info exists hwtypes($type)]) &&
	(! [info exists vtypes($type)])} {
	perror "\[tb-set-hardware] Invalid hardware type $type."
	return
    }
    if {! ${GLOBALS::anonymous}} {
	var_import ::TBCOMPAT::nodetypeXpid_permissions
	var_import ::GLOBALS::pid
	set allowed 1
	
	if {[info exists nodetypeXpid_permissions($type)]} {
	    set allowed 0
	    foreach allowedpid $nodetypeXpid_permissions($type) {
		if {$allowedpid == $pid} {
		    set allowed 1
		}
	    }
	}
	if {! $allowed} {
	    perror "\[tb-set-hardware] No permission to use type $type."
	    return
	}
    }
    set remote 0
    if {[info exists isremote($type)]} {
	set remote $isremote($type)
    }
    $node set_hwtype $type $remote
}

proc tb-set-node-os {node os} {
    if {! ${GLOBALS::anonymous}} {
	var_import ::TBCOMPAT::osids
	if {! [info exists osids($os)]} {
	    perror "\[tb-set-node-os] Invalid osid $os."
	    return
	}
    }
    $node set osid $os
}
proc tb-set-node-cmdline {node cmdline} {
    $node set cmdline $cmdline
}
proc tb-set-node-rpms {node args} {
    if {$args == {}} {
	perror "\[tb-set-node-rpms] No rpms given."
	return
    }
    $node set rpms [join $args :]
}
proc tb-set-node-startup {node cmd} {
    $node set startup $cmd
}
proc tb-set-node-tarfiles {node args} {
    if {$args == {}} {
	perror "\[tb-set-node-tarfiles] tb-set-node-tarfiles <node> (<dir> <tar>)+"
	return
    }
    if {[expr [llength $args] % 2] != 0} {
	perror "\[tb-set-node-tarfiles] Arguments should be node and series of pairs."
	return
    }
    set tarfiles {}
    while {$args != {}} {
	lappend tarfiles [join [lrange $args 0 1]]
	set args [lrange $args 2 end]
    }
    $node set tarfiles [join $tarfiles :]
}
proc tb-set-node-deltas {node args} {
    if {$args == {}} {
	perror "\[tb-set-node-deltas] No deltas given."
	return
    }
    $node set deltas [join $args :]
}
proc tb-set-ip-routing {type} {
    var_import ::GLOBALS::default_ip_routing_type

    if {$type == {}} {
	perror "\[tb-set-ip-routing] No type given."
	return
    }
    if {($type != "none") &&
	($type != "ospf")} {
	perror "\[tb-set-ip-routing] Type is not one of none|ospf"
	return
    }
    set default_ip_routing_type $type
}

# Lan/Link state routines.

# This takes two possible formats:
# tb-set-link-loss <link> <loss>
# tb-set-link-loss <src> <dst> <loss>
proc tb-set-link-loss {srclink args} {
    var_import ::TBCOMPAT::FLOAT
    if {[llength $args] == 2} {
	set dst [lindex $args 0]
	set lossrate [lindex $args 1]
	set sim [$srclink set sim]
	set reallink [$sim find_link $srclink $dst]
	if {$reallink == {}} {
	    perror "\[tb-set-link-loss] No link between $srclink and $dst."
	    return
	}
    } else {
	set reallink $srclink
	set lossrate [lindex $args 0]
    }
    if {([regexp $FLOAT $lossrate] == 0) ||
	($lossrate > 1.0)} {
	perror "\[tb-set-link-loss] $lossrate is not a valid loss rate."
    }
    $reallink instvar loss
    $reallink instvar rloss
    set adjloss [expr 1-sqrt(1-$lossrate)]
    foreach pair [array names loss] {
	set loss($pair) $adjloss
	set rloss($pair) $adjloss
    }
}

proc tb-set-lan-loss {lan lossrate} {
    var_import ::TBCOMPAT::FLOAT
    if {[$lan info class] != "Lan"} {
	perror "\[tb-set-lan-loss] $lan is not a lan."
	return
    }
    if {([regexp $FLOAT $lossrate] == 0) ||
	($lossrate > 1.0)} {
	perror "\[tb-set-lan-loss] $lossrate is not a valid loss rate."
    }
    $lan instvar loss
    $lan instvar rloss
    set adjloss [expr 1-sqrt(1-$lossrate)]
    foreach pair [array names loss] {
	set loss($pair) $adjloss
	set rloss($pair) $adjloss
    }
}

proc tb-set-node-lan-delay {node lan delay} {
    if {[$node info class] != "Node"} {
	perror "\[tb-set-node-lan-delay] $node is not a node."
	return
    }
    if {[$lan info class] != "Lan"} {
	perror "\[tb-set-node-lan-delay] $lan is not a lan."
	return
    }
    set port [$lan get_port $node]
    if {$port == {}} {
	perror "\[tb-set-node-lan-delay] $node is not in $lan."
	return
    }
    $lan set delay([list $node $port]) [parse_delay $delay]
    $lan set rdelay([list $node $port]) [parse_delay $delay]
}
proc tb-set-node-lan-bandwidth {node lan bw} {
    if {[$node info class] != "Node"} {
	perror "\[tb-set-node-lan-delay] $node is not a node."
	return
    }
    if {[$lan info class] != "Lan"} {
	perror "\[tb-set-node-lan-delay] $lan is not a lan."
	return
    }
    set port [$lan get_port $node]
    if {$port == {}} {
	perror "\[tb-set-node-lan-delay] $node is not in $lan."
	return
    }
    $lan set bandwidth([list $node $port]) [parse_bw $bw]
    $lan set rbandwidth([list $node $port]) [parse_bw $bw]
}
proc tb-set-node-lan-loss {node lan loss} {
    var_import ::TBCOMPAT::FLOAT
    if {[$node info class] != "Node"} {
	perror "\[tb-set-node-lan-delay] $node is not a node."
	return
    }
    if {[$lan info class] != "Lan"} {
	perror "\[tb-set-node-lan-delay] $lan is not a lan."
	return
    }
    set port [$lan get_port $node]
    if {$port == {}} {
	perror "\[tb-set-node-lan-delay] $node is not in $lan."
	return
    }
    if {([regexp $FLOAT $loss] == 0) ||
	($loss > 1.0)} {
	perror "\[tb-set-link-loss] $loss is not a valid loss rate."
    }
    $lan set loss([list $node $port]) $loss
    $lan set rloss([list $node $port]) $loss
}
proc tb-set-node-lan-params {node lan delay bw loss} {
    tb-set-node-lan-delay $node $lan $delay
    tb-set-node-lan-bandwidth $node $lan $bw
    tb-set-node-lan-loss $node $lan $loss
}

proc tb-set-node-failure-action {node type} {
    if {[$node info class] != "Node"} {
	perror "\[tb-set-node-failure-action] $node is not a node."
	return
    }
    if {[lsearch -exact {fatal nonfatal ignore} $type] == -1} {
	perror "\[tb-set-node-failure-action] type must be one of fatal|nonfatal|ignore."
	return
    }
    $node set failureaction $type
}

proc tb-fix-node {vnode pnode} {
    if {[$vnode info class] != "Node"} {
	perror "\[tb-fix-node] $node is not a node."
	return
    }
    $vnode set fixed $pnode
}

proc tb-make-soft-vtype {name types} {
    var_import ::TBCOMPAT::hwtypes
    var_import ::TBCOMPAT::isremote
    var_import ::GLOBALS::vtypes
    var_import ::TBCOMPAT::default_soft_vtype_weight

    foreach type $types {
	if {! [info exists hwtypes($type)]} {
	    perror "\[tb-make-soft-vtype] Invalid hardware type $type."
	}
	if {$isremote($type)} {
	    perror "\[tb-make-soft-vtype] Remote type $type not allowed."
	}
    }
    set vtypes($name) [Vtype $name $default_soft_vtype_weight $types]
}

proc tb-make-hard-vtype {name types} {
    var_import ::TBCOMPAT::hwtypes
    var_import ::TBCOMPAT::isremote
    var_import ::GLOBALS::vtypes
    var_import ::TBCOMPAT::default_hard_vtype_weight

    foreach type $types {
	if {! [info exists hwtypes($type)]} {
	    perror "\[tb-make-hard-vtype] Invalid hardware type $type."
	}
	if {$isremote($type)} {
	    perror "\[tb-make-hard-vtype] Remote type $type not allowed."
	}
    }
    set vtypes($name) [Vtype $name $default_hard_vtype_weight $types]
}

proc tb-make-weighted-vtype {name weight types} {
    var_import ::TBCOMPAT::hwtypes
    var_import ::TBCOMPAT::isremote
    var_import ::GLOBALS::vtypes
    var_import ::TBCOMPAT::FLOAT

    foreach type $types {
	if {! [info exists hwtypes($type)]} {
	    perror "\[tb-make-weighted-vtype] Invalid hardware type $type."
	}
	if {$isremote($type)} {
	    perror "\[tb-make-weighted-vtype] Remote type $type not allowed."
	}
    }
    if {([regexp $FLOAT $weight] == 0) ||
	($weight <= 0) || ($weight >= 1.0)} {
	perror "\[tb-make-weighted-vtype] $weight is not a valid weight. (0 < weight < 1)."
    }
    set vtypes($name) [Vtype $name $weight $types]
}

proc tb-set-link-simplex-params {link src delay bw loss} {
    var_import ::TBCOMPAT::FLOAT
    if {[$link info class] != "Link"} {
	perror "\[tb-set-link-simplex-params] $link is not a link."
	return
    }
    if {[$src info class] != "Node"} {
	perror "\[tb-set-link-simplex-params] $src is not a link."
	return
    }
    set port [$link get_port $src]
    if {$port == {}} {
	perror "\[tb-set-link-simplex-params] $src is not in $link."
	return
    }
    if {([regexp $FLOAT $loss] == 0) || ($loss > 1.0)} {
	perror "\[tb-set-link-simplex-params] $loss is not a valid loss rate."
	return
    }
    set adjloss [expr 1-sqrt(1-$loss)]
    set np [list $src $port]
    foreach nodeport [$link set nodelist] {
	if {$nodeport != $np} {
	    set onp $nodeport
	}
    }

    set realdelay [parse_delay $delay]
    set realbw [parse_bw $bw]
    $link set delay($np) [expr $realdelay / 2.0]
    $link set rdelay($onp) [expr $realdelay / 2.0]
    $link set bandwidth($np) $realbw
    $link set rbandwidth($onp) $realbw
    $link set loss($np) [expr $adjloss]
    $link set rloss($onp) [expr $adjloss]
}

proc tb-set-lan-simplex-params {lan node todelay tobw toloss fromdelay frombw fromloss} {
    var_import ::TBCOMPAT::FLOAT
    if {[$node info class] != "Node"} {
	perror "\[tb-set-node-lan-delay] $node is not a node."
	return
    }
    if {[$lan info class] != "Lan"} {
	perror "\[tb-set-node-lan-delay] $lan is not a lan."
	return
    }
    set port [$lan get_port $node]
    if {$port == {}} {
	perror "\[tb-set-node-lan-delay] $node is not in $lan."
	return
    }
    if {([regexp $FLOAT $toloss] == 0) || ($toloss > 1.0)} {
	perror "\[tb-set-link-loss] $toloss is not a valid loss rate."
    }
    if {([regexp $FLOAT $fromloss] == 0) || ($fromloss > 1.0)} {
	perror "\[tb-set-link-loss] $fromloss is not a valid loss rate."
    }

    set realtodelay [parse_delay $todelay]
    set realfromdelay [parse_delay $fromdelay]
    set realtobw [parse_bw $tobw]
    set realfrombw [parse_bw $frombw]

    $lan set delay([list $node $port]) $realtodelay
    $lan set rdelay([list $node $port]) $realfromdelay
    $lan set loss([list $node $port]) $toloss
    $lan set rloss([list $node $port]) $fromloss
    $lan set bandwidth([list $node $port]) $realtobw
    $lan set rbandwidth([list $node $port]) $realfrombw
}

proc tb-set-uselatestwadata {onoff} {
    var_import ::GLOBALS::uselatestwadata

    if {$onoff != 0 && $onoff != 1} {
	perror "\[tb-set-uselatestwadata] $onoff must be 0/1"
	return
    }

    set uselatestwadata $onoff
}

proc tb-set-wasolver-weights {delay bw plr} {
    var_import ::GLOBALS::wa_delay_solverweight
    var_import ::GLOBALS::wa_bw_solverweight
    var_import ::GLOBALS::wa_plr_solverweight

    if {($delay < 0) || ($bw < 0) || ($plr < 0)} {
	perror "\[tb-set-wasolver-weights] Weights must be postive integers."
	return
    }
    if {($delay == {}) || ($bw == {}) || ($plr == {})} {
	perror "\[tb-set-wasolver-weights] Must provide delay, bw, and plr."
	return
    }

    set wa_delay_solverweight $delay
    set wa_bw_solverweight $bw
    set wa_plr_solverweight $plr
}
