#!/usr/local/bin/perl -w

# This sets adds the commands that take ns CBR traffic generation
# and use send/consume kernels to set up the same traffic on the testbed
#
# It takes the ns file, and after finding the trafgen data, it adds
# a few lines to the tbcmds file.

my $debug=0;
if ( $ARGV[0] =~ /^-d(\d+)?$/) {
  shift;
  if (defined $1) { 
    $debug=$1;
  } else {
    if ($ARGV[0] =~ /(\d+)/) {
      $debug=$1;
      shift;
    } else {
      $debug=1;
    }
  }
}

if (@ARGV < 2) {
  print STDERR "Syntax: $0 [-d[N]] <ns_file> <tbcmds_file>\n";
  exit(1);
}

my $nsfilename = shift;
my $tbcmdsname = shift || "tbcmds";

open(NS,"<$nsfilename") || 
  die ("Couldn't open ns file '$nsfilename' for reading.\n");
open(TBCMDS,">>$tbcmdsname") || 
  die ("Couldn't open tbcmds file '$tbcmdsname' for appending.\n");

# Assumption: Any file that makes it here "should" be valid ns, but we can try
# to print useful errors, just in case.

# (We need to track the links to see where the gateways are)

my $ns = "ns";
my $simre;
my %links = ();
my %LANs = ();
my %UDP = ();
my %NULL = ();
my %CBR = ();
my %connect = ();

print "Getting traffic generation information from '$nsfilename'...\n"
  if $debug;
while ( <NS> ) {
  chop;
  s/\s+/ /g; # condense whitespace to only one

  print "NS:'$_'\n" if $debug > 1;

  # Get the simulator name (usually '$ns'...)
  if ( /^ ?set (\w+) \[ ?new Simulator ?\]/ ) { 
    $ns = "\$".$1; 
    print "Simulator is called '$ns'\n" if $debug;
    $simre = " ?\\$ns";
    print "Using simulator RE '$simre'\n" if $debug > 1;
  }

  # Look for links and save them, for finding gateways later
  if ( defined ($simre) && /^$simre duplex-link (\$\w+) (\$\w+) / ) {
    my $src = $1;
    my $dst = $2;
    print "Found link from '$src' to '$dst'\n" if $debug;
    #print "[",join(", ",keys %LANs),"]=>[",join(", ",values %LANs),"]\n";
    if ( defined $LANs{$src} && defined $LANs{$dst} ) {
      print "(LAN to LAN link)\n" if $debug;
      foreach my $s (@{$LANs{$src}}) {
	foreach my $d (@{$LANs{$dst}}) {
	  if ($s eq $d) { next; }
	  makelink($s,$d);
	}
      }
    } elsif (defined $LANs{$src}) {
      print "(LAN to node link)\n" if $debug;
      foreach my $s (@{$LANs{$src}}) {
	if ($s eq $dst) { next; }
	makelink($s,$dst);
      }
    } elsif (defined $LANs{$dst}) {
      print "(node to LAN link)\n" if $debug;
      foreach my $d (@{$LANs{$dst}}) {
	if ($src eq $d) { next; }
	makelink($src,$d);
      }
    } else {
      makelink($src,$dst);
    }
  }

  # Look for lans and save them as links, for finding gateways later
  if ( defined ($simre) && 
       /^ ?set (\w+) \[$simre make-lan \"([^\"]+)\" / ) {
    my $name = "\$$1";
    my @lan = split (" ",$2);
    print "Found a LAN '$name' with '$2'\n" if $debug;
    $LANs{$name} = \@lan;
    foreach my $src (@lan) {
      foreach my $dst (@lan) {
	if ($src eq $dst) { next; }
	makelink($src,$dst);
      }
    }
  }

  # Watch for UDP agents
  if ( /^ ?set (\w+) \[ ?new Agent\/UDP ?\]/ ) {
    my $udp = "\$".$1;
    $UDP{$udp} = 1;
    print "Found UDP agent '$udp'\n" if $debug;
  }

  # Watch for Null agents
  if ( /^ ?set (\w+) \[ ?new Agent\/Null ?\]/ ) {
    my $null = "\$".$1;
    $NULL{$null} = 1;
    print "Found Null agent '$null'\n" if $debug;
  }

  # See what an agent is attached to
  if ( defined ($simre) && /^$simre attach-agent (\$\w+) (\$\w+)/ ) {
    my $node = $1;
    my $agent = $2;
    print "Attached '$agent' to '$node' " if $debug;
    $found = 0;
    foreach $a (keys %UDP, keys %NULL) {
      print "Checking '$a' == '$agent'\n" if $debug > 1;
      if ($a eq $agent) {
	print "Matched!\n" if $debug > 1;
	if ($UDP{$a}) {
	  $found = 1;
	  $UDP{$a} = $node;
	  print "(UDP)\n" if $debug;
	} elsif ($NULL{$a}) {
	  $found = 1;
	  $NULL{$a} = $node;
	  print "(Null)\n" if $debug;
	} else {
	  print STDERR "Warning: How did I get here? This is impossible!\n";
	}
      }
    }
    if (!$found) {
      print STDERR "Warning: '$agent' was not declared before attachment!\n";
    }
  }

  # Find any CBR generators
  if ( /^ ?set (\w+) \[ ?new Application\/Traffic\/CBR ?\]/ ) {
    my $cbr = "\$".$1;
    $CBR{$cbr} = { }; # "re" => " ?\\$cbr" };
    print "Found CBR generator '$cbr'\n" if $debug;
  }

  # Find any CBR configuration settings
  if ( /^ ?(\$\w+) set (packetSize_|interval_|rate_) ([\.0-9]+\w*)/ ) {
    my $cbr = $1;
    my $attr = $2;
    my $val = $3;
    print "Found setting for CBR '$cbr': '$attr' => $val\n" if $debug;
    if (defined $CBR{$cbr}) {
      $CBR{$cbr}{$attr} = $val;
      print "CBR '$cbr' has ('",join("', '",keys %{$CBR{$cbr}}),"')\n"
	if $debug > 1;
    } else {
      print STDERR "Warning: '$cbr' was not declared before CBR settings!\n";
    }
  }

  # Find any CBR attachments
  if ( /^ ?(\$\w+) attach-agent (\$\w+) ?$/ ) {
    my $cbr = $1;
    my $agent = $2;
    print "Found CBR attachment '$cbr' to '$agent'\n" if $debug;
    if (defined $CBR{$cbr}) {
      $CBR{$cbr}{"agent"} = $agent;
      if (defined ($CBR{$agent}) ) {
	print STDERR "Warning: CBR{'$agent'} was already defined!\n";
      } else {
	$CBR{$agent} = $cbr;
      }
      print "CBR '$cbr' has ('",join("', '",keys %{$CBR{$cbr}}),"')\n"
	if $debug > 1;
    } else {
      print STDERR "Warning: '$cbr' was not declared before CBR attachment!\n";
    }
  }

  # Find any connections of UDP agents to Null agents
  if ( defined($simre) && /^$simre connect (\$\w+) (\$\w+)/ ) {
    my $a1 = $1;
    my $a2 = $2;
    print "Found '$a1' connected to '$a2'\n" if $debug;
    if  ( defined $connect{$a1} ) {
      $connect{$a1} = join(":",split(":",$connect{$a1}),$a2);
    } else {
      $connect{$a1} = $a2;
    }
    if  ( defined $connect{$a2} ) {
      $connect{$a2} = join(":",split(":",$connect{$a2}),$a1);
    } else {
      $connect{$a2} = $a1;
    }
    print "'$a1' connects to ('",join("', '",split(":",$connect{$a1})),"')\n"
      if $debug;
    print "'$a2' connects to ('",join("', '",split(":",$connect{$a2})),"')\n"
      if $debug;
  }
}

print "Finished parsing traffic generation information from '$nsfilename'\n"
  if $debug;
close(NS);

if (! ( ((keys %UDP)>0) && ((keys %NULL)>0) && 
	((keys %CBR)>0) && ((keys %connect)>0) ) ) {
  print STDERR "Compatible traffic generation did not occur, or was incomplete.\n";
  close(TBCMDS);
  exit(0);
}

print STDERR "Adding traffic generation commands to '$tbcmdsname'...\n";

print TBCMDS "tb-create-os SEND x86/send mb\n";
print TBCMDS "tb-create-os CONSUME x86/consume mb\n";
print "tb-create-os SEND x86/send mb\n" if $debug;
print "tb-create-os CONSUME x86/consume mb\n" if $debug;

my @senders = ();
my @consumers = ();

# Find sending/consuming agents
foreach $agent (keys %connect) {
  if (defined $UDP{$agent}) {
    print "Found sender '$agent'\n" if $debug;
    push(@senders,$agent);
  } elsif (defined $NULL{$agent}) {
    print "Found consumer '$agent'\n" if $debug;
    push(@consumers,$agent);
  } else {
    print "Agent '$agent' is connected, but is not UDP or Null! Oh my!\n";
  }
}

foreach $udp ( @senders ) {
  my $node = $UDP{$udp};
  my $cleannode = $node;
  $cleannode =~ s/\$//;
  my $dest = $NULL{$connect{$udp}};
  $dest =~ s/\$//;
  my $gate = (split(":",$links{$node}))[0]; # maybe make it smarter later
  $gate =~ s/\$//;
  print TBCMDS "tb-set-node-os $cleannode SEND\n";
  print "tb-set-node-os $cleannode SEND\n" if $debug;
  $cmd = "tb-set-node-cmdline $cleannode {DST_NAME=".$dest." GATE_NAME=".$gate;
  my $cbr = $CBR{$udp};
  print "cbr for $udp is $cbr\n" if $debug;
  if (defined $CBR{$cbr}) {
    print "CBR '$cbr' has ('",join("', '",keys %{$CBR{$cbr}}),"')\n"
      if $debug;
    foreach $attr ( keys %{$CBR{$cbr}} ) {
      if ($attr eq "packetSize_") {
	$cmd .=" PKT_SIZE=".$CBR{$cbr}{$attr};
      }
      if ($attr eq "interval_") {
	my $interval = $CBR{$cbr}{$attr}; # interval in seconds/packet
	my $pkt_rate = int (1.0 / $interval); # rate in packets/sec
	$cmd .=" PKT_RATE=".$pkt_rate; # PKT_RATE is packets/sec
      }
      if ($attr eq "rate_") {
	my $size = 210;
	if (defined $CBR{$cbr}{"packetSize_"}) { 
	  $size = $CBR{$cbr}{"packetSize_"};
	}
	my $rate = $CBR{$cbr}{$attr}; # number in bps, might have k or m
	if ( $rate =~ /^([\.\d]+)([kKmM])?b?p?s?$/) {
	  $rate = $1;
	  if ( defined ($2) ) {
	    $rate *= 1024; # its at least got a K...
	    if ($2 eq "m" || $2 eq "M") {
	      $rate *= 1024; # give it another 1000 for M
	    }
	  }
	} else {
	  print "Warning: Invalid rate_ for '$cbr'!\n";
	  $rate = 1; # set to 1 pps (ala ping)
	}
	# We now have a rate in bps - change it to packets/sec
	$rate = int($rate / ($size * 8)); # (bits/sec)/(bits/packet)=pac/sec
	$cmd .=" PKT_RATE=".$rate; # PKT_RATE is packets/sec
      }
    }
  }
  $cmd .= "}";
  print TBCMDS "$cmd\n";
  print "$cmd\n" if $debug;
}

foreach $null ( @consumers ) {
  my $node = $NULL{$null};
  my $cleannode = $node;
  $cleannode =~ s/\$//;
  my $dest = $UDP{$connect{$null}};
  $dest =~ s/\$//;
  my $gate = (split(":",$links{$node}))[0]; # maybe make it smarter later
  $gate =~ s/\$//;
  print TBCMDS "tb-set-node-os $cleannode CONSUME\n";
  print "tb-set-node-os $cleannode CONSUME\n" if $debug;
  print TBCMDS 
    "tb-set-node-cmdline $cleannode {DST_NAME=$dest GATE_NAME=$gate}\n";
  print "tb-set-node-cmdline $cleannode {DST_NAME=$dest GATE_NAME=$gate}\n"
    if $debug;

}

close(TBCMDS);

exit(0);

sub makelink {
  my $src = shift;
  my $srcre= "\\$src";
  my $dst = shift;
  my $dstre= "\\$dst";
  if  ( defined $links{$src} ) {
    if ( ! ($links{$src} =~ /^(.+:)?$dstre(:.+)?$/ ) ) {
      $links{$src} = join(":",split(":",$links{$src}),$dst);
    } else { return; }
  } else {
    $links{$src} = $dst;
  }
  if  ( defined $links{$dst} ) {
    if ( ! ($links{$dst} =~ /^(.+:)?$srcre(:.+)?$/ ) ) {
      $links{$dst} = join(":",split(":",$links{$dst}),$src);
    } else { return; }
  } else {
    $links{$dst} = $src;
  }
  print "Connecting $src<->$dst, have $links{$src} and $links{$dst}\n" 
    if $debug;
}
