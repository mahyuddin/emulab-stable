#!/usr/bin/perl -wT

#
# EMULAB-COPYRIGHT
# Copyright (c) 2000-2003 University of Utah and the Flux Group.
# All rights reserved.
#

use English;
use Getopt::Std;
use Socket;
    
#
# Parse an ns file. Since the parser runs arbitrary NS file for the user,
# this cannot be safely done on boss without jumping through huge hoops
# to secure tcl and the DB. Yuck! So, instead of running the parser on boss,
# we run it over on ops. This first version operates like this:
#
# NB: This script is setuid.
#
sub usage()
{
    print STDOUT
	"Usage: parse-ns [options] pid gid eid nsfile\n".
        "Where options and arguments are those required by parse.tcl\n";
 
    exit(-1);
}
my $optlist  = "nqap";
my $anonmode = 0;
my $passmode = 0;
my $impotent = 0;
my $debug    = 0;

#
# Configure variables
#
my $TB       = "@prefix@";
my $TBOPS    = "@TBOPSEMAIL@";
my $CONTROL  = "@USERNODE@";
my $TESTMODE = @TESTMODE@;

# Locals
my $infile   = "parse.input";
my $outfile  = "parse.output";
my $SAVEUID  = $UID;
my $dbuid;
my $pid;
my $gid;
my $eid;
my $nsfile;

#
# Turn off line buffering on output
#
$| = 1;

#
# Untaint the path
# 
$ENV{'PATH'} = "$TB/bin:$TB/sbin:/bin:/usr/bin:/sbin:/usr/sbin";
delete @ENV{'IFS', 'CDPATH', 'ENV', 'BASH_ENV'};

if ($TESTMODE) {
    # In testmode, drop privs (my devel tree at home is TESTMODE=1)
    $EUID = $UID;
}
elsif ($EUID != 0) {
    # We don't want to run this script unless its the real version.
    die("*** $0:\n".
	"    Must be root! Maybe its a development version?\n");
}

# This script is setuid, so please do not run it as root. Hard to track
# what has happened.
if ($UID == 0) {
    die("*** $0:\n".
	"    Please do not run this as root! Its already setuid!\n");
}

#
# Testbed Support libraries
#
use lib "@prefix@/lib";
use libdb;
use libtestbed;

#
# Parse command arguments. Once we return from getopts, all that should
# left are the required arguments.
#
%options = ();
if (! getopts($optlist, \%options)) {
    usage();
}
if (defined($options{"a"})) {
    $anonmode = 1;
}
if (defined($options{"n"})) {
    $impotent = 1;
}
if (defined($options{"p"})) {
    $passmode = 1;
}
if (@ARGV != 4 && @ARGV != 1) {
    usage();
}

if (@ARGV == 1) {
    $nsfile = $ARGV[0];
}
else {
    $pid   = $ARGV[0];
    $gid   = $ARGV[1];
    $eid   = $ARGV[2];
    $nsfile= $ARGV[3];
}

#
# Must taint check!
#
if ($nsfile =~ /^([-\w\/\.]+)$/) {
    $nsfile = $1;
}
else {
    die("Bad data in argument: $nsfile.");
}
   
if (defined($pid)) {
    if ($pid =~ /^([-\w]+)$/) {
	$pid = $1;
    }
    else {
	die("Bad data in argument: $pid.");
    }
    if ($eid =~ /^([-\w]+)$/) {
	$eid = $1;
    }
    else {
	die("Bad data in argument: $eid.");
    }
    if ($gid =~ /^([-\w]+)$/) {
	$gid = $1;
    }
    else {
	die("Bad data in argument: $gid.");
    }
}

# Remove temps cause of swapin by alternates.
unlink($infile);
unlink($outfile);

if (!$TESTMODE) {
    #
    # Get DB uid for sending over to ops. In testmode, it runs locally
    # as the user running the testsuite, obviously.
    #
    if (! UNIX2DBUID($UID, \$dbuid)) {
	die("*** $0:\n".
	    "    You do not exist in the Emulab Database!\n");
    }

    # Run as the user for most of this script.
    $EUID = $UID;
}

# Create the defs files.
GenDefsFile($infile);

# Now append the NS file to. This part is hokey. Fix later.
system("cat $nsfile >> $infile") == 0
    or die("Could not combine TCL defs file and the NS file!\n");

#
# Touch the output file, to avoid a root owned, 644 file. 
#
if (-e $outfile) {
    unlink($outfile) or
	die("*** $0:\n".
	    "    Could not unlink $outfile\n");
}
system("touch $outfile") == 0 or
    die("*** $0:\n".
	"    Could not create $outfile\n");

#
# Build up a new command line to run the parser on ops, writing the
# result back to a file if not in anonmode. Remember to tack on the
# user ID to flip to, when not in testmode.
#
my $cmdargs = "$TB/libexec/ns2ir/parse.proxy ";
$cmdargs .= " -u $dbuid"
    if (defined($dbuid));
$cmdargs .= " -a"
    if ($anonmode);
$cmdargs .= " -n"
    if (defined($options{"n"}));
$cmdargs .= " -q"
    if (defined($options{"q"}));
$cmdargs .= " -p"
    if ($passmode);
$cmdargs .= " $pid $gid $eid"
    if (!$anonmode);

#
# Run parser, redirecting stdout to a file to capture the parser results.
# Must flip to real root to run ssh.
#
if ($TESTMODE) {
    #
    # In testmode, no ssh. Just run locally.
    #
    system("$cmdargs < $infile >> $outfile");
}
else {
    #
    # In non-testmode, must flip to real root for the ssh, and then flip
    # back afterwards.
    # 
    $EUID = $UID = 0;
    system("sshtb -host $CONTROL $cmdargs < $infile >> $outfile");
    $EUID = $UID = $SAVEUID;
}

# 
# Error output went to stderr, so the caller captures that. 
# 
if ($?) {
    my $exit_status = $? >> 8;
    
    die("Parser exited with error code $exit_status!\n");
}
exit(0)
    if ($impotent);

#
# Run the XML converter on the output. 
#
system("$TB/libexec/xmlconvert -x $outfile $pid $eid");

if ($?) {
    my $exit_status = $? >> 8;
    
    die("XML converter exited with error code $exit_status!\n");
}

#
# Now we have to fix up one minor thing; widearea tunnel IPs. These have
# to be unique, but without the DB to ask, there is no easy way to arrange
# that.

my %subnetmap = ();
my $WANETMASK = "255.255.255.248";

my $query_result =
    DBQueryFatal("select vname,ips from virt_nodes ".
		 "where pid='$pid' and eid='$eid'");
while (my ($vname,$ips) = $query_result->fetchrow_array()) {
    my @newiplist = ();
    my $newips;

    foreach my $ipinfo (split(" ", $ips)) {
	my ($port,$ip) = split(":", $ipinfo);
	my ($a,$b,$c,$d) = ($ip =~ /(\d+).(\d+).(\d+).(\d+)/);

	if ($a eq "1" && $b eq "1") {
	    my $net = inet_ntoa(inet_aton($WANETMASK) & inet_aton($ip));
		
	    if (! defined($subnetmap{$net})) {
		DBQueryFatal("insert into ipsubnets ".
			     "values ('$pid','$eid', NULL)");
		my ($id) =
		    DBQueryFatal("select LAST_INSERT_ID() ".
				 "from ipsubnets")->fetchrow_array();

		# We are going to shift the bits up so they do not conflict
		# with the lower part.
		if ($id >= 8192) {
		    die("No more widearea subnets left!\n");
		}
		$id = $id << 3;

		my $cc = ($id & 0xff00) >> 8;
		my $dd = ($id & 0xf8);
		$subnetmap{$net} = inet_aton("192.168.$cc.$dd");
	    }
	    my $newsubnet = inet_ntoa($subnetmap{$net} | inet_aton("$d"));
	    push(@newiplist, "$port:${newsubnet}");
	}
	else {
	    push(@newiplist, $ipinfo);
	}
    }
    $newips = join(" ", @newiplist);
    
    if ($newips ne $ips) {
	DBQueryFatal("update virt_nodes set ips='$newips' ".
		     "where vname='$vname' and pid='$pid' and eid='$eid'");
    }
}
#
# So, if we ended up changing any, we have look for corresponding entries
# in virt_trafgens, and fix them too.
#
if (keys(%subnetmap)) {
    $query_result =
	DBQueryFatal("select vnode,vname,ip,target_ip from virt_trafgens ".
		     "where pid='$pid' and eid='$eid'");
    while (my ($vnode,$vname,$ip,$dstip) = $query_result->fetchrow_array()) {
	my ($a,$b,$c,$d) = ($ip =~ /(\d+).(\d+).(\d+).(\d+)/);
	my $newip        = $ip;
	my $newdstip     = $dstip;
	my $net		 = inet_ntoa(inet_aton($WANETMASK) & inet_aton($ip));
	
	if (defined($subnetmap{$net})) {
	    $newip = inet_ntoa($subnetmap{$net} | inet_aton("$d"));
	}
	($a,$b,$c,$d) = ($dstip =~ /(\d+).(\d+).(\d+).(\d+)/);
	$net          = inet_ntoa(inet_aton($WANETMASK) & inet_aton($dstip));
	if (defined($subnetmap{$net})) {
	    $newdstip = inet_ntoa($subnetmap{$net} | inet_aton("$d"));
	}
	if ($ip ne $newip || $dstip ne $newdstip) {
	    DBQueryFatal("update virt_trafgens set ".
			 "       ip='$newip',target_ip='$newdstip' ".
			 "where pid='$pid' and eid='$eid' and ".
			 "      vnode='$vnode' and vname='$vname'");
	}
    }
}
exit(0);


#
# Open up a TCL file and write a bunch of TCL to it!
#
sub GenDefsFile($)
{
    my($fname) = $_[0];

    open(TCL, "> $fname")
	or die("Could not open TCL defs file for writing: $!\n");

    print TCL "namespace eval TBCOMPAT {\n";

    print TCL "# Event Object Types\n";
    my $query_result =
	DBQueryFatal("select idx,type from event_objecttypes");
    while (my ($idx,$type) = $query_result->fetchrow_array()) {
	print TCL "set objtypes($type) $idx\n";
    }
    print TCL "\n";

    print TCL "# Event Event Types\n";
    $query_result =
	DBQueryFatal("select idx,type from event_eventtypes");
    while (my ($idx,$type) = $query_result->fetchrow_array()) {
	print TCL "set eventtypes($type) $idx\n";
    }
    print TCL "\n";
    
    print TCL "# Node Types\n";
    $query_result =
	DBQueryFatal("select type,isremotenode,isvirtnode,osname,issubnode ".
		     " from node_types as nt ".
		     "left join os_info as o on nt.osid=o.osid");
    while (my ($type,$isrem,$isvirt,$osid,$issubnode) =
	   $query_result->fetchrow_array()) {
	print TCL "set hwtypes($type) 1\n";
	print TCL "set isremote($type) $isrem\n";
	print TCL "set isvirt($type) $isvirt\n";
	print TCL "set issubnode($type) $issubnode\n";
	print TCL "set default_osids($type) \"$osid\"\n"
	    if (defined($osid) && $osid ne "");
    }
    print TCL "\n";
    
    print TCL "# Node Classes\n";
    $query_result =
	DBQueryFatal("select class,isremotenode,isvirtnode,issubnode ".
		     "from node_types");
    while (my ($class,$isrem,$isvirt,$issubnode) =
	   $query_result->fetchrow_array()) {
	print TCL "set hwtypes($class) 1\n";
	print TCL "set isremote($class) $isrem\n";
	print TCL "set isvirt($class) $isvirt\n";
	print TCL "set issubnode($class) $issubnode\n";
    }
    print TCL "\n";

    print TCL "# Node Aux Types\n";
    $query_result =
	DBQueryFatal("select at.auxtype,".
		     "       isremotenode,isvirtnode,osname,issubnode ".
		     " from node_types_auxtypes as at ".
		     "left join node_types as nt on nt.type=at.type ".
		     "left join os_info as o on nt.osid=o.osid");
    while (my ($type,$isrem,$isvirt,$osid,$issubnode) =
	   $query_result->fetchrow_array()) {
	print TCL "set hwtypes($type) 1\n";
	print TCL "set isremote($type) $isrem\n";
	print TCL "set isvirt($type) $isvirt\n";
	print TCL "set issubnode($type) $issubnode\n";
	print TCL "set default_osids($type) \"$osid\"\n"
	    if (defined($osid) && $osid ne "");
    }
    print TCL "\n";
    
    print TCL "# Node Permissions\n";
    my %nodeperms = ();
    $query_result =
	DBQueryFatal("select type,pid from nodetypeXpid_permissions");
    while (my ($type,$pid) = $query_result->fetchrow_array()) {
	if (! defined($nodeperms{$type})) {
	    $nodeperms{$type} = [];
	}
	push(@{$nodeperms{$type}}, $pid);
    }
    foreach my $type (keys(%nodeperms)) {
	my @pids = @{$nodeperms{$type}};

	print TCL "set nodetypeXpid_permissions($type) [list @pids]\n";
    }
    print TCL "\n";

    if (defined($pid)) {
	print TCL "# OSIDs\n";
	$query_result =
	    DBQueryFatal("select osname from os_info ".
			 "where shared=1 or pid='$pid'");
		     
	while (my ($osname) = $query_result->fetchrow_array()) {
	    print TCL "set osids($osname) 1\n";
	}
	print TCL "\n";
    }

    if (defined($pid)) {
	# Load reserved nodes, for swapmodify.
	$query_result = 
	    DBQueryFatal("select r.vname,r.node_id,n.type from reserved as r ".
			 "left join nodes as n on n.node_id=r.node_id ".
			 "where r.pid='$pid' and r.eid='$eid'");

	print TCL "# Reserved Nodes\n";
	while (($vname,$reserved,$type) = $query_result->fetchrow_array()) {
	    print TCL "lappend reserved_list \"$vname\"\n";
	    print TCL "set reserved_type($vname) \"$type\"\n";
	    print TCL "set reserved_node($vname) \"$reserved\"\n";
	}
    }

    print TCL "}\n";
    close(TCL);
}
