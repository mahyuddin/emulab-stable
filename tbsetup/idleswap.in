#!/usr/bin/perl -wT

#
# EMULAB-COPYRIGHT
# Copyright (c) 2000-2006 University of Utah and the Flux Group.
# All rights reserved.
#

use English;
use Getopt::Std;

#
# This gets invoked from the Web interface and from idlemail
#
sub usage()
{
    print STDOUT "Usage: idleswap [-i | -a] <pid> <eid>\n";
    exit(-1);
}
# Hidden switch: -r = root mode - used by idlemail
my  $optlist = "iar";

#
# Configure variables
#
my $TB		= "@prefix@";
my $DBNAME	= "@TBDBNAME@";
my $TBOPS	= "@TBOPSEMAIL@";
my $TBLOGS	= "@TBLOGSEMAIL@";
my $TBAUDIT	= "@TBAUDITEMAIL@";
my $swapexp	= "$TB/bin/swapexp";
my $template_swapout = "$TB/bin/template_swapout";

# Testbed Support libraries
use lib "@prefix@/lib";
use libaudit;
use libdb;
use libtestbed;
use libTemplates;

# Locals.
my $idleswap   = 0;
my $autoswap   = 0;
my $isinstance = 0;

# Untaint the path
$ENV{'PATH'} = '/bin:/usr/bin';
delete @ENV{'IFS', 'CDPATH', 'ENV', 'BASH_ENV'};

# Turn off line buffering on output
$| = 1;

# We don't want to run this script unless its the real version.
if ($EUID != 0) {
    die("*** $0:\n".
	"    Must be root! Maybe its a development version?\n");
}

# Parse command arguments. Once we return from getopts, all that should
# left are the required arguments.
%options = ();
if (! getopts($optlist, \%options)) { usage(); }
if (defined($options{"i"})) { $idleswap = 1; }
if (defined($options{"a"})) { $autoswap = 1; }
if (defined($options{"r"})) { $rootokay = 1; }

# This script is setuid, so please do not run it as root. Hard to track
# what has happened.
if ($UID == 0 && (!defined($rootokay) || !$rootokay) ) {
    die("*** $0:\n".
	"    Please do not run this as root! Its already setuid!\n");
}

if (@ARGV != 2) {
    usage();
}
my $pid   = $ARGV[0];
my $eid   = $ARGV[1];

# Untaint the arguments.
if ($pid =~ /^([-\@\w.]+)$/) {
    $pid = $1;
}
else {
    die("Tainted argument $pid!\n");
}
if ($eid =~ /^([-\@\w.]+)$/) {
    $eid = $1;
}
else {
    die("Tainted argument $eid!\n");
}

# Only admins can forcibly swap an idle experiment out.
if (! TBAdmin($UID) && ($UID!=0 || !$rootokay) ) {
    die("*** $0:\n".
	"    Only testbed administrators can issue a forcible swap!\n");
}

#
# This script is always audited.
#
if (AuditStart(0)) {
    #
    # Parent exits normally
    #
    exit(0);
}

# Need to know the creator of the experiment.
my $query_result =
    DBQueryFatal("SELECT * FROM experiments WHERE eid='$eid' and pid='$pid'");

if (! $query_result->numrows) {
    die("*** $0:\n".
	"    No such experiment $pid/$eid!\n");
}
my %hashrow = $query_result->fetchhash();
my $creator = $hashrow{'expt_head_uid'};
my $gid     = $hashrow{'gid'};
my $exptidx = $hashrow{'idx'};

# See below; different swapout procedure.
$isinstance = IsTemplateInstanceExperiment($exptidx);

# Fire off the swap and exit.
#
# Flip to the creator. The swap happens as the creator of the
# experiment.
my ($unix_uid, $unix_gid, $unix_gname);

(undef,undef,$unix_uid) = getpwnam($creator) or
  die("*** $0:\n".
      "    No such user $creator\n");
TBGroupUnixInfo($pid, $gid, \$unix_gid, \$unix_gname) or
  die("*** $0:\n".
      "    No such group $pid/$gid\n");

#
# Need the entire group list for the user, cause of subgroups, and cause
# thats the correct thing to do. Too bad perl does not have a getgrouplist
# function like the C library. Maybe its cleaner to just use sudo? Should
# we get this info from the DB instead of using "id?" 
#
my $glist = `id -G $creator`;
if ($glist =~ /^([\d ]*)$/) {
    $glist = $1;
}
else {
  die("*** $0:\n".
      "    Unexpected results from 'id -G $creator': $glist\n");
}

# Send the email now, which terminates the audit.
AuditEnd();

# Remove current group from glist, then add gid twice at the front of the list
# Order matters here, or we won't pick up all the groups we need.

$glist =~ s/ ?\b$unix_gid\b ?//;
$glist = $unix_gid . " " . $unix_gid . " " . $glist;

$GID            = $unix_gid;
$EGID           = $glist;
$EUID = $UID    = $unix_uid;
$ENV{'USER'}    = $creator;
$ENV{'LOGNAME'} = $creator;

if (0 && IsTemplateInstanceExperiment($exptidx)) {
    my ($guid, $vers);
    
    if (MapExptidxtoTemplate($exptidx, \$guid, \$vers) < 0) {
	die("*** $0:\n".
	    "    Error mapping experiment to its template!\n");
    }
    exec "$template_swapout $guid/$vers $eid";
}
else {
    my $arg = "";
    
    if    ($idleswap) { $arg = "-i"; }
    elsif ($autoswap) { $arg = "-a"; }
    else { $arg = "-f"; }

    exec "$swapexp $arg -s out $pid $eid";
}

die("*** $0:\n".
    "    Failed to exec $swapexp!\n");

