#!/usr/bin/perl
#
# portstats - Get port statistics for nodes in an experiment
#
#
# NOTE: no -w, because $::line below is used in the eval, which perl
# can't pick up on, so it warns about this variable being only used once
#


#
# Configure variables
#
use lib '@prefix@/lib';

use libdb;
use snmpit_lib;

use English;
use Getopt::Long;
use strict;

sub usage {
    print << "END";
Usage: $0 [-h] <pid> <eid> [vname ...] [vname:port ...]
-h    This message
-e    Show only error counters
-a    Show all stats
-z    Zero out counts for selected counters, after printing
-q    Quiet: don't actually print counts - useful with -z
-c    Print absolute, rather than relative, counts

If only pid and eid are given, prints out information about all ports in the
experiment. Otherwise, output is limited to the nodes and/or ports given.

NOTE: Statistics are reported from the switch's perspective. This means that
'In' packets are those sent FROM the node, and 'Out' packets are those
sent TO the node.

In the output, packets described as 'NUnicast' or 'NUcast' are non-unicast
(broadcast or multicast) packets.'
END

    return 1;
}

#
# Process command-line arguments
#
my %opt = ();
GetOptions(\%opt,'h','a','e','p','b','z','q','c');

if ($opt{h}) {
    exit &usage;
}

my @oids = (); # The set of OIDs we care about

if ($opt{a}) {
    @oids = ('ifInOctets', 'ifInUcastPkts', 'ifInNUcastPkts', 'ifInDiscards',
	     'ifInErrors', 'ifInUnknownProtos', 'ifOutOctets', 'ifOutUcastPkts',
	     'ifOutNUcastPkts', 'ifOutDiscards', 'ifOutErrors', 'ifOutQLen');
} elsif ($opt{e}) {
    @oids = ('ifInDiscards', 'ifInErrors', 'ifInUnknownProtos', 'ifOutDiscards',
	     'ifOutErrors');
} else {
    @oids = ('ifInOctets', 'ifInUcastPkts', 'ifInNUcastPkts',
	     'ifOutOctets', 'ifOutUcastPkts', 'ifOutNUcastPkts');
}

if (@ARGV < 2) {
    exit &usage;
}
my ($pid,$eid) = (shift,shift);

my @passedPorts = @ARGV;

#
# This hash is used to create colmn headers and the format string
#
my %oids = (
    'ifInOctets'        => [['        In','    Octets'], '@>>>>>>>>>'],
    'ifInUcastPkts'     => [[' InUnicast','   Packets'], '@>>>>>>>>>'],
    'ifInNUcastPkts'    => [['InNUnicast','   Packets'], '@>>>>>>>>>'],
    'ifInDiscards'      => [['        In','  Discards'], '@>>>>>>>>>'],
    'ifInErrors'        => [['        In','    Errors'], '@>>>>>>>>>'],
    'ifInUnknownProtos' => [['   Unknown','  Protocol'], '@>>>>>>>>>'],
    'ifOutOctets'       => [['       Out','    Octets'], '@>>>>>>>>>'],
    'ifOutUcastPkts'    => [['OutUnicast','   Pakcets'], '@>>>>>>>>>'],
    'ifOutNUcastPkts'   => [[' OutNUcast','   Packets'], '@>>>>>>>>>'],
    'ifOutDiscards'     => [['       Out','  Discards'], '@>>>>>>>>>'],
    'ifOutErrors'       => [['       Out','    Errors'], '@>>>>>>>>>'],
    'ifOutQLen'         => [['  OutQueue','    Length'], '@>>>>>>>>>']
);

#
# First, make sure the experiment exists
#
if (!ExpState($pid,$eid)) {
    die "There is no experiment $eid in project $pid\n";
}

#
# Make sure they have access to it
#
if (!TBExptAccessCheck($UID,$pid,$eid,TB_EXPT_READINFO)) {
    die "You do not have permission to view experiment $pid/$eid\n";
}

snmpit_lib::init(0);

#
# Get a list of all ports in the experiment
#
my @experimentPorts = getExperimentPorts($pid,$eid);
my @ports;
if (@passedPorts) {
    #
    # Handle a set of passed-in ports
    #
    foreach my $port (@passedPorts) {
	$port =~ /^([^:]+)(:(\d+))?$/;
	my ($hostname,$portnumber) = ($1,$3);
	my $nodeid;
	if (!VnameToNodeid($pid,$eid,$hostname,\$nodeid)) {
	    die "There is no node $hostname in $pid/$eid\n";
	}

	if (defined($portnumber)) {
	    # They gave us a specific interface
	    push @ports, "$nodeid:$portnumber";
	} else {
	    # We need to find all experimental ports for this node
	    push @ports, grep(/^$nodeid:(\d+)$/,@experimentPorts);
	}

    }
} else {
    #
    # They didn't ask for specific ports, so we'll use 'em all
    #
    @ports = @experimentPorts;
}

#
# List of OIDs we want to look at for each port
#

#
# Find out which devices these ports are on
#
my %portMap = mapPortsToDevices(@ports);

my @stats;
foreach my $name (keys %portMap) {
    my @ports = @{$portMap{$name}};

    #
    # Connect to the switch and get the data we want off of it
    #
    my $type = getDeviceType($name);
    my $device;
    SWITCH: for ($type) {
	/cisco/ && do {
	    require snmpit_cisco;
	    $device = new snmpit_cisco($name);
	    last;
	};
	/intel/ && do {
	    require snmpit_intel;
	    $device = new snmpit_intel($name);
	    last;
	};

	# 'default' case
	die "Unknown switch type ($type) for $name\n";
    }
    my @results = $device->getFields(\@ports,\@oids);

    foreach my $result (@results) {
	my $port = shift @ports;

	#
	# Figure out which port on which switch this corresponds to
	#
	my $switchport = portnum($port);
	if (!($switchport && ($switchport =~ /(.+):(\d+)\.(\d+)/))) {
	    warn "WARNING: No switch port found for $port\n";
	} else {
	    my ($switch_id,$switch_card,$switch_port) = ($1, $2, $3);
	    my $dbresult = DBQueryFatal("select * from port_counters where ".
	    		"node_id='$switch_id' and card=$switch_card and ".
			"port=$switch_port");

	    my $oldresult = [@$result];

	    #
	    # Unless they want absolute counters, go through and subtract
	    # out the values stored in the database
	    #
	    if (!$opt{c}) {
		if ($dbresult && $dbresult->num_rows()) {
		    my %oldvals = $dbresult->fetchhash();
		    for (my $i = 0; $i < @oids; $i++) {
			if ($oldvals{$oids[$i]}) {
			    $result->[$i] -= $oldvals{$oids[$i]};
			}
		    }
		}
	    }

	    #
	    # If requested, update the counters in the database
	    #
	    if ($opt{z}) {
		#
		# What we do to the DB depends on whether or not there is
		# already an entry for this port
		#
		my $query;
		if ($dbresult->num_rows()) {
		    $query = "update port_counters set ";
		} else {
		    $query = "insert into port_counters set ";
		}

		my @query_terms = ();
		for (my $i = 0; $i < @oids; $i++) {
		    push @query_terms, " $oids[$i]=$oldresult->[$i] ";
		}
		$query .= join(",",@query_terms);

		if ($dbresult->num_rows()) {
		    $query .= " where node_id='$switch_id' and " .
			    "card=$switch_card and port=$switch_port";
		} else {
		    $query .= ", node_id='$switch_id', card=$switch_card, " .
			    "port=$switch_port ";
		}

		DBQueryFatal($query);
	    }
	}

	#
	# Try to translate the port name to the node's vname
	#
	$port =~ /^(.+):(\d+)/;
	if ($1) {
	    my $portnum = $2;
	    my ($junk, $vname);
	    NodeidToExp($1,\$junk,\$junk,\$vname);
	    $port = "$vname:$portnum";
	}

	#
	# Throw this onto a list, so that we can sort it
	#
	push @stats, [$port,@$result];
    }
}

#
# Exit now if they wanted quiet operation
#
if ($opt{q}) {
    exit(0);
}

#
# Build up the heading a format strings
#
my @heading1 = ('              ');
my @heading2 = ('Port          ');
my @format   = ('@<<<<<<<<<<<<<');

foreach my $line (@oids{@oids}) {
    my ($heading,$format) = @$line;
    push @heading1, $$heading[0];
    push @heading2, $$heading[1];
    push @format,   $format;
}

my $heading1 = join(" ",@heading1);
my $heading2 = join(" ",@heading2);

my $format = "format stats =\n" . join(" ",@format) . "\n";
$format .= join(",",map {"\$\$::line[$_]"} (0 .. @oids)) . "\n.\n";

eval $format;
$FORMAT_NAME = 'stats';

#
# Print out the heading
#
print "$heading1\n";
print "$heading2\n";
print "-" x length($heading1),"\n";

#
# Finally, print out the results
#
foreach $::line (sort {$$a[0] cmp $$b[0]} @stats) {
    write;
}
