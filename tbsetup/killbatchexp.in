#!/usr/bin/perl -wT
use English;
use Getopt::Std;

#
# Create a batch experiment.
#
# usage: killbatchexp $pid $eid
#
sub usage()
{
    print STDOUT "Usage: killbatchexp $pid $eid\n";
    exit(-1);
}
my  $optlist = "";

#
# Configure variables
#
my $TB       = "@prefix@";

my $tbbindir = "$TB/bin/";
my $batchdir = "$TB/batch";
my $projroot = "/proj";

#
# Untaint the path
# 
$ENV{'PATH'} = "/bin:/usr/bin";
delete @ENV{'IFS', 'CDPATH', 'ENV', 'BASH_ENV'};

#
# Turn off line buffering on output
#
$| = 1;

#
# Testbed Support libraries
# 
push(@INC, "$TB/lib");
require libtestbed;
require libdb;

#
# Parse command arguments. Once we return from getopts, all that should
# be left are the required arguments.
#
%options = ();
if (! getopts($optlist, \%options)) {
    usage();
}
if (@ARGV != 2) {
    usage();
}
my $pid = $ARGV[0];
my $eid = $ARGV[1];

#
# Untaint the arguments.
#
if ($pid =~ /^([-\@\w.]+)$/) {
    $pid = $1;
}
if ($eid =~ /^([-\@\w.]+)$/) {
    $eid = $1;
}

#
# This is where we currently hold the batch goo.
#
my $dirname = "$batchdir/$pid-$eid";

#
# Need to lock the table for this. We could avoid the locking if we just
# set the canceled bit and let the batch_daemon clean things up, but that
# introduces needless (and annoying) delay when killing a batch experiment
# that is not even running. See corresponding lock in the batch_daemon.
#
DBQueryFatal("lock tables batch_experiments write");

#
# Set the canceled state right away. This will prevent the batch_daemon
# from trying to run it. It might already be running, but thats okay.
#
DBQueryFatal("UPDATE batch_experiments set canceled=1 ".
	     "WHERE eid='$eid' and pid='$pid'");

#
# Now its safe to look at the state. If its in the "new" state, then
# all we need to do is kill the record and the directory, since the
# batch daemon will not bother with it once the canceled bit is set.
#
$query_result = 
    DBQueryFatal("SELECT status from batch_experiments ".
		 "WHERE eid='$eid' and pid='$pid'");

DBQueryFatal("unlock tables");

@row = $query_result->fetchrow_array();
$state = $row[0];

if ($state ne "new") {
    #
    # Daemon does the rest ...
    #
    print STDOUT
	"Batch Experiment $eid in project $pid is running on the testbed\n".
	"You will receive email notification when the experiment is torn\n".
	"down and you can reuse the experiment name\n";

    #
    # exit status is special. Tells the caller that cancelation is pending.
    # The web script will say something useful.
    #
    exit(1);
}

#
# Delete the DB record. LOCKING!
#
DBQueryFatal("DELETE from batch_experiments WHERE eid='$eid' and pid='$pid'");

#
# And kill the directory.
#
system("rm -rf $dirname");

#
# Lets not bother with an email message. Just print out something nice
# and tell the caller (the php script) to say something nice too).
# 
print STDOUT
    "Batch Experiment $eid in project $pid has been canceled!\n";

exit(0);
