#!/usr/bin/perl -wT

my $ping	= "/sbin/ping";
my $TB		= "/usr/testbed/bin";
my $power	= "$TB/power";
my $me		= "root";
my $dbg		= 1;
my $net		= "fxp";
my $pipe	= 1;
my $DBOSID	= "FBSD40-STD";

# Need to make sure we use the right identity file in case we're
# setuid root and $ENV{HOME} is wrong
my $identity    = "-i /root/.ssh/identity";
my $rsh		= "sshtb $identity -q";
my $ssh		= "sshtb $identity -q";
my $rcp		= "scptb $identity -q";

# Scrub environment
$ENV{PATH} = "/usr/testbed/bin:/bin:/usr/bin:/usr/local/bin";
delete @ENV{qw(IFS CDPATH ENV BASH_ENV)};

# Apparently ssh checks to see if ruid != euid, and sets eduid=ruid
# if so. So, let's let it see what it wants...
if ($> == 0) {
	$< =0;
}

my %delaynodes  = ();
my %delaylinks  = ();
my %delayparams = ();

$| = 1; #Turn off line buffering on output

#
# Set up for querying the database.
# 
use Mysql;
my $DB = Mysql->connect("localhost", "tbdb", "script", "none");

if ( $#ARGV < 0) {
    die("Usage: delay_setup <ifc_file>\n". 	
	"Sets delay node configuration from a .ir file.\n");
}

#
# Must run, effectively, as root.
# 
if ($> != 0) {
    die("This won't work unless you run as user $me\n");
}

#
# Open up the ir file.
#
if (-e "$ARGV[0]" ) {
    open(IN,$ARGV[0]) || die("Couldn't open $ARGV[0]\n");
}

my $virtsection=0;

#
# Look for the start of the VIRTUAL section. Error if not found
#
while (<IN>) {
    if ( /^start virtual/i ) { 
	$virtsection=1; 
	print STDERR "Start VIRTUAL section...\n" if $dbg;
	last;
    }
}
if ($virtsection == 0) {
    die("No VIRTUAL section in $ARGV[0]\n");
}

#
# Okay, parse the VIRTUAL section.
# 
if ($virtsection == 1) {
    #
    # Search the NODES section for delayX labels and save the name of the
    # PC operating as the delay node (tbpcX).
    # 
    while (<IN>) {
	if ( /^start nodes/i ) { 
	    print STDERR "Start NODES section...\n" if $dbg;
	    next;
	}
	elsif ( /^end nodes/i ) {
	    print STDERR "End NODES section...\n" if $dbg;
	    last;
	}
	my ($node,$pc) = split();
	if ($node =~ /^delay/) {
	    print STDERR "$node $pc\n" if $dbg;

	    # We can safely untaint these variables
	    if (!($node =~ /^(\w+\d*)$/)) {
		die "Unexpected data in \$node : $node\n";
	    } else {
		$node = $1;
	    }
	    if (!($pc =~ /^(\w+\d*)$/)) {
		die "Unexpected data in \$pc : $pc\n";
	    } else {
		$pc = $1;
	    }

	    $delaynodes{$node} = $pc;
	}
    }

    #
    # Just record all the links for now. We will correlate them later.
    # 
    while (<IN>) {
	if ( /^start links/i ) { 
	    print STDERR "Start LINKS section...\n" if $dbg;
	    next;
	}
	elsif ( /^end links/i ) {
	    print STDERR "End LINKS section...\n" if $dbg;
	    last;
	}
	chop;
	#
	# Just record all the links for now.
	#
	my ($link,$rest) = split(' ', $_, 2);
	$delaylinks{$link} = [ split(' ', $rest) ];
    }
}

foreach my $link ( keys %delaylinks ) {
    my $rest = $delaylinks{$link};
    print STDERR "$link @{ $rest }\n" if $dbg;
}

#
# Skip to the end of the VIRTUAL section. Not really needed ...
# 
while (<IN>) {
    if ( /^end virtual/i ) { 
	$virtsection=0; 
	print STDERR "End VIRTUAL section...\n" if $dbg;
	last;
    }
}

#
# Now find the DELAY section.
#
while (<IN>) {
    if ( /^start delay/i ) { 
	print STDERR "Start DELAY section...\n" if $dbg;
	last;
    }
}

#
# Parse the DELAY section till it ends.
#
while (<IN>) {
    if ( /^end delay/i ) { 
	print STDERR "End DELAY section...\n" if $dbg;
	last;
    }

    chop;
    my ($link, $node, $bandw, $delay) = split();
    print STDERR "$link $node $bandw $delay\n" if $dbg;
    $delayparams{$link} = [ $node, $bandw, $delay ];
}

close(IN);

#
# First, check to make sure that each delay node is up and running the
# correct OS (FreeBSD). We get all the nodes rebooted at once, and then
# wait to start running the delay configuration setup stuff.
#
foreach my $link ( keys %delayparams ) {
    my $node  = $delayparams{$link}[0];
    my $pc    = $delaynodes{$node};


    #
    # database goo. We check to make sure the default image is set to
    # FreeBSD, and reset it if not. 
    #
    my $cmd = "select def_boot_image_id from nodes where node_id='$pc'";
    my $sth = $DB->query($cmd);
    my @row = $sth->fetchrow_array();
    print STDERR "$pc is currently set to OS = $row[0]\n" if $dbg;
    if ($row[0] ne $DBOSID) {
	print STDERR "Changing default OS for $pc to $DBOSID\n";
	$cmd = "update nodes set def_boot_image_id='$DBOSID' ";
	$cmd = "$cmd where node_id='$pc'";
	$sth = $DB->query($cmd);
	if ($sth == 0) {
	    die("Database update failed. Aborted...\n");
	}
    }

    #
    # See if the machine is pingable. If its not pingable, then
    # we just power cycle the machine rather than wait for a bunch
    # of ssh/rsh commands to time out.
    #
    print STDERR "Pinging $pc ... \n" if $dbg;
    if (-e $ping) {
	open(PING, "$ping -c 4 $pc 2>&1 |");
    }
    else {
	die("PING command $ping not found!\n");
    }
    do {
    }
    until ( <PING> =~ /transmitted, (\d*) packets received/ );
    close(PING);
    print STDERR "Got back $1 ping packets from $pc.\n" if $dbg;

    #
    # Power cycle if the machine is dead. It will come back up with the
    # proper OS, cause we modified the database above.
    #
    if ( $1 == 0 ) {
	print STDERR "$pc appears to be dead. Power cycling ... ";
	PowerCycle($pc);
	print STDERR "Done!\n";
    }

    #
    # Machine is up. See if its already running the proper OS so that we can
    # avoid a reboot.
    #
    open(UNAME, "$rsh $pc uname -a 2>&1 |");
    $_ = <UNAME>;
    close(UNAME);
    my $OS = "Unknown";    
    if ( $_ ) {
	@temp = split(" ",$_);
	$OS = $temp[0];
    }
    if ( $OS eq "FreeBSD" ) {
	print STDERR "$pc appears to be running the correct OS\n";
	next;
    }

    #
    # Time to reboot or power cycle. 
    # 
    print STDERR "Rebooting $pc cause its not running the correct OS\n";

    if (system("$ssh -l root $pc /sbin/reboot") == 0) {
	printf STDERR "$pc appears to be rebooting\n" if $dbg;
	#
	# Wait for it to really die so we are sure, and to avoid problems
	# with WaitTillAlive down below.
	# 
	if (WaitTillDead($pc) == 0) {
	    next;
	}
	printf STDERR "Hmm, maybe not. $pc is still alive\n" if $dbg;
    }

    #
    # Okay, before we power cycle lets really make sure. On FreeBSD, it might
    # have rebooted, but since the connection is terminated, system returns
    # an error status. So, lets ping it again and if its pingable, the
    # reboot must have failed. If it is not pingable, I assume that the
    # reboot really worked, and the exit value can be ignored.
    #
    my $exit_value = $? >> 8;
    print STDERR "reboot returned $exit_value. Lets make sure it dies\n"
	if $dbg;

    if (WaitTillDead($pc) == 0) {
	next;
    }
	
    print STDERR "$pc appears to still be running Power cycling ...\n";
    PowerCycle($pc);
}

#
# Okay, got everything we need. Generate some script files 
#
foreach my $link ( keys %delayparams ) {
    my $node  = $delayparams{$link}[0];
    my $bandw = $delayparams{$link}[1];
    my $delay = $delayparams{$link}[2];
    my $pc    = $delaynodes{$node};
    my $cards = ();

    print STDERR "$link, $node, $pc, $bandw, $delay\n" if $dbg;

    foreach my $pclink ( @{ $delaylinks{$link} } ) {
	if ($pclink =~ /$pc/) {
	    $_ = $pclink;
	    s/$pc-/$net/g;
	    $pclink = $_;
	    push @cards, $pclink;
	}
    }
    my $iface1 = $cards[0];		# Okay, fxp0
    my $iface2 = $cards[1];		# Okay, fxp1
    my $fname  = "/tmp/delayconfig_${pc}_$$";
    
    open(TEMP, "> $fname");
    print TEMP "sysctl -w net.link.ether.bridge=0\n";
    print TEMP "sysctl -w net.link.ether.bridge_ipfw=0\n";
    print TEMP "sysctl -w net.link.ether.bridge_cfg=fxp4:6,";
    print TEMP "$iface1:69,$iface2:69,\n";
    print TEMP "sysctl -w net.link.ether.bridge=1\n";
    print TEMP "sysctl -w net.link.ether.bridge_ipfw=1\n";

    #
    # Try to form unqiue pipe numbers, since at some point I'll have
    # to deal with one node doing two delays,
    # 
    my $p1 = $pipe++;
    my $p2 = $pipe++;

    print TEMP "ipfw -f flush\n";
    print TEMP "ipfw add pipe $p1 ip from any to any in recv $iface1\n";
    print TEMP "ipfw add pipe $p2 ip from any to any in recv $iface2\n";
    print TEMP "ipfw pipe $p1 config delay ${delay}ms bw ${bandw}Mbit/s\n";
    print TEMP "ipfw pipe $p2 config delay ${delay}ms bw ${bandw}Mbit/s\n";
    print TEMP "echo \"Delay Configuration Complete\"\n";
    
    close(TEMP);

    if ($dbg) {
	system("cat $fname");
    }

    #
    # Wait for it to be pingable again
    # 
    if (WaitTillAlive($pc)) {
	die("Oops, $pc did not come back alive!");
    }

    #
    # Copy the file over to the target machine.
    #
    my $tries=0;
    my $max_tries=5;
    my $interval=5;
    while (system("$rcp $fname $pc:/etc/rc.delayconfig") && 
	   ($tries < $max_tries)) {
        $tries++;
        print STDERR "Remote Copy to $pc failed... Waiting and retrying...\n";
	# Sleep $interval seconds longer each time
	# Waits in total ($max_tries)! * $interval
	# seconds after its pingable before giving up
	sleep ($interval*$tries); 
    }
    if ($tries>=$max_tries) {
	die("Error copying delay config file to $pc\n");
    }
    unlink($fname);

    #
    # Now run the config script on the target. We look for the echo
    # at the end of the script that says it completed okay (See above).
    # The script generated above needs to be changed so that it terminates
    # early if one of the commands fails, but I have not done that yet.
    # 
    open(CONFIG, "$rsh $pc sh /etc/rc.delayconfig 2>&1 |");
    while ( $_ = <CONFIG> ) {
	if ( $_ =~ /Complete/ ) {
	    close(CONFIG);
	    goto FIGGED;
	}
    }
    die("Problem running configuration script on delay node $pc.\n");
FIGGED:
    print STDERR "Wow! Delay node $pc configured okay!\n" if $dbg;
}

print STDERR "Done!\n";
exit 0;

#
# Power cycle a PC using the testbed power program.
#
sub PowerCycle {
    local($pc) = @_;

    if (system("$power cycle $pc") != 0) {
	die("Could not power cycle $pc! Quitting\n");
    }
}

sub WaitTillAlive {
    local($pc) = @_;

    print STDERR "Waiting for $pc to come alive\n" if $dbg;
    #
    # Sigh, a long ping results in the script waiting until all the
    # packets are sent from all the pings, before it will exit. So,
    # loop doing a bunch of shorter pings.
    #
    for ($i = 0; $i < 30; $i++) {
	open(PING, "$ping -c 5 $pc 2>&1 |");
	do {
	    $_ = <PING>;
	    if ( $_ =~ /bytes from/ ) {
		print STDERR "Yep, $pc alive and well\n" if $dbg;
		return 0;
	    }
	}
	until ( $_ =~ /transmitted, (\d*) packets received/ );
    }
    close(PING);
    print STDERR "$pc is not responding. Better check into it\n";
    return 1;
}

sub WaitTillDead {
    local($pc) = @_;

    print STDERR "Waiting for $pc to die off\n" if $dbg;
    #
    # Sigh, a long ping results in the script waiting until all the
    # packets are sent from all the pings, before it will exit. So,
    # loop doing a bunch of shorter pings.
    #
    for ($i = 0; $i < 12; $i++) {
	open(PING, "$ping -c 5 $pc 2>&1 |");
	do {
	}
	until ( <PING> =~ /transmitted, (\d*) packets received/ );

	if ( $1 == 0 ) {
	    print STDERR "Good, $pc must have rebooted.\n" if $dbg;
	    return 0;
	}
    }
    close(PING);
    print STDERR "$pc is still alive.\n" if $dbg;
    return 1;
}

