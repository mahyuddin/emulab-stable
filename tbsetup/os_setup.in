#!/usr/bin/perl -wT
use English;
use Getopt::Std;
require 'ctime.pl';

#
# Reboot the nodes in an experiment. The nodes table will already contain
# all the information. This script deals with possible disk reloading,
# rebooting, and waiting for nodes to come back alive before allowing
# experiment creation to continue.
#
# TODO: Reload disk images.
# 
# usage: os_setup <pid> <eid>
#
sub usage()
{
    print STDOUT "Usage: os_setup <pid> <eid>\n";
    exit(-1);
}
my  $optlist = "";

#
# Configure variables
#
my $TB		= "@prefix@";
my $DBNAME	= "@TBDBNAME@";
my $TBOPS       = "@TBOPSEMAIL@";
my $TFTP	= "/tftpboot";

my $nodereboot	= "$TB/bin/node_reboot";
my $ping	= "/sbin/ping";
my $dbg		= 0;
my @nodes       = ();
my %osid        = ();
my %waitfor     = ();
my @row;

#
# This stuff is BOGUS! Quick hack for paper deadline to make Jay happy.
# If Frisbee works, this might be appropriate.
#
my $doreloading = 0;
my $forcereload = 0;
my %reload      = ();
my $osload	= "$TB/bin/os_load";
    
# un-taint path
$ENV{'PATH'} = '/bin:/usr/bin:/usr/local/bin';
delete @ENV{'IFS', 'CDPATH', 'ENV', 'BASH_ENV'};

$| = 1; #Turn off line buffering on output

#
# Testbed Support library
# 
push(@INC, "$TB/lib");
require libtestbed;

#
# Parse command arguments. Once we return from getopts, all that should be
# left are the required arguments.
#
%options = ();
if (! getopts($optlist, \%options)) {
    usage();
}
if (@ARGV != 2) {
    usage();
}
my $pid = $ARGV[0];
my $eid = $ARGV[1];

#
# Untaint args.
#
if ($pid =~ /^([-\@\w]+)$/) {
    $pid = $1;
}
else {
    die("Bad data in pid: $pid.");
}
if ($eid =~ /^([-\@\w]+)$/) {
    $eid = $1;
}
else {
    die("Bad data in eid: $eid.");
}

#
# Set up for querying the database.
# 
use Mysql;
my $DB = Mysql->connect("localhost", $DBNAME, "script", "none");

#
# Figure out who called us. Only root, people with admin status
# in the DB, or the owner of the experiment can run this script.
#
$db_result = $DB->query("select expt_head_uid from experiments ".
			"where eid='$eid' and pid='$pid'");
if ($db_result->numrows < 1) {	
  die("There is no experiment '$eid' in project '$pid'.\n");
}

if ($UID != 0) {
    my ($me) = getpwuid($UID)
	or die "$UID not in passwd file";

    @row = $db_result->fetchrow_array();
    if ($row[0] ne "$me") {
	print STDERR "Checking for admin status ...\n" if $dbg;
	$db_result = $DB->query("select admin from users where uid='$me'");
        @row = $db_result->fetchrow_array();
	if ($row[0] != 1) {
	    die("os_setup: You must be root or a TB administrator\n");
	}
    }
}

#
# Get the set of nodes, as well as the nodes table information for them.
#
$db_result = $DB->query("select * from nodes left join reserved on ".
			"nodes.node_id=reserved.node_id ".
			"where reserved.pid='$pid' and reserved.eid='$eid'");
if ($db_result->numrows < 1) {	
    die("There are no nodes assigned to experiment '$eid' in project '$pid'.");
}

for ($i = 0; $i < $db_result->numrows; $i++) {
    my %row  = $db_result->fetchhash();
    my $node = $row{'node_id'};

    push(@nodes, $node);
    $osid{$node} = $row{'def_boot_osid'};

    #
    # Make sure the files specified in the paths exist. We mount the
    # user tftp directory on boss node, so we can ignore the IP address,
    # and just check the path directly. 
    #
    if (defined($row{'def_boot_path'})) {
	my $path = $row{'def_boot_path'};

	if ($path ne "") {
	    my $ip   = 0;

	    # Split out IP address if it exists.
	    if ($path =~ /^([0-9\.]+):(\/.*)$/) {
		$ip   = $1;
		$path = $2;
	    }

	    # Path must begin with $TFTP
	    if (! ($path =~ /^\/$TFTP\//)) {
		die("File $path for node $node must reside in $TFTP\n");
	    }

	    if (! -e $path) {
		die("File $path for node $node does not exist!");
	    }
	}
    }
    if (defined($row{'next_boot_path'})) {
	my $path = $row{'next_boot_path'};

	if ($path ne "") {
	    my $ip   = 0;

	    # Split out IP address if it exists.
	    if ($path =~ /^([0-9\.]+):(\/.*)$/) {
		$ip   = $1;
		$path = $2;
	    }

	    # Path must begin with $TFTP
	    if (! ($path =~ /^\/$TFTP\//)) {
		die("File $path for node $node must reside in $TFTP\n");
	    }

	    if (! -e $path) {
		die("File $path for node $node does not exist!");
	    }
	}
    }

    #
    # XXX - Check for existence of the delta files. We do this here
    # cause its easier than looking for a failure later, when the node
    # tries to install the delta. Not a general solution though. Needs
    # more thought.
    #
    foreach my $delta (split(":", $row{'deltas'})) {
	if (! -e $delta) {
	    die("Delta file $delta for node $node does not exist!");
	}
    }
    #
    # XXX - Ditto for RPMs.
    #
    foreach my $rpm (split(":", $row{'rpms'})) {
	if (! -e $rpm) {
	    die("RPM $rpm for node $node does not exist!");
	}
    }
    
    #
    # XXX - Ditto for tarfiles.
    #
    foreach my $tarspec (split(":", $row{'tarballs'})) {
	my ($dir, $tar) = split(" ", $tarspec);
	
	if (! -e $tar) {
	    die("Tarfile $tar for node $node does not exist!");
	}
    }
    
    #
    # If pingable, then the node is "waitable".
    #
    if (OSFeatureSupported($osid{$node}, "ping")) {
	$waitfor{$node} = 1;
    }
    else {
	$waitfor{$node} = 0;
    }
    print STDOUT "$node - $osid{$node} - $waitfor{$node}\n" if $dbg;
}

#
# Fire off a mass reboot. The reboot script does this in parallel, so
# no need to create any new children here. We just wait until it exits,
# which means all the nodes are actually rebooting.
#
if (system("$nodereboot @nodes")) {
    die("Failed to reboot some nodes!");
}

print STDOUT "Waiting for testbed nodes to finish rebooting ...\n";

my $waitstart = time;

#
# Now lets wait for them to come back alive.
#
foreach my $node ( @nodes ) {
    #
    # Don't bother to wait for nodes that are running foreign OSs since
    # we are not going to deal with them anyway later in the process.
    #
    if ($waitfor{$node} == 0) {
	print STDOUT "Not waiting for $node to come alive. Foreign OS.\n";
	next;
    }	

    if (WaitTillAlive($node) == 0) {
	print STDOUT "$node is alive and well\n";
	next;
    }

    print STDOUT "$node may be down. This has been reported to testbed-ops.\n";
    print STDOUT "Please end this experiment, and try again.\n";
    
    # Reserve it to testbed down

    $cmd = "update reserved set pid='testbed',eid='down' ".
      "where eid='$eid' and pid='$pid' and node_id='$node'";
    print "Using '$cmd'\n" if $dbg;
    $db_result = $DB->query($cmd) 
      || print STDERR "WARNING: Couldn't change reservation:".
	$DB->errmsg."\n";
    if ($db_result->num_rows < 1 ) {
      print STDERR "WARNING: Couldn't change reservation!\n";
    }

    # Send mail to testbed-ops about it
    SENDMAIL($TBOPS, "TESTBED: Node $node is down",
	     "User ".getpwuid($UID)." was running expt. $eid\n".
	     "in proj. $pid using ir file /proj/$pid/exp/$eid/tbdata\n".
	     "but $node appears to be unresponsive.\n\n".
	     "Please look into this matter. $node has been reserved to\n".
	     "the testbed/down experiment until this has been resolved.\n\n".
	     "Thanks,\n");
    
    die("Oops, $node did not come back alive!\n");
}

print STDOUT "OS Setup Done!\n";
exit 0;

#
# Wait for a node to come back alive.
# 
sub WaitTillAlive {
    my ($pc) = @_;

    print STDERR "Waiting for $pc to come alive\n" if $dbg;
    
    #
    # Eight minutes seems like a long time to wait, but it ain't!
    # 
    my $maxwait = (60 * 3);
    if ($reload{$pc}) {
	$maxwait += (60 * 5);
    }

    #
    # Start a counter going, relative to the time we rebooted the first
    # node. 
    # 
    my $waittime  = 0;
    my $minutes   = 0;

    #
    # Sigh, a long ping results in the script waiting until all the
    # packets are sent from all the pings, before it will exit. So,
    # loop doing a bunch of shorter pings.
    #
    while (1) {
	system("$ping -q -c 4 -t 4 $pc >/dev/null 2>&1");
	$status = $? >> 8;

	#
	# Returns 0 if any packets are returned. Returns 2 if pingable
	# but no packets are returned. Other non-zero error codes indicate
	# other problems.  Any non-zero return indicates "not pingable" to us.
	# 
	if (! $status) {
	    print STDERR "$pc alive and well\n" if $dbg;
	    return 0;
	}
	$waittime = time - $waitstart;
	if ($waittime > $maxwait) {
	    print "$pc appears dead; its been ",
	    (int ($waittime / 60))," minutes since reload started.\n";
	    return 1;
	}
	if (int($waittime / 60) > $minutes) {
	    $minutes = int($waittime / 60);
	    print "Still waiting for $pc - its been $minutes minute(s)\n";
	}
    }
}

sub OSFeatureSupported {
    local($os)      = $_[0];
    local($feature) = $_[1];
    local($db_result);

    $db_result = $DB->query("select osfeatures from os_info where osid='$os'");

    if ($db_result->numrows < 1) {
	return 0;
    }
    foreach $osfeature (split(',', $db_result->fetchrow_array())) {
	if ($feature eq $osfeature) {
	    return 1;
	}
    }
    return 0;
}
