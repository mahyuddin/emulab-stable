#!/usr/bin/perl -wT
use English;

#
# TODO: Database checks for valid OS image in IR file.
#       Delta stuff.
#       Reload disk images.
#

#
# Parse an IR file and determine what OS has been requested on each node.
# Do the database magic to make it so. Only root, admin types, or the
# owners of the nodes in an experiments may do this. The machines are then
# rebooted (or power cycled).
# 
# usage: os_setup <pid> <eid> <ir_file>
#
my $rsh		= "sshtb -q";
my $ssh		= "sshtb -q";
my $TB		= "/usr/testbed/bin";
my $power	= "$TB/power";
my $ping	= "/sbin/ping";
my $dbg		= 1;
my %nodeos      = ();
my $SAVEUID	= $UID;

# un-taint path
$ENV{'PATH'} = '/bin:/usr/bin:/usr/local/bin';
delete @ENV{'IFS', 'CDPATH', 'ENV', 'BASH_ENV'};

$| = 1; #Turn off line buffering on output

#
# Set up for querying the database.
# 
use Mysql;
my $DB = Mysql->connect("localhost", "tbdb", "script", "none");

if ( $#ARGV != 2) {
    die("Usage: os_setup <pid> <eid> <ir_file>\n". 	
	"Sets node PS configuration from a .ir file.\n");
}
my $pid = $ARGV[0];
my $eid = $ARGV[1];
my $ir  = $ARGV[2];

#
# Figure out who called us. Only root, tbroot, people with admin status
# in the DB, or the owner of the experiment can run this script.
#
if ($UID != 0) {
    my ($me) = getpwuid($UID)
	or die "$UID not in passwd file";

    $db_result = $DB->query("select expt_head_uid from experiments ".
			    "where eid='$eid' and pid='$pid'");
    if ($db_result->numrows < 1) {	
	die("There is no experiment '$eid' in project '$pid'.\n");
    }
    my @row = $db_result->fetchrow_array();
    if ($row[0] ne "$me") {
	print STDOUT "Checking for admin status ...\n" if $dbg;
	$db_result = $DB->query("select admin from users where uid='$me'");
        my @row = $db_result->fetchrow_array();
	if ($row[0] != 1) {
	    die("mkprojdir: You must be root or a TB administrator\n");
	}
    }
}

#
# Open up the ir file.
#
if (-e "$ir") {
    open(IN, $ir) || die("Couldn't open $ir\n");
}
else {
    die("Couldn't open $ir\n");
}

#
# Look for the start of the OS section. Exit if not found
#
my $ossection=0;

while (<IN>) {
    if ( /^start os/i ) { 
	$ossection=1; 
	print STDERR "Start OS section...\n" if $dbg;
	last;
    }
}
if ($ossection == 0) {
    die("No OS section in $ir\n");
}

#
# Okay, parse the OS section.
# 
# Search the NODES section for OS labels. Consult the database to make
# sure the node specified in the IR file is really in the pid/eid that
# was given on the command line. 
# 
while (<IN>) {
    if ( /^start nodes/i ) { 
	print STDERR "Start NODES section...\n" if $dbg;
	next;
    }
    elsif ( /^end nodes/i ) {
	print STDERR "End NODES section...\n" if $dbg;
	last;
    }
    my ($node,$os) = split();
    print STDERR "$node $os\n" if $dbg;
    $nodeos{$node} = $os;

    $db_result = $DB->query("select pid,eid from reserved ".
			    "where node_id='$node'");
    if ($db_result->numrows < 1) {	
	die("There is no node '$node' in the DB.\n");
    }
    my @row = $db_result->fetchrow_array();
    if ($row[0] ne "$pid" ||
	$row[1] ne "$eid") {
	die("Node '$node' pid/eid mismatch: $pid/$eid ... $row[0]/$row[1]\n");
    }

    #
    # Check to make sure that the OS spec is valid by checking the database.
    # Cross check type from nodes table against image_ids for that type in
    # the disk_images table. 
    #
    $db_result = $DB->query("select disk_images.image_id from disk_images ".
			    "left join nodes ".
			    "on nodes.type=disk_images.type ".
			    "and disk_images.image_id='$os' ".
                            "where nodes.node_id='tbpc09'");
    if ($db_result->numrows < 1) {	
	die("Improper image specification $node:$os in IR file.\n");
    }
}

#
# Lifted right out of delay_setup.
# 
foreach my $node ( keys %nodeos ) {
    my $pc	= $node;
    my $os	= $nodeos{$node};

    #
    # database goo. We check to make sure the default image is set correctly
    # and reset it if not. 
    #
    my $cmd = "select def_boot_image_id from nodes where node_id='$pc'";
    my $sth = $DB->query($cmd);
    my @row = $sth->fetchrow_array();
    print STDERR "$pc is currently set to OS = $row[0]\n" if $dbg;
    if ($row[0] ne $os) {
	print STDERR "Changing default OS for $pc to $os\n";
	$cmd = "update nodes set def_boot_image_id='$os' ";
	$cmd = "$cmd where node_id='$pc'";
	$sth = $DB->query($cmd);
	if ($sth == 0) {
	    die("Database update failed. Aborted...\n");
	}
    }

    #
    # See if the machine is pingable. If its not pingable, then
    # we just power cycle the machine rather than wait for a bunch
    # of ssh/rsh commands to time out.
    #
    print STDERR "Pinging $pc ... \n" if $dbg;
    if (-e $ping) {
	open(PING, "$ping -c 4 $pc 2>&1 |");
    }
    else {
	die("PING command $ping not found!\n");
    }
    do {
    }
    until ( <PING> =~ /transmitted, (\d*) packets received/ );
    close(PING);
    print STDERR "Got back $1 ping packets from $pc.\n" if $dbg;

    #
    # Power cycle if the machine is dead. It will come back up with the
    # proper OS, cause we modified the database above.
    #
    if ( $1 == 0 ) {
	print STDERR "$pc appears to be dead. Power cycling ...\n";
	PowerCycle($pc);
	print STDERR "Done!\n";
	next;
    }

    #
    # Machine is pingable at least. Try to reboot it gracefully,
    # or power cycle anyway if that does not work. To this, we must
    # change our real UID to root so that ssh will work.
    #
    print STDERR "Rebooting $pc ...\n";
    
    $UID = 0;
    if (system("$ssh -l root $pc /sbin/reboot") == 0) {
	$UID = $SAVEUID;
	print STDERR "$pc appears to be rebooting\n" if $dbg;
	next;
    }
    $UID = $SAVEUID;

    #
    # Okay, before we reboot lets really make sure. On FreeBSD, it might
    # have rebooted, but since the connection is terminated, system returns
    # an error status. So, lets ping it again and if its pingable, the
    # reboot must have failed. If it is not pingable, I assume that the
    # reboot really worked, and the exit value can be ignored.
    #
    my $exit_value = $? >> 8;
    print STDERR "reboot returned $exit_value. Lets make sure ...\n" if $dbg;

    print STDERR "Sleeping for a few seconds to give reboot a chance ...\n";
    sleep(10);
    if (-e $ping) {
	open(PING, "$ping -c 4 $pc 2>&1 |");
    }
    else {
	die("PING command $ping not found!\n");
    }
    do {
    }
    until ( <PING> =~ /transmitted, (\d*) packets received/ );
    close(PING);
    print STDERR "Got back $1 ping packets from $pc.\n" if $dbg;

    if ( $1 == 0 ) {
	print STDERR "Good, $pc must have rebooted. Continuing ...\n" if $dbg;
	next;
    }
	
    print STDERR "$pc appears to still be running Power cycling ...\n";
    PowerCycle($pc);
    print STDERR "Done!\n";
}

print STDOUT "OS Setup Done!\n";
exit 0;

#
# Power cycle a PC using the testbed power program.
#
sub PowerCycle {
    local($pc) = @_;

    if (system("$power cycle $pc") != 0) {
	print STDERR "WARNING: Could not power cycle $pc. Skipping ...\n";
    }
}

