#!/usr/bin/perl -wT
#
# EMULAB-COPYRIGHT
# Copyright (c) 2005, 2006 University of Utah and the Flux Group.
# All rights reserved.
#
# XXX Need to deal with locking at some point ...
#
package libTemplates;

use strict;
use Exporter;
use vars qw(@ISA @EXPORT);

@ISA    = "Exporter";
@EXPORT = qw ( );

# Must come after package declaration!
use lib '@prefix@/lib';
use libdb;
use libtestbed;
use libtblog;
use English;

# Configure variables
my $TB		= "@prefix@";
my $MD5         = "/sbin/md5";

#
# Grab a new GUID for a template. We do not have to use it of course.
#
sub NewGUID($)
{
    my ($pidx) = @_;
    my $idx;
    
    DBQueryFatal("lock tables emulab_indicies write");

    my $query_result = 
	DBQueryFatal("select idx from emulab_indicies ".
		     "where name='next_guid'");
	
    if (! $query_result->num_rows) {
	$idx = 10000;
	
	DBQueryFatal("insert into emulab_indicies (name, idx) ".
		     "values ('next_guid', $idx)");
    }
    else {
	($idx) = $query_result->fetchrow_array();
    }
    my $nextidx = $idx + 1;
    
    DBQueryFatal("update emulab_indicies set idx='$nextidx' ".
		 "where name='next_guid'");

    DBQueryFatal("unlock tables");

    $$pidx = $idx;
    return 0;
}

#
# Check for valid template.
#
sub TBValidExperimentTemplate($$)
{
    my ($guid, $version) = @_;

    my $query_result =
	DBQueryFatal("select guid from experiment_templates ".
		     "where guid='$guid' and vers='$version'");

    return $query_result->num_rows;
}

#
# Template permission checks. Using the experiment access check stuff!
#
# Usage: TBExptTemplateAccessCheck($uid, $guid, $access_type)
#	 returns 0 if not allowed.
#        returns 1 if allowed.
#
sub TBExptTemplateAccessCheck($$$)
{
    my ($uid, $guid, $access_type) = @_;
    my $mintrust;

    if ($access_type < TB_EXPT_MIN ||
	$access_type > TB_EXPT_MAX) {
	die("*** Invalid access type: $access_type!");
    }

    #
    # Admins do whatever they want!
    #
    if (TBAdmin($uid)) {
	return 1;
    }
    $uid = MapNumericUID($uid);

    my $query_result =
	DBQueryFatal("select pid,gid from experiment_templates where ".
		     "guid='$guid' limit 1");
    
    if ($query_result->numrows == 0) {
	return 0;
    }
    my @row = $query_result->fetchrow_array();
    my $pid = $row[0];
    my $gid = $row[1];

    #
    # An experiment may be destroyed by the experiment creator or the
    # project/group leader.
    #
    if ($access_type == TB_EXPT_READINFO) {
	$mintrust = PROJMEMBERTRUST_USER;
    }
    else {
	$mintrust = PROJMEMBERTRUST_LOCALROOT;
    }

    #
    # Either proper permission in the group, or group_root in the project.
    # This lets group_roots muck with other people's experiments, including
    # those in groups they do not belong to.
    #
    return TBMinTrust(TBGrpTrust($uid, $pid, $gid), $mintrust) ||
	TBMinTrust(TBGrpTrust($uid, $pid, $pid), PROJMEMBERTRUST_GROUPROOT);
}

#
# Create a new template record from the args provided. We assume that
# the table is locked by the caller. 
#
# Usage: int NewTemplateRecord(\%args)
#
sub NewTemplateRecord($)
{
    my ($args) = @_;

    my $query = "insert into experiment_templates set ".
	join(",", map("$_='" . $args->{$_} . "'", keys(%{$args})));

    # Append some default value stuff.
    $query .= ",created=now()";

    return -1
	if (! DBQueryWarn($query));
    return 0;
}

#
# Update a template record
#
sub UpdateTemplateRecord($$$)
{
    my ($guid, $vers, $args) = @_;

    my $query = "update experiment_templates set ".
	join(",", map("$_='" . $args->{$_} . "'", keys(%{$args})));

    $query .= " where guid='$guid' and vers='$vers'";

    return -1
	if (! DBQueryWarn($query));
    return 0;
}

#
# Delete a template (all tables).
#
sub DeleteTemplateRecord($$)
{
    my ($guid, $vers) = @_;

    DeleteTemplateMetadata($guid, $vers) == 0
	or return -1;

    # Make sure the experiment_templates table is always last, in case
    # something goes wrong. 
    my @tables = ("experiment_templates", "experiment_template_parameters");

    foreach my $table (@tables) {
        if ($table eq "experiment_templates") {
            DBQueryFatal("delete from $table ".
                         "where guid='$guid' and vers='$vers'");
        }
        else {
            DBQueryFatal("delete from $table ".
                         "where parent_guid='$guid' and parent_vers='$vers'");
        }
    }
}

#
# Create a new template instance record from the args provided. 
#
# Usage: int NewTemplateInstanceRecord(\%args, \$idx)
#
sub NewTemplateInstanceRecord($$)
{
    my ($args, $pidx) = @_;

    my $query = "insert into experiment_template_instances set ".
	join(",", map("$_='" . $args->{$_} . "'", keys(%{$args})));

    my $query_result = DBQueryWarn($query);
    return -1
	if (! $query_result);

    # Grab the insert record.
    $$pidx = $query_result->insertid;
    return 0;
}

#
# Delete a template instance record.
#
sub DeleteTemplateInstanceRecord($$$)
{
    my ($guid, $vers, $idx) = @_;

    #
    # Delete the run records first since they will not mean much after
    # this record is gone.
    #
    my $query_result =
	DBQueryWarn("select exptidx from experiment_template_instances ".
		    "where parent_guid='$guid' and parent_vers='$vers' and ".
		    "      idx='$idx'");

    return -1
	if (!$query_result);

    while (my ($exptidx) = $query_result->fetchrow_array()) {
	DBQueryWarn("delete from experiment_run_bindings ".
		    "where exptidx='$exptidx'")
	    or return -1;

	DBQueryWarn("delete from experiment_runs ".
		    "where exptidx='$exptidx'")
	    or return -1;
    }

    #
    # Also delete the binding records for the instance.
    #
    DeleteTemplateInstanceBindingRecords($guid, $vers, $idx) == 0
	or return -1;

    # And finally the instance record.
    DBQueryWarn("delete from experiment_template_instances ".
		"where parent_guid='$guid' and parent_vers='$vers' and ".
		"      idx='$idx'")
	or return -1;

    return 0;
}

#
# Finalize a template instance record; usage is similar to above
#
# Usage: int FinalizeTemplateInstanceRecord($guid, $vers, $exptidx, \%args)
#
sub FinalizeTemplateInstanceRecord($$$;$)
{
    my ($guid, $vers, $idx, $args) = @_;

    #
    # Get the runidx and do it first.
    #
    my $runidx;
    my $exptidx;
    return -1
	if (TemplateInstanceInfo($idx, \$runidx, undef, \$exptidx) < 0);

    if (defined($runidx)) {
	return -1
	    if (FinalizeTemplateExerimentRunRecord($exptidx, $runidx) < 0);
    }

    my $query = "update experiment_template_instances set stop_time=now() ";

    if (defined($args) && scalar(keys%{$args})) {
	$query .= ",";
	$query .= join(",", map("$_='" . $args->{$_} . "'", keys(%{$args})));
    }
    $query .= " where parent_guid='$guid' and parent_vers='$vers' and ".
	      "       idx='$idx'";

    return -1
	if (! DBQueryWarn($query));
    return 0;
}

#
# Update an instance record.
#
sub UpdateTemplateInstanceRecord($$$$$)
{
    my ($guid, $vers, $idx, $start_time, $args) = @_;

    my $query = "update experiment_template_instances set ";

    $query .= "start_time=now() "
	if ($start_time);

    if (defined($args) && scalar(keys%{$args})) {
	$query .= ","
	    if ($start_time);
	
	$query .= join(",", map("$_='" . $args->{$_} . "'", keys(%{$args})));
    }
    $query .= " where parent_guid='$guid' and parent_vers='$vers' and ".
	      "       idx='$idx'";

    return -1
	if (! DBQueryWarn($query));
    return 0;
}

#
# Get info about a template run.
#
sub TemplateInstanceInfo($$;$$)
{
    my ($idx, $prunidx, $peid, $pidx) = @_;

    my $query_result =
	DBQueryWarn("select eid,runidx,exptidx ".
		    "  from experiment_template_instances ".
		    "where idx='$idx'");

    return -1
	if (! $query_result);

    my ($eid,$runidx,$exptidx) = $query_result->fetchrow_array();
    $$prunidx = $runidx;
    $$peid    = $eid
	if (defined($peid));
    $$pidx    = $exptidx
	if (defined($pidx));
    return 0;
}

sub TemplateInstanceInfoByExptidx($$;$$)
{
    my ($exptidx, $prunidx, $peid, $pidx) = @_;

    my $query_result =
	DBQueryWarn("select eid,runidx,idx ".
		    "  from experiment_template_instances ".
		    "where exptidx='$exptidx'");

    return -1
	if (! $query_result);

    my ($eid,$runidx,$idx) = $query_result->fetchrow_array();
    $$prunidx = $runidx;
    $$peid    = $eid
	if (defined($peid));
    $$pidx    = $idx
	if (defined($pidx));
    return 0;
}

#
# Create a new template instance record from the args provided. 
#
# Usage: int NewTemplateInstanceRecord(\%args)
#
sub NewTemplateInstanceBindingRecord($)
{
    my ($args) = @_;

    my $query = "insert into experiment_template_instance_bindings set ".
	join(",", map("$_='" . $args->{$_} . "'", keys(%{$args})));

    return -1
	if (! DBQueryWarn($query));
    return 0;
}

#
# Delete template instance binding records
#
sub DeleteTemplateInstanceBindingRecords($$$)
{
    my ($guid, $vers, $idx) = @_;

    DBQueryWarn("delete from experiment_template_instance_bindings ".
		"where parent_guid='$guid' and parent_vers='$vers' and ".
		"      instance_idx='$idx'")
	or return -1;

    return 0;
}

#
# Create a new experiment run record from the args provided, and return the
# newly generated index for it.
#
# Usage: int NewTemplateExerimentRunRecord(\%args, \$idx)
#
sub NewTemplateExerimentRunRecord($$)
{
    my ($args, $pidx) = @_;

    my $query = "insert into experiment_runs set ".
	join(",", map("$_='" . $args->{$_} . "'", keys(%{$args})));

    # Append some default value stuff.
    $query .= ",start_time=now()";

    my $query_result = DBQueryWarn($query);
    return -1
	if (! $query_result);

    # Grab the insert record.
    $$pidx = $query_result->insertid;
    return 0;
}

#
# Delete experiment run record, by its index number.
#
sub DeleteTemplateExerimentRunRecord($$)
{
    my ($exptidx, $runidx) = @_;

    DBQueryFatal("delete from experiment_run_bindings ".
		 "where exptidx='$exptidx' and runidx='$runidx'");

    DBQueryFatal("delete from experiment_runs ".
		 "where exptidx='$exptidx' and idx='$runidx'");

    return 0;
}

#
# Finalize an experiment run record.
#
# Usage: int FinalizeTemplateExerimentRunRecord($exptidx, $runidx)
#
sub FinalizeTemplateExerimentRunRecord($$)
{
    my ($exptidx, $runidx) = @_;

    my $query = "update experiment_runs set stop_time=now() ";
    $query   .= "where exptidx='$exptidx' and idx='$runidx'";

    return -1
	if (! DBQueryWarn($query));
    
    return 0;
}

#
# Insert new experiment run binding records.
#
# Usage: int NewTemplateInstanceRecord(\%args)
#
sub NewExperimentRunBindingRecord($)
{
    my ($args) = @_;

    my $query = "insert into experiment_run_bindings set ".
	join(",", map("$_='" . $args->{$_} . "'", keys(%{$args})));

    return -1
	if (! DBQueryWarn($query));
    return 0;
}

#
# Delete template instance binding records
#
sub DeleteExperimentRunBindingRecords($$)
{
    my ($exptidx, $runidx) = @_;

    DBQueryFatal("delete from experiment_run_bindings ".
		 "where exptidx='$exptidx' and runidx='$runidx'");

    return 0;
}

#
# Utility routine to get the pid,tid,gid of a template.
#
sub TemplateInfo($$;$$$$)
{
    my ($guid, $version, $ppid, $ptid, $pgid, $peid) = @_;

    my $query_result =
	DBQueryWarn("select pid,tid,gid,eid from experiment_templates ".
		    "where guid='$guid' and vers='$version'");

    return -1
	if (!$query_result || !$query_result->numrows);

    my ($pid, $tid, $gid, $eid) = $query_result->fetchrow_array();
    $$ppid = $pid
	if (defined($ppid));
    $$ptid = $tid
	if (defined($ptid));
    $$pgid = $gid
	if (defined($pgid));
    $$peid = $eid
	if (defined($peid));
    return 0;
}

#
# Create the directory for a template, update the DB, and return that
# path to the caller.
#
#sub CreateTemplateDirectory($$$)
#{
#    my ($guid, $vers, $ppath) = @_;
#
#    # See mkexpdir.
#    my $template_dir = PROJROOT() . "/$pid/templates/$guid/$vers";
#
#    if (! -e $template_dir) {
#	system("/bin/mkdir -p $template_dir") == 0
#	    or return -1;
#    }
#    DBQueryWarn("update experiment_templates set path='$template_dir' ".
#		"where guid='$guid' and vers='$vers'")
#	or return -1;
#
#    $$ppath = $template_dir;
#    return 0;
#}

#
# Add an input file to the template. The point of this is to reduce
# duplication by taking an md5 of the input file, and sharing that
# record/file.
# 
sub AddTemplateInputFile($$$)
{
    my ($guid, $version, $inputfile) = @_;
    my $input_data_idx;
    my $data_string = `cat $inputfile`;
    return -1
	if ($?);

    # pid/tid are inserted for debugging.
    my ($pid,$tid) = ();
    if (TemplateInfo($guid, $version, \$pid, \$tid) < 0) {
	tberror("Could not find pid,tid for experiment template '$guid'!");
	return -1;
    }

    if ($data_string) {
	# As you can see, we md5 the raw data.
	$data_string = DBQuoteSpecial($data_string);
	if (length($data_string) >= DBLIMIT_NSFILESIZE()) {
	    tberror("Input file is too big (> " . DBLIMIT_NSFILESIZE() . ")!");
	    return -1;
	}

	#
	# Grab an MD5 of the file to see if we already have a copy of it.
	# Avoids needless duplication.
	#
	my $md5 = `$MD5 -q $inputfile`;
	chomp($md5);

	DBQueryWarn("lock tables experiment_template_inputs write, ".
		    "            experiment_template_input_data write")
	    or return -1;

	my $query_result =
	    DBQueryWarn("select idx from experiment_template_input_data ".
			"where md5='$md5'");

	if (!$query_result) {
	    DBQueryWarn("unlock tables");
	    return -1;
	}

	if ($query_result->numrows) {
	    ($input_data_idx) = $query_result->fetchrow_array();
	}
	else {
	    $query_result =
		DBQueryWarn("insert into experiment_template_input_data ".
			    "(idx, md5, input) ".
			    "values (NULL, '$md5', $data_string)");
	    
	    if (!$query_result) {
		DBQueryWarn("unlock tables");
		return -1;
	    }
	    $input_data_idx = $query_result->insertid;
	}

	$query_result =
	    DBQueryWarn("insert into experiment_template_inputs ".
			" (idx, parent_guid, parent_vers, ".
			"  pid, tid, input_idx) values ".
			" (NULL, '$guid', '$version', '$pid', '$tid', ".
			"  '$input_data_idx')");
	DBQueryWarn("unlock tables");
	return -1
	    if (!$query_result);
    }
    return 0;
}

#
# Delete an input file, say for a template create/modify that fails.
#
sub DeleteTemplateInputFiles($$)
{
    my ($guid, $version) = @_;

    DBQueryWarn("lock tables experiment_template_inputs as i write, ".
		"            experiment_template_inputs as j write, ".
		"            experiment_template_inputs write, ".
		"            experiment_template_input_data write")
	or return -1;

    #
    # The point of this query is to see if any of the input files in this
    # template are shared with some other template, and thus should not
    # be deleted from the input_data table.
    #
    my $query_result =
	DBQueryWarn("select i.idx,i.input_idx,count(j.input_idx) as count ".
		    "   from experiment_template_inputs as i ".
		    "left join experiment_template_inputs as j on ".
		    "     j.input_idx=i.input_idx ".
		    "where i.parent_guid='$guid' and ".
		    "      i.parent_vers='$version' ".
		    "group by j.input_idx having count > 1");

    if (! $query_result) {
	DBQueryWarn("unlock tables");
	return -1;
    }

    while (my ($input_idx, $data_idx) = $query_result->fetchrow_array()) {
	DBQueryWarn("delete from experiment_template_input_data ".
		    "where idx='$data_idx'");
    }
    $query_result = 
	DBQueryWarn("delete from experiment_template_inputs ".
		    "where parent_guid='$guid' and parent_vers='$version'");
    DBQueryWarn("unlock tables");
    
    return -1
	if (! $query_result);

    return 0;
}

#
# Add a metadata record. This is used for new templates.
#
sub NewTemplateMetadata($$$$$)
{
    my ($template_guid, $template_version, $name, $value, $creator) = @_;
    my $guid;
    my $version = 1;

    return -1
	if (libTemplates::NewGUID(\$guid) < 0);

    $name  = DBQuoteSpecial($name);
    $value = DBQuoteSpecial($value);

    my $query_result =
	DBQueryWarn("insert into experiment_template_metadata_items set ".
		    "   guid='$guid', vers='$version', uid='$creator', ".
		    "   template_guid='$template_guid', ".
		    "   name=$name, value=$value, created=now()");
    return -1
	if (!$query_result);

    DBQueryWarn("insert into experiment_template_metadata set ".
		"   parent_guid='$template_guid', ".
		"   parent_vers='$template_version', ".
		"   metadata_guid='$guid', ".
		"   metadata_vers='$version', ".
		"   internal=1")
	or return -1;
    
    return 0;
}

#
# Delete all template metadata; thats all we need here at the moment
#
sub DeleteTemplateMetadata($$)
{
    my ($template_guid, $template_version) = @_;

    my $query_result =
	DBQueryWarn("select metadata_guid ".
		    "    from experiment_template_metadata ".
		    "where parent_guid='$template_guid' and ".
		    "      parent_vers='$template_version'");

    return -1
	if (!$query_result);

    while (my ($metadata_guid) = $query_result->fetchrow_array()) {
	my @versions = ();

	#
	# Delete all versions for each record. This is wrong if we ever
	# want to share entries between templates.
	#
	my $metadata_result =
	    DBQueryWarn("select vers from experiment_template_metadata_items ".
			"where guid='$metadata_guid'");

	return -1
	    if (!$metadata_result);

	next
	    if (!$metadata_result->numrows);

	while (my ($metadata_vers) = $metadata_result->fetchrow_array()) {
	    push(@versions, $metadata_vers);
	}

	my $clause = join(" or ", map("vers='$_'", @versions));

	DBQueryWarn("delete from experiment_template_metadata_items ".
		    "where guid='$metadata_guid' and ($clause)")
	    or return -1;
    }
    DBQueryWarn("delete from experiment_template_metadata ".
		"where parent_guid='$template_guid' and ".
		"      parent_vers='$template_version'")
	or return -1;

    return 0;
}

#
# Copy exiting template metadata to a child. This is likely to change
# since we probably want to share at some point.
#
sub CopyTemplateMetadata($$$$)
{
    my ($from_guid, $from_version, $to_version, $copier) = @_;

    #
    # Copy the toplevel items.
    #
    my $query_result =
	DBQueryWarn("select name,value ".
		    "  from experiment_template_metadata as m ".
		    "left join experiment_template_metadata_items as i on ".
		    "     i.guid=m.metadata_guid and ".
		    "     i.vers=m.metadata_vers ".
		    "where m.parent_guid='$from_guid' and ".
		    "      m.parent_vers='$from_version' and m.internal=0")
	or return -1;

    while (my ($name, $value) = $query_result->fetchrow_array()) {
	my $guid;
	my $version = 1;
	
	$name   = DBQuoteSpecial($name);
	$value  = DBQuoteSpecial($value);

	return -1
	    if (libTemplates::NewGUID(\$guid) < 0);

	DBQueryWarn("insert into experiment_template_metadata set ".
		    "   parent_guid='$from_guid', ".
		    "   parent_vers='$to_version', ".
		    "   metadata_guid='$guid', ".
		    "   metadata_vers='$version', ".
		    "   internal=0")
	    or return -1;

	DBQueryWarn("insert into experiment_template_metadata_items set ".
		    "   guid='$guid', vers='$version', uid='$copier', ".
		    "   template_guid='$from_guid', ".
		    "   name=$name, value=$value, created=now()")
	    or return -1;
    }

    return 0;
}

#
# Find out if an experiment is a template instantiation; used by existing
# pages to alter what they do.
#
sub IsTemplateInstanceExperiment($)
{
    my ($exptidx) = @_;
    
    my $query_result =
	DBQueryFatal("select pid,eid from experiment_template_instances ".
		     "where exptidx='$exptidx'");

    return $query_result->numrows;
}

#
# Map an experiment to its template.
#
sub MapExptidxtoTemplate($$$)
{
    my ($exptidx, $pguid, $pvers) = @_;

    my $query_result =
	DBQueryFatal("select parent_guid,parent_vers ".
		     "  from experiment_template_instances ".
		     "where exptidx='$exptidx'");

    return -1
	if (! $query_result->numrows);

    my ($guid,$vers) = $query_result->fetchrow_array();
    $$pguid = $guid;
    $$pvers = $vers;
    return 0;
}
