#!/usr/bin/perl -wT
#
# EMULAB-COPYRIGHT
# Copyright (c) 2005, 2006 University of Utah and the Flux Group.
# All rights reserved.
#
# XXX Need to deal with locking at some point ...
#
package Template;

use strict;
use Exporter;
use vars qw(@ISA @EXPORT);

@ISA    = "Exporter";
@EXPORT = qw ( );

# Must come after package declaration!
use lib '@prefix@/lib';
use libdb;
use libtestbed;
use libtblog;
use English;
use overload ('""' => 'Stringify');

# Configure variables
my $TB		= "@prefix@";
my $MD5         = "/sbin/md5";
my $makegraph   = "$TB/bin/template_graph";
my $TEVC	= "$TB/bin/tevc";

# Cache of template instances to avoid regenerating them.
my %templates   = ();

#
# Grab a new GUID for a template. We do not have to use it of course.
#
sub NewGUID($)
{
    my ($pidx) = @_;
    my $idx;
    
    DBQueryFatal("lock tables emulab_indicies write");

    my $query_result = 
	DBQueryFatal("select idx from emulab_indicies ".
		     "where name='next_guid'");
	
    if (! $query_result->num_rows) {
	$idx = 10000;
	
	DBQueryFatal("insert into emulab_indicies (name, idx) ".
		     "values ('next_guid', $idx)");
    }
    else {
	($idx) = $query_result->fetchrow_array();
    }
    my $nextidx = $idx + 1;
    
    DBQueryFatal("update emulab_indicies set idx='$nextidx' ".
		 "where name='next_guid'");

    DBQueryFatal("unlock tables");

    $$pidx = $idx;
    return 0;
}

#
# Lookup a template and create a class instance to return.
#
sub Lookup($$$)
{
    my ($class, $guid, $vers) = @_;

    # Look in cache first
    return $templates{"$guid/$vers"}
        if (exists($templates{"$guid/$vers"}));
    
    my $query_result =
	DBQueryWarn("select * from experiment_templates ".
		    "where guid='$guid' and vers='$vers'");

    return undef
	if (!$query_result || !$query_result->numrows);

    my $self             = {};
    $self->{'TEMPLATE'}  = $query_result->fetchrow_hashref();
    # Filled lazily.
    $self->{'INSTANCES'} = undef;
    bless($self, $class);
    
    # Add to cache. 
    $templates{"$guid/$vers"} = $self;
    
    return $self;
}
# accessors
sub guid($) { return ((! ref($_[0])) ? -1 : $_[0]->{'TEMPLATE'}->{'guid'}); }
sub vers($) { return ((! ref($_[0])) ? -1 : $_[0]->{'TEMPLATE'}->{'vers'}); }
sub pid($)  { return ((! ref($_[0])) ? -1 : $_[0]->{'TEMPLATE'}->{'pid'}); }
sub gid($)  { return ((! ref($_[0])) ? -1 : $_[0]->{'TEMPLATE'}->{'gid'}); }
sub eid($)  { return ((! ref($_[0])) ? -1 : $_[0]->{'TEMPLATE'}->{'eid'}); }
sub tid($)  { return ((! ref($_[0])) ? -1 : $_[0]->{'TEMPLATE'}->{'tid'}); }
sub archive_idx($) {
    return ((! ref($_[0])) ? -1 : $_[0]->{'TEMPLATE'}->{'archive_idx'}); }

#
# Lookup a template given an experiment index.
#
sub LookupByExptidx($$)
{
    my ($class, $exptidx) = @_;

    # Use the Template Instance routine, and grab the template out of it.
    my $template_instance = Template::Instance->LookupByExptidx($exptidx);

    return undef
	if (!defined($template_instance));

    return $template_instance->template();
}

#
# Refresh a template instance by reloading from the DB.
#
sub Refresh($)
{
    my ($self) = @_;

    return -1
	if (! ref($self));

    my $guid = $self->guid();
    my $vers = $self->vers();
    
    my $query_result =
	DBQueryWarn("select * from experiment_templates ".
		    "where guid='$guid' and vers='$vers'");

    return -1
	if (!$query_result || !$query_result->numrows);
	
    $self->{'TEMPLATE'} = $query_result->fetchrow_hashref();
    return 0;
}

#
# Create a new template. This installs the new record in the DB,
# and returns an instance. There is some bookkeeping along the way.
#
sub Create($$)
{
    my ($class, $argref) = @_;
    my ($guid, $vers);

    return undef
	if (ref($class));

    # See if this a child of an existing template.
    if (defined($argref->{'parent_guid'})) {
	$guid = $argref->{'parent_guid'};
    }
    else {
	#
	# Grab a new GUID before we lock other tables.
	#
	if (NewGUID(\$guid) < 0) {
	    tberror("Could not get a new GUID!");
	    return undef;
	}
	$vers = 1;
    }

    DBQueryWarn("lock tables experiments write, ".
		"            experiment_templates write")
	or return undef;

    #
    # Find unused version number now that tables are locked. 
    #
    if (! defined($vers)) {
	my $query_result =
	    DBQueryWarn("select MAX(vers) from experiment_templates ".
			"where guid='$guid'");

	if (!$query_result) {
	    DBQueryWarn("unlock tables");
	    return undef;
	}

	$vers = ($query_result->fetchrow_array())[0];
	$vers++;
    }

    # We make up an eid using the guid and version. This is the eid for the
    # hidden experiment behind each template. 
    my $eid = "T${guid}-${vers}";
    my $pid = $argref->{'pid'};

    #
    # Sanity check; make sure this eid is not in use. Tables are still locked.
    #
    my $query_result =
	DBQueryWarn("select pid,eid from experiments ".
		    "where eid='$eid' and pid='$pid'");

    if (!$query_result) {
	DBQueryWarn("unlock tables");
	return undef;
    }
    
    if ($query_result->numrows) {
	DBQueryWarn("unlock tables");
	tberror("Experiment ID $eid in project $pid is already in use!");
	return undef;
    }

    my $query = "insert into experiment_templates set ".
	join(",", map("$_='" . $argref->{$_} . "'", keys(%{$argref})));

    # Append the rest
    $query .= ",created=now(),guid='$guid',vers='$vers',eid='$eid'";

    if (! DBQueryWarn($query)) {
	DBQueryWarn("unlock tables");
	return undef;
    }
    DBQueryWarn("unlock tables");

    return Template->Lookup($guid, $vers);
}

#
# Stringify for output.
#
sub Stringify($)
{
    my ($self) = @_;
    my $guid   = $self->guid();
    my $vers   = $self->vers();

    return "[Template: $guid/$vers]";
}

#
# Update a template record given an array reference of slot/value pairs.
#
sub Update($$)
{
    my ($self, $argref) = @_;

    # Must be a real reference. 
    return -1
	if (! ref($self));

    my $guid = $self->guid();
    my $vers = $self->vers();

    my $query = "update experiment_templates set ".
	join(",", map("$_='" . $argref->{$_} . "'", keys(%{$argref})));

    $query .= " where guid='$guid' and vers='$vers'";

    return -1
	if (! DBQueryWarn($query));

    return Refresh($self);
}

#
# Delete a template (all tables). Note that other parts of the template
# like instances must already be gone when this is called.
#
sub Delete($)
{
    my ($self) = @_;

    # Must be a real reference. 
    return -1
	if (! ref($self));

    my $guid = $self->guid();
    my $vers = $self->vers();

    DeleteAllMetadata($self) == 0
	or return -1;

    DeleteInputFiles($self) == 0
	or return -1;

    # The graph can be removed if this is the last template version.
    my $query_result =
	DBQueryWarn("select vers from experiment_templates ".
		    "where guid='$guid' and vers!='$vers'");
    return -1
	if (! $query_result);

    if (! $query_result->numrows) {
	DBQueryWarn("delete from experiment_template_graphs ".
		    "where parent_guid='$guid'")
	    or return -1;
    }

    # Make sure the experiment_templates table is always last, in case
    # something goes wrong. 
    my @tables = ("experiment_template_parameters",
		  "experiment_templates");

    foreach my $table (@tables) {
        if ($table eq "experiment_templates") {
            DBQueryWarn("delete from $table ".
			"where guid='$guid' and vers='$vers'")
		or return -1;
        }
        else {
            DBQueryWarn("delete from $table ".
			"where parent_guid='$guid' and parent_vers='$vers'")
		or return -1;
        }
    }
    $self->{'TEMPLATE'} = undef;
    return 0;
}

#
# Template permission checks. Using the experiment access check stuff.
#
# Usage: AccessCheck($guid, $uid, $access_type)
#	 returns 0 if not allowed.
#        returns 1 if allowed.
#
sub AccessCheck($$$;$)
{
    my ($self, $guid, $uid, $access_type);
    my $mintrust;
    
    #
    # If called as a method, no guid argument is provided. 
    #
    $self = shift();

    if (ref($self)) {
	($uid, $access_type) = @_;
    }
    else {
	($guid, $uid, $access_type) = @_;

	$self = Template->Lookup($guid, 1);
	return 0
	    if (! $self);
    }
    
    if ($access_type < TB_EXPT_MIN ||
	$access_type > TB_EXPT_MAX) {
	tbdie("Invalid access type: $access_type!");
    }

    #
    # Admins do whatever they want!
    #
    if (TBAdmin($uid)) {
	return 1;
    }
    $uid = MapNumericUID($uid);

    my $pid = $self->pid();
    my $gid = $self->gid();

    #
    # An experiment may be destroyed by the experiment creator or the
    # project/group leader.
    #
    if ($access_type == TB_EXPT_READINFO) {
	$mintrust = PROJMEMBERTRUST_USER;
    }
    else {
	$mintrust = PROJMEMBERTRUST_LOCALROOT;
    }

    #
    # Either proper permission in the group, or group_root in the project.
    # This lets group_roots muck with other people's experiments, including
    # those in groups they do not belong to.
    #
    return TBMinTrust(TBGrpTrust($uid, $pid, $gid), $mintrust) ||
	TBMinTrust(TBGrpTrust($uid, $pid, $pid), PROJMEMBERTRUST_GROUPROOT);
}

#
# Return a list of all children of the given template.
#
sub Children($$)
{
    my ($self, $resultp) = @_;

    # Must be a real reference. 
    return -1
	if (! ref($self));

    my $guid      = $self->guid();
    my %children  = ();
    my @allkids   = ();
    my @kids      = ();
    my @result    = ();
    
    my $query_result =
	DBQueryWarn("select vers,parent_vers from experiment_templates ".
		    "where parent_guid='$guid' ".
		    "order by vers desc");
    return -1
	if (!$query_result);

    while (my ($vers, $parent_vers) = $query_result->fetchrow_array()) {
	$children{$parent_vers} = []
	    if (!exists($children{$parent_vers}));

	# List of all children for the parent.
	push(@{ $children{$parent_vers} }, $vers);
    }

    # Start with direct children of this template.
    unshift(@allkids, @{ $children{$self->vers()} })
	if (exists($children{$self->vers()}));

    # Descend the tree getting all children recursively.
    while (@allkids) {
	my $kid   = pop(@allkids);

	# New kid to return
	push(@kids, $kid);

	# New children of kid
	unshift(@allkids, @{ $children{$kid} })
	    if (exists($children{$kid}));
    }
    # Most recent templates first.
    @kids = sort {$b <=> $a} @kids;

    # Now convert to template objects.
    foreach my $vers (@kids) {
	my $template = Template->Lookup($guid, $vers);
	return -1
	    if (! $template);
	push(@result, $template);
    }

    @$resultp = @result;
    return 0;
}

#
# Add an input file to the template. The point of this is to reduce
# duplication by taking an md5 of the input file, and sharing that
# record/file.
# 
sub AddInputFile($$)
{
    my ($self, $inputfile) = @_;
    my $input_data_idx;

    # Must be a real reference. 
    return -1
	if (! ref($self));

    my $data_string = `cat $inputfile`;
    return -1
	if ($?);

    my $guid = $self->guid();
    my $vers = $self->vers();
    my $pid  = $self->pid();
    my $tid  = $self->tid();

    if ($data_string) {
	# As you can see, we md5 the raw data.
	$data_string = DBQuoteSpecial($data_string);
	if (length($data_string) >= DBLIMIT_NSFILESIZE()) {
	    tberror("Input file is too big (> " . DBLIMIT_NSFILESIZE() . ")!");
	    return -1;
	}

	#
	# Grab an MD5 of the file to see if we already have a copy of it.
	# Avoids needless duplication.
	#
	my $md5 = `$MD5 -q $inputfile`;
	chomp($md5);

	DBQueryWarn("lock tables experiment_template_inputs write, ".
		    "            experiment_template_input_data write")
	    or return -1;

	my $query_result =
	    DBQueryWarn("select idx from experiment_template_input_data ".
			"where md5='$md5'");

	if (!$query_result) {
	    DBQueryWarn("unlock tables");
	    return -1;
	}

	if ($query_result->numrows) {
	    ($input_data_idx) = $query_result->fetchrow_array();
	}
	else {
	    $query_result =
		DBQueryWarn("insert into experiment_template_input_data ".
			    "(idx, md5, input) ".
			    "values (NULL, '$md5', $data_string)");
	    
	    if (!$query_result) {
		DBQueryWarn("unlock tables");
		return -1;
	    }
	    $input_data_idx = $query_result->insertid;
	}

	$query_result =
	    DBQueryWarn("insert into experiment_template_inputs ".
			" (idx, parent_guid, parent_vers, ".
			"  pid, tid, input_idx) values ".
			" (NULL, '$guid', '$vers', '$pid', '$tid', ".
			"  '$input_data_idx')");
	DBQueryWarn("unlock tables");
	return -1
	    if (!$query_result);
    }
    return 0;
}

#
# Delete all input files, say for a template create/modify that fails.
#
sub DeleteInputFiles($)
{
    my ($self) = @_;

    # Must be a real reference. 
    return -1
	if (! ref($self));

    my $guid = $self->guid();
    my $vers = $self->vers();
    
    DBQueryWarn("lock tables experiment_template_inputs as i write, ".
		"            experiment_template_inputs as j write, ".
		"            experiment_template_inputs write, ".
		"            experiment_template_input_data write")
	or return -1;

    #
    # The point of this query is to see if any of the input files in this
    # template are shared with some other template, and thus should not
    # be deleted from the input_data table.
    #
    my $query_result =
	DBQueryWarn("select i.idx,i.input_idx,count(j.input_idx) as count ".
		    "   from experiment_template_inputs as i ".
		    "left join experiment_template_inputs as j on ".
		    "     j.input_idx=i.input_idx ".
		    "where i.parent_guid='$guid' and ".
		    "      i.parent_vers='$vers' ".
		    "group by j.input_idx having count > 1");

    if (! $query_result) {
	DBQueryWarn("unlock tables");
	return -1;
    }

    while (my ($input_idx, $data_idx) = $query_result->fetchrow_array()) {
	DBQueryWarn("delete from experiment_template_input_data ".
		    "where idx='$data_idx'");
    }
    $query_result = 
	DBQueryWarn("delete from experiment_template_inputs ".
		    "where parent_guid='$guid' and parent_vers='$vers'");
    DBQueryWarn("unlock tables");
    
    return -1
	if (! $query_result);

    return 0;
}

#
# Add a metadata record. 
#
sub NewMetadata($$$$;$)
{
    my ($self, $name, $value, $creator, $type) = @_;
    my $guid;
    my $version  = 1;
    my $internal = 0;
    my $metadata_type;

    # Must be a real reference. 
    return -1
	if (! ref($self));

    my $template_guid = $self->guid();
    my $template_vers = $self->vers();

    return -1
	if (NewGUID(\$guid) < 0);

    # Special ...
    $internal = 1
	if (defined($type));

    # Current set of allowed types;
    my @okay_types = ("tid", "template_description", "parameter_description");

    if (defined($type)) {
	if (! grep {$_ eq $type} @okay_types) {
	    tberror("Illegal metadata type: $type");
	    return -1;
	}
	$metadata_type = "'$type'";
    }
    else {
	$metadata_type = "NULL";
    }

    my $safename  = DBQuoteSpecial($name);
    my $safevalue = DBQuoteSpecial($value);

    my $query_result =
	DBQueryWarn("insert into experiment_template_metadata_items set ".
		    "   guid='$guid', vers='$version', uid='$creator', ".
		    "   template_guid='$template_guid', ".
		    "   name=$safename, value=$safevalue, created=now()");
    return -1
	if (!$query_result);

    DBQueryWarn("insert into experiment_template_metadata set ".
		"   parent_guid='$template_guid', ".
		"   parent_vers='$template_vers', ".
		"   metadata_guid='$guid', ".
		"   metadata_vers='$version', ".
		"   metadata_type=$metadata_type, ".
		"   internal=$internal")
	or return -1;

    # Some metadata is special ...
    if (defined($type)) {
	if ($type eq "parameter_description") {
	    $query_result =
		DBQueryWarn("update experiment_template_parameters set ".
			    "   metadata_guid='$guid', ".
			    "   metadata_vers='$version' ".
			    "where parent_guid='$template_guid' and ".
			    "      parent_vers='$template_vers' and ".
			    "      name=$safename");
	    return -1
		if (!$query_result);
	}
    }
    
    return 0;
}

#
# Lookup a metadata value by name, optionally returning guid/vers.
#
sub LookupMetadata($$;$$$)
{
    my ($self, $name, $pguid, $pvers, $ptype) = @_;

    # Must be a real reference. 
    return -1
	if (! ref($self));

    my $template_guid = $self->guid();
    my $template_vers = $self->vers();

    $name = DBQuoteSpecial($name);

    my $query_result =
	DBQueryWarn("select metadata_guid,metadata_vers,metadata_type ".
		    "   from experiment_template_metadata as m ".
		    "left join experiment_template_metadata_items as i on ".
		    "     m.metadata_guid=i.guid and m.metadata_vers=i.vers ".
		    "where m.parent_guid='$template_guid' and ".
		    "      m.parent_vers='$template_vers' and ".
		    "      i.name=$name");
    
    return -1
	if (!$query_result);
    return 0
	if (!$query_result->numrows);

    my ($metadata_guid, $metadata_vers, $metadata_type) =
	$query_result->fetchrow_array();
    $$pguid = $metadata_guid
	if (defined($pguid));
    $$pvers = $metadata_vers
	if (defined($pvers));
    $$ptype = $metadata_type
	if (defined($ptype));
    
    return 1;
}

#
# Modify a metadata record; these are versioned of course.
#
sub ModifyMetadata($$$$)
{
    my ($self, $name, $value, $creator) = @_;
    my $guid;
    my $version = 1;

    # Must be a real reference. 
    return -1
	if (! ref($self));

    my $template_guid = $self->guid();
    my $template_vers = $self->vers();
    my $parent_guid;
    my $parent_vers;
    my $metadata_type;
    my $already_exists =
	$self->LookupMetadata($name,
			      \$parent_guid, \$parent_vers, \$metadata_type);
    return -1
	if ($already_exists <= 0);

    $name  = DBQuoteSpecial($name);
    $value = DBQuoteSpecial($value);

    DBQueryWarn("lock tables experiment_template_metadata_items write")
	or return -1;
    
    my $query_result =
	DBQueryWarn("select MAX(vers) ".
		    " from experiment_template_metadata_items ".
		    "where guid='$parent_guid'");
    if (!$query_result) {
	DBQueryWarn("unlock tables");
	return -1;
    }
    my ($metadata_vers) = $query_result->fetchrow_array();
    $metadata_vers++;

    #
    # Insert new item.
    #
    if (!DBQueryWarn("insert into experiment_template_metadata_items set ".
		     "     guid='$parent_guid',vers='$metadata_vers', ".
		     "     template_guid='$template_guid', uid='$creator', ".
		     "     parent_guid='$parent_guid',".
		     "     parent_vers='$parent_vers'," .
		     "     name=$name, value=$value, created=now()")) {
	DBQueryWarn("unlock tables");
	return -1;
    }
    DBQueryWarn("unlock tables");

    if (!DBQueryWarn("update experiment_template_metadata ".
		     "  set metadata_vers='$metadata_vers' ".
		     "where metadata_guid='$parent_guid' and ".
		     "      metadata_vers='$parent_vers'")) {
	DBQueryWarn("delete from experiment_template_metadata_items ".
		    "where guid='$parent_guid',vers='$metadata_vers'");
	return -1;
    }

    #
    # XXX Some metadata is special ...
    #
    if (defined($metadata_type)) {
	if ($metadata_type eq "tid") {
	    DBQueryWarn("update experiment_templates set tid=$value ".
			"where guid='$template_guid' and ".
			"      vers='$template_vers'")
		or return -1;
	    
	    Refresh($self);
	    # This can fail; it is not critical.
	    system("$makegraph $template_guid");
	}
	elsif ($metadata_type eq "template_description") {
	    DBQueryWarn("update experiment_templates set description=$value ".
			"where guid='$template_guid' and ".
			"      vers='$template_vers'")
		or return -1;
	    
	    Refresh($self);	
	}
	elsif ($metadata_type eq "parameter_description") {
	    DBQueryWarn("update experiment_template_parameters set ".
			"   metadata_guid='$parent_guid', ".
			"   metadata_vers='$metadata_vers' ".
			"where parent_guid='$template_guid' and ".
			"      parent_vers='$template_vers' and ".
			"      name=$name")
		or return -1
	}
    }
    return 0;
}

#
# Add a formal parameter to a template.
#
sub NewFormalParameter($$$)
{
    my ($self, $name, $value) = @_;

    # Must be a real reference. 
    return -1
	if (! ref($self));

    my $template_guid = $self->guid();
    my $template_vers = $self->vers();
    my $pid = $self->pid();
    my $tid = $self->tid();

    if (defined($value)) {
      $value = DBQuoteSpecial($value);
    }
    else {
      $value = "NULL";
    }

    DBQueryWarn("insert into experiment_template_parameters set ".
		"  parent_guid='$template_guid', ".
		"  parent_vers='$template_vers', ".
		"  pid='$pid', tid='$tid', ".
		"  name='$name', value=$value")
	or return -1;

    return 0;
}

#
# Get list of template formal parameters.
#
sub FormalParameterList($$)
{
    my ($self, $prval) = @_;

    # Must be a real reference. 
    return -1
	if (! ref($self));

    my %results = ();
    my $template_guid = $self->guid();
    my $template_vers = $self->vers();

    my $query_result =
	DBQueryWarn("select name,value from experiment_template_parameters ".
		    "where parent_guid='$template_guid' and ".
		    "      parent_vers='$template_vers'");

    return -1
	if (!$query_result);

    while (my ($name,$value) = $query_result->fetchrow_array()) {
	$results{$name} = $value;
    }
    %$prval = %results;
    return 0;
}

#
# Get description for formal parameters; this needs to be its own object.
#
sub FormalParameterDescription($$)
{
    my ($self, $name, $prval) = @_;

    # Must be a real reference. 
    return -1
	if (! ref($self));

    my $result = undef;
    my $template_guid = $self->guid();
    my $template_vers = $self->vers();
    $name = DBQuoteSpecial($name);

    my $query_result =
	DBQueryWarn("select m.value from experiment_template_parameters as p ".
		    "left join experiment_template_metadata_items as m on ".
		    "     m.guid=p.metadata_guid and m.vers=p.metadata_vers ".
		    "where p.parent_guid='$template_guid' and ".
		    "      p.parent_vers='$template_vers' and ".
		    "      p.name=$name");

    return -1
	if (!$query_result);

    if ($query_result->numrows) {
	($result) = $query_result->fetchrow_array();
    }
    $$prval = $result;
    return 0;
}

#
# Delete (all) template metadata
#
sub DeleteAllMetadata($)
{
    my ($self) = @_;

    # Must be a real reference. 
    return -1
	if (! ref($self));

    my $template_guid = $self->guid();
    my $template_vers = $self->vers();

    my $query_result =
	DBQueryWarn("select metadata_guid ".
		    "    from experiment_template_metadata ".
		    "where parent_guid='$template_guid' and ".
		    "      parent_vers='$template_vers'");

    return -1
	if (!$query_result);

    while (my ($metadata_guid) = $query_result->fetchrow_array()) {
	my @versions = ();

	#
	# Delete all versions for each record. This is wrong if we ever
	# want to share entries between templates.
	#
	my $metadata_result =
	    DBQueryWarn("select vers from experiment_template_metadata_items ".
			"where guid='$metadata_guid'");

	return -1
	    if (!$metadata_result);

	next
	    if (!$metadata_result->numrows);

	while (my ($metadata_vers) = $metadata_result->fetchrow_array()) {
	    push(@versions, $metadata_vers);
	}

	my $clause = join(" or ", map("vers='$_'", @versions));

	DBQueryWarn("delete from experiment_template_metadata_items ".
		    "where guid='$metadata_guid' and ($clause)")
	    or return -1;
    }
    DBQueryWarn("delete from experiment_template_metadata ".
		"where parent_guid='$template_guid' and ".
		"      parent_vers='$template_vers'")
	or return -1;

    return 0;
}

#
# Delete a specific template metadata item from the template, but we leave
# actual items behind. 
#
sub DeleteMetadata($$)
{
    my ($self, $name) = @_;

    # Must be a real reference. 
    return -1
	if (! ref($self));

    my $template_guid = $self->guid();
    my $template_vers = $self->vers();
    $name = DBQuoteSpecial($name);

    my $query_result =
	DBQueryWarn("select metadata_guid,metadata_vers ".
		    "   from experiment_template_metadata as m ".
		    "left join experiment_template_metadata_items as i on ".
		    "     m.metadata_guid=i.guid and m.metadata_vers=i.vers ".
		    "where m.parent_guid='$template_guid' and ".
		    "      m.parent_vers='$template_vers' and ".
		    "      i.name=$name");
    
    return -1
	if (!$query_result);
    return -1
	if (!$query_result->numrows);

    my ($metadata_guid, $metadata_vers) = $query_result->fetchrow_array();
    
    DBQueryWarn("update experiment_template_metadata set hidden=1 ".
		"where parent_guid='$template_guid' and ".
		"      parent_vers='$template_vers' and ".
		"      metadata_guid='$metadata_guid' and ".
		"      metadata_vers='$metadata_vers'")
	or return -1;

    return 0;
}

#
# Copy exiting template metadata to a child. This is likely to change
# since we probably want to share at some point.
#
sub CopyMetadata($$$)
{
    my ($self, $parent, $copier) = @_;

    # Must be a real reference. 
    return -1
	if (! (ref($self) && ref($parent)));

    my $from_guid = $parent->guid();
    my $from_vers = $parent->vers();
    my $to_vers   = $self->vers();

    #
    # Copy the toplevel items.
    #
    my $query_result =
	DBQueryWarn("select name,value,metadata_type,internal ".
		    "  from experiment_template_metadata as m ".
		    "left join experiment_template_metadata_items as i on ".
		    "     i.guid=m.metadata_guid and ".
		    "     i.vers=m.metadata_vers ".
		    "where m.parent_guid='$from_guid' and ".
		    "      m.parent_vers='$from_vers'")
	or return -1;

    while (my ($name,$value,$type,$internal) =
	   $query_result->fetchrow_array()) {

	my $guid;
	my $version = 1;
	my $metadata_type = "NULL";
	
	$name   = DBQuoteSpecial($name);
	$value  = DBQuoteSpecial($value);

	#
	# XXX Some metadata is special ...
	#
	if (defined($type)) {
	    # XXX Skip the tid and template descriptions.
	    next
		if ($type eq "tid" or $type eq "template_description");

	    # XXX Skip parameters that were deleted.
	    if ($type eq "parameter_description") {
		my $param_result = 
		    DBQueryWarn("select * ".
				"   from experiment_template_parameters ".
				"where parent_guid='$from_guid' and ".
				"      parent_vers='$to_vers' and ".
				"      name=$name");

		return -1
		    if (!$param_result);
		
		next
		    if (!$param_result->numrows);
	    }
	    $metadata_type = "'$type'";
	}

	return -1
	    if (NewGUID(\$guid) < 0);

	DBQueryWarn("insert into experiment_template_metadata set ".
		    "   parent_guid='$from_guid', ".
		    "   parent_vers='$to_vers', ".
		    "   metadata_guid='$guid', ".
		    "   metadata_vers='$version', ".
		    "   metadata_type=$metadata_type, ".
		    "   internal=$internal")
	    or return -1;

	DBQueryWarn("insert into experiment_template_metadata_items set ".
		    "   guid='$guid', vers='$version', uid='$copier', ".
		    "   template_guid='$from_guid', ".
		    "   name=$name, value=$value, created=now()")
	    or return -1;

	#
	# XXX Some metadata is special ...
	#
	if (defined($type)) {
	    if ($type eq "parameter_description") {
		DBQueryWarn("update experiment_template_parameters set ".
			    "   metadata_guid='$guid', ".
			    "   metadata_vers='$version' ".
			    "where parent_guid='$from_guid' and ".
			    "      parent_vers='$to_vers' and ".
			    "      name=$name")
		    or return -1
		}
	}
    }
    return 0;
}

#
# Return a list of metadata. This should be its own object.
#
sub MetadataList($$)
{
    my ($self, $prval) = @_;

    # Must be a real reference. 
    return -1
	if (! ref($self));

    my %results = ();

    my $template_guid = $self->guid();
    my $template_vers = $self->vers();

    #
    # Copy the toplevel items.
    #
    my $query_result =
	DBQueryWarn("select i.* from experiment_template_metadata as m ".
		    "left join experiment_template_metadata_items as i on ".
		    "     i.guid=m.metadata_guid and ".
		    "     i.vers=m.metadata_vers ".
		    "where m.parent_guid='$template_guid' and ".
		    "      m.parent_vers='$template_vers' and ".
		    "      m.hidden=0 and m.metadata_type is null")
	or return -1;

    while (my $rowref = $query_result->fetchrow_hashref()) {
	my $name	= $rowref->{"name"};
	my $value       = $rowref->{"value"};
	my $guid	= $rowref->{"guid"};
	my $vers	= $rowref->{"vers"};

	my $ref = {'name'   => $name,
		   'value'  => $value,
		   'guid'   => "$guid/$vers"};

	$results{$name} = $ref;
    }
    %$prval = %results;
    return 0;
}

#
# Create a new Instance record, using the package below.
#
sub NewInstance($$$)
{
    my ($self, $eid, $creator) = @_;

    # Must be a real reference. 
    return undef
	if (! ref($self));

    # We provide this stuff now.
    my %args = ();
    $args{'parent_guid'} = $self->guid();
    $args{'parent_vers'} = $self->vers();
    $args{'pid'}         = $self->pid();
    $args{'eid'}         = $eid;
    $args{'uid'}         = $creator;

    return Template::Instance->Create(\%args);
}

#
# Generate a list of instances for a template and save in the template
# structure. The argument indicates whether you want just active, or all
# of them (historical).
#
sub InstanceList($$$)
{
    my ($self, $all, $resultp) = @_;

    # Must be a real reference. 
    return -1
	if (! ref($self));

    my $query_result;
    my @instances = ();
    my $guid = $self->guid();
    my $vers = $self->vers();

    if ($all) {
	$query_result = 
	    DBQueryWarn("select idx from experiment_template_instances ".
			"where parent_guid='$guid' and ".
			"      parent_vers='$vers'");
    }
    else {
	$query_result =
	    DBQueryWarn("select i.idx ".
			"  from experiment_template_instances as i ".
			"left join experiments as e on e.idx=i.exptidx ".
			"where i.parent_guid='$guid' and ".
			"      i.parent_vers='$vers' and e.idx is not null");
    }
    return -1
	if (!$query_result);
    
    if (!$query_result->numrows) {
	@$resultp = ();
	return 0;
    }
	
    while (my ($idx) = $query_result->fetchrow_array()) {
	my $instance = Template::Instance->LookupByID($idx);
	return -1
	    if (!defined($instance));
	push(@instances, $instance);
    }

    @$resultp = @instances;
    return 0;
}

############################################################################

package Template::Instance;
use libdb;
use libtestbed;
use libtblog;
use English;
use libArchive;
use overload ('""' => 'Stringify');

#
# Lookup a template experiment and create a class instance to return.
#
sub LookupByID($$)
{
    my ($class, $idx) = @_;

    my $query_result =
	DBQueryWarn("select * ".
		    "  from experiment_template_instances ".
		    "where idx='$idx'");

    return undef
	if (!$query_result || !$query_result->numrows);

    my $self            = {};
    $self->{'DB'}       = $query_result->fetchrow_hashref();

    # Backlink to the template.
    my $template_guid   = $self->{'DB'}->{'parent_guid'};
    my $template_vers   = $self->{'DB'}->{'parent_vers'};
    my $template        = Template->Lookup($template_guid, $template_vers);
    return undef
	if (!defined($template));
    $self->{'TEMPLATE'} = $template;
    
    bless($self, $class);
    return $self;
}
sub LookupByExptidx($$)
{
    my ($class, $exptidx) = @_;

    my $query_result =
	DBQueryWarn("select * ".
		    "  from experiment_template_instances ".
		    "where exptidx='$exptidx'");

    return undef
	if (!$query_result || !$query_result->numrows);

    my $self            = {};
    $self->{'DB'}       = $query_result->fetchrow_hashref();

    # Backlink to the template.
    my $template_guid   = $self->{'DB'}->{'parent_guid'};
    my $template_vers   = $self->{'DB'}->{'parent_vers'};
    my $template        = Template->Lookup($template_guid, $template_vers);
    return undef
	if (!defined($template));
    $self->{'TEMPLATE'} = $template;
    
    bless($self, $class);
    return $self;
}

#
# Create a new template instance record. This installs the new record
# in the DB, and returns a class instance. 
#
sub Create($$)
{
    my ($class, $argref) = @_;

    return undef
	if (ref($class));

    my $query = "insert into experiment_template_instances set ".
	join(",", map("$_='" . $argref->{$_} . "'", keys(%{$argref})));

    my $query_result = DBQueryWarn($query);
    return undef
	if (! $query_result);

    # Grab the insert record.
    my $idx = $query_result->insertid;

    return Template::Instance->LookupByID($idx);
}
# accessors
sub idx($)     { return ((!ref($_[0])) ? -1 : $_[0]->{'DB'}->{'idx'}); }
sub exptidx($) { return ((!ref($_[0])) ? -1 : $_[0]->{'DB'}->{'exptidx'}); }
sub guid($)    { return ((!ref($_[0])) ? -1 : $_[0]->{'DB'}->{'parent_guid'});}
sub vers($)    { return ((!ref($_[0])) ? -1 : $_[0]->{'DB'}->{'parent_vers'});}
sub pid($)     { return ((!ref($_[0])) ? -1 : $_[0]->{'DB'}->{'pid'}); }
sub eid($)     { return ((!ref($_[0])) ? -1 : $_[0]->{'DB'}->{'eid'}); }
sub uid($)     { return ((!ref($_[0])) ? -1 : $_[0]->{'DB'}->{'uid'}); }
sub runidx($)  { return ((!ref($_[0])) ? -1 : $_[0]->{'DB'}->{'runidx'}); }
sub template($){ return ((!ref($_[0])) ? -1 : $_[0]->{'TEMPLATE'}); }

#
# Stringify for output.
#
sub Stringify($)
{
    my ($self)  = @_;
    my $guid    = $self->guid();
    my $vers    = $self->vers();
    my $idx     = $self->idx();
    my $exptidx = $self->exptidx();
    my $eid     = $self->eid();

    return "[Instance:$idx exptidx:$exptidx Template:$guid/$vers]";
}

#
# Refresh instance by reloading from the DB.
#
sub Refresh($)
{
    my ($self) = @_;

    return -1
	if (! ref($self));

    my $idx = $self->idx();
    
    my $query_result =
	DBQueryWarn("select * from experiment_template_instances ".
		    "where idx='$idx'");

    return -1
	if (!$query_result || !$query_result->numrows);
	
    $self->{'DB'} = $query_result->fetchrow_hashref();
    return 0;
}

#
# Update an instance record.
#
sub Update($$;$)
{
    my ($self, $start_time, $argref) = @_;

    # Must be a real reference. 
    return -1
	if (! ref($self));

    my $idx   = $self->idx();
    my $query = "update experiment_template_instances set ";

    $query .= "start_time=now() "
	if ($start_time);

    if (defined($argref) && scalar(keys%{$argref})) {
	$query .= ","
	    if ($start_time);
	
	$query .= join(",",
		       map("$_='" . $argref->{$_} . "'", keys(%{$argref})));
    }
    $query .= " where idx='$idx'";

    return -1
	if (! DBQueryWarn($query));

    return Refresh($self);
}
# Set the start time ...
sub Start($)
{
    my ($self) = @_;

    # Must be a real reference. 
    return -1
	if (! ref($self));

    return $self->Update(1);
}
# Set the stop time ...
sub Stop($;$)
{
    my ($self, $argref) = @_;

    # Must be a real reference. 
    return -1
	if (! ref($self));

    my $idx = $self->idx();
    
    #
    # Do the Run record first
    #
    my $runidx = $self->runidx();

    return -1
	if (defined($runidx) && StopCurrentRun($self) < 0);

    # And then the instance.
    DBQueryWarn("update experiment_template_instances set stop_time=now() ".
		"where idx='$idx'")
	or return -1;
    
    return Refresh($self);
}

#
# Finalize.
#
sub Finalize($;$)
{
    my ($self, $argref) = @_;

    # Must be a real reference. 
    return -1
	if (! ref($self));

    my $idx = $self->idx();
    
    #
    # Do the Run record first
    #
    my $runidx = $self->runidx();

    return -1
	if (defined($runidx) && FinalizeCurrentRun($self) < 0);

    return Refresh($self);
}

#
# Is an instance currently instantiated (a current experiment).
#
sub Instantiated($)
{
    my ($self) = @_;

    # Must be a real reference. 
    return -1
	if (! ref($self));

    my $exptidx = $self->exptidx();

    my $query_result =
	DBQueryWarn("select pid,eid from experiments where idx='$exptidx'");

    return -1
	if (! $query_result);

    return $query_result->numrows;
}    

#
# Delete a template instance record.
#
sub Delete($$$)
{
    my ($self) = @_;

    # Must be a real reference. 
    return -1
	if (! ref($self));

    my $guid    = $self->guid();
    my $vers    = $self->vers();
    my $idx     = $self->idx();
    my $exptidx = $self->exptidx();

    #
    # Delete the run records first since they will not mean much after
    # this record is gone.
    #
    DBQueryWarn("delete from experiment_run_bindings ".
		"where exptidx='$exptidx'")
	or return -1;

    DBQueryWarn("delete from experiment_runs ".
		"where exptidx='$exptidx'")
	or return -1;

    #
    # Also delete the binding records for the instance.
    #
    DeleteBindings($self) == 0
	or return -1;

    # And finally the instance record.
    DBQueryWarn("delete from experiment_template_instances ".
		"where idx='$idx'")
	or return -1;

    $self->{'DB'} = undef;
    return 0;
}

#
# Binding records are part of an instance, and we do not actually mess
# with them after we create them. Just need to be able to delete them,
# as when we have a failure.
#
sub NewBinding($$)
{
    my ($self, $name, $value) = @_;

    # Must be a real reference. 
    return -1
	if (! ref($self));

    my $parent_guid  = $self->guid();
    my $parent_vers  = $self->vers();
    my $pid          = $self->pid();
    my $eid          = $self->eid();
    my $instance_idx = $self->idx();

    if (defined($value)) {
	$value = DBQuoteSpecial($value);
    }
    else {
	$value = "''";
    }

    DBQueryWarn("insert into experiment_template_instance_bindings set ".
		"    name='$name', value=$value, ".
		"    parent_guid='$parent_guid',parent_vers='$parent_vers', ".
		"    pid='$pid', eid='$eid', instance_idx='$instance_idx'")
	or return -1;
    
    return 0;
}

#
# Get list of bindings for the instance (the values at swapin time).
#
sub BindingList($$)
{
    my ($self, $prval) = @_;

    # Must be a real reference. 
    return -1
	if (! ref($self));

    my %results = ();
    my $guid = $self->guid();
    my $vers = $self->vers();
    my $idx  = $self->idx();

    my $query_result =
	DBQueryWarn("select name,value ".
		    "   from experiment_template_instance_bindings ".
		    "where instance_idx='$idx' and ".
		    "      parent_guid='$guid' and ".
		    "      parent_vers='$vers'");

    return -1
	if (!$query_result);

    while (my ($name,$value) = $query_result->fetchrow_array()) {
	$results{$name} = $value;
    }
    %$prval = %results;
    return 0;
}

sub DeleteBindings($)
{
    my ($self) = @_;

    # Must be a real reference. 
    return -1
	if (! ref($self));

    my $guid = $self->guid();
    my $vers = $self->vers();
    my $idx  = $self->idx();

    DBQueryWarn("delete from experiment_template_instance_bindings ".
		"where instance_idx='$idx'")
	or return -1;

    return 0;
}

#
# Run records are also integral to Template Instances. 
#
sub NewRun($$;$)
{
    my ($self, $runid, $description) = @_;

    # Must be a real reference. 
    return -1
	if (! ref($self));

    my $exptidx = $self->exptidx();
    my $dclause = "";

    if (defined($description) && $description ne "") {
	$description = DBQuoteSpecial($description);
	$dclause     = "description=$description , ";
    }

    my $query_result =
	DBQueryWarn("insert into experiment_runs set ".
		    "   exptidx='$exptidx', runid='$runid', $dclause ".
		    "   start_time=now()");

    return -1
	if (! $query_result);

    # Grab the insert record and store that back into the instance since it
    # is now the current run.
    my $runidx = $query_result->insertid;
    my $idx    = $self->idx();

    DBQueryWarn("update experiment_template_instances set ".
		"  runidx='$runidx' ".
		"where idx='$idx'")
	or return -1;
    
    return Refresh($self);
}

#
# Delete the current run record.
#
sub DeleteCurrentRun($)
{
    my ($self) = @_;

    # Must be a real reference. 
    return -1
	if (! ref($self));

    my $idx     = $self->idx();
    my $runidx  = $self->runidx();
    my $exptidx = $self->exptidx();

    return 0
	if (!defined($runidx));

    DBQueryWarn("delete from experiment_run_bindings ".
		"where exptidx='$exptidx' and runidx='$runidx'")
	or return -1;

    DBQueryWarn("delete from experiment_runs ".
		"where exptidx='$exptidx' and idx='$runidx'")
	or return -1;
    
    DBQueryWarn("update experiment_template_instances set runidx=NULL ".
		"where idx='$idx'")
	or return -1;
    
    return Refresh($self);
}

#
# Stop the current experiment run,
#
sub StopCurrentRun($)
{
    my ($self) = @_;

    # Must be a real reference. 
    return -1
	if (! ref($self));

    my $idx     = $self->idx();
    my $runidx  = $self->runidx();
    my $exptidx = $self->exptidx();

    return -1
	if (!defined($runidx));

    DBQueryWarn("update experiment_runs set stop_time=now() ".
		"where exptidx='$exptidx' and idx='$runidx'")
	or return -1;

    return Refresh($self);
}

#
# Finalize the current experiment run record.
#
sub FinalizeCurrentRun($)
{
    my ($self) = @_;

    # Must be a real reference. 
    return -1
	if (! ref($self));

    my $idx     = $self->idx();
    my $runidx  = $self->runidx();
    my $exptidx = $self->exptidx();
    my $archive_tag;

    return -1
	if (!defined($runidx));

    #
    # Grab the current archive tag.
    #
    return -1
	if (ArchiveTag($self, \$archive_tag) < 0);
    
    DBQueryWarn("update experiment_runs set archive_tag='$archive_tag' ".
		"where exptidx='$exptidx' and idx='$runidx'")
	or return -1;

    DBQueryWarn("update experiment_template_instances set runidx=NULL ".
		"where idx='$idx'")
	or return -1;
    
    return Refresh($self);
}

#
# Need to make "run" its own object ...
#
# Return an array of runs, indexed by its idx.
#
sub RunList($$)
{
    my ($self, $prval) = @_;

    # Must be a real reference. 
    return -1
	if (! ref($self));

    my %results = ();
    my $exptidx = $self->exptidx();

    my $query_result =
	DBQueryWarn("select * from experiment_runs ".
		    "where exptidx='$exptidx'");

    return -1
	if (!$query_result);

    while (my $rowref = $query_result->fetchrow_hashref()) {
	$results{$rowref->{'idx'}} = $rowref;
    }
    %$prval = %results;
    return 0;
}

#
# Binding records for each Run.
#
sub NewRunBinding($$$)
{
    my ($self, $name, $value) = @_;

    # Must be a real reference. 
    return -1
	if (! ref($self));

    # We provide this stuff now.
    my $exptidx = $self->exptidx();
    my $runidx  = $self->runidx();
    my $pid     = $self->pid();
    my $eid     = $self->eid();

    if (defined($value)) {
	$value = DBQuoteSpecial($value);
    }
    else {
	$value = "''";
    }

    DBQueryWarn("insert into experiment_run_bindings set ".
		"  exptidx='$exptidx', runidx='$runidx', ".
		"  name='$name', value=$value")
	or return -1;

    DBQueryFatal("replace into virt_user_environment set ".
		 "   name='$name', value=$value, ".
		 "   pid='$pid', eid='$eid'");
    
    return 0;
}

#
# Use tevc to tell loghole to sync. We have to send a bunch of extra args
# to get loghole to do what we want.
#
sub LogHole($)
{
    my ($self) = @_;

    # Must be a real reference. 
    return -1
	if (! ref($self));

    my $pid     = $self->pid();
    my $eid     = $self->eid();

    my $archivedir = libArchive::TBUserFileArchiveDirectory($pid, $eid);
    my $logdir     = "$archivedir/logs";

    if (! -e $logdir) {
	mkdir($logdir)
	    or return -1;
    }

    system("$TEVC -w -t 60 -e $pid/$eid now ns SNAPSHOT ".
	   "    LOGHOLE_ARGS='-l $logdir -P -s'") == 0
       or return -1;

    return 0;
}

#
# Grab the current archive tag. I think this info belongs in the instance
# record.
#
sub ArchiveTag($$)
{
    my ($self, $ptag) = @_;

    # Must be a real reference. 
    return -1
	if (! ref($self));

    my $exptidx = $self->exptidx();

    #
    # Grab the current archive tag. This will correspond to the commit
    # done at the end of the run.
    #
    my $query_result =
	DBQueryWarn("select r.archive_tag from experiment_stats as s ".
		    "left join experiment_resources as r on ".
		    "     r.idx=s.rsrcidx ".
		    "where s.exptidx='$exptidx'");
    return -1
	if (!$query_result || !$query_result->numrows);

    my ($archive_tag) = $query_result->fetchrow_array();

    return -1
	if (!defined($archive_tag));

    $$ptag = $archive_tag;

    return 0;
}



# _Always_ make sure that this 1 is at the end of the file...

1;
