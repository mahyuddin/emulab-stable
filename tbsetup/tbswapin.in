#!/usr/bin/perl -w
use English;

# tbswapin

# This is the second program in the
# tbprerun/tbswapin/tbswapout/.../tbend sequences.  It's purpose is
# to setup the testbed for experimental use.  The first part centers
# around assign and converting the virtual topology to a physical
# actuality and setting up the vlans and delays table.  The second
# part calls a number of scripts to set up switch, node, and 
# nameserver state.

#
# Configure variables
#
my $TBROOT   = "@prefix@";
my $TESTMODE = @TESTMODE@;

# Untaint the path
$ENV{'PATH'} = "/usr/bin:$TBROOT/libexec:$TBROOT/libexec/ns2ir" . 
    ":$TBROOT/sbin:$TBROOT/bin";

#
# Testbed Support libraries
#
use lib "@prefix@/lib";
use libdb;
use libtestbed;
require exitonwarn; # exitonwarn isn't really a module, so just require it

#
# Turn off line buffering on output
#
$| = 1;

if ($#ARGV != 1) {
    print STDERR "Syntax: $0 pid eid\n";
    exit(1);
}
my ($pid,$eid) = @ARGV;
my $cleanvlans = 0;
my $state;

#
# Cleanup if something goes wrong. 
# 
sub cleanup {
    print STDERR "Cleaning up after errors.\n";

    if ($os_setup_pid) {
	print "Waiting for os_setup to finish\n";
	waitpid($os_setup_pid,0);
    }

    print "Stopping event system\n";
    if (system("eventsys_control stop $pid $eid")) {
	print STDERR "*** Failed to stop the event system.\n";
    }

    if ($cleanvlans) {
	print STDERR "Removing VLANs.\n";
	if (system("snmpit -r $pid $eid")) {
	    print STDERR "*** Failed to clean up VLANs\n";
	}
    }
    
    print STDERR "Freeing up nodes.\n";
    if (system("nfree $pid $eid")) {
	print STDERR "*** Could not free nodes.\n";
    }
    
    print STDERR "Resetting DB.\n";
    DBQueryWarn("DELETE from delays  where pid='$pid' and eid='$eid'");
    DBQueryWarn("DELETE from vlans   where pid='$pid' and eid='$eid'");
    SetExpState($pid, $eid, EXPTSTATE_SWAPPED);
}

print "Beginning swapin in for $pid/$eid. " .  TBTimeStamp() . "\n";

if (! ($state = ExpState($pid, $eid))) {
    print STDERR "*** No such experiment $pid/$eid\n";
    exit(1);
}
if ($state eq EXPTSTATE_ACTIVE) {
    print STDERR "*** Experiment is already running. Must be swapped out.\n";
    exit(1);
}
elsif ($state ne EXPTSTATE_SWAPPED) {
    print STDERR "*** Experiment is in the wrong state: $state.\n";
    exit(1);
}
if (! SetExpState($pid, $eid, EXPTSTATE_ACTIVATING)) {
    print STDERR "*** Failed to set intermediate experiment state.\n";
    exit(1);
}

# This does all the virtual to physical mapping and updating the DB state.
print "Mapping to physical reality ...\n";
my $exitcode;
if ($exitcode = system("assign_wrapper $pid $eid")) {
    print STDERR "*** Failed to map to reality.\n";
    cleanup();
    # Pass exit code through
    exit($exitcode >> 8);
}
print "Mapped to physical reality! " . TBTimeStamp() . "\n";

# Exit here if we are testing.
if ($TESTMODE) {
    print "Testing run - Stopping here.\n";
    
    if (! SetExpState($pid, $eid, EXPTSTATE_TESTING)) {
	print STDERR "*** Failed to set experiment state.\n";
	cleanup();
	exit(1);
    }
    exit(0);
}

# Everything from now on sets up switch and node state.

#
# These things need to get started before the nodes come up, so we'll
# do them before the os_setup. Everything else can done in parallel with
# os_setup. (Actually, these probably can too, since they should finish
# long before the nodes reboot, but better safe than sorry)
#
print "Setting up mountpoints.\n";
if (system("exports_setup")) {
    print STDERR "*** Failed to setup mountpoints.\n";
    cleanup();
    exit(1);
}

print "Setting up named maps.\n";
if (system("named_setup")) {
    print STDERR "*** WARNING: Failed to add node names to named map.\n";
    #
    # This is a non-fatal error.
    # 
}

#
# Since it'll take a while for the nodes to reboot, we'll start now, and
# wait for the os_setup to finish, down below
#
print "Resetting OS and rebooting.\n";
if (!($os_setup_pid = fork())) { 
    exec("os_setup $pid $eid") or exit(1);
} elsif ($os_setup_pid == -1) {
    print STDERR "*** Fork failed.\n";
    cleanup();
    exit(1);
}

#
# XXX: Don't add any steps between here and the waitpid() call below without
# verifying that 1) It's OK for nodes to come up before the step has
# completed and 2) It's OK for the command to run in parallel with os_setup
# (no DB dependencies, etc.)
#

print "Setting up VLANs.\n";
if (system("snmpit -t $pid $eid")) {
    print STDERR "*** Failed to set up VLANs.\n";
    cleanup();
    exit(1);
}

#
# An error now means that the VLANS need to be cleaned up.
#
$cleanvlans = 1;

print "Setting up email lists.\n";
if (system("genelists")) {
    print STDERR "*** WARNING: Failed to update email lists.\n";
    #
    # This is a non-fatal error.
    # 
}

#
# OK, let's see how that os_setup did
#
$kid = waitpid($os_setup_pid,0);
if ($kid == $os_setup_pid) {
    undef $os_setup_pid; # Make sure cleanup() doesn't wait for it
    if ($CHILD_ERROR) {
	print STDERR "*** Failed to reset OS and reboot nodes.\n";
	cleanup;
	exit(1);
    }
} else {
    undef $os_setup_pid;
    print STDERR "*** Error waiting for os_setup to finish.\n";
    cleanup;
    exit(1);
}

#
# Okay, start the event system now that we know all the nodes have
# rebooted (os_setup is done). This only takes a moment (puts itself
# in the background), so its not enough of a delay to worry about.
# 
print "Starting the event system.\n";
if (system("eventsys_control start $pid $eid")) {
    print STDERR "*** Failed to start the event system.\n";
    cleanup;
    exit(1);
}

# Accounting info.
TBSetExpSwapTime($pid, $eid);

if (!SetExpState($pid, $eid, EXPTSTATE_ACTIVE)) {
    print STDERR "*** Failed to set experiment state!\n";
    cleanup();
    exit(1);
}

print "Swapin finished. " . TBTimeStamp() . "\n";
exit(0);
