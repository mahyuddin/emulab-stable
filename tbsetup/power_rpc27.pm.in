#!/usr/bin/perl -wT

package power_rpc27;

use Exporter;
@ISA = ("Exporter");
@EXPORT = qw( rpc27ctrl );

use Socket;
use IO::Handle;
use lib "@prefix@/lib";
use libdb;

# A little perl module to power cycle something attached to an RPC27.
# Thats a serially controlled, power controller.
#
# XXX The little secretkey handshake is coded in here. If this changes
# in capture, you have to change it here too. Look for the "pack"
# statement below.
#
# XXX Note that if someone has already tipped to the power controller 
# in question, this won't work at all.

# Turn off line buffering on output
$| = 1;

# Set for more output.
my $debug = 0;

# RPC27 Prompt string
my $RPC27_PROMPT = "RPC-27>";
my %RPC27_CMD =
  ("cycle"=>"reboot",
   "on"    =>"on",
   "off"   =>"off");

# Main routine.
# usage: rpc27ctrl(cmd, controller, outlet)
# cmd = { "cycle" | "on" | "off" }
# controller = <node_id>
# outlet = int, 1 <= outlet <= 20
#
# Returns 0 on success. Non-zero on failure.
# 
sub rpc27ctrl {
    my($cmd, $controller, $outlet) = @_;
    my($TIP, $i, $insync);

    if ( $outlet < 1 || $outlet > 20 ) {
	print STDERR "*** Invalid outlet '$outlet': Must be 1-20\n";
	return 1;
    }

    #
    # Form the connection to the controller via a "tip" line to the
    # capture process. Once we have that, we can just talk to the
    # controller directly.
    #
    if (! ($TIP = tipconnect($controller))) {
	print STDERR "*** Could not form TIP connection to $controller\n";
	return 1;
    }
    
    #
    # Send a couple of newlines to get the command prompt, and then wait
    # for it to print out the command prompt. This loop is set for a small
    # number since if it cannot get the prompt quickly, then something has
    # gone wrong.
    #
    $insync = 0;

    for ($i = 0; $i < 10; $i++) {
	my $line;

	if (syswrite($TIP, "\r\n") == 0) {
	    print STDERR
		"*** Power control sync failed ($controller/$outlet)\n";
	    close($TIP);
	    return 1;
	}

	if (sysread($TIP, $line, 1024) == 0) {
	    last;
	}
	if ($debug) {
	    print "Read: $line";
	}
	if ($line =~ /$RPC27_PROMPT/) {
	    if ($debug) {
		print "Matched prompt '$RPC27_PROMPT'!\n";
	    }
	    $insync = 1;
	    last;
	}
    }
    if (! $insync) {
	print STDERR "*** Could not sync with power controller! ".
	    "($controller/$outlet)\n";
	close($TIP);
	return 1;
    }

    if ($debug) {
	print "Sending '$RPC27_CMD{$cmd} $outlet' to $controller\n";
    }

    # Okay, got a prompt. Send it the string:
    if (syswrite($TIP, "$RPC27_CMD{$cmd} $outlet\r\n") == 0) {
	print STDERR "*** Power control write failed ($controller/$outlet)\n";
	close($TIP);
	return 1;
    }

    close($TIP);
    return 0;
}

#
# Connect up to the capture process. This should probably be in a library
# someplace.
#
sub tipconnect($) {
    my($controller) = $_[0];
    my($server, $portnum, $keylen, $keydata);
    my($inetaddr, $paddr, $proto);
    my(%powerid_row);
    local *TIP;

    my $query_result =
      DBQueryWarn("select * from tiplines where node_id='$controller'");

    if ($query_result->numrows < 1) {
	print STDERR "*** No such tipline: $controller\n";
	return 0;
    }
    %powerid_row = $query_result->fetchhash();

    $server  = $powerid_row{'server'};
    $portnum = $powerid_row{'portnum'};
    $keylen  = $powerid_row{'keylen'};
    $keydata = $powerid_row{'keydata'};

    if ($debug) {
	print "tipconnect: $server $portnum $keylen $keydata\n";
    }

    #
    # We have to send over the key. This is a little hokey, since we have
    # to make it look like the C struct.
    #
    my $secretkey = pack("iZ256", $keylen, $keydata);

    #
    # This stuff from the PERLIPC manpage.
    # 
    if (! ($inetaddr = inet_aton($server))) {
	print STDERR "*** Cannot map $server to IP address\n";
	return 0;
    }
    $paddr    = sockaddr_in($portnum, $inetaddr);
    $proto    = getprotobyname('tcp');

    #
    # We have no locking protocol in place for the tiplines. So, loop
    # a small number of time, trying to form a proper connection. 
    #
    for ($i = 0; $i < 10; $i++) {
	if (! socket(TIP, PF_INET, SOCK_STREAM, $proto)) {
	    print STDERR "*** Cannot create socket.\n";
	    return 0;
	}

	if (! connect(TIP, $paddr)) {
	    print STDERR
		"*** Cannot connect to $controller on $server($portnum)\n";
	    return 0;
	}
	TIP->autoflush(1);

	#
	# If the connect succeeds, but the write fails, it means that the
	# other end dropped the connection cause there was already a tip
	# active (either a person on the tip line, or another power control).
	#
	# I'm not happy about this. We need a more positive action protocol.
	#
	if (syswrite(TIP, $secretkey) > 0) {
	    return(*TIP);
	}
	
	print STDERR
	    "*** WARNING: Cannot write to $controller on $server($portnum)" .
	    "    Power controller might be busy. Waiting a bit ...\n";
	
	close(TIP);
    }
    print STDERR
	"*** Cannot connect to $controller on $server($portnum)\n";
    return 0;
}

1;
