#!/usr/bin/perl -wT
use English;
use Getopt::Std;

#
# Reboot a node (or nodes). Will power cycle the node as a last resort.
# Use -e option to reboot all nodes in an experiment.
#
# usage: node_reboot [-d] [-f] node [node ...]
#        node_reboot [-d] [-f] -e pid,eid
#        Exit value is 0 if all nodes reboot okay, or the number of nodes
#        could not be rebooted.
#
sub usage()
{
    print STDOUT "Usage: node_reboot [-d] [-f] node [node ...]\n" .
	         "       node_reboot [-d] [-f] -e pid,eid\n".
	"Use the -d option to turn on debugging\n" .
	"Use the -e option to reboot all the nodes in an experiment\n" .
	"Use the -f option to shoot the node in the head\n";
    exit(-1);
}
my  $optlist = "dfe:";

#
# Configure variables
#
my $TB		= "@prefix@";

#
# Testbed Support libraries
#
use lib "@prefix@/lib";
use libdb;
use libtestbed;
use event;

my $ssh		= "$TB/bin/sshtb -n";
my $power	= "$TB/bin/power";
my $ipod	= "$TB/sbin/ipod";
my $ping	= "/sbin/ping";
my %pids	= ();
my @row;
my @nodes       = ();
my $debug       = 0;
my $force       = 0;
my $failed      = 0;
my $eidmode     = 0;
my $pid;
my $eid;

# un-taint path
$ENV{'PATH'} = '/bin:/sbin:/usr/bin:/usr/local/bin';
delete @ENV{'IFS', 'CDPATH', 'ENV', 'BASH_ENV'};

# Turn off line buffering on output
$| = 1; 

#
# We don't want to run this script unless its the real version.
#
if ($EUID != 0) {
    die("Must be root! Maybe its a development version?");
}

#
# Parse command arguments. Once we return from getopts, all that should
# left are the required arguments.
#
%options = ();
if (! getopts($optlist, \%options)) {
    usage();
}
if (defined($options{"d"})) {
    $debug = 1;
}
if (defined($options{"f"})) {
    $force = 1;
}
if (defined($options{"e"})) {
    if (@ARGV) {
	usage();
    }
    
    $eidmode = $options{"e"};
    if ($eidmode =~ /([-\w]*),([-\w]*)/) {
	$pid = $1;
	$eid = $2;
    }
    else {
	print STDOUT "Invalid argument to -e option: $eidmode\n";
	usage();
    }
}

#
# If eidmode, then get the node list out of the DB instead of the command
# line. A proper check is made later, so need to be fancy about the query.
#
if ($eidmode) {
    my @row;

    #
    # Verify permission to muck with this experiment.
    #
    if ($UID && !TBAdmin($UID) &&
	! TBExptAccessCheck($UID, $pid, $eid, TB_EXPT_MODIFY)) {
	die("*** You not have permission to reboot nodes in $pid/$eid!\n");
    }
    
    my $query_result =
	DBQueryFatal("select node_id from reserved where ".
		     "pid='$pid' and eid='$eid'");

    if ($query_result->numrows == 0) {
	print STDOUT "There are no nodes reserved in pid/eid $pid/$eid\n";
	usage();
    }
    while (@row = $query_result->fetchrow_array()) {
	push(@nodes, $row[0]);
    }
}
else {
    if (@ARGV == 0) {
	usage();
    }
    
    # Untaint the nodes.
    foreach my $node ( @ARGV ) {
	if ($node =~ /^([-\@\w]+)$/) {
	    $node = $1;
	}
	else {
	    die("Bad node name: $node.");
	}
    
	push(@nodes, $node);
    }

    #
    # Verify permission to reboot these nodes.
    #
    if ($UID && !TBAdmin($UID) &&
	! TBNodeAccessCheck($UID, TB_NODEACCESS_REBOOT, @nodes)) {
	die("You do not have permission to reboot one (or more) ".
	    "of the nodes!\n");
    }
}

#
# Another shark hack. Well, perhaps not. We really don't want 50 nodes
# all rebooting at the same time, PCs *or* sharks. Lets order them
# so that the shelves are grouped together at least, and issue the reboots
# in batches. 
#
my @sortednodes = sort(@nodes);

while (@sortednodes) {
    my @batch = ();
    my $i     = 0;
    my $lastshelf = 0;
    
    while ($i < 8 && @sortednodes > 0) {
	my $node = shift(@sortednodes);
	my $shelf;
	my $unit;

	#
	# The point of this sillyness is stop at each shelf transition.
	#
	if (IsShelved($node, \$shelf, \$unit)) {
	    if ($lastshelf && $lastshelf ne $shelf) {
		unshift(@sortednodes, $node);
		last;
	    }
	    $lastshelf = $shelf;
	}
	    
	push(@batch, $node);
	$i++;
    }

    if ($force) {
        #
        # In force mode, call the power program for the whole batch, and
	# continue on. We don't wait for them to go down or reboot.
        #
	system("$power cycle @batch");
	if ($?) {
	    exit ($? >> 8);
	}
    }
    else {
        #
        # Fire off a reboot process so that we can overlap them all.
        # We need the pid so we can wait for them all before preceeding.
        #
	foreach my $node ( @batch ) {
	    $mypid = RebootNode($node);
	    $pids{$node} = $mypid;
	}
    }

    # 
    # If there are more nodes to go, then lets pause a bit so that we
    # do not get a flood of machines coming up all at the same exact
    # moment.
    #
    if (@sortednodes) {
	print STDOUT "Pausing to give some nodes time to reboot ...\n";
	if ($lastshelf) {
	    sleep(15);
	} else {
	    sleep(10);
	}
    }
}

#
# In force mode, we are done.
#
if ($force) {
    exit 0;
}

#
# Wait for all the reboot children to exit before continuing.
#
foreach my $node ( sort(@nodes) ) {
    my $mypid     = $pids{$node};

    waitpid($mypid, 0);
    if ($?) {
	$failed++;
	print STDERR "Reboot of node $node failed!\n";
    }
    else {
	print STDOUT "$node rebooting ...\n";
    }
}

if ($debug && $failed) {
    print STDERR "$failed nodes could not be rebooted\n";
}
exit $failed;

#
# Reboot a node in a child process. Return the pid to the parent so
# that it can wait on all the children later.
# 
sub RebootNode {
    local($pc) = @_;
    local($status, $syspid, $mypid);

    print STDOUT "Rebooting $pc ...\n";

    $mypid = fork();
    if ($mypid) {
	return $mypid;
    }
    TBdbfork();

    #
    # See if the machine is pingable. If its not pingable, then we just
    # power cycle the machine rather than wait for ssh to time out.
    #
    # ping returns 0 if any packets make it through. 
    #
    if (! DoesPing($pc)) {
	print STDERR "$pc appears to be dead. Power cycling ...\n" if $debug;
	if (PowerCycle($pc)) {
	    exit(-1);
	}
	exit(0);
    }

    #
    # Machine is pingable at least. Try to reboot it gracefully,
    # or power cycle anyway if that does not work. 
    #
    print STDERR "Trying ssh reboot of $pc ...\n" if $debug;

    #
    # Must change our real UID to root so that ssh will work. We save the old
    # UID so that we can restore it after we finish the ssh
    #
    my $oldUID = $UID;
    print STDERR "Saved UID: $oldUID\n" if $debug;
    $UID = 0;
    
    #
    # Run an ssh command in a child process, protected by an alarm to
    # ensure that the ssh is not hung up forever if the machine is in
    # some funky state.
    # 
    $syspid = fork();

    if ($syspid) {
	local $SIG{ALRM} = sub { kill("TERM", $syspid); };
	alarm 20;
	waitpid($syspid, 0);
	alarm 0;

	#
	# The ssh can return non-zero exit status, but still have worked.
	# FreeBSD for example.
	#
	print STDERR "reboot of $pc returned $?.\n" if $debug;
    
	#
	# If either ssh is not running or it timed out,
	# send it a ping of death.
	# 
	if ($? == 256 || $? == 15) {
	    if ($? == 256) {
		print STDERR "$pc is not running sshd.\n" if $debug;
	    } else {
		print STDERR "$pc is wedged.\n" if $debug;
	    }
	    print STDERR "Trying Ping-of-Death on $pc ...\n" if $debug;

	    system("$ipod $pc");
	}
    }
    else {
	exec("$ssh $pc /sbin/reboot");
	exit(0);
    }

    #
    # Restore the old UID so that scripts run from this point on get the 
    # user's real UID
    #
    $UID = $oldUID;
    print STDERR "Restored UID: $UID\n" if $debug;

    #
    # Okay, before we power cycle lets really make sure. We wait a while
    # for it to stop responding to pings, and if it never goes silent,
    # punch the power button.
    #
    if (WaitTillDead($pc) == 0) {
	EventSendFatal(objtype   => "TBNODESTATE",
	    	       objname   => $pc,
		       eventtype => "REBOOTING",
		       host      => TB_BOSSNODE);
	exit(0);
    }
	
    print STDERR "$pc is still running. Power cycling ...\n" if $debug;
    if (PowerCycle($pc)) {
	exit(-1);
    }
    exit(0);
}

#
# Power cycle a PC using the testbed power program.
#
sub PowerCycle {
    local($pc) = @_;

    system("$power cycle $pc");
    return $? >> 8;
}

#
# Wait until a machine stops returning ping packets.
# 
sub WaitTillDead {
    local($pc) = @_;
    local($status);

    print STDERR "Waiting for $pc to die off\n" if $debug;
    
    #
    # Sigh, a long ping results in the script waiting until all the
    # packets are sent from all the pings, before it will exit. So,
    # loop doing a bunch of shorter pings.
    #
    for ($i = 0; $i < 30; $i++) {
	if (! DoesPing($pc)) {
	    print STDERR "$pc is rebooting.\n" if $debug;
	    return 0;
	}
    }
    print STDERR "$pc is still alive.\n" if $debug;
    return 1;
}

#
# Returns 1 if host is responding to pings, 0 otherwise
#
sub DoesPing {
    local($pc) = @_;
    local($status);
    local($saveuid);

    $saveuid = $UID;
    $UID = 0;
    system("$ping -q -i 0.25 -c 8 -t 2 $pc >/dev/null 2>&1");
    $UID = $saveuid;
    $status = $? >> 8;

    #
    # Returns 0 if any packets are returned. Returns 2 if pingable
    # but no packets are returned. Other non-zero error codes indicate
    # other problems.  Any non-zero return indicates "not pingable" to us.
    # 
    print STDERR "$ping $pc returned $status\n" if $debug;
    if ($status) {
	return 0;
    }
    return 1;
}
