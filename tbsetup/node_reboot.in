#!/usr/bin/perl -wT
#
# EMULAB-COPYRIGHT
# Copyright (c) 2000-2006 University of Utah and the Flux Group.
# All rights reserved.
#
use English;
use Getopt::Std;

#
# Reboot a node (or nodes). Will power cycle the node as a last resort.
# Use -e option to reboot all nodes in an experiment.
#
# Exit value is 0 if all nodes reboot okay, or the number of nodes
# could not be rebooted.
#
sub usage()
{
    print(STDERR
	  "Usage: node_reboot [-d] [-f] [-w] [-k] node [node ...]\n" .
	  "       node_reboot [-d] [-f] [-w] [-k] -e pid,eid\n".
	  "Use the -d option to turn on debugging\n" .
	  "Use the -e option to reboot all the nodes in an experiment\n" .
	  "Use the -w option to to wait for nodes is come back up\n" .
	  "Use the -k option to power cycle nodes in PXEWAIT mode\n" .
	  "Use the -b option to reboot nodes in PXEWAIT mode\n" .
	  "Use the -a option to reboot all free nodes\n".
	  "Use the -c option to reconfig nodes instead of rebooting\n".
	  "Use the -f option to power cycle (and not wait for nodes to die)\n");
    exit(-1);
}
# The hidden -r option runs this in "realmode", ie don't send an event, but
# really do the work instead.
my $optlist     = "dfe:wrkacb";
my $debug       = 0;
my $powercycle  = 0;
my $waitmode    = 0;
my $realmode    = 1; # XXX Temporary, until we make event sending the default.
my $killmode    = 0;
my $reconfig    = 0;
my $rebootmode  = 0;

#
# Configure variables
#
my $TB		= "@prefix@";
my $CLIENT_BIN  = "@CLIENT_BINDIR@";

# Locals
my $nodes	= ();

#
# Testbed Support libraries
#
use lib "@prefix@/lib";
use libdb;
use libreboot;

# un-taint path
$ENV{'PATH'} = '/bin:/sbin:/usr/bin:/usr/local/bin';
delete @ENV{'IFS', 'CDPATH', 'ENV', 'BASH_ENV'};

# Turn off line buffering on output
$| = 1;

# Be careful not to exit on transient error
$libdb::DBQUERY_MAXTRIES = 30;

#
# We don't want to run this script unless its the real version.
#
if ($EUID != 0) {
    die("*** $0:\n".
        "    Must be root! Maybe its a development version?\n");
}

#
# Parse command arguments. Once we return from getopts, all that should
# left are the required arguments.
#
%options = ();
if (! getopts($optlist, \%options)) {
    usage();
}
if (defined($options{"d"})) {
    $debug = 1;
}
if (defined($options{"b"})) {
    $rebootmode = 1;
}
if (defined($options{"f"})) {
    $powercycle = 1;
}
if (defined($options{"k"})) {
    $killmode = 1;
}
if (defined($options{"w"})) {
    $waitmode = 1;
}
if (defined($options{"r"})) {
    $realmode = 1;

    #if ($UID && !TBAdmin($UID)) {
    #	die("*** You cannot use real mode!\n");
    #}
}
if (defined($options{"c"})) {
    $reconfig = 1;
}

if (defined($options{"a"})) {
    #
    # Reboot all free nodes
    #
    if ($UID && !TBAdmin($UID)) {
	die("*** $0:\n".
	    "    You not have permission to reboot all free nodes!\n");
    }

    if (@ARGV) {
	usage();
    }
    
    my $query_result =
	DBQueryFatal("select n.node_id from nodes as n ".
		     "left join reserved as r on r.node_id=n.node_id ".
		     "left join node_types as nt on nt.type=n.type ".
		     "where nt.class='pc' and n.role='testnode' and ".
		     "      r.pid is NULL");

    if ($query_result->numrows == 0) {
	die("*** $0:\n".
	    "    There are no free nodes to reboot\n");
    }

    while (my ($nodeid) = $query_result->fetchrow_array()) {
	push(@nodes, $nodeid);
    }
}
elsif (defined($options{"e"})) {
    #
    # Reboot all nodes in an experiment
    #
    if (@ARGV) {
	usage();
    }

    my $eidmode = $options{"e"};
    my $pid;
    my $eid;
    
    if ($eidmode =~ /([-\w]*),([-\w]*)/) {
	$pid = $1;
	$eid = $2;
    }
    else {
	die("*** $0:\n".
	    "    Invalid argument to -e option: $eidmode\n");
    }

    #
    # Verify permission to muck with this experiment. This is to head off
    # permission problems early; the nodes are indvidually checked later
    # in the library.
    #
    if ($UID && !TBAdmin($UID) &&
	! TBExptAccessCheck($UID, $pid, $eid, TB_EXPT_MODIFY)) {
	die("*** $0:\n".
	    "    You not have permission to reboot nodes in $pid/$eid!\n");
    }

    my $query_result =
	DBQueryFatal("select node_id from reserved where ".
		     "pid='$pid' and eid='$eid'");

    if ($query_result->numrows == 0) {
	die("*** $0:\n".
            "    There are no nodes reserved in pid/eid $pid/$eid\n");
    }
    
    #
    # If this is a firewalled experiment, don't reboot the firewall.
    # If you want to reboot the firewall, you have to do it individually.
    #
    # Two reasons.  One is that the firewall is not conceptually part of
    # the experiment and the user should not "be aware" of it.  This
    # is a pretty lame reason because pretty much everywhere else, the
    # firewall IS part of the experiment.  That leads to reason number
    # two: rebooting the firewall causes all other nodes in the experiment
    # to become disconnected until the firewall reboots.  For some machines,
    # that are also rebooting as you recall, not getting PXE info for a
    # significant amount of time causes them to fail to the next boot.
    # For some machines this might mean halting ("Strike any key to continue"),
    # as there is no other boot possibility.  This means ya gotta come back
    # later and reboot all those nodes again.
    #
    my $firewall = "";
    if (TBExptFirewall($pid, $eid, \$firewall)) {
	warn("WARNING: NOT rebooting firewall node $firewall\n");
    }

    while (my ($nodeid) = $query_result->fetchrow_array()) {
	push(@nodes, $nodeid)
	    if ($nodeid ne $firewall);
    }
}
else {
    #
    # Reboot nodes listed on command line.
    # 
    if (!@ARGV) {
	usage();
    }

    # Untaint the nodes.
    foreach my $node ( @ARGV ) {
	if ($node =~ /^([-\w]+)$/) {
	    $node = $1;
	}
	else {
	    die("*** Tainted node name: $node\n");
	}
	if (!TBValidNodeName($node)) {
	    die("*** $0:\n".
		"    Node does not exist: $node\n");
	}
	push(@nodes, $node);
    }
}

#
# Okay, call into the library using a hash of arguments.
#
my %args   = ();
my %status = ();

$args{'debug'}       = $debug;
$args{'powercycle'}  = $powercycle;
$args{'rebootmode'}  = $rebootmode;
$args{'waitmode'}    = $waitmode;
$args{'realmode'}    = $realmode;
$args{'killmode'}    = $killmode;
$args{'reconfig'}    = $reconfig;
$args{'nodelist'}    = [ @nodes ];

exit(nodereboot(\%args, \%status));
