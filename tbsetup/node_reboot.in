#!/usr/bin/perl -wT

#
# EMULAB-COPYRIGHT
# Copyright (c) 2000-2003 University of Utah and the Flux Group.
# All rights reserved.
#

use English;
use Getopt::Std;

#
# Reboot a node (or nodes). Will power cycle the node as a last resort.
# Use -e option to reboot all nodes in an experiment.
#
# Exit value is 0 if all nodes reboot okay, or the number of nodes
# could not be rebooted.
#
sub usage()
{
    print STDOUT "Usage: node_reboot [-d] [-f] [-n] [-w] node [node ...]\n" .
	         "       node_reboot [-d] [-f] [-n] [-w] -e pid,eid\n".
	"Use the -d option to turn on debugging\n" .
	"Use the -e option to reboot all the nodes in an experiment\n" .
	"Use the -n option to not wait for nodes to go down\n" .
	"Use the -w option to to wait for nodes is come back up\n" .
	"Use the -f option to power cycle (and not wait for nodes to die)\n";
    exit(-1);
}
# The hidden -r option runs this in "realmode", ie don't send an event, but
# really do the work instead.
my  $optlist = "dfe:nwr";

#
# Configure variables
#
my $TB		= "@prefix@";
my $CLIENT_BIN  = "@CLIENT_BINDIR@";
my $BOSSNODE    = "@BOSSNODE@";

#
# Testbed Support libraries
#
use lib "@prefix@/lib";
use libdb;
use libtestbed;
use event;
use POSIX qw(strftime);

my $ssh		= "$TB/bin/sshtb -n";
my $power	= "$TB/bin/power";
my $ipod	= "$TB/sbin/apod";
my $vnodesetup	= "$TB/sbin/vnode_setup";
my $logfile	= "$TB/log/power.log";
my $ping	= "/sbin/ping";
my %pids	= ();
my @row;
my @nodes       = ();
my $debug       = 0;
my $force       = 0;
my $waitmode    = 0;
my $realmode    = 0;
my $nowait      = 0;
my $failed      = 0;
my $eidmode     = 0;
my $pid;
my $eid;

# un-taint path
$ENV{'PATH'} = '/bin:/sbin:/usr/bin:/usr/local/bin';
delete @ENV{'IFS', 'CDPATH', 'ENV', 'BASH_ENV'};

# Turn off line buffering on output
$| = 1; 

#
# We don't want to run this script unless its the real version.
#
if ($EUID != 0) {
    die("Must be root! Maybe its a development version?");
}

#
# Parse command arguments. Once we return from getopts, all that should
# left are the required arguments.
#
%options = ();
if (! getopts($optlist, \%options)) {
    usage();
}
if (defined($options{"d"})) {
    $debug = 1;
}
if (defined($options{"f"})) {
    $force = 1;
}
if (defined($options{"w"})) {
    $waitmode = 1;
}
if (defined($options{"r"})) {
    $realmode = 1;
}
if (defined($options{"n"}) && !defined($options{"w"})) {
    $nowait = 1;
}
if (defined($options{"e"})) {
    if (@ARGV) {
	usage();
    }

    $eidmode = $options{"e"};
    if ($eidmode =~ /([-\w]*),([-\w]*)/) {
	$pid = $1;
	$eid = $2;
    }
    else {
	print STDOUT "Invalid argument to -e option: $eidmode\n";
	usage();
    }
}

# XXX Temporary, until we make event sending the default
$realmode=1;
#if ($realmode && $UID && !TBAdmin($UID)) {
#    die("*** You cannot use real mode!\n");
#}

#
# If eidmode, then get the node list out of the DB instead of the command
# line. A proper check is made later, so need to be fancy about the query.
#
if ($eidmode) {
    my @row;

    #
    # Verify permission to muck with this experiment.
    #
    if ($UID && !TBAdmin($UID) &&
	! TBExptAccessCheck($UID, $pid, $eid, TB_EXPT_MODIFY)) {
	die("*** You not have permission to reboot nodes in $pid/$eid!\n");
    }

    my $query_result =
	DBQueryFatal("select node_id from reserved where ".
		     "pid='$pid' and eid='$eid'");

    if ($query_result->numrows == 0) {
	print STDOUT "There are no nodes reserved in pid/eid $pid/$eid\n";
	usage();
    }
    while (@row = $query_result->fetchrow_array()) {
	push(@nodes, $row[0]);
    }
}
else {
    if (@ARGV == 0) {
	usage();
    }

    # Untaint the nodes.
    foreach my $node ( @ARGV ) {
	if ($node =~ /^([-\@\w]+)$/) {
	    $node = $1;
	}
	else {
	    die("Bad node name: $node.");
	}

	push(@nodes, $node);
    }

    #
    # Verify permission to reboot these nodes.
    #
    if ($UID && !TBAdmin($UID) &&
	! TBNodeAccessCheck($UID, TB_NODEACCESS_REBOOT, @nodes)) {
	die("You do not have permission to reboot one (or more) ".
	    "of the nodes!\n");
    }
}

#
# VIRTNODE HACK: Virtual nodes are special. We can reboot jailed vnodes.
# but not old style (non-jail). Also, if we are going to reboot the physical
# node that a vnode is on, do not bother with rebooting the vnode since
# it will certainly get rebooted anyway!
#
my %realnodes = ();
my %virtnodes = ();

foreach my $node ( @nodes ) {
    my $jailed;

    if (TBIsNodeVirtual($node, \$jailed)) {
	if (! $jailed) {
	    print "*** Skipping old style (non-jail) virtual node $node ...\n";
	    next;
	}
	my $pnode;

	if (! TBPhysNodeID($node, \$pnode)) {
	    die("*** $0:\n".
		"    No physical node for $node!\n");
	}
	$virtnodes{$node} = $pnode;
    }
    else {
	$realnodes{$node} = $node;
    }
}
for my $node ( keys(%virtnodes) ) {
    my $pnode = $virtnodes{$node};

    if (defined($realnodes{$pnode})) {
	print "*** Dropping $node since its host ($pnode) will reboot ...\n";
	delete($virtnodes{$node});
    }
}
if (! keys(%realnodes) && ! keys(%virtnodes)) {
    print "No nodes to reboot. Exiting ...\n";
    exit(0);
}

#
# By here we've done all the preliminaries... send the event, unless we're
# in realmode.
#

my @sortednodes = sort(keys(%realnodes));

if (!$realmode) {
    EventSendFatal(host      => $BOSSNODE ,
		   objtype   => TBDB_TBEVENT_COMMAND ,
		   eventtype => TBDB_COMMAND_REBOOT ,
		   objname   => join(",",@sortednodes) );
    if (!$nowait) {
	# In here we can do some output to tell the user what's going on.
	if ($waitmode) {
	    # Wait for [SHUTDOWN,ISUP]

	} else {
	    # Wait for [SHUTDOWN]

	}
    }
    exit(0);
}

#
# Another shark hack. Well, perhaps not. We really don't want 50 nodes
# all rebooting at the same time, PCs *or* sharks. Lets order them
# so that the shelves are grouped together at least, and issue the reboots
# in batches. 
#
while (@sortednodes) {
    my @batch = ();
    my $i     = 0;
    my $lastshelf = 0;

    while ($i < 8 && @sortednodes > 0) {
	my $node = shift(@sortednodes);
	my $shelf;
	my $unit;

	#
	# The point of this sillyness is stop at each shelf transition.
	#
	if (IsShelved($node, \$shelf, \$unit)) {
	    if ($lastshelf && $lastshelf ne $shelf) {
		unshift(@sortednodes, $node);
		last;
	    }
	    $lastshelf = $shelf;
	}

	push(@batch, $node);
	$i++;
    }

    if ($force) {
        #
        # In force mode, call the power program for the whole batch, and
	# continue on. We don't wait for them to go down or reboot.
        #
	info("Force mode: power cycle ".join(" ",@batch));
	PowerCycle(@batch);
	if ($?) {
	    exit ($? >> 8);
	}
    }
    else {
        #
        # Fire off a reboot process so that we can overlap them all.
        # We need the pid so we can wait for them all before preceeding.
        #
	foreach my $node ( @batch ) {
	    $mypid = RebootNode($node);
	    $pids{$node} = $mypid;
	}
    }

    # 
    # If there are more nodes to go, then lets pause a bit so that we
    # do not get a flood of machines coming up all at the same exact
    # moment.
    #
    if (@sortednodes) {
	print STDOUT "Pausing to give some nodes time to reboot ...\n";
	if ($lastshelf) {
	    sleep(15);
	} else {
	    sleep(10);
	}
    }
}

#
# Wait for all the reboot children to exit before continuing.
#
my @needPowercycle = ();
if (! $force) {
    foreach my $node ( sort(keys(%realnodes)) ) {
	my $mypid     = $pids{$node};

	waitpid($mypid, 0);
	my $status = $? >> 8;
	if ($status == 2) {
	    # Child signaled to us that this node needs a power cycle
	    push @needPowercycle, $node;
	} elsif ($?) {
	    $failed++;
	    print STDERR "Reboot of node $node failed!\n";
	}
	else {
	    print STDOUT "$node rebooting ...\n";
	}
    }
}

#
# Power cycle nodes that couldn't be brought down any other way
#
if (@needPowercycle) {
    PowerCycle(@needPowercycle);
}

#
# Now do vnodes. Do these serially for now (simple).
# 
for my $node ( keys(%virtnodes) ) {
    my $pnode = $virtnodes{$node};

    if (RebootVNode($node, $pnode)) {
	$failed++;
	print STDERR "Reboot of node $node on $pnode failed!\n";
    }
    else {
	print STDOUT "$node on $pnode rebooting ...\n";
    }
}

if ($failed) {
    print STDERR "$failed real nodes could not be rebooted\n";
    exit($failed);
}

#
# Wait for nodes to reboot. We wait only once, no reboots. 
# 
if ($waitmode) {
    my $waitstart = time;

    print STDOUT "Waiting for nodes to come up ...\n";

    # Wait for events to filter through stated! If we do not wait, then we
    # could see nodes still in ISUP.
    sleep(2);

    foreach my $node ( sort(@nodes) ) {
	if (!TBNodeStateWait($node, TBDB_NODESTATE_ISUP, $waitstart, (60*6))) {
	    print STDOUT "$node is alive and well\n";
	    SetNodeBootStatus($node, NODEBOOTSTATUS_OKAY);
	    next;
	}
	SetNodeBootStatus($node, NODEBOOTSTATUS_FAILED);
	$failed++;
    }
}
print "Done. There were $failed failures to reboot.\n";
exit $failed;

#
# Reboot a node in a child process. Return the pid to the parent so
# that it can wait on all the children later.
# 
sub RebootNode {
    my ($pc) = @_;
    my ($status, $syspid, $mypid, $didipod);

    print STDOUT "Rebooting $pc ...\n";

    # Report some activity into last_ext_act
    TBActivityReport($pc);

    $mypid = fork();
    if ($mypid) {
	return $mypid;
    }
    TBdbfork();

    #
    # See if the machine is pingable. If its not pingable, then we just
    # power cycle the machine rather than wait for ssh to time out.
    #
    # ping returns 0 if any packets make it through. 
    #
    if (! DoesPing($pc)) {
	info("$pc appears dead: power cycle");
	print STDERR "$pc appears to be dead. Power cycling ...\n" if $debug;
	# Signal to the parent that the node needs to be power cycled
	exit(2);
    }

    #
    # Machine is pingable at least. Try to reboot it gracefully,
    # or power cycle anyway if that does not work. 
    #
    print STDERR "Trying ssh reboot of $pc ...\n" if $debug;

    #
    # Must change our real UID to root so that ssh will work. We save the old
    # UID so that we can restore it after we finish the ssh
    #
    my $oldUID = $UID;
#    print STDERR "Saved UID: $oldUID\n" if $debug;
    $UID = 0;

    #
    # Run an ssh command in a child process, protected by an alarm to
    # ensure that the ssh is not hung up forever if the machine is in
    # some funky state.
    # 
    $syspid = fork();

    if ($syspid) {
	local $SIG{ALRM} = sub { kill("TERM", $syspid); };
	alarm 20;
	waitpid($syspid, 0);
	alarm 0;

	#
	# The ssh can return non-zero exit status, but still have worked.
	# FreeBSD for example.
	#
	print STDERR "reboot of $pc returned $?.\n" if $debug;

	#
	# If either ssh is not running or it timed out,
	# send it a ping of death.
	# 
	if ($? == 256 || $? == 15) {
	    if ($? == 256) {
		print STDERR "$pc is not running sshd.\n" if $debug;
	    } else {
		print STDERR "$pc is wedged.\n" if $debug;
	    }
	    info("$pc: ssh reboot failed ... sending ipod");
	    print STDERR "Trying Ping-of-Death on $pc ...\n" if $debug;

	    system("$ipod $pc");
	    $didipod = 1;
	} else {
	    info("$pc: ssh reboot ($?)");
	    $didipod = 0;
	}
    }
    else {
	exec("$ssh -host $pc /sbin/reboot");
	exit(0);
    }

    #
    # Restore the old UID so that scripts run from this point on get the 
    # user's real UID
    #
    $UID = $oldUID;
#    print STDERR "Restored UID: $UID\n" if $debug;

    #
    # Okay, before we power cycle lets really make sure. We wait a while
    # for it to stop responding to pings, and if it never goes silent,
    # punch the power button.
    #
    if (WaitTillDead($pc) == 0) {
	my $state = TBDB_NODESTATE_SHUTDOWN;
	TBSetNodeEventState($pc,$state);
	exit(0);
    }

    #
    # Haven't yet tried an ipod, try that and wait again.
    # This further slows down reboot but is probably worth it
    # since this should be a rare case (reboot says it worked but
    # node doesn't reboot) and is vital if the nodes have no
    # power cycle capability to fall back on.
    #
    if (! $didipod) {
	info("$pc: reboot failed ... sending ipod");
	$UID = 0;
	system("$ipod $pc");
	$UID = $oldUID;
	if (WaitTillDead($pc) == 0) {
	    my $state = TBDB_NODESTATE_SHUTDOWN;
	    TBSetNodeEventState($pc,$state);
	    exit(0);
	}
    }

    info("$pc: ipod failed ... power cycle");
    print STDERR "$pc is still running. Power cycling ...\n" if $debug;
    exit(2);
}

#
# Reboot a vnode in a child process, and wait for it. 
# 
sub RebootVNode($$) {
    my ($vnode, $pnode) = @_;
    my $syspid;

    print STDOUT "Rebooting $vnode on $pnode ...\n";

    #
    # Run an ssh command in a child process, protected by an alarm to
    # ensure that the ssh is not hung up forever if the machine is in
    # some funky state.
    # 
    $syspid = fork();

    if ($syspid) {
	local $SIG{ALRM} = sub { kill("TERM", $syspid); };
	alarm 20;
	waitpid($syspid, 0);
	alarm 0;
	my $exitstatus = $?;

	#
	# The ssh can return non-zero exit status, but still have worked.
	# FreeBSD for example.
	#
	print STDERR "reboot of $vnode returned $exitstatus.\n" if $debug;

	#
	# Look for setup failure, reported back through ssh.
	# 
	if ($exitstatus) {
	    if ($exitstatus == 256) {
		print STDERR "$pnode is not running sshd.\n" if $debug;
	    }
	    elsif ($exitstatus == 15) {
		print STDERR "$pnode is wedged.\n" if $debug;
	    }
	}
	return($exitstatus);
    }
    #
    # Must change our real UID to root so that ssh will work.
    #
    $UID = 0;

    exec("$ssh -host $pnode $CLIENT_BIN/vnodesetup -r -j $vnode");
    exit(0);
}

#
# Power cycle a PC using the testbed power program.
#
sub PowerCycle {
    my @pcs = @_;

    my $pcstring = join(" ",@pcs);

    system("$power cycle $pcstring");
    return $? >> 8;
}

#
# Wait until a machine stops returning ping packets.
# 
sub WaitTillDead {
    my ($pc) = @_;

    print STDERR "Waiting for $pc to die off\n" if $debug;

    #
    # Sigh, a long ping results in the script waiting until all the
    # packets are sent from all the pings, before it will exit. So,
    # loop doing a bunch of shorter pings.
    #
    for ($i = 0; $i < 30; $i++) {
	if (! DoesPing($pc)) {
	    print STDERR "$pc is rebooting.\n" if $debug;
	    return 0;
	}
    }
    print STDERR "$pc is still alive.\n" if $debug;
    return 1;
}

#
# Returns 1 if host is responding to pings, 0 otherwise
#
sub DoesPing {
    my ($pc) = @_;
    my $status;
    my $saveuid;

    $saveuid = $UID;
    $UID = 0;
    system("$ping -q -i 0.25 -c 8 -t 2 $pc >/dev/null 2>&1");
    $UID = $saveuid;
    $status = $? >> 8;

    #
    # Returns 0 if any packets are returned. Returns 2 if pingable
    # but no packets are returned. Other non-zero error codes indicate
    # other problems.  Any non-zero return indicates "not pingable" to us.
    # 
    print STDERR "$ping $pc returned $status\n" if $debug;
    if ($status) {
	return 0;
    }
    return 1;
}


sub info($) {
    my $message = shift;
    # Print out log entries like this:
    # Sep 20 09:36:00 $message
    open(LOG,">> $logfile");
    print LOG strftime("%b %e %H:%M:%S",localtime)." $message\n";
    close(LOG);
}

