#!/usr/bin/perl -wT

#
# EMULAB-COPYRIGHT
# Copyright (c) 2000-2003 University of Utah and the Flux Group.
# All rights reserved.
#

use English;
use Getopt::Std;
use Socket;
use IO::Handle;     # thousands of lines just for autoflush :-(

#
# usage: staticroutes <pid> <eid>
#
sub usage()
{
    print("Usage: staticroutes [-n [-s|-l|-b]] [-d] [-f] [-t] <pid> <eid>\n".
	  "       Use -n to print routes, but leave the DB alone.\n".
	  "       Use -s (with -n) to print routes in NS format.\n".
	  "       Use -b (with -n) to print routes in Freebsd format.\n".
	  "       Use -l (with -n) to print routes in Linux format.\n".
	  "       Use -d to turn on debugging output.\n".
	  "       Use -t to optimize network routes.\n".
	  "       Use -f to force route calculation; ignore 'static' flag.\n");
    exit(-1);
}
my  $optlist = "dnftslb";

#
# Configure variables
#
my $TB		= "@prefix@";
my $NETMASK	= "255.255.255.0";

my $debug       = 0;
my $routecalc   = "$TB/libexec/routecalc";
my $impotent    = 0;
my $force	= 0;
my $optimize    = 1;
my $format      = "";

#
# Testbed Support libraries
#
use lib "@prefix@/lib";
use libdb;
use libtestbed;

# un-taint path
$ENV{'PATH'} = '/bin:/usr/bin:/usr/local/bin';
delete @ENV{'IFS', 'CDPATH', 'ENV', 'BASH_ENV'};

#
# Turn off line buffering on output
#
$| = 1; 

#
# Parse command arguments. Once we return from getopts, all that should be
# left are the required arguments.
#
%options = ();
if (! getopts($optlist, \%options)) {
    usage();
}
if (@ARGV != 2) {
    usage();
}
if (defined($options{"d"})) {
    $debug = 1;
}
if (defined($options{"n"})) {
    $impotent = 1;
}
if (defined($options{"f"})) {
    $force = 1;
}
if (defined($options{"t"})) {
    $optimize = 0;
}
if (defined($options{"s"})) {
    $format = "ns";
}
if (defined($options{"b"})) {
    $format = "bsd";
}
if (defined($options{"l"})) {
    $format = "suxs";
}
if ($format && !$impotent) {
    usage();
}

my $pid = $ARGV[0];
my $eid = $ARGV[1];

#
# Untaint args.
#
if ($pid =~ /^([-\@\w]+)$/) {
    $pid = $1;
}
else {
    die("Bad data in pid: $pid.");
}
if ($eid =~ /^([-\@\w]+)$/) {
    $eid = $1;
}
else {
    die("Bad data in eid: $eid.");
}

#
# Get the list of nodes.
# 
my $query_result =
    DBQueryFatal("select vname,ips,routertype from virt_nodes ".
		 "where pid='$pid' and eid='$eid'");

if (!$query_result->numrows) {
    warn("*** $0:\n".
	 "    No nodes in experiment $pid/$eid!\n");
    exit(0);
}

# A Flag.
my $dostatic = 0;

# A map of ips for each node, indexed by vname:port. 
my %ips      = ();

# A map (and reverse map) of node (vname) to unique index.
my %map      = ();
my %rmap     = ();
my $index    = 0;

# A map of lans, where each is a list of the members, indexed by lan.
my %lans     = ();

# A reverse map (sorta). Map a pair of links back to the lan they belong to.
my %rlans    = ();

# The costs, indexed by lan. This is kinda bogus, but since the cost
# is the same for each member of a lan, no big deal.
my %costs    = ();

# Number of links per node, indexed by node (vname). This is strictly
# for generating NS style output. When there is more than one link on
# a node, we *must* generate net routes instead of host routes, or the
# parser will be unhappy.
my %linkcount= ();

# list of ports that a node is connected on. Indexed by node.
my %nodeportlist = ();

#
# Convert list of nodes into a map of $vname:$port to IP. We will need the
# IPs later when filling in the virt_routes table.
# 
while (my ($vname,$ips,$routertype) = $query_result->fetchrow_array) {
    if (!$force && $routertype ne TBDB_ROUTERTYPE_STATIC()) {
	next;
    }
    $dostatic++;
    
    $linkcount{$vname} = 0;
    
    if (! defined($nodeportlist{$vname}) ) {
      $nodeportlist{$vname} = [];
    }
    
    foreach my $ipinfo (split(" ", $ips)) {
	my ($port,$ip) = split(":", $ipinfo);
	$ips{"$vname:$port"} = $ip;
	if (! defined($map{$vname})) {
	    $map{$vname}  = $index;
	    $rmap{$index} = $vname;
	    $index++;
	}
	push( @{$nodeportlist{$vname}}, $port );
	$linkcount{$vname} += 1;
    }
}

if (! $dostatic) {
    warn("No nodes requested static routing in $pid/$eid. This is okay!\n");
    exit(0);
}

#
# Now get the lans. 
#
$query_result =
    DBQueryFatal("select vname,member,cost " .
		 "from virt_lans where pid='$pid' and eid='$eid'");
if (!$query_result->numrows) {
    warn("*** $0:\n".
	 "    No links or lans in experiment $pid/$eid!\n");
    exit(0);
}

while (my ($vname,$member,$cost) = $query_result->fetchrow_array) {
    if (! defined($lans{$vname})) {
	$lans{$vname} = [];
    }
    push(@{$lans{$vname}},$member);
    $costs{$vname} = $cost;
}

#
# We use perl IPC goo to create a child we can both write to and read from
# (normal perl I/O provides just unidirectional I/O to a process).
# 
if (! socketpair(CHILD, PARENT, AF_UNIX, SOCK_STREAM, PF_UNSPEC)) {
    die("*** $0:\n".
	"    socketpair failed: $!\n");
}

CHILD->autoflush(1);
PARENT->autoflush(1);

my $childpid = fork();
if (! $childpid) {
    close CHILD;

    #
    # Dup our descriptors to the parent, and exec the program.
    # The parent then talks to it read/write.
    #
    open(STDIN,  "<&PARENT") || die "Can't redirect stdin";
    open(STDOUT, ">&PARENT") || die "Can't redirect stdout";
    open(STDERR, ">&PARENT") || die "Can't redirect stderr";

    exec($routecalc);
    die("*** $0:\n".
	"    exec $routecalc failed: $!\n");
}
close PARENT;

#
# Okay, now send adjacency info for all the nodes on each lan to the child.
#
foreach my $lan (keys(%lans)) {
    my @members = @{$lans{$lan}};

    foreach my $member1 (@members) {
	foreach my $member2 (@members) {
	    if ($member1 ne $member2) {
		my ($node1,$port1) = split(":", $member1);
		my ($node2,$port2) = split(":", $member2);
		my $id1 = $map{$node1};
		my $id2 = $map{$node2};

		# Reverse mapping for later. 
		$rlans{"$node1:$node2"} = $lan;

		if ($debug) {
		    print STDERR "$member1($id1) $member2($id2)\n";
		}

		print CHILD "i $id1 $id2 $costs{$lan}\n";
	    }
	}
    }
}
# Tell the child to print the routes.
print CHILD "C\n";

#
# Read back the results from the child.
#
my @results = ();
while (<CHILD>) {
    if ($debug) {
	print "$_";
    }
    push(@results, $_);
}
# Tell the child to quit. Then wait for it.
print CHILD "q\n";
waitpid($childpid, 0);
if ($?) {
    die("*** $0:\n".
	"    $routecalc failed with status: $?\n");
}

#
# Parse the routes. Need to map the indices back to nodes, and then form a
# matrix. Why, well you will see in a bit ...
#
my %routes	= ();
my %netroutes   = ();

#
# Host route ips for interfaces of a dst node besides the nearest one
# This is indexed by a node (i.e. a "src:dst" node) and is a list of dst ips
# The hop info is obtained from the shortest path route
my %hostroutes = ();

foreach my $result (@results) {
    my ($src, $dst, $hop);

    if ($result =~ /route (\d+) to (\d+) via (\d+)/) {
	$src = $rmap{$1};
	$dst = $rmap{$2};
	$hop = $rmap{$3};
    }
    else {
	die("*** $0:\n".
	    "    $routecalc returned a bad line: '$result'\n");
    }
    if ($debug) {
	print "src:$src dst:$dst hop:$hop\n";
    }
    $routes{"$src:$dst"} = $hop;
}

#
# Clean the routes.
#
if (! $impotent) {
    DBQueryFatal("delete from virt_routes where ".
		 "pid='$pid' and eid='$eid'");
}

#
# Now it gets fun. We have to go through each src:dst pair in the route
# list. The problem is that the dst could be multihomed and multiple hops
# away, and so we have no idea what interface (IP) we are actually routing
# to. We have to know the IP, or else we won't be able to insert the route!
# So, we use the matrix to recurse through and find our way to the
# destination. When we get to the last hop, we can use the src:dst of that
# last hop to index into rlans, which gives the full lanlink list. Then we
# search that to find the IP.
#
foreach my $route (keys(%routes)) {
    my ($src,$dst) = split(":", $route);
    my $hop  = $routes{$route};
    my $type = 'host';
    my $directlyconn = 0;
    my $netroutedefined = 0;
    # remember the port for which we have dstip
    my $dstport;

    #
    # This is the lan that contains the src and hop. (the link). 
    #
    my $srclan = $rlans{"$src:$hop"};
    
    #
    # This is the lan that contains the node one hop before dst and dst
    # 
    my $dstlan;
    
    #
    # Members in the srclan and dstlan respectively
    #
    my @srcmembers;
    my @dstmembers;

    #
    # If directly connected, skip adding the route into the DB
    # However, we still need to add a route for other interfaces
    # of the directly connected node
    if ($dst eq $hop) {
	$directlyconn = 1;
	$dstlan = $rlans{"$src:$dst"};
	@dstmembers = @{$lans{$dstlan}};
	@srcmembers = @{$lans{$srclan}};
	#
	# Scan dstmembers till we find the dst. This is the IP we want.
	#
	foreach my $member (@dstmembers) {
	    my ($node,$port) = split(":", $member);
	    
	    if ($node eq $dst) {
		$dstport = $port;
		last;
	    }
	}
	
	goto HOSTROUTES;
    }

    #
    # Now we need to find the destination lan (link) by stepping through
    # each hop till we get to it.
    #
    my $nhop = $hop;
    while (1) {
	# Next hop to destination.
	if (!defined($routes{"$nhop:$dst"})) {
	    die("*** $0:\n".
		"    Failed to find route: $nhop:$dst!\n");
	}
	my $nnhop = $routes{"$nhop:$dst"};

	# Last hop to destination.
	if ($nnhop eq $dst) {
	    last;
	}
	$nhop = $nnhop;
    }
    $dstlan = $rlans{"$nhop:$dst"};

    if ($debug) {
	print "$src --> $dst : $nhop:$dst\n";
    }
    
    #
    # The members of the lan are used to map back to the IPs of the
    # interfaces (since we need IPs to insert route entries).
    #
    @srcmembers = @{$lans{$srclan}};
    @dstmembers = @{$lans{$dstlan}};

    # Want to find these.
    my ($srcip,$dstip,$hopip);
    
    #
    # Scan dstmembers till we find the dst. This is the IP we want.
    #
    foreach my $member (@dstmembers) {
	my ($node,$port) = split(":", $member);

	if ($node eq $dst) {
	    $dstip = $ips{$member};
	    $dstport = $port;
	    last;
	}
    }

    #
    # If optimzing create a net route and avoid a per-host entry for each
    # pair. Convert the route, but remember we did it so we can skip similar
    # routes in the future.
    #
    if ($optimize) {
	my $newip = inet_ntoa(inet_aton($dstip) & inet_aton($NETMASK));

	if (defined($netroutes{"$src:$newip"})) {
	    if ($netroutes{"$src:$newip"} ne $hop) {
		die("*** $0:\n".
		    "    network route mismatch: $src:$dst:$hop!\n");
	    }
	    $netroutedefined = 1;
	} else {
	    $netroutes{"$src:$newip"} = $hop;
	    $type  = "net";
	    $dstip = $newip;
	}
    }

HOSTROUTES:    

    #
    # Scan srcmembers to find the IPs for the src and hop.
    #
    foreach my $member (@srcmembers) {
	my ($node,$port) = split(":", $member);
	
	if ($node eq $src) {
	    $srcip   = $ips{$member};
	    next;
	}
	if ($node eq $hop) {
	    $hopip = $ips{$member};
	    next;
	}
    }    

    # Construct host routes for the other interfaces of dst
    foreach my $port (@{$nodeportlist{$dst}}) {

	# We already have a route for the ip on dstport
	if ( $port eq $dstport ) {
	    next;
	}
	
	my $newip = $ips{"$dst:$port"};
	my $newipsubnet = inet_ntoa(inet_aton($newip) & inet_aton($NETMASK));
	
	# If we already have a route to newipsubnet via the same hop,
	# we don't need the host route
	if ( defined($netroutes{"$src:$newipsubnet"}) &&
	     $netroutes{"$src:$newipsubnet"} eq $hop ) {
	    next;
	} else {	    
	    $hostroutes{"$src:$srcip%$dst:$newip"} = "$hop:$hopip";
	}
    }

    # We had to run till here to store hostroutes
    # that may have to be added later. However,
    # we can skip for directly connected neighbors
    # or if net route was already defined
    if ($directlyconn || $netroutedefined) {
	next;
    }
    
    if ($impotent) {
	if ($debug) {
	    printf(STDERR "%s: %-23s --> %-23s - %s\n",
		   ($type eq "net" ? "n" : "h"),
		   "$src:$srcip", "$dst:$dstip", "$hop:$hopip");
	}
	if ($format eq "ns") {
	    print "\$${src} add-route ";
	    if ($type eq "host" && $linkcount{$dst} == 1) {
		print "\$${dst} \$${hop}\n";
	    }
	    else {
		print "\$${dstlan} \$${hop}\n";
	    }
	}
	elsif ($format eq "bsd") {
	    if ($type eq "host") {
		print "route add -host $dstip $hopip\n";
	    }
	    else {
		print "route add -net $dstip $hopip $NETMASK\n";
	    }
	}
	elsif ($format eq "suxs") {
	    if ($type eq "host") {
		print "route add -host $dstip gw $hopip\n";
	    }
	    else {
		print "route add -net $dstip netmask $NETMASK gw $hopip\n";
	    }
	}
    }
    else {
	DBQueryFatal("insert into virt_routes ".
		     " (pid,eid,vname,src,dst,nexthop,dst_type) ".
		     " values ('$pid', '$eid', '$src', '$srcip', '$dstip', ".
		     "         '$hopip', '$type')");
    }
}

# This part adds host routes for subnets that don't have a route.
# However, the first route will be added as a net route
# and if subsequent host routes are different from the first
# route we added, only then will the host routes get added.
foreach my $hostroute (keys(%hostroutes)) {
    my ($srcinfo,$dstinfo) = split("%", $hostroute);
    my ($src,$srcip) = split(":", $srcinfo);
    my ($dst,$dstip) = split(":", $dstinfo);
    my ($hop,$hopip) = split(":", $hostroutes{$hostroute});
    my $type = 'host';
    
    my $dstipsubnet = inet_ntoa(inet_aton($dstip) & inet_aton($NETMASK));
    
    # If we already have a net route to dstipsubnet via the same hop,
    # we don't need the host route
    if ( defined($netroutes{"$src:$dstipsubnet"}) ) {
	if ($netroutes{"$src:$dstipsubnet"} eq $hop ) {
	    next;
	}
    } else {

	# We do the following optimization only for
	# hosts that are _not_ directly connected
	# neighbors. Otherwise, adding interface 
	# subnet routes fail. Even with this certain
	# redundant links might be unused since the
	# route calculator ended up choosing one of
	# the routes over the other(s)
	if ($optimize && ($dst ne $hop)) {
	    $netroutes{"$src:$dstipsubnet"} = $hop;
	    $type = "net";
	    $dstip = $dstipsubnet;
	}
    }
    
    if ($impotent) {
	if ($debug) {
	    printf(STDERR "%s: %-23s --> %-23s - %s\n",
		   ($type eq "net" ? "n" : "h"),
		   "$src:$srcip", "$dst:$dstip", "$hop:$hopip");
	}
	# No need to print the host routes in the 'ns' case
	# since we already have printed a route for $dst
	if ($format eq "bsd") {	    
	    if ($type eq "host") {
		print "route add -host $dstip $hopip\n";
	    }
	    else {
		print "route add -net $dstip $hopip $NETMASK\n";
	    }
	}
	elsif ($format eq "suxs") {
	    if ($type eq "host") {
		print "route add -host $dstip gw $hopip\n";
	    }
	    else {
		print "route add -net $dstip netmask $NETMASK gw $hopip\n";
	    }
	}
    }
    else {
	DBQueryFatal("insert into virt_routes ".
		     " (pid,eid,vname,src,dst,nexthop,dst_type) ".
		     " values ('$pid', '$eid', '$src', '$srcip', '$dstip', ".
		     "         '$hopip', '$type')");
    }
}

exit 0;



