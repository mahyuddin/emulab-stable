#!/usr/bin/perl -wT
use English;
use Getopt::Std;
 
#
# Create a user account. All this script does is create the account
# if it does not exist, or update the password and gecos fields.
# No groups processing is done here. The initial account is created in
# the "guest" group; use the setgroups command to set a users groups.
#
# XXX - /users wired in. 
# 
sub usage()
{
    print STDOUT "Usage: mkacct [-a] <name>\n";
    exit(-1);
}
my  $optlist = "a";

#
# Configure variables
#
my $TB      = "@prefix@";
my $TBOPS   = "@TBOPSEMAIL@";
my $TBLOGS  = "@TBLOGSEMAIL@";
my $CONTROL = "@USERNODE@";
my $BOSSNODE= "@BOSSNODE@";

my $HOMEDIR = "/users";
my $USERPATH= "$TB/bin";
my $PBAG    = "$TB/sbin/paperbag";
my $SSH     = "$TB/bin/sshtb";
my $USERADD = "/usr/sbin/pw useradd";
my $USERDEL = "/usr/sbin/pw userdel";
my $USERMOD = "/usr/sbin/pw usermod";
my $CHPASS  = "/usr/bin/chpass";
my $KEYGEN  = "/usr/bin/ssh-keygen";
my $SETGROUPS = "$TB/sbin/setgroups";
my $GENELISTS = "$TB/sbin/genelists";

my $auditmode = 0;
my $logname;
my $user;
my @db_row;
my $query_result;

#
# Note hardwired control node. 
# 
my $control_node = $CONTROL;

#
# We don't want to run this script unless its the real version.
#
if ($EUID != 0) {
    die("*** $0:\n".
	"    Must be setuid! Maybe its a development version?\n");
}

#
# This script is setuid, so please do not run it as root. Hard to track
# what has happened.
# 
if ($UID == 0) {
    die("*** $0:\n".
	"    Please do not run this as root! Its already setuid!\n");
}

#
# Untaint the path
# 
$ENV{'PATH'} = "/bin:/usr/bin";
delete @ENV{'IFS', 'CDPATH', 'ENV', 'BASH_ENV'};

#
# Turn off line buffering on output
#
$| = 1;

#
# Load the Testbed support stuff. 
#
use lib "@prefix@/lib";
use libdb;
use libtestbed;

#
# Parse command arguments. Once we return from getopts, all that should be
# left are the required arguments.
#
%options = ();
if (! getopts($optlist, \%options)) {
    usage();
}
if (defined($options{"a"})) {
    $auditmode = 1;
}
if (@ARGV != 1) {
    usage();
}
$user = $ARGV[0];

#
# Untaint the argument.
#
if ($user =~ /^([a-z0-9]+)$/i) {
    $user = $1;
}
else {
    die("Invalid uid '$user' contains illegal characters.\n");
}
my $SSHDIR  = "$HOMEDIR/$user/.ssh";

#
# This script always does the right thing, but we prefer that mere users
# do not run it, except when its for themselves. Otherwise, make sure that
# user has group/project root in at least one project, which indicates they
# have some level of responsibility.
#
if (!TBAdmin($UID)) {
    my $dbuid;

    if (! UNIX2DBUID($UID, \$dbuid)) {
	die("You are not a valid emulab user!\n");
    }
    if ($dbuid ne $user) {
	#
	# Check if group_root/project_root anyplace.
	#
	$query_result =
	    DBQueryFatal("select trust from group_membership ".
			 "where uid='$dbuid' and ".
			 "trust='project_root' or trust='group_root'");

	if ($query_result->numrows == 0) {
	    die("$0: You do not have permission to run this script!\n");
	}
    }
}

#
# In audit mode, go to background and wait so we can send email.
# 
if ($auditmode) {
    my $childpid;
    
    #
    # Create a temporary name for a log file.
    #
    $logname = TBMakeLogname("mkacct");
    
    if ($childpid = TBBackGround($logname)) {
	waitpid($childpid, 0);
	exit($? >> 8);
    }
}

#
# Get the user info (the user being created). This join picks out the
# user's earliest project membership to use for the default group.
#
$query_result =
    DBQueryFatal("select u.usr_pswd,u.unix_uid,u.usr_name, ".
		 " u.usr_email,u.status,m.pid ".
		 " from users as u ".
		 "left join group_membership as m ".
		 " on u.uid=m.uid and m.pid=m.gid ".
		 "where u.uid='$user' order by date_approved asc limit 1");

if ($query_result->numrows == 0) {
    fatal("$user is not in the DB. This is bad.\n");
}
@db_row         = $query_result->fetchrow_array();
my $pswd        = $db_row[0];
my $user_number = $db_row[1]; 
my $fullname    = $db_row[2];
my $user_email  = $db_row[3];
my $status      = $db_row[4];
my $defpid      = $db_row[5];

if ($status eq USERSTATUS_FROZEN ||
    $status eq USERSTATUS_NEWUSER ||
    $status eq USERSTATUS_UNAPPROVED) {
    #
    # All this stuff must be done as root (ssh).
    #
    $UID = $EUID;

    if ($control_node ne $BOSSNODE) {
	print "Removing user $user from $control_node.\n";
	if (system("$SSH -host $control_node '$USERDEL $user'") &&
	    (($? >> 8) != 67)) {
	    fatal("Could not remove user $user from $control_node.\n");
	}
    }

    print "Removing user $user from local node.\n";
    if (system("$USERDEL $user") && (($? >> 8) != 67)) {
	fatal("Could not remove user $user from local node.");
    }
    exit(0);
}

if (!defined($defpid)) {
    die("*** $0:\n".
	"    $user is not in any projects!\n");
}

#
# Unix info for users default group.
#
my $default_groupname;
my $default_groupgid;

if (! TBGroupUnixInfo($defpid, $defpid,
		      \$default_groupgid, \$default_groupname)) {
    fatal("No info for default project $defpid!");
}

#
# All this stuff must be done as root (ssh).
#
$UID = $EUID;

#
# Run genelists to update the email lists. This is a convenient
# spot to do this. Errors are non-fatal; the testbed list will
# will find out about problems via email from genelists. Note that
# this command must be run when EUID==UID==0 because its a setuid
# PERL script.
#
system("$GENELISTS -n $user");

#
# Make user on local. We don't give them a password since they are not
# allowed to log in, except via paperbag. 
#
if (system("egrep -q -s '^${user}:' /etc/passwd")) {
    print "Adding user $user ($user_number) to local node.\n";

    if (system("$USERADD $user -u $user_number -c \"$fullname\" ".
	       "-k /usr/share/skel -m -d $HOMEDIR/$user ".
	       "-g $default_groupname -s $PBAG")) {
	fatal("Could not add user $user to local node.");
    }
    #
    # First time account is made, do some extra work. 
    #
    FirstTime();
}
else {
    print "Updating user $user ($user_number) on local node.\n";

    #
    # MAKE SURE not to update anything else!
    #
    if (system("$USERMOD $user -c \"$fullname\" ")) {
	fatal("Could not modify user $user on local node.");
    }

    #
    # Temp Hack!
    # 
    FirstTime();
}

#
# Make user account on control node. We do the password setup as separate
# step since thats easier than trying to do both via ssh.
#
# Quote special chars for ssh and the shell on the other side
#
$fullname =~ s/\"/\'/g;
$fullname =~ s/([^\\])([\'\"\(\)])/$1\\$2/g;

if ($control_node ne $BOSSNODE) {
    if (system("$SSH -host $control_node ".
	       "egrep -q -s '^${user}:' /etc/passwd")) {
	print "Adding user $user ($user_number) to $control_node.\n";

	if (system("$SSH -host $control_node ".
		   "'$USERADD $user -u $user_number -c \\\"$fullname\\\" ".
		   "-k /usr/share/skel -m -d $HOMEDIR/$user ".
		   "-g $default_groupname -s /bin/tcsh'")) {
	    fatal("Could not add user $user ($user_number) ".
		  "to $control_node.\n");
	}
    }
    else {
	print "Updating user $user ($user_number) on $control_node.\n";

	#
	# MAKE SURE not to update anything else!
	#
	if (system("$SSH -host $control_node ".
		   "'$USERMOD $user -c \\\"$fullname\\\"'")) {
	    fatal("Could not modify user $user record on $control_node.");
	}
    }

    print "Updating user $user password on $control_node.\n";

    if (system("$SSH -host $control_node $CHPASS -p $pswd $user")) {
	fatal("Could not change password for user $user on $control_node.\n");
    }
}

#
# Create a new authorized keys file from DB.
#
# Grab pub keys.
#
$query_result =
    DBQueryFatal("select * from user_pubkeys where uid='$user'");

#
# Okay, regen it.
# 
if (open(AKEYS, "> $SSHDIR/authorized_keys.new")) {
    print "Generating a new authorized_keys file for $user\n";
    
    print AKEYS "#\n";
    print AKEYS "# DO NOT EDIT! This file auto generated by ".
	"Emulab.Net account software.\n";
    print AKEYS "#\n";
    print AKEYS "# Please use the web interface to edit your ".
	"public key list.\n";
    print AKEYS "#\n";

    while (my %row = $query_result->fetchhash()) {
	my $pubkey = $row{'pubkey'};

	print AKEYS "$pubkey\n";
    }
    close(AKEYS);

    chmod(0600, "$SSHDIR/authorized_keys.new") or
	fatal("Could not chmod authorized_keys.new for $user: $!");
    chown($user_number, $default_groupgid, "$SSHDIR/authorized_keys.new") or
	fatal("Could not chown authorized_keys.new for $user: $!");
	    
    if (-e "$SSHDIR/authorized_keys") {
	if (system("cp -f $SSHDIR/authorized_keys ".
		   "$SSHDIR/authorized_keys.old")) {
	    fatal("Could not save authorized_keys for $user: $!");
	}
	chmod(0600, "$SSHDIR/authorized_keys.old") or
	    fatal("Could not chmod authorized_keys.old for $user: $!");
	chown($user_number, $default_groupgid,
	      "$SSHDIR/authorized_keys.old") or
	    fatal("Could not chown authorized_keys.old for $user: $!");
    }
	    
    if (system("mv -f $SSHDIR/authorized_keys.new ".
	       "$SSHDIR/authorized_keys")) {
	fatal("Could not mv authorized_keys.new for $user: $!");
    }
}
else {
    warn("*** $0:\n".
	 "    Could not open new authorized_keys file for $user!\n");
}

if ($auditmode) {
    AUDIT("Account Create Completed!\n", 0);
    unlink($logname);
}
exit(0);

sub fatal {
    local($msg) = $_[0];

    SENDMAIL($TBOPS, "mkacct $user Failed", $msg, $TBOPS, undef,
	     (defined($logname) ? ($logname) : ()));
    die("$0: $msg\n");
}

sub AUDIT($)
{
    my($msg) = @_;

    SENDMAIL($TBLOGS, "mkacct $user Complete", $msg, $TBOPS, undef, $logname);
}

#
# Do some new account stuff.
#
sub FirstTime()
{
    my $dossh = 0;
    
    #
    # Set up the ssh key, but only if not done so already.
    #
    if (! -e "$SSHDIR" ) {
	print "Setting up ssh configuration for $user.\n";
    
	mkdir("$SSHDIR", 0700) or
	    fatal("Could not mkdir $SSHDIR: $!");
	chown($user_number, $default_groupgid, "$SSHDIR") or
	    fatal("Could not chown $SSHDIR: $!");
	
	$dossh = 1;
    }

    #
    # Check for missing identity file
    # 
    if (! -e "$SSHDIR/identity") {
	$dossh = 1;
    }
    
    #
    # The rest of this needs to be done as the user, so fork a child.
    #
    $mypid = fork();
    if ($mypid) {
	waitpid($mypid, 0);
	if ($?) {
	    exit($? >> 0);
	}
	return;
    }
    
    $EUID = $user_number;
    $UID  = $EUID;

    TBdbfork();

    if ($dossh) {
	if (system("$KEYGEN -P '' -f $SSHDIR/identity")) {
	    fatal("Failure in ssh-keygen");
	}

	#
	# Grab a copy for the DB.
	# 
	my $ident = `cat $SSHDIR/identity.pub`;

	if ($ident =~ /(\d*\s\d*\s[0-9a-zA-Z]*)\s([\w\@\.]*)/) {
	    DBQueryFatal("replace into user_pubkeys ".
			 "values ('$user', '$2', '$1 $2', now())");

	    #
	    # Backwards compat. Remove later.
	    #
	    DBQueryFatal("update users set emulab_pubkey='$1 $2' ".
			 "where uid='$user'");
	}
	else {
	    warn("*** $0:\n".
		 "    Bad emulab public key: $ident\n");
	}
    }

    #
    # Set up a .forward file so that any email to them gets forwarded off.
    #
    if (! -e "$HOMEDIR/$user/.forward" ) {
	print "Setting up .forward file for $user.\n";

	if (system("echo \"$user_email\" > $HOMEDIR/$user/.forward")) {
	    fatal("Could not create $HOMEDIR/$user/.forward");
	}
	chmod(0644, "$HOMEDIR/$user/.forward") or
	    fatal("Could not chmod $HOMEDIR/$user/.forward");
    }

    #
    # Add testbed path to .cshrc and .profile.
    #
    my $cpathstr = "set path = ($USERPATH \$path)";
    if (-e "$HOMEDIR/$user/.cshrc" &&
	system("egrep -q -s '$USERPATH' $HOMEDIR/$user/.cshrc")) {
	system("echo '$cpathstr' >> $HOMEDIR/$user/.cshrc");
    }

    my $spathstr = "PATH=$USERPATH:\$PATH";
    if (-e "$HOMEDIR/$user/.profile" &&
	system("egrep -q -s '$USERPATH' $HOMEDIR/$user/.profile")) {
	system("echo '$spathstr' >> $HOMEDIR/$user/.profile");
    }

    exit(0);
}
