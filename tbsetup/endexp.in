#!/usr/bin/perl -wT
use English;
use Getopt::Std;

#
# This gets invoked from the Web interface. Terminate an experiment.
# Most of the STDOUT prints are never seen since the web interface
# repeats only errors. My plan is make this script the front end to
# experiment termination and make tbend a backend program that no one
# uses.
#
# The -b (batch) argument is so that this script can be part of a batchmode
# that starts/ends experiments offline. In that case, we don't want to put
# it into the background and send email, but just want an exit status 
# returned to the batch system.
#
sub usage()
{
    print STDOUT "Usage: endexp [-b] <pid> <eid>\n";
    exit(-1);
}
my  $optlist = "b";

#
# Configure variables
#
my $TB     = "@prefix@";
my $DBNAME = "@TBDBNAME@";
my $TBOPS  = "@TBOPSEMAIL@";
my $TBLOGS = "@TBLOGSEMAIL@";

#
# Testbed Support libraries
#
use lib "@prefix@/lib";
use libdb;
use libtestbed;

my $tbdir    = "$TB/bin/";
my $projroot = "/proj";
my $tbdata   = "tbdata";
my $logname  = 0;
my $batch    = 0;
my $estate   = 0;
my $user_login;
my @row;
    
#
# Untaint the path
# 
$ENV{'PATH'} = '/bin:/usr/bin';
delete @ENV{'IFS', 'CDPATH', 'ENV', 'BASH_ENV'};

#
# Turn off line buffering on output
#
$| = 1;

#
# Parse command arguments. Once we return from getopts, all that should
# left are the required arguments.
#
%options = ();
if (! getopts($optlist, \%options)) {
    usage();
}
if (@ARGV != 2) {
    usage();
}
my $pid   = $ARGV[0];
my $eid   = $ARGV[1];
if (defined($options{"b"})) {
    $batch = $options{"b"};
}

#
# Untaint the arguments.
#
if ($pid =~ /^([-\@\w.]+)$/) {
    $pid = $1;
}
if ($eid =~ /^([-\@\w.]+)$/) {
    $eid = $1;
}

my $piddir  = "$projroot/$pid";
my $expdir  = "$piddir/exp";
my $eiddir  = "$expdir/$eid";

#
# Verify user and get his DB uid.
#
if (! UNIX2DBUID($EUID, \$user_login)) {
    print STDOUT "Go Away! You do not exist in the Emulab Database.\n";
    exit(1);
}

#
# Get email info for user.
#
my $user_name;
my $user_email;
if (! UserDBInfo($user_login, \$user_name, \$user_email)) {
    print STDOUT "Cannot determine your name and email address.\n";
    exit(1);
}

#
# Verify that this person is allowed to end the experiment. Must be
# in the project membership table, or must be an admin type. Note that
# any script down the line has to do an admin check also. 
#
if ($EUID && !TBAdmin($EUID) &&
    ProjMember($pid, $user_login) != PROJMEMBERTRUST_ROOT) {

    print STDOUT "Go Away! You do not have permission to end experiments ".
	         "in project $pid\n";
    exit(1);
}

#
# We have to protect against trying to end an experiment that is currently
# in the process of being terminated. We use a "wrapper" state (actually
# a timestamp so we can say when termination was requested) since
# terminating conists of a couple of different experiment states down inside
# the tb scripts. 
#
DBQueryFatal("lock tables experiments write");

$query_result =
    DBQueryFatal("SELECT expt_terminating,state,expt_head_uid ".
		 "FROM experiments WHERE eid='$eid' and pid='$pid'");

if ($query_result->numrows < 1) {
    print STDOUT "No such experiment $pid/$eid exists!\n";
    exit(1);
}

@row = $query_result->fetchrow_array();
if (defined($row[0])) {
    print STDOUT
	"It appears that $pid/$eid started terminating at $row[0]\n".
	"You will be notified via email when the experiment has been ".
	"torn down\n";
    exit(1);
}
my $expt_head_login = $row[2];

#
# Okay, check state. We do not allow termination to start when the
# experiment is in transition. A future task would be to allow this,
# but for now the experiment must be in one of a few states to proceed
#
# Seems like too many states!
#
$estate = $row[1];
if ($estate eq EXPTSTATE_PRERUN ||
    $estate eq EXPTSTATE_ACTIVATING ||
    $estate eq EXPTSTATE_SWAPPING ||
    $estate eq EXPTSTATE_TERMINATING) {
    print STDOUT
	"It appears that experiment $pid/$eid is in transition.\n".
	"The user that created the experiment will be notified via email\n".
        "when the experiment is no longer in transition, and can be killed\n";
    exit(1);
}

#
# Set the timestamp now, and unlock the experiments table.
#
$stamp = `date '+20%y-%m-%d %H:%M:%S'`;

DBQueryFatal("UPDATE experiments SET expt_terminating='$stamp' ".
	     "WHERE eid='$eid' and pid='$pid'");

DBQueryFatal("unlock tables");

#
# At this point a failure is going to leave things in an inconsistent
# state. Not much to do about that right now. 
#

#
# Get email address of the experiment head, which may be different than
# the person who is actually terminating the experiment, since its polite
# to let the original creator know whats going on. 
#
my $expt_head_name;
my $expt_head_email;

if (! UserDBInfo($expt_head_login, \$expt_head_name, \$expt_head_email)) {
    print STDERR "*** WARNING: ".
	         "Could not determine name/email for $expt_head_login.\n";
    $expt_head_name  = "TBOPS";
    $expt_head_email = $TBOPS;
}

#
# If not in batch mode, go into the background. Parent exits.
#
if (! $batch) {
    if (background()) {
	#
	# Parent exits normally
	#
	print STDOUT
	    "Experiment $pid/$eid is now terminating\n".
	    "You will be notified via email when the experiment has been\n".
	    "torn down, and you can reuse the experiment name.\n";
	exit(0);
    }
}

#
# Sanity check states in case someone changes something.
#
if ($estate eq EXPTSTATE_ACTIVE) { 
    print STDOUT "Running tbswapout with arguments: $pid $eid\n";
    if (system("$tbdir/tbswapout $pid $eid") != 0) {
	fatal("tbswapout failed!\n");
    }
    
    $estate = ExpState($pid,$eid);
    if ($estate ne EXPTSTATE_SWAPPED) {
	fatal("Experiment is in the wrong state: $estate\n");
    }
}

if ($estate eq EXPTSTATE_SWAPPED) {
    print STDOUT "Running tbend with arguments: $pid $eid\n";
    if (system("$tbdir/tbend $pid $eid") != 0) {
	fatal("tbend failed!\n");
    }    
    $estate = ExpState($pid,$eid);
    if ($estate ne EXPTSTATE_TERMINATED) {
	fatal("Experiment is in the wrong state: $estate\n");
    }
}

if ($estate ne EXPTSTATE_TERMINATED && $estate ne EXPTSTATE_NEW) {
    fatal("Experiment is in the wrong state: $estate\n");
}

#
# Try to remove experiment directory. We allow for it not being there
# cause we often run the tb programs directly. We also allow for not
# having permission, in the case that an admin type is running this,
# in which case it won't be allowed cause of directory permissions. Thats
# okay since admin types should rarely end experiments in other projects.
#
if (chdir($expdir)) {
    print STDOUT "Removing experiment directory: $eiddir\n";
    system("rm -rf $eid");
}
else {
    print STDOUT "Not able to remove experiment directory: $eiddir\n";
    print STDOUT "Someone will need to do this by hand.\n";
}

#
# Done! Remove all trace from the DB.
# 
DBQueryWarn("DELETE from experiments ".
	    "WHERE eid='$eid' and pid='$pid'");

DBQueryWarn("DELETE from nsfiles ".
	    "WHERE eid='$eid' and pid='$pid'");

print STDOUT "Termination Success\n";

#
# In batch mode, just exit without sending email.
#
if ($batch) {
    exit(0);
}

#
# Send email notification if not in batch mode.
#
if (! ($MAIL = OPENMAIL("$user_name <$user_email>",
			"TESTBED: Experiment $pid/$eid Terminated",
			undef,
			"Cc:  $expt_head_name <$expt_head_email>\n".
			"Bcc: $TBLOGS"))) {
    die("Cannot start mail program!");
}

print $MAIL "Experiment `$eid' in project `$pid' has been terminated.\n";
print $MAIL "You may now reuse `$eid' as an experiment name.\n\n";
print $MAIL "Appended below is the output of the experiment teardown.\n";
print $MAIL "If you have any questions or comments, please include the\n";
print $MAIL "output below in your message to $TBOPS\n";
print $MAIL "\n\n---------\n\n";

if (open(IN, "$logname")) {
    while (<IN>) {
	print $MAIL "$_";
    }
    close(IN);
}
close($MAIL);

unlink("$logname");
exit 0;

sub fatal($)
{
    my($mesg) = $_[0];
    local $MAIL;
    
    print STDOUT $mesg;

    #
    # In batch mode, exit without sending the email. 
    #
    if ($batch) {
	exit(-1);
    }

    #
    # Send a message to the testbed list. Append the logfile if it got
    # that far.
    #
    if (! ($MAIL = OPENMAIL("$user_name <$user_email>",
			    "TESTBED: Termination Failure: $pid/$eid",
			    undef,
			    "Cc: $expt_head_name <$expt_head_email>\n".
			    "Cc: $TBOPS"))) {
	die("Cannot start mail program!");
    }

    print $MAIL $mesg;

    if (open(IN, "$logname")) {
	print $MAIL "\n\n---------\n\n";
	
	while (<IN>) {
	    print $MAIL "$_";
	}
	close(IN);
    }
    close($MAIL);
    
    unlink("$logname");
    exit(-1);
}

#
# Put ourselves into the background so that caller sees immediate response.
# Mail notification will happen later.
# 
sub background()
{
    $mypid = fork();
    if ($mypid) {
	return $mypid;
    }

    #
    # We have to disconnect from the caller by redirecting both STDIN and
    # STDOUT away from the pipe. Otherwise the caller (the web server) will
    # continue to wait even though the parent has exited. 
    #
    open(STDIN, "< /dev/null") or
	die("opening /dev/null for STDIN: $!");

    #
    # Create a temporary name for a log file and untaint it.
    #
    $logname = `mktemp /tmp/end-$pid-$eid.XXXXXX`;

    # Note different taint check (allow /).
    if ($logname =~ /^([-\@\w.\/]+)$/) {
	$logname = $1;
    } else {
	die "Bad data in $logname";
    }

    open(STDERR, ">> $logname") or die("opening $logname for STDERR: $!");
    open(STDOUT, ">> $logname") or die("opening $logname for STDOUT: $!");

    return 0;
}
