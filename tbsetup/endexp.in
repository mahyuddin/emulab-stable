#!/usr/bin/perl -wT
use English;
use Getopt::Std;

#
# This gets invoked from the Web interface. Terminate an experiment.
# Most of the STDOUT prints are never seen since the web interface
# repeats only errors. My plan is make this script the front end to
# experiment termination and make tbend a backend program that no one
# uses.
#
# The -b (batch) argument is so that this script can be part of a batchmode
# that starts/ends experiments offline. In that case, we don't want to put
# it into the background and send email, but just want an exit status 
# returned to the batch system.
#
sub usage()
{
    print STDOUT "Usage: endexp [-b] <pid> <eid>\n";
    exit(-1);
}
my  $optlist = "b";

#
# Configure variables
#
my $TB     = "@prefix@";
my $DBNAME = "@TBDBNAME@";
my $TBOPS  = "@TBOPSEMAIL@";
my $TBLOGS = "@TBLOGSEMAIL@";

my $tbdir    = "$TB/bin/";
my $projroot = "/proj";
my $tbdata   = "tbdata";
my $logname  = 0;
my $batch    = 0;
my $estate   = 0;

#
# Untaint the path
# 
$ENV{'PATH'} = '/bin:/usr/bin';
delete @ENV{'IFS', 'CDPATH', 'ENV', 'BASH_ENV'};

#
# Turn off line buffering on output
#
$| = 1;

#
# Testbed Support library
# 
push(@INC, "$TB/lib");
require libtestbed;

#
# Parse command arguments. Once we return from getopts, all that should
# left are the required arguments.
#
%options = ();
if (! getopts($optlist, \%options)) {
    usage();
}
if (@ARGV != 2) {
    usage();
}
my $pid   = $ARGV[0];
my $eid   = $ARGV[1];
if (defined($options{"b"})) {
    $batch = $options{"b"};
}

#
# Untaint the arguments.
#
if ($pid =~ /^([-\@\w.]+)$/) {
    $pid = $1;
}
if ($eid =~ /^([-\@\w.]+)$/) {
    $eid = $1;
}

my $piddir  = "$projroot/$pid";
my $expdir  = "$piddir/exp";
my $eiddir  = "$expdir/$eid";

#
# Set up for querying the database.
# 
use Mysql;
my $DB = Mysql->connect("localhost", $DBNAME, "script", "none");

#
# Get some user information. 
#
$query_result = $DB->query("SELECT uid,usr_name,usr_email,admin from users ".
			   "WHERE unix_uid='$EUID'");

if (! $query_result) {
    fatal("DB Error getting user information for uid $EUID\n");
}
if ($query_result->numrows < 1) {
    print STDOUT "Go Away! You do not exist in the Emulab Database.\n";
    exit(1);
}

@row = $query_result->fetchrow_array();
$uid        = $row[0];
$user_name  = $row[1];
$user_email = $row[2];
$isadmin    = $row[3];

#
# Verify that this person is allowed to end the experiment. Must be
# in the project membership table, or must be an admin type. Note that
# any script down the line has to do an admin check also. 
#
if (! $isadmin) {
    $query_result =
	$DB->query("SELECT pid FROM proj_memb ".
		   "WHERE uid=\"$uid\" and pid=\"$pid\"");

    if (! $query_result) {
	fatal("DB Error getting project membership for uid $uid\n");
    }
    
    if ($query_result->numrows == 0) {
	print STDOUT "Go Away! You are not a member of project $pid\n";
	exit(1);
    }
}

#
# We have to protect against trying to end an experiment that is currently
# in the process of being terminated. We use a "wrapper" state (actually
# a timestamp so we can say when termination was requested) since
# terminating conists of a couple of different experiment states down inside
# the tb scripts. 
#
$query_result = $DB->query("lock tables experiments write");
if (! $query_result) {
    fatal("DB Error locking experiments table");
}

$query_result =
    $DB->query("SELECT expt_terminating,state FROM experiments ".
	       "WHERE eid='$eid' and pid='$pid'");

if (! $query_result) {
    fatal("DB Error getting experiment termination date for $pid/$eid\n");
}
if ($query_result->numrows < 1) {
    print STDOUT "No such experiment $pid/$eid exists!\n";
    exit(1);
}

@row = $query_result->fetchrow_array();
if (defined($row[0])) {
    print STDOUT
	"It appears that $pid/$eid started terminating at $row[0]\n".
	"You will be notified via email when the experiment has been ".
	"torn down\n";
    exit(1);
}

#
# Okay, check state. We do not allow termination to start when the
# experiment is in transition. A future task would be to allow this,
# but for now the experiment must be in one of a few states to proceed
#
# Seems like too many states!
#
$estate = $row[1];
if ($estate eq "prerunning" ||
    $estate eq "activating" ||
    $estate eq "swapping" ||
    $estate eq "terminating") {
    print STDOUT
	"It appears that experiment $pid/$eid is in transition.\n".
	"The user that created the experiment will be notified via email\n".
        "when the experiment is no longer in transition, and can be killed\n";
    exit(1);
}

#
# Set the timestamp now, and unlock the experiments table.
#
$stamp = `date '+20%y-%m-%d %H:%M:%S'`;

$query_result = $DB->query("UPDATE experiments SET expt_terminating='$stamp' ".
			   "WHERE eid='$eid' and pid='$pid'");
if (! $query_result) {
    fatal("DB Error setting expt_terminating for experiment $pid/$eid\n");
}

$query_result = $DB->query("unlock tables");
if (! $query_result) {
    fatal("DB Error unlocking experiments table");
}

#
# If not in batch mode, go into the background. Parent exits.
#
if (! $batch) {
    if (background()) {
	#
	# Parent exits normally
	#
	print STDOUT
	    "Experiment $pid/$eid is now terminating\n".
	    "You will be notified via email when the experiment has been\n".
	    "torn down, and you can reuse the experiment name.\n";
	exit(0);
    }
}

if ($estate eq "active") { 
    print STDOUT "Running tbswapout with arguments: -nologfile $pid $eid\n";
    if (system("$tbdir/tbswapout -nologfile $pid $eid") != 0) {
	fatal("tbswapout failed!\n");
    }
}
elsif ($estate ne "swapped") {
    fatal("Experiment is in the wrong state: $estate\n");
}

print STDOUT "Running tbend with arguments: -nologfile $pid $eid\n";
if (system("$tbdir/tbend -nologfile $pid $eid") != 0) {
    fatal("tbend failed!\n");
}    

#
# Try to remove experiment directory. We allow for it not being there
# cause we often run the tb programs directly. We also allow for not
# having permission, in the case that an admin type is running this,
# in which case it won't be allowed cause of directory permissions. Thats
# okay since admin types should rarely end experiments in other projects.
#
if (chdir($expdir)) {
    print STDOUT "Removing experiment directory: $eiddir\n";
    system("rm -rf $eid");
}
else {
    print STDOUT "Not able to remove experiment directory: $eiddir\n";
    print STDOUT "Someone will need to do this by hand.\n";
}

#
# Done! Remove all trace from the DB.
# 
$query_result = $DB->query("DELETE from experiments ".
			   "WHERE eid='$eid' and pid='$pid'");

if (! $query_result) {
    fatal("DB Error deleting experiment record for $pid/$eid\n");
}

print STDOUT "Termination Success\n";

#
# In batch mode, just exit without sending email.
#
if ($batch) {
    exit(0);
}

#
# Send email notification if not in batch mode.
#
if (! ($MAIL = OPENMAIL("$user_name <$user_email>",
			"TESTBED: Experiment $pid/$eid Terminated",
			undef, "Bcc: $TBLOGS"))) {
    die("Cannot start mail program!");
}

print $MAIL "Experiment `$eid' in project `$pid' has been terminated.\n";
print $MAIL "You may now reuse `$eid' as an experiment name.\n\n";
print $MAIL "Appended below is the output of the experiment teardown.\n";
print $MAIL "If you have any questions or comments, please include the\n";
print $MAIL "output below in your message to $TBOPS\n";
print $MAIL "\n\n---------\n\n";

if (open(IN, "$logname")) {
    while (<IN>) {
	print $MAIL "$_";
    }
    close(IN);
}
close($MAIL);

unlink("$logname");
exit 0;

sub fatal()
{
    my($mesg) = $_[0];
    local $MAIL;
    
    print STDOUT $mesg;

    #
    # In batch mode, exit without sending the email. 
    #
    if ($batch) {
	exit(-1);
    }

    #
    # Send a message to the testbed list. Append the logfile if it got
    # that far.
    #
    if (! ($MAIL = OPENMAIL("$user_name <$user_email>",
			    "TESTBED: Termination Failure: $pid/$eid",
			    undef, "Cc: $TBOPS"))) {
	die("Cannot start mail program!");
    }

    print $MAIL $mesg;

    if (open(IN, "$logname")) {
	print $MAIL "\n\n---------\n\n";
	
	while (<IN>) {
	    print $MAIL "$_";
	}
	close(IN);
    }
    close($MAIL);
    
    unlink("$logname");
    exit(-1);
}

#
# Put ourselves into the background so that caller sees immediate response.
# Mail notification will happen later.
# 
sub background()
{
    $mypid = fork();
    if ($mypid) {
	return $mypid;
    }

    #
    # We have to disconnect from the caller by redirecting both STDIN and
    # STDOUT away from the pipe. Otherwise the caller (the web server) will
    # continue to wait even though the parent has exited. 
    #
    open(STDIN, "< /dev/null") or
	die("opening /dev/null for STDIN: $!");

    #
    # Create a temporary name for a log file and untaint it.
    #
    $logname = `mktemp /tmp/end-$pid-$eid.XXXXXX`;

    # Note different taint check (allow /).
    if ($logname =~ /^([-\@\w.\/]+)$/) {
	$logname = $1;
    } else {
	die "Bad data in $logname";
    }

    open(STDERR, ">> $logname") or die("opening $logname for STDERR: $!");
    open(STDOUT, ">> $logname") or die("opening $logname for STDOUT: $!");

    return 0;
}
