# -*- python -*-
#
# EMULAB-COPYRIGHT
# Copyright (c) 2000-2003 University of Utah and the Flux Group.
# All rights reserved.
#

#
# This is a modified version of mod_PLCNM.py.in, lifted because the upgrade
# to PLC 4.0 and the NM is going to require discrete modules for talking to
# both the new and old PLCs for awhile.  Not only that, but the new NM is
# somewhat different, so it makes sense to put the PLC4 and new NM stuff in its
# own file at this point.
#

import sys
sys.path.append("@prefix@/lib")

import xmlrpclib
import getopt
import fcntl
import time
import calendar
import cPickle
import os
import socket

from libtestbed import *
from aspects import wrap_around
from timer_advisories import timeAdvice

#from sshhttp import *
import popen2

#
# output control vars
#
verbose = 0
debug = 0

#
# PLC constants
#
DEF_PLC_URI = "https://www.planet-lab.org/PLCAPI/"
#DEF_PLC_URI = "https://n.djplc.tbres.emulab.net/PLCAPI/"
# these are now sucked in from a file
DEF_PLC_USER = ""
DEF_PLC_PASS = ""
DEF_PLC_PASS_FILE = "@prefix@/etc/plab/plc.pw"

DEF_NM_PORT = "812"
DEF_NM_LEGACY_PORT = "814"

#
# A bunch of time constants / intervals (in seconds)
#
MAX_PLC_LEASELEN = 2*MONTH-5*DAY   # defined by PLC as ~two months (56 days)
                                   # but have to use 55 now cause PLC won't take 56.
MIN_LEASE_WINDOW = 2*MONTH-12*DAY  # minimum time until expiration
MAX_LEASE_SLOP = 600 # (ten minutes)
MAX_CACHE_TIME = HOUR # (one hour)

EMULABMAN_EMAIL = "emulabman@emulab.net"

DEF_SLICE_DESC = "Slice created by Emulab"
DEF_EMULAB_URL = "http://www.emulab.net"

INSTMETHOD_NMCONTROLLER = "nm-controller"
INSTMETHOD_DELEGATED = "delegated"
INSTMETHOD_PLCINST = "plc-instantiated"
DEF_EMULAB_INSTMETHOD = INSTMETHOD_DELEGATED

# XXX: need to figure out what these are in the new NM's context
# hm, doesn't seem to have a version() call
MAJOR_VERS = 1
MINOR_VERS = 0
MIN_REV    = 10

class NM3agent:
    def __init__(self, IP, nodeid, nmport = DEF_NM_LEGACY_PORT):
        self.__server = xmlrpclib.ServerProxy("http://" + IP + ":" +
                                              nmport + "/")
        self.__vers = [0,0,0]
        self.IP = IP
        self.nodeid = nodeid
        pass

    def create_sliver(self, ticket):
        res = self.__server.create_sliver(xmlrpclib.Binary(ticket))
        if debug:
            print "NM3: create_sliver(%s/%s): res = %s" % (self.nodeid,self.IP,
                                                           str(res))
        return res

    def delete_sliver(self, rcap):
        res = self.__server.delete_sliver(rcap)
        if debug:
            print "NM3: delete_sliver(%s/%s): res = %s" % (self.nodeid,self.IP,
                                                           str(res))
        return res

    def version(self):
        if self.__vers == [0,0,0]:
            res = self.__server.version()
            if type(res) == list and len(res) == 2 and res[0] == 0:
                verslist = res[1].split(".")
                major = verslist[0]
                minor, revision = verslist[1].split("-")
                self.__vers = [int(major), int(minor), int(revision)]
                pass
            pass
        return self.__vers
    
    def getAgentClass(self):
        return self.__class__

    pass

DEF_NM_DELEGATE_ACCT = "utah_nmcontrol"
DEF_NM_DELEGATE_KEY = "/root/.ssh/id_rsa"
DEF_NM_SSHCMD = "/usr/bin/ssh -q -oStrictHostKeyChecking=no" \
                " -oPasswordAuthentication=no -l %s -i %s %s"

class NM4agent:
    def __init__(self,IP,nodeid,nmport=DEF_NM_PORT,
                 del_acct=DEF_NM_DELEGATE_ACCT,
                 del_key=DEF_NM_DELEGATE_KEY):
        #self._sPipeMethod = SshConnection(DEF_NM_SSHCMD % (del_acct,
        #                                                   del_key,
        #                                                   IP))

        # Instead of ssh xmlrpc transport, we use xmlrpclib load/dumps.
        self._isopen = False
        self.delacct = del_acct
        self.delkey = del_key
        
        self.__vers = [4,0,0]
        self.IP = IP
        self.nodeid = nodeid
        pass

    def _open(self):
        if not self._isopen:
            try:
                self.__agentconn = popen2.Popen3(DEF_NM_SSHCMD % (self.delacct,
                                                                  self.delkey,
                                                                  self.IP))
                self._isopen = True
            except:
                raise
            pass
        pass

    def _close(self):
        if self._isopen:
            # Nothing else we can do except wait for the connection to die,
            # and that's silly... or kill the pid ourself---but the connection
            # will naturally die after the response.
            self._isopen = False
        pass

    def _xcall(self,cmd,args=()):
        self._open()
        try:
            if debug:
                print "NM4: xmlrpc send(%s/%s): %s" % (self.nodeid,self.IP,cmd)
                pass
            print >>self.__agentconn.tochild, xmlrpclib.dumps(args,cmd)
            self.__agentconn.tochild.close()
            retval = xmlrpclib.loads(self.__agentconn.fromchild.read())
            if debug:
                print "NM4: xmlrpc response(%s/%s): '%s'" % (self.nodeid,
                                                             self.IP,
                                                             str(retval))
                pass
            self.__agentconn.wait()
            if debug:
                print "NM4: xmlrpc done(%s/%s)" % (self.nodeid,self.IP)
                pass
            self._close()
        except:
            # always close; we can only send one xmlrpc request at a time
            self._close()
            raise
        
        # XXX: we whack the retval to be compat with NMv3
        rret = retval[0][0]
        if rret == 1:
            rret = 0
            pass
        retval = [ rret, [''] ]
        
        return retval
    
    def deliver_ticket(self,ticket):
        if debug:
            print "NM4: deliver_ticket(%s/%s)" % (self.nodeid,self.IP)
        return self._xcall('Ticket',(ticket,))
    
    def create_sliver(self,slice_name,tries=2,interval=5):
        if debug:
            print "NM4: create_sliver(%s/%s), slice %s" % (self.nodeid,self.IP,
                                                           slice_name)
            pass
        (success,rtries) = (False,tries)
        while not success and rtries > 0:
            rtries -= 1
            try:
                retval = self._xcall('Create',(slice_name,))
                success = True
            except:
                if rtries == 0:
                    raise
                else:
                    print "NM4: create_sliver(%s/%s) failed" \
                          % (self.nodeid,self.IP)
                    time.sleep(interval)
                    pass
                pass
            pass
        return retval
    
    def delete_sliver(self,slice_name):
        if debug:
            print "NM4: delete_sliver(%s/%s), slice %s" % (self.nodeid,self.IP,
                                                           slice_name)
        return self._xcall('Destroy',(slice_name,))

    def start_sliver(self,slice_name):
        if debug:
            print "NM4: start_sliver(%s/%s), slice %s" % (self.nodeid,self.IP,
                                                          slice_name)
        return self._xcall('Start',(slice_name,))

    def stop_sliver(self,slice_name):
        if debug:
            print "NM4: stop_sliver(%s/%s), slice %s" % (self.nodeid,self.IP,
                                                         slice_name)
        return self._xcall('Stop',(slice_name,))

    # NM v4 does not have a version method...
    def version(self):
        return self.__vers
    
    def getAgentClass(self):
        return self.__class__
    pass

DEF_NM_LEGACY_AGENT = NM3agent
DEF_NM_AGENT = NM4agent

class NMagent_wrapper:
    def __init__(self,IP,nodeid):
        # first try a tcp connection to the legacy NM port; if timeout,
        # try default agent right away.
        self.__agent = None
        self.IP = IP
        self.nodeid = nodeid
        
        if DEF_NM_LEGACY_AGENT != None:
            legacy_nm = False
            
            #sock = socket.socket(socket.AF_INET,socket.SOCK_STREAM)
            #sock.settimeout(10.0)
            try:
                #sock.connect((str(IP),int(DEF_NM_LEGACY_PORT)))

                tmp_agent = DEF_NM_LEGACY_AGENT(self.IP,self.nodeid)
                tmp_agent.version()
                
                legacy_nm = True
                if debug:
                    print "NM on %s/%s is legacy." % (self.nodeid,self.IP)
                    pass
            except:
                if debug:
                    print "NM on %s/%s does not appear to be legacy." \
                          % (self.nodeid,self.IP)
                #traceback.print_exc()
                pass
            
            if legacy_nm:
                self.__agent = DEF_NM_LEGACY_AGENT(self.IP,self.nodeid)
                pass
            else:
                self.__agent = DEF_NM_AGENT(self.IP,self.nodeid)
                pass
            pass
        else:
            self.__agent = DEF_NM_AGENT(self.IP,self.nodeid)
            pass
        pass
    
    def getAgent(self):
        return self.__agent

    def getAgentClass(self):
        return self.__agent.__class__

    def create_sliver(self,slicename,ticketdata):
        arg = None
        
        if self.__agent.__class__ == NM4agent:
            arg = slicename
            pass
        else:
            arg = ticketdata
            pass

        # If the agent wants to deliver a ticket explicitly before the create
        # call, we do that.
        if self.__agent.__class__.__dict__.has_key('deliver_ticket'):
            try:
                res = tryXmlrpcCmd(self.__agent.deliver_ticket,ticketdata)
                if res[0] == 0:
                    print "Warning: deliver_ticket(%s/%s), slice %s: %s" \
                          % (self.nodeid,self.IP,slicename,str(res[1]))
                    pass
                pass
            except:
                print "Warning: deliver_ticket(%s/%s), slice %s: exception" \
                      "\n%s" \
                      % (self.nodeid,self.IP,slicename,
                         traceback.format_exc())
                #traceback.print_exc()
                pass
            pass
        
        res = tryXmlrpcCmd(self.__agent.create_sliver,arg)
        if self.__agent.__class__ == NM4agent:
            return (res,'')
        else:
            retval = (res,None)
            try:
                retval = (res,cPickle.dumps(res[1][0]))
            except:
                pass
            return retval

        return None
    
    def delete_sliver(self,slicename,ticketdata):
        arg = None
        if self.__agent.__class__ == NM4agent:
            arg = slicename
            pass
        else:
            arg = ticketdata
            pass
        return tryXmlrpcCmd(self.__agent.delete_sliver,arg)

    def update_sliver(self,slicename,ticketdata):
        arg = None
        if self.__agent.__class__ == NM4agent:
            return tryXmlrpcCmd(self.__agent.deliver_ticket,ticketdata)
        else:
            return tryXmlrpcCmd(self.__agent.create_sliver,ticketdata)
        return None

    def stop_sliver(self,slicename):
        if self.__agent.__class__.__dict__.has_key('stop_sliver'):
            return tryXmlrpcCmd(self.__agent.stop_sliver,slicename)
        return 0

    def start_sliver(self,slicename):
        if self.__agent.__class__.__dict__.has_key('start_sliver'):
            return tryXmlrpcCmd(self.__agent.start_sliver,slicename)
        return 0

    def restart_sliver(self,slicename):
        if self.__agent.__class__.__dict__.has_key('restart_sliver'):
            return tryXmlrpcCmd(self.__agent.restart_sliver,slicename)
        return 0
    
    pass

#
# The real PLC agent.  Wraps up standard arguments to the
# PLC XMLRPC interface.
#
class PLCagent:
    def __init__(self, slicename,
                 uri = DEF_PLC_URI,
                 username = "",
                 password = ""):

        if username == "":
            username = mod_PLC4.username
            pass
        if password == "":
            password = mod_PLC4.password
            pass
        
        if not slicename:
            raise RuntimeError, "Must provide a slicename!"
        self.__slice = {}
        self.__slice['sliceName'] = slicename
        self.__slicename = slicename
        self.__auth = {}
        self.__auth['AuthMethod'] = "password"
        self.__auth['Username'] = username
        self.__auth['AuthString'] = password
        self.__auth['Role'] = "pi"
        self.__insmeth = "delegated"
        try:
            # Need allow_none=1 to marshal `None' since PLC4 uses it
            # in wildcard situations...
            self.__server = xmlrpclib.ServerProxy(uri,allow_none=1)
            self.server = self.__server
        except:
            print "Failed to create XML-RPC proxy"
            raise
        return

    def getSliceName(self):
        return self.__slice['sliceName']

    def SliceCreate(self,
                    sliceurl = DEF_EMULAB_URL,
                    slicedesc = DEF_SLICE_DESC,
                    instmethod = DEF_EMULAB_INSTMETHOD):
        return self.__server.AddSlice(self.__auth,
                                      { 'url' : sliceurl,
                                        'instantiation' : instmethod,
                                        'name' : self.__slicename,
                                        'description' : slicedesc })

    def SliceDelete(self):
        return self.__server.DeleteSlice(self.__auth, self.__slicename)

    def SliceUpdate(self,slicedesc = DEF_SLICE_DESC,sliceURL = DEF_EMULAB_URL):
        return self.__server.UpdateSlice(self.__auth, self.__slicename,
                                         { 'url' : sliceURL,
                                           'description' : slicedesc })

    def SliceRenew(self,expdate):
        return self.__server.UpdateSlice(self.__auth, self.__slicename,
                                         { 'expires' : expdate })

    def SliceNodesAdd(self,nodelist):
        if not type(nodelist) == list:
            nodelist = [nodelist]
            pass
        return self.__server.AddSliceToNodes(self.__auth,self.__slicename,
                                             nodelist)
    
    def SliceNodesDel(self,nodelist):
        if not type(nodelist) == list:
            nodelist = [nodelist,]
        return self.__server.DeleteSliceFromNodes(self.__auth,self.__slicename,
                                                  nodelist)

    # Ick, have to use GetSlices and GetNodes.  Ick!  Ick!
    def SliceNodesList(self):
        # use a return filter to get only the node ids.
        retval = self.__server.GetSlices(self.__auth,
                                         [ self.__slicename ])
        # well, there's a bug in PLC with return filters in GetSlices...
        #                                 [ 'node_ids' ])

        if len(retval) > 0 and retval[0]['name'] == self.__slicename:
            nidlist = retval[0]['node_ids']
            # then use a node filter to GetNodes to get the names.
            # XXX: probably should convert over to using node ids at
            # some point.
            retval = self.__server.GetNodes(self.__auth,
                                            nidlist,
                                            [ 'hostname' ])
        else:
            retval = []
        
        nhostlist = map(lambda x: x['hostname'], retval)

        return nhostlist

    # PLC 4's default behavior is to add one user at a time.  Thus, we
    # just call their function for each list item; if a fault occurs, it'll
    # go back to the caller.  The reason we can do it this way is because
    # subsequent calls to AddPersonToSlice don't fail if the person is already
    # a member of the slice.  It's nasty, but whatever.
    def SliceUsersAdd(self, userlist):
        if type(userlist) != list:
            userlist = [userlist]
            pass
        for user in userlist:
            retval = self.__server.AddPersonToSlice(self.__auth,
                                                    user,
                                                    self.__slicename)
            pass
        # this is 1 if all (i.e., the last) call succeeds
        return retval

    # Same PLC 4 behavior change as for AddPersonToSlice.
    def SliceUsersDel(self, userlist):
        if type(userlist) != list:
            userlist = [userlist]
            pass
        for user in userlist:
            retval = self.__server.DeletePersonFromSlice(self.__auth,
                                                         user,
                                                         self.__slicename)
            pass
        return retval

    # Ick, have to implement this in terms of GetSlices and GetPersons
    # just as for the node hostnames in SliceNodesList.
    def SliceUsersList(self):
        retval = self.__server.GetSlices(self.__auth,
                                         [ self.__slicename ])
        # XXX PLC bug
        #                                 [ 'name','person_ids' ])
        if len(retval) > 0 and retval[0]['name'] == self.__slicename:
            uidlist = retval[0]['person_ids']
            retval = self.__server.GetPersons(self.__auth,
                                              uidlist,
                                              [ 'email' ])
        else:
            retval = []
        
        usernamelist = map(lambda x: x['email'], retval)

        return usernamelist

    # XXX: keep the commented version around to get tickets for the old
    # NMs.
    def SliceGetTicketLegacy(self):
        return self.__server.SliceGetTicket(self.__auth,self.__slicename)
    
    def SliceGetTicket(self):
        return self.__server.GetSliceTicket(self.__auth,self.__slicename)

    # XXX: this returns a lot more crap than we use, but we'll keep it intact
    # for the future...
    def SliceInfo(self,slicefilter=None,returnfilter=None):
        return self.__server.GetSlices(self.__auth,slicefilter,returnfilter)

    def AuthCheck(self):
        return self.__server.AuthCheck(self.__auth)

    def SliceAddAttribute(self,attrname,attrvalue):
        if attrname == None or attrvalue == None \
           or attrname == '' or attrvalue == '':
            return 0
        return self.__server.AddSliceAttribute(self.__auth,self.__slicename,
                                               attrname,attrvalue)

    pass # end of PLCagent class


class mod_PLC4:
    username = ""
    password = ""
    
    def __init__(self):
        self.modname = "mod_PLC4"
        self.__PLCagent = None
        self.__sliceexpdict = {}
        self.__sliceexptime = 0

        # try to grab the master account info from the file:
        try:
            file = open(DEF_PLC_PASS_FILE,'r')
            lines = file.readlines()
            mod_PLC4.username = lines[0].strip('\n')
            mod_PLC4.password = lines[1].strip('\n')
            pass
        except:
            print "Failed to retrive passwd from %s" % DEF_PLC_PASS_FILE
            raise
        
        return

    def createSlice(self,slice):

        agent = self.__getAgent(slice.slicename)
        res = None
        now = calendar.timegm(time.gmtime())

        # fix up some slice info just in case
        if slice.sliceurl == None:
            slice.sliceurl = DEF_EMULAB_URL
            pass
        if slice.description == None:
            slice.description = DEF_SLICE_DESC
            pass
        if slice.instmethod == None:
            slice.instmethod = DEF_EMULAB_INSTMETHOD
            pass
        
        try:
            # XXX: fix to take desc and url args! (i.e., SliceUpdate)
            res = tryXmlrpcCmd(agent.SliceCreate,(slice.sliceurl,
                                                  slice.description,
                                                  slice.instmethod))
            if debug:
                print "SliceCreate result: %s" % res
                pass
            pass
        except:
            print "Failed to create slice %s" % slice.slicename
            raise

        # If the slice is delegated, make sure to set the `delegations` attr
        # to our nm-controller slice
        if slice.instmethod == INSTMETHOD_DELEGATED:
            try:
                res = tryXmlrpcCmd(agent.SliceAddAttribute,
                                   ('delegations',DEF_NM_DELEGATE_ACCT))
                if debug:
                    print "SliceAddAttribute(delegations) result: %s" % res
                    pass
                pass
            except:
                print "Failed to set 'delegations' attribute on slice %s" \
                      % slice.slicename
                raise
            pass
        
        try:
            userlist = slice.getSliceUsers()
            # XXX: we might not always want to add emulabman
            if userlist == None:
                userlist = []
                pass
            if not EMULABMAN_EMAIL in userlist:
                userlist.append(EMULABMAN_EMAIL)
                pass
            res = tryXmlrpcCmd(agent.SliceUsersAdd,
                               userlist)
            if debug:
                print "SliceUsersAdd result: %s" % res
                pass
            pass
        except:
            print "Failed to assign emulabman to slice %s" % slice.slicename
            raise

        # The new NM will check to see if the slice has been added to the
        # nodes, and will delete the ticket if when it contacts PLC it finds
        # that the slice doesn't include the local NM's node... or something
        # like that... so we must add the nodes to the slice.
        try:
            tnodelist = slice.getSliceNodes()
            if tnodelist == None or tnodelist == []:
                pass
            else:
                nodelist = map(lambda x: x[2], tnodelist)
                res = tryXmlrpcCmd(agent.SliceNodesAdd, nodelist)
                if debug:
                    print "SliceNodesAdd result: %s" % res
                    pass
                pass
            pass
        except:
            print "Failed to add nodes to slice %s" % slice.slicename
            raise

        # XXX: this is currently locked out to pi/user roles, although the docs
        # say otherwise, so we can't use it automatically yet.
        #
        # Add a proper_op, mount_dir, so that we can eventually replace
        # our current rootball load mechanism with proper.
        # NOTE: this is secure, even though it seems like we're not specifying
        # any access control.  ACLs consist of ".exportdir" and ".importdir"
        # files in the vserver directories to be imported into ("reverse
        # export") or exported.
        #try:
        #    res = tryXmlrpcCmd(agent.SliceAddAttribute,('proper_op',
        #                                                'mount_dir',))
        #    if debug:
        #        print "SliceAddAttribute result: %s" % str(res)
        #        pass
        #    pass
        #except:
        #    print "Failed to add proper_op:mount_dir to slice %s" \
        #          % slice.slicename
        #    raise

        (PLCticket,PLCticket_legacy) = ('','')
        # We can only get the tickets if the slice is in delegated mode.
        if slice.instmethod == INSTMETHOD_DELEGATED:
            try:
                # XXX - fix for new NM and rollout.
                PLCticket = tryXmlrpcCmd(agent.SliceGetTicket)
                PLCticket_legacy = tryXmlrpcCmd(agent.SliceGetTicketLegacy)
                if debug:
                    print "ticket = %s" % str(PLCticket)
                    print "legacy ticket = %s" % str(PLCticket_legacy)
                    pass
                pass
            except:
                print "Failed to get PLC ticket for slice %s" % slice.slicename
                raise
            pass
        
        # XXX: fix for PLC 4
        leaseend = now + MAX_PLC_LEASELEN
        return (res, (cPickle.dumps(PLCticket),
                      cPickle.dumps(PLCticket_legacy)),
                leaseend)
    
    def deleteSlice(self, slice):
        agent = self.__getAgent(slice.slicename)
        # XXX: fix OKstrs based on what plc actually returns
        tryXmlrpcCmd(agent.SliceDelete, OKstrs = ["does not exist"])
        pass

    def renewSlice(self, slice, force = False):
        agent = self.__getAgent(slice.slicename)
        ret = 0
        now = int(time.time()) # seconds since the epoch (UTC)
 
        # Get current PLC timeout for this slice
        leaseend = self.getSliceExpTime(slice.slicename)

        if debug:
            print "PLC says %s/%s expires at %s" % \
                  (slice.eid,slice.pid,
                   time.strftime("%Y-%m-%d %H:%M:%S",
                                 time.gmtime(leaseend)))

        # Warn that we weren't able to get the exp. time from PLC,
        # but don't fail - try to renew anyway.
        if not leaseend:
            print "Couldn't get slice expiration time from PLC!"
            leaseend = slice.leaseend
            pass

        # Allow some slop in our recorded time versus PLC's.  This is necessary
        # since we calculate the expiration locally.  If we are off by too much
        # then adjust to PLC's recorded expiration.
        if abs(leaseend - slice.leaseend) > MAX_LEASE_SLOP:
            print "Warning: recorded lease for %s doesn't agree with PLC" % \
                  slice.slicename
            print "\tRecorded: %s  Actual: %s" % (slice.leaseend, leaseend)
            slice.leaseend = leaseend
            pass

        # Expired!  Just bitch about it; try renewal anyway.  The renewal
        # code in libplab will send email.
        if leaseend < now:
            print "Slice %s (%s/%s) has expired!" % \
                  (slice.slicename, slice.pid, slice.eid)
            pass

        # If the lease is at least as large as the minimum window,
        # don't bother renewing it.
        if leaseend - now > MIN_LEASE_WINDOW and not force:
            print "Slice %s (%s/%s) doesn't need to be renewed" % \
                  (slice.slicename, slice.pid, slice.eid)
            return 1

        # Max out leaseend as far as (politically) possible
        newleaseend = now + MAX_PLC_LEASELEN

        if debug:
            print "Renewing until %s (adding now +%d s)" % \
                  (time.strftime("%Y-%m-%d %H:%M:%S",
                                 time.gmtime(newleaseend)),
                   newleaseend - now)
        
        try:
            # XXX: again fix NOKstrs as necessary
            res = tryXmlrpcCmd(agent.SliceRenew,
                               newleaseend,
                               NOKstrs = ["does not exist"])
            # Get the updated ticket.
            # XXX: update for NM4 when we switch.  For now we need to record
            # the old ticketdata in the db.
            slice.slicemeta = self.getSliceMeta(slice)
            slice.slicemeta_legacy = self.getSliceMetaLegacy(slice)

            ret = 1
            if debug:
                print "SliceRenew returns: %s" % res
                pass
            pass
        except:
            print "Failed to renew lease for slice %s" % slice.slicename
            traceback.print_exc()
            ret = 0
            pass
        else:
            slice.leaseend = newleaseend
            pass
        
        return ret

    def getSliceMetaLegacy(self, slice):
        agent = self.__getAgent(slice.slicename)

        # We can only get the tickets if the slice is in delegated mode.
        if slice.instmethod != INSTMETHOD_DELEGATED:
            return cPickle.dumps('')
        
        try:
            PLCticket = tryXmlrpcCmd(agent.SliceGetTicketLegacy)
            if debug:
                print PLCticket
                pass
            pass
        except:
            print "Failed to get legacy PLC ticket for slice %s" % slice.slicename
            raise

        return cPickle.dumps(PLCticket)

    def getSliceMeta(self,slice):
        agent = self.__getAgent(slice.slicename)
        
        try:
            retval = tryXmlrpcCmd(agent.SliceGetTicket)
            if debug:
                print str(retval)
                pass
            pass
        except:
            print "Failed to get PLC ticket for slice %s" % slice.slicename
            raise
        return cPickle.dumps(retval)

    def createNode(self, node):
        plcagent = self.__getAgent(node.slice.slicename)

        ticketdata = cPickle.loads(node.slice.slicemeta)
        node.nmagent = NMagent_wrapper(node.IP,node.nodeid)

        # XXX: if node is NM4agent, grab new-style ticket from PLC
        # (flip during rollout once a majority of nodes have NMv4).
        #
        if (node.nmagent.getAgent()).__class__ == NM3agent:
            ticketdata = cPickle.loads(node.slice.slicemeta_legacy)
            pass
        
        res = tryXmlrpcCmd(plcagent.SliceNodesAdd, node.hostname,
                           OKstrs = ["already assigned"])

        # Make sure node is running compatible interface
#        try:
#            vers = agent.version()
#            pass
#        except:
#            print "Unable to check version on remote NM agent!"
#            raise
#        if vers[0] != MAJOR_VERS or vers[1] != MINOR_VERS \
#               or vers[2] < MIN_REV:
#            raise RuntimeError, \
#                  "Remote node manager version incompatible on %s: %s" % \
#                  (node.nodeid, ".".join(map(lambda x: str(x), vers)))
#        pass

        try:
            res = node.nmagent.create_sliver(node.slice.slicename,ticketdata)
            if debug:
                print res
                pass

            realres = res[0]

            if not realres[0] == 0:
                raise RuntimeError, "create_sliver(%s/%s) failed: %d, %s" % \
                      (node.nodeid,node.IP,realres[0], realres[1])
            pass
        except:
            print "create_sliver(%s/%s), slice %s: exception\n%s" \
                  % (node.nodeid,node.IP,node.slice.slicename,
                     traceback.format_exc())
            # XXX: Can we clean up on the plab side here?
            #      delete_sliver requires an rcap, but we don't have one
            #      in this case (since sliver creation failed).
            # self.freeNode(node)
            raise

        # send back the rcap
        #return (res, cPickle.dumps(res[1][0]), node.slice.leaseend)
        # instead, we send back whatever the wrapped agent sends back... which
        # is some form of rcap.
        return (realres,res[1],node.slice.leaseend)
    
    def freeNode(self, node):
        rcap = None
        try:
            rcap = cPickle.loads(node.nodemeta)
        except:
            #print "WARNING: couldn't load rcap"
            pass
        node.nmagent = NMagent_wrapper(node.IP,node.nodeid)
        res = None

        try:
            res = node.nmagent.delete_sliver(node.slice.slicename,rcap)
            if debug:
                print res
                pass
            if not res[0] == 0:
                raise RuntimeError, "delete_sliver failed: %d" % res[0]
            pass
        except:
            print "Failed to release node %s/%s from slice %s" % \
                  (node.nodeid,node.IP,node.slice.slicename)
            raise
        
        return res

    def renewNode(self, node, length = 0):
        return self.createNode(node)
    
    def startNode(self,node):
        node.nmagent = NMagent_wrapper(node.IP,node.nodeid)
        try:
            res = node.nmagent.start_sliver(node.slice.slicename)
        except:
            print "Failed to start node %s/%s from slice %s" % \
                  (node.nodeid,node.IP,node.slice.slicename)
            raise
        return res

    def stopNode(self,node):
        node.nmagent = NMagent_wrapper(node.IP,node.nodeid)
        try:
            res = node.nmagent.stop_sliver(node.slice.slicename)
        except:
            print "Failed to stop node %s/%s from slice %s" % \
                  (node.nodeid,node.IP,node.slice.slicename)
            raise
        return res

    def restartNode(self,node):
        node.nmagent = NMagent_wrapper(node.IP,node.nodeid)
        try:
            res = node.nmagent.restart_sliver(node.slice.slicename)
        except:
            print "Failed to stop node %s/%s from slice %s" % \
                  (node.nodeid,node.IP,node.slice.slicename)
            raise
        return res
    
    # XXX: this is broken, appears to be bug in GetSlices xmlrpc call in PLC4
    def getSliceExpTime(self, slicename):
        """
        Grab the expiration time for a slice according to PLC.
        Entries are cached for a time specified in this module by
        MAX_CACHE_TIME.  Returns seconds since the epoch in UTC.
        """
        agent = self.__getAgent(slicename)
        # Refresh the slice expiration cache if:
        # 1) cache is cold
        # 2) cache is too old
        # 3) given slice is not in cache
        if not self.__sliceexpdict or \
           self.__sliceexptime < time.time() - MAX_CACHE_TIME or \
           not self.__sliceexpdict.has_key(slicename):
            #
            # This behavior (of getting ALL our slice expiration times)
            # can only be emulated by getting the slice list, and then
            # checking the expiration times for ALL slices in the list...
            # GetSlices in PLC 4 doesn't give you everything if you ask for
            # nothing.
            #
            sdict = tryXmlrpcCmd(agent.SliceInfo,[slicename])
            # bug in PLC return filter...
            #                     ([slicename],['name','expires']))
            for entry in sdict:
                self.__sliceexpdict[entry['name']] = entry
                pass
            self.__sliceexptime = time.time()
            pass

        if not self.__sliceexpdict.has_key(slicename):
            print "Slice %s unknown to PLC" % slicename
            return None

        leaseend = self.__sliceexpdict[slicename]['expires']

        return leaseend

    def doAuthCheck(self,slicename):
        return tryXmlrpcCmd(self.__getAgent(slicename).AuthCheck)

    def __getAgent(self, slicename):
        """
        Returns a PLC agent object for the specified slice.  May cache.
        """
        if not self.__PLCagent or \
           not self.__PLCagent.getSliceName() == slicename:
            self.__PLCagent = PLCagent(slicename)
            pass

        return self.__PLCagent

    pass # end of mod_PLC class
