#!/usr/local/bin/python
# -*- python -*-

import sys, os
sys.path.append("@prefix@/lib")
import syslog
import getopt
from libtestbed import *
import libplab

GETFREE_PERIOD = 2*60
RENEW_PERIOD = 60*60

# maximum number of times (in a row) the daemon loop can
# catch an exception before bailing out.
MAXCONSECEXC = 3

def usage(me):
    print "Usage: %s [ -vd ] { getfree [-o [-i]] | renew }" % me
    print "  Passing -o to getfree will cause it to only run once."
    print "  Passing -i to getfree will cause if to only update using"
    print "   existing node info (no new nodes will be added)."
    sys.exit(1)

class logfile:
    def __init__(self, logname):
        self.buf = ""

    def close(self):
        syslog.closelog()

    def flush(self): pass

    def write(self, str):
        # Ugh
        self.buf += str
        while self.buf.find("\n") >= 0:
            pos = self.buf.find("\n")
            line = self.buf[:pos]
            self.buf = self.buf[pos+1:]
            syslog.syslog(line)

def daemonize(logname):
    """
    Fork off into a daemon process, redirecting stdout and stderr to
    logfile.

    Based on code from the ASPN Python Cookbook.
    """
    # First fork
    if os.fork():
        sys.exit(0)
        
    # Decouple from parent environment.
    os.chdir("/") 
    os.umask(0) 
    os.setsid() 
    
    # Second fork
    if os.fork():
        sys.exit(0)

    # Redirect standard fd's
    si = open("/dev/null", 'r')
    so = open("/dev/null", 'a+', 0)
    os.dup2(si.fileno(), sys.stdin.fileno())
    os.dup2(so.fileno(), sys.stdout.fileno())
    os.dup2(so.fileno(), sys.stderr.fileno())

    # Log output
    syslog.openlog(logname, syslog.LOG_PID, syslog.LOG_USER)
    sys.stdout = sys.stderr = logfile(logname)

def doDaemon(func, period, logname):
    """
    Forks off into a daemon process with output directed to logfile, and
    calls the given func every period seconds.
    """
    import time
    import traceback

    consecexc = MAXCONSECEXC

    if not debug:
        daemonize(logname)
    while True:
        start = time.clock()
        try:
            func()
        except SignalInterrupt, e:
            print "Received signal %s in daemon loop, exiting." % e.signum
            sys.exit(0)
        except KeyboardInterrupt:
            print "Received keyboard interrupt in daemon loop, exiting."
            sys.exit(1)
        except:
            print "Exception caught in plab daemon loop:"
            print "".join(traceback.format_exception(*sys.exc_info()))
            consecexc -= 1
            if consecexc > 0:
                print "Going back to sleep until next scheduled run"
            else:
                print "Too many consecutive exceptions seen, bailing out!"
                SENDMAIL(libplab.TBOPS, "Plabdaemon Exiting",
                         "The plab %s daemon has seen too many "
                         "consecutive exceptions and is bailing out."
                         "Someone needs to check the log!" %
                         func.func_name)
                raise

        else:
            consecexc = MAXCONSECEXC
            
        end = time.clock()
        if end - start < period:
            wait = period - (end - start)
            print "Sleeping %g seconds" % wait
            time.sleep(wait)

def main(args):
    me = args[0]
    try:
        args = handleArgs(args[1:])
        if not len(args):
            usage(me)
        command = args[0]

        plab = libplab.Plab()
        if command == "getfree":
            opts, args = getopt.getopt(args[1:], "io")
            updateOnly = False
            for o, a in opts:
                if o == "-i":
                    updateOnly = True
                elif o == "-o":
                    runonce = True
            if len(args):
                usage(me)
            if runonce:
                plab.getFree(updateOnly)
            else:
                doDaemon(plab.getFree, GETFREE_PERIOD, "plabgetfree")
        elif command == "renew":
            doDaemon(plab.renew, RENEW_PERIOD, "plabrenew")
        else:
            usage(me)
    except getopt.GetoptError:
        usage(me)

if __name__ == "__main__":
    main(sys.argv)
