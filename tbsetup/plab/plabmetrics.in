#!/usr/bin/perl -wT
#
# EMULAB-COPYRIGHT
# Copyright (c) 2000-2003 University of Utah and the Flux Group.
# All rights reserved.
#
use English;
use Getopt::Std;
use XML::Parser;

#
# Drift to allow between our clock and the gmond nodes
#
my $STALESLOP = 1 * 60;

#
# Age (in seconds) at which we consider metric data stale
# Configured via site variable.
#
my $STALEAGE;

sub usage()
{
    print STDOUT
	"Usage: plabmetrics [-d] [-n] [-f <xmlfile>]\n";
    exit(-1);
}
my $optlist = "dnf:";
my $debug   = 0;
my $impotent= 0;
my $xmlfile;
my $now     = time();

#
# Only real root can call this.
# 
if ($UID != 0) {
    print STDERR "You must be root to run this script!\n";
    exit(-1);
}

#
# Configure variables
#
my $TB		= "@prefix@";
my $TBOPS       = "@TBOPSEMAIL@";

#
# Turn off line buffering on output
#
$| = 1;

#
# Untaint the path
# 
$ENV{'PATH'} = '/bin:/usr/bin';
delete @ENV{'IFS', 'CDPATH', 'ENV', 'BASH_ENV'};

#
# Testbed Support libraries
#
use lib "@prefix@/lib";
use libdb;
use libtestbed;

# Locals
my $tempfile	= "/tmp/plabxml.$$";
my $agedfile    = "$TB/log/plabxml.txt";
my %nodemap     = ();
my $LOADMETRIC;
my $MAXLOAD;
my $MINDISK;

# Current cluster and host.
my $cluster;
my $host;
my $IP;
my $metricsage;
my %metrics;

# Be careful not to exit on transient error
$libdb::DBQUERY_MAXTRIES = 5;

#
# Parse command arguments. Once we return from getopts, all that should
# left are the required arguments.
#
%options = ();
if (! getopts($optlist, \%options)) {
    usage();
}
if (@ARGV) {
    usage();
}
if (defined($options{"d"})) {
    $debug = 1;
}
if (defined($options{"n"})) {
    $impotent = 1;
}
if (defined($options{"f"})) {
    $xmlfile = $options{"f"};

    # Note different taint check (allow /).
    if ($xmlfile =~ /^([-\w.\/]+)$/) {
	$xmlfile = $1;
    }
    else {
	die("Tainted xmlfile name: $xmlfile");
    }
}

#
# Set default values
#
if (TBSiteVarExists("plab/load_metric")) {
    $LOADMETRIC = TBGetSiteVar("plab/load_metric");
    if ($LOADMETRIC !~ /^load_(one|five}fifteen)$/) {
	undef $LOADMETRIC;
    }
}
if (!defined($LOADMETRIC)) {
    $LOADMETRIC = "load_fifteen";
}

if (TBSiteVarExists("plab/max_load")) {
    $MAXLOAD = TBGetSiteVar("plab/max_load");
    $MAXLOAD = 0.0 if $MAXLOAD <= 0.0;
    $MAXLOAD = 1000.0 if $MAXLOAD > 1000.0;
} else {
    $MAXLOAD = 5.0;
}

if (TBSiteVarExists("plab/min_disk")) {
    $MINDISK = TBGetSiteVar("plab/min_disk");
    $MINDISK = 0 if $MINDISK < 0;
    $MINDISK = 100 if $MINDISK > 100;
} else {
    $MINDISK = 10;
}

if (TBSiteVarExists("plab/stale_age")) {
    $STALEAGE = TBGetSiteVar("plab/stale_age");
    $STALEAGE = 0 if $STALEAGE < 0;
} else {
    $STALEAGE = 60;
}
$STALEAGE *= 60;

print "\n=== plabmetrics ".
    "(metric=$LOADMETRIC, maxload=$MAXLOAD, mindisk=$MINDISK) ".
    "running at " . `date`
    if $debug;

#
# Download the metrics from the plab site.
# Do this before hitting the DB in case it fails.
#
if (defined($xmlfile)) {
    fatal("Could not copy $xmlfile to $tempfile!")
	if (system("cp -pf $xmlfile $tempfile"));
}
else {
    #
    # Must prevent hangs ...
    #
    my $syspid = fork();

    if ($syspid) {
	local $SIG{ALRM} = sub { kill("TERM", $syspid); };
	alarm 120;
	waitpid($syspid, 0);
	alarm 0;

	fatal("Timed out downloading XML data from web site!")
	    if ($? == 15);
	    
	fatal("Could not download XML data from web site!")
	    if ($?);
    }
    else {
	exec("/usr/local/bin/wget -q -O $tempfile ".
	     "http://www.planet-lab.org/xml/gmetad.xml");
	exit(0);
    }
}

#
# Grab the node list from the DB in one query, which we use later to
# map from the IP we get from the XML output, to our node_id. 
#
my $query_result =
    DBQueryFatal("select i.node_id,i.IP from nodes as n ".
		 "left join node_types as nt on n.type=nt.type ".
		 "left join interfaces as i on i.node_id=n.node_id ".
		 "where nt.isremotenode=1 and nt.isvirtnode=0 ".
    		 "and nt.class='pcplabphys'");

while (my ($nodeid,$IP) = $query_result->fetchrow_array()) {
    $nodemap{$IP} = $nodeid;
}

#
# Finally, run the parser.
#
$p1 = new XML::Parser(Style => 'Tree');
$p1->setHandlers('Start'   => \&StartElement,
		 'End'     => \&EndElement);

fatal($@)
    if (eval { $p1->parsefile($tempfile); return 1; } != 1);

#
# Loop thru the IP map looking for any nodes that we have listed in the DB
# but for which we got no metrics.  We will insert default values.
#
foreach my $arg (keys(%nodemap)) {
    $IP = $arg;
    if (defined($nodemap{$IP})) {
	$host = $nodemap{$IP} . " ($IP)";
	InsertMetrics();
	undef($host);
	undef($metricsage);
	%metrics = ();
    }
}

#
# If the data came from the web server, copy to the aged file.
# Only if root though
#
system("cp -f $tempfile $agedfile")
    if (!defined($xmlfile) && !$UID);
    
unlink($tempfile)
    if (-e $tempfile);
exit(0);

sub CheckMetrics()
{
    my $localdebug = $debug;

    #
    # See if we got any metric data.  If so, then check for stale data.
    # In the case where metric data appears to be in the future,
    # it may be clock skew, so allow a little slop.
    #
    if (!defined($metricsage)) {
	print "WARNING: $host: no metric data, ignoring\n"
	    if $localdebug;
	$metrics{$LOADMETRIC} = 999;
	$localdebug = 0;
    } elsif ($metricsage < 0) {
	if (-$metricsage > $STALESLOP) {
	    print "WARNING: $host: metric data in the future, ignoring\n"
		if $localdebug;
	    $metrics{$LOADMETRIC} = 999;
	}
    } elsif ($STALEAGE == 0) {
	if ($metricsage > 4 * 60 * 60) {
	    print "WARNING: $host: metric data older than 4 hours, using anyway\n"
		if $localdebug;
	}
    } elsif ($metricsage > $STALEAGE) {
	print "WARNING: $host: stale metric data, ignoring\n"
	    if $localdebug;
	$metrics{$LOADMETRIC} = 999;
    }

    #
    # Make sure all the metrics we might need are defined
    #
    if (!defined($metrics{$LOADMETRIC})) {
	print "WARNING: $host: no $LOADMETRIC metric\n"
	    if $localdebug;
	$metrics{$LOADMETRIC} = 999;
    }
    if (!defined($metrics{disk_free}) || !defined($metrics{disk_total})) {
	print "WARNING: $host: no disk_free/disk_total metrics, assuming enough\n"
	    if $localdebug;
	$metrics{disk_free} = $metrics{disk_total} = 1;
    }
    $metrics{disk_total} = 1
	if $metrics{disk_total} == 0;
    $metrics{disk_free} = $metrics{disk_total}
	if $metrics{disk_free} > $metrics{disk_total};
}

#
# Insert the metrics we care about. Called for each node.
#
sub InsertMetrics()
{
    if (defined($nodemap{$IP})) {
	my $nodeid   = $nodemap{$IP};
	my $scaled;
	my $load;
	my $disk;

	CheckMetrics();

	#
	# Load must be under MAXLOAD, favor those with lower load
	#
	$load = $metrics{$LOADMETRIC};
	if ($MAXLOAD > 0) {
	    $scaled = $load / $MAXLOAD;
	} else {
	    $scaled = 999.0;
	}
		
	#
	# Plab people request that we not start jobs on nodes
	# with less than a certain amount of available disk space
	#
	if ($metrics{disk_free} / $metrics{disk_total} * 100.0 >= $MINDISK) {
	    $disk = 0;
	} else {
	    $disk = 1;
	}

	if (0&& $debug) {
	    print STDERR "$nodeid ($host) $load $scaled $disk\n";
	}

	if (!$impotent) {
	    DBQueryWarn("replace delayed into node_features ".
			" (node_id, feature, weight) ".
			" values ('$nodeid', '+load', $scaled)");
	    DBQueryWarn("replace delayed into node_features ".
			" (node_id, feature, weight) ".
			" values ('$nodeid', '+disk', $disk)");
	}

	# XXX so we can detect nodes in the DB for which we got no status
	undef($nodemap{$IP});
    }
}

#
# Start an element.
# 
sub StartElement ($$$)
{
    my ($expat, $element, %attrs) = @_;

    SWITCH: for ($element) {
	/^CLUSTER/i && do {
	    fatal("Out of Sync: CLUSTER!")
		if (defined($cluster) || defined($host));
	    
	    fatal("Malformed CLUSTER Element!")
		if (!defined($attrs{"NAME"}));
	    
	    $cluster = $attrs{"NAME"};
	    last SWITCH;
	};
	/^HOST/i && do {
	    fatal("Out of Sync: HOST!")
		if (defined($host) || !defined($cluster));
	    
	    fatal("Malformed HOST Element!")
		if (!defined($attrs{"NAME"}));
	    
	    $host = $attrs{"NAME"};
	    $IP   = $attrs{"IP"};

	    $metricsage = $now - $attrs{"REPORTED"};
	    last SWITCH;
	};
	/^METRIC/i && do {
	    fatal("Out of Sync: METRIC!")
		if (!defined($host) || !defined($cluster));

	    fatal("Malformed METRIC Element!")
		if (!defined($attrs{"NAME"}) ||
		    !defined($attrs{"VAL"}));
		
	    $metrics{$attrs{"NAME"}} = $attrs{"VAL"};
	    last SWITCH;
	};
    }
}

#
# End an element.
# 
sub EndElement ($$)
{
    my ($expat, $element) = @_;

    SWITCH: for ($element) {
	/^CLUSTER/i && do {
	    fatal("Out of Sync (End): CLUSTER!")
		if (!defined($cluster) || defined($host));
	    
	    undef($cluster);
	    last SWITCH;
	};
	/^HOST/i && do {
	    fatal("Out of Sync (End): HOST!")
		if (!defined($host) || !defined($cluster));

	    InsertMetrics();

	    undef($host);
	    undef($IP);
	    undef($metricsage);
	    %metrics = ();
	    last SWITCH;
	};
	/^METRIC/i && do {
	    fatal("Out of Sync (End): METRIC!")
		if (!defined($host) || !defined($cluster));

	    last SWITCH;
	};
    }
}



sub fatal {
    my $msg = $_[0];

    SENDMAIL($TBOPS, "plabmetrics Failed", $msg);
    print "$msg\n"
	if $debug;

    unlink($tempfile)
	if (defined($tempfile) && -e $tempfile);
    die($msg);
}
