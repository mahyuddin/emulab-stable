#!/usr/bin/perl -wT
#
# EMULAB-COPYRIGHT
# Copyright (c) 2000-2003 University of Utah and the Flux Group.
# All rights reserved.
#
use English;
use Getopt::Std;
use POSIX qw(strftime);

#
# Monitor the condition of plab nodes by continually trying to setup/teardown
# vnodes on pnodes that are in hwdown. The goal is to move the pnodes out
# of hwdown so that the vnodes on that pnode will be considered okay for
# experiments (see ptopgen). 
# 
sub usage()
{
    print STDERR "Usage: plabmonitor [-d]\n";
    exit(-1);
}
my $optlist = "d";
my $debug   = 0;

#
# Only real root can call this.
# 
if ($UID != 0) {
    print STDERR "You must be root to run this script!\n";
    exit(-1);
}

#
# Configure variables
#
my $TB		= "@prefix@";
my $TBOPS       = "@TBOPSEMAIL@";

# un-taint path
$ENV{'PATH'} = "/bin:/usr/bin:/usr/local/bin:$TB/sbin:$TB/bin";
delete @ENV{'IFS', 'CDPATH', 'ENV', 'BASH_ENV'};

$ENV{'WITH_TB_ADMIN_PRIVS'} = '1';

# Turn off line buffering on output
$| = 1;

# Load the Testbed support stuff.
use lib "@prefix@/lib";
use libdb;
use libtestbed;

# Be careful not to exit on transient error
$libdb::DBQUERY_MAXTRIES = 30;

# Variables from libdb.
my $PLABMOND_PID    = PLABMOND_PID();
my $PLABMOND_EID    = PLABMOND_EID();
my $PLABHOLDING_PID = PLABHOLDING_PID();
my $PLABHOLDING_EID = PLABHOLDING_EID();
my $NODEDEAD_PID    = NODEDEAD_PID();
my $NODEDEAD_EID    = NODEDEAD_EID();

sub TimeStamp()
{
    return POSIX::strftime("%m/%d/%y %H:%M:%S", localtime());
}

#
# Parse command arguments. Once we return from getopts, all that should be
# left are the required arguments.
#
my %options = ();
if (! getopts($optlist, \%options)) {
    usage();
}
if (@ARGV) {
    usage();
}
if (defined($options{"d"})) {
    $debug = 1;
}

#
# Local vars
#
my $logfile = "$TB/log/plabmonitord";
my @oldnodes = ();
my $LOOPSLEEP = 1800;  # 1/2 hour between successive loops.
my $PAUSETIME = 120;   # 2 minute pause after running vnode_setup
my $SETUPWAIT = 960;   # 16 minutes to wait for vnode to setup.
my $BATCHNUM = 20;     # degree of parallelization

#
# daemonize
#
if (!$debug) {
    if (TBBackGround($logfile)) {
        exit(0);
    }
}

print "Plab Monitor Daemon starting... pid $$, at ".`date`;

#
# We want list of all vnodes in our special experiment, whose pnodes are
# in hwdown. These are the nodes we test, hoping to move them out of
# hwdown.
#
while (1) {

    my $start = time();

    print "--------------------------------------------------------------". 
          "----------------\n";
    print "Starting plabmonitord loop at ". TimeStamp() ."\n";

    # Get entries for plab physnodes in hwdown.
    my $query_result =
	DBQueryWarn("select r1.node_id,n1.phys_nodeid from reserved as r1 ".
		    "left join nodes as n1 on n1.node_id=r1.node_id ".
		    "left join reserved as r2 on r2.node_id=n1.phys_nodeid ".
		    "where r1.pid='$PLABMOND_PID' and ".
		    "      r1.eid='$PLABMOND_EID' and ".
		    "      r2.pid='$NODEDEAD_PID' and ".
		    "      r2.eid='$NODEDEAD_EID' ".
		    "order by rand()");

    if (!$query_result) {
	print "Failed to get node list from DB! Waiting a while ...\n";
	goto loop;
    }

    #
    # Build up current node list.  We prefer to try nodes that haven't
    # failed in previous iterations (the newly dead).
    #
    my @nodes = ();
    while (my ($vnode,$pnode) = $query_result->fetchrow_array()) {
        if (search($vnode, @oldnodes)) {
            # We've seen this node before, put it on the end.
            push (@nodes, [$vnode, $pnode]);
        }
        else {
            # We haven't seen this one, put it on the front.
            unshift(@nodes, [$vnode, $pnode]);
        }
    }

    # We're done with last run's failed node list.  Clear it since it
    # will be built again this run.
    @oldnodes = ();

    # Run through the nodes in parallelized batches
    while (my @batch = splice(@nodes,0,$BATCHNUM)) {
        # Do some initial checks on the nodes and remove those that
        # fail these from testing this time around.
        my @batch2 = grep(nodeprecheck($_), @batch);
        my @vnodes = map {$_->[0]} @batch2;
        my @pnodes = map {$_->[1]} @batch2;

        sleep 5;
    
        print "##############################################################################\n";
        print "### Checking vnodes: @vnodes on pnodes: @pnodes at ".
            TimeStamp() . "\n";
    
        #
        # Try to setup this batch of vnodes.
        #
        system("vnode_setup -f -d -w $SETUPWAIT -n $BATCHNUM ".
               "$PLABMOND_PID $PLABMOND_EID @vnodes");

        print "sleeping for a bit.\n"
            if ($debug);
        sleep($PAUSETIME); # wait a bit to let final stragglers check in.

        # Check the nodes to find out which are up, and which failed
        # in the vnode_setup we just ran.
        print "Checking vnode_setup run status\n";
        my @failed = grep(nodepostalloc($_), @batch2);
        
        # If any fail, try to tear them down.
        if (@failed) {
            my @fvnodes = map {$_->[0]} @failed;
            my @fpnodes = map {$_->[1]} @failed;
            
            print "### vnode_setup failed for the following vnodes: @fvnodes\n";
            print "### Proceding to tear them down.\n";
            system("vnode_setup -f -d -k -n $BATCHNUM $PLABMOND_PID $PLABMOND_EID @fvnodes");
        }

        # Keep track of failed nodes for next daemon loop iteration.
        push(@oldnodes, @failed);
    }

  loop:
    # Wait a while between setup attempts to let PLAB deallocation percolate.
    print "Sleeping for $LOOPSLEEP seconds.\n";
    sleep($LOOPSLEEP);
}

#
# Check vnode status, moving nodes back into production if they booted up,
# and leaving them in hwdown if they didn't.
#
sub nodepostalloc($) {
    my ($vnode, $pnode) = @{$_[0]};
    my $revive = 0;
    my $retval = 1;
    my $state = TBDB_NODESTATE_UNKNOWN();

    # Did the node send ISUP (boot up completely)?
    if (TBGetNodeEventState($vnode, \$state) && 
        $state eq TBDB_NODESTATE_ISUP()) 
    {
        $revive = 1;
    }

    print "State for $vnode is $state\n" if $debug;

    #
    # It came up! Move the pnode out of hwdown and back into
    # normal holding experiment.
    #
    if ($revive &&
        DBQueryWarn("update reserved set ".
                    "  pid='$PLABHOLDING_PID',eid='$PLABHOLDING_EID' ".
                    "where node_id='$pnode'")) {
        print "$pnode brought back from the afterworld at ".
            TimeStamp() . "\n";
        
        TBSetNodeLogEntry($pnode, "root", TB_DEFAULT_NODELOGTYPE(),
                          "'Moved to $PLABHOLDING_EID; ".
                          "plab node $vnode setup okay by monitor.'");
        
        SENDMAIL($TBOPS, "$pnode is alive",
                 "$pnode has been brought back from the afterworld!",
                 $TBOPS);
        $retval = 0;

    # It didn't come up..
    } else {
        print "Leaving $pnode in hwdown!\n";
        $retval = 1
    }

    return $retval;
}


#
# Preliminary checks:
# * make sure pnode is still in hwdown
#
sub nodeprecheck($) {
    my ($vnode, $pnode) = @{$_[0]};
    my $retval = 1;

    # * Try full vnode_setup on node - mgmt sliver.
    #   - If (multiple?) fail, try to delete node/sliver from mgmt slice.
    #     (can we push out this action?)
    #
    
    #
    # Make sure the node is still in $NODEDEAD_*
    #
    my $query_result = DBQueryWarn("select node_id from reserved where ".
                                   "node_id = '$pnode' and ".
                                   "pid = '$NODEDEAD_PID' and ".
                                   "eid = '$NODEDEAD_EID'");
    if (!$query_result) {
        print "Node $pnode entry DB check failed!  Skipping it ...\n";
        $retval = 0;
    }
        
    elsif (!$query_result->num_rows()) {
        print "Node was removed out from under us! Continuing on ...\n";
        $retval = 0;
    }

    return $retval;
}

#
# send mail with given message, and exit (also printing message).
#    
sub fatal($)
{
    local($msg) = $_[0];

    SENDMAIL($TBOPS, "Plab Monitor Died", $msg, $TBOPS);
    die($msg);
}

#
# Helper function - see if item is first element in any member of 
# an array of tuples.
#
sub search($@)
{
    $target = shift;
    foreach $elt (@_) {
        if ($target eq $elt->[0]) {
            return 1;
        }
    }
    return 0;
}
