#!/usr/bin/perl -wT
#
# EMULAB-COPYRIGHT
# Copyright (c) 2000-2003 University of Utah and the Flux Group.
# All rights reserved.
#
use English;
use Getopt::Std;
use POSIX qw(strftime);
use POSIX ":sys_wait_h";

#
# Monitor the condition of plab nodes by continually trying to setup/teardown
# vnodes on pnodes that are in hwdown. The goal is to move the pnodes out
# of hwdown so that the vnodes on that pnode will be considered okay for
# experiments (see ptopgen). 
# 
sub usage()
{
    print STDERR "Usage: plabmonitor [-dS]\n";
    print STDERR "  -d   Debug mode.\n";
    print STDERR "  -S   Run WITHOUT reading monitor state from database;\n";
    print STDERR "         new state will still be written (default is to" .
	" load state).\n";
    exit(-1);
}
my $optlist = "dS";
my $debug   = 0;
my $stateful = 1;

#
# Only real root can call this.
# 
if ($UID != 0) {
    print STDERR "You must be root to run this script!\n";
    exit(-1);
}

#
# Configure variables
#
my $TB		= "@prefix@";
my $TBOPS       = "@TBOPSEMAIL@";
my $TBAUTOMAIL  = "@TBAUTOMAILEMAIL@";

# un-taint path
$ENV{'PATH'} = "/bin:/usr/bin:/usr/local/bin:$TB/sbin:$TB/bin";
delete @ENV{'IFS', 'CDPATH', 'ENV', 'BASH_ENV'};

$ENV{'WITH_TB_ADMIN_PRIVS'} = '1';

# Turn off line buffering on output
$| = 1;

# Load the Testbed support stuff.
use lib "@prefix@/lib";
use libdb;
use libtestbed;
use libplabmon;

# Load pool libraries
use plabmon_badpool;
use plabmon_goodpool;

# Be careful not to exit on transient error
$libdb::DBQUERY_MAXTRIES = 30;

# Variables from libdb.
my $PLABDOWN_PID    = PLABDOWN_PID();
my $PLABDOWN_EID    = PLABDOWN_EID();
my $PLABHOLDING_PID = PLABHOLDING_PID();
my $PLABHOLDING_EID = PLABHOLDING_EID();

#
# Parse command arguments. Once we return from getopts, all that should be
# left are the required arguments.
#
my %options = ();
if (! getopts($optlist, \%options)) {
    usage();
}
if (@ARGV) {
    usage();
}
if (defined($options{"d"})) {
    $debug = 1;
}
if (defined($options{'S'})) {
    $stateful = 0;
}

#
# Function prototypes
#
sub updatenodepool($);
sub fatal($);
#sub loadstate($$);

#
# Global vars
#
my $LOGFILE      = "$TB/log/plabmonitord";
my $PIDFILE      = "/var/run/plabmonitord.pid";
my $MINSLEEP     = 2;    # Sleep for no less than 2 seconds.
my $MAXWINSIZE   = 40;   # Degree of parallelization.
my $MAXSLEEPTIME = 600;  # Don't ever sleep for longer than this - we need
                         #  to wake up once in a while!
my $CHILLTIME    = 5;    # How long to wait after processing expirations.
my $NEVER        = 0;    # "Never" in seconds since the Epoch.

my $MAXLA        = 20;   # Don't let the system load get out of hand.

# Keep only this many (success,fail) sequences in memory at a 
# time (they get saved in the db anyway... we just need to minimize cost
# across fork()s)
my $MAX_STATE_SEQUENCES = 10;

#
# daemonize
#
if (!$debug) {
    if (TBBackGround($LOGFILE)) {
        exit(0);
    }
}

#
# Write our pid into the pid file so we can be killed later. 
#
system("echo '$PID' > $PIDFILE") == 0 or
    die("*** $0:\n".
	"    Could not create $PIDFILE!");

# pid -> pool mapping; passed in as param to pool setup funtion.
my %chpid2pool = ();

print "Plab Monitor Daemon starting... pid $$, at ".`date`;

#
# Open the status log.  This will be used by the pools to log
# node success/fail results, and other status info.
#
OpenLog(STATUSLOG, STATUSLOGPATH) or die "Can't open status log!";

#
# Create the node pools.
#
my $badpool  = plabmon_badpool->new("bad", 
                                    $PLABDOWN_PID, 
                                    $PLABDOWN_EID, 
                                    \%chpid2pool);
my $goodpool = plabmon_goodpool->new("good", 
                                     $PLABHOLDING_PID, 
                                     $PLABHOLDING_EID, 
                                     \%chpid2pool);
@allpools = ($badpool, $goodpool);

#
# Handle termination/hangup signals
#
sub termsig($) {
    my $signame = shift;
    print "*** $0: Received $signame - exiting.\n";

    # Whack the whole process group (except top level parent!)
    local $SIG{TERM} = 'IGNORE';
    kill("TERM", -$$);

    while (wait() > 0) {};

    unlink($PIDFILE);

    exit -1;
}

$SIG{TERM} = \&termsig;
$SIG{HUP}  = \&termsig;
$SIG{INT}  = \&termsig;

#
# Main loop: grind around looking for nodes to check in the various
# pools.  Sleep until next node is ready to be processed.
#
my $windowsize = 0;
while (1) {
    my $now = time();
    my $sleeptime = $MAXSLEEPTIME;
    my $reappool;
    my $lastwindowsize = -1;

    # Update pool membership.
    foreach my $pool (@allpools) {
        updatenodepool($pool);
    }

    # Check pools and fire off new checks as window room permits.  If no
    # new node tests were added since the last run through the pools, then
    # bail out.
    my $curLA = getLA();
    while ($windowsize < $MAXWINSIZE && $windowsize != $lastwindowsize
           && $curLA < $MAXLA) {
        $lastwindowsize = $windowsize;
        $curLA = getLA();
        foreach my $pool (@allpools) {
            # if pool still has nodes to test, get them going.
            if ($pool->getnextchecktime() <= $now) {
                $pool->checknextnode();
                $windowsize++;
            }
        }
    }

    # Now adjust the sleep time according to the next node service 
    # time.  The next service time is defined as the soonest time in 
    # the future that a node in any of the pools needs attention 
    # (either to be checked, or to be processed as a result of an 
    # already running check).
    foreach my $pool (@allpools) {
        my $nextservicetime = $pool->getnextservicetime();
        my $servicediff = $nextservicetime - $now;
        $servicediff = $servicediff > $MINSLEEP ? $servicediff : $MINSLEEP;
        $sleeptime = MIN($servicediff, $sleeptime);
    }

    # Go to sleep waiting for the next node to process.
    print "Monitor going to sleep for $sleeptime seconds ".
          "(winsize: $windowsize, LA: $curLA).\n";

    sleep($sleeptime);

    #$now = time(); # Must reset $now after sleep.

    # Handle any children that have exited.
    while((my $chpid = waitpid(-1, WNOHANG)) > 0) {
        my $chstat = $?;
        next if !defined($chpid2pool{$chpid});
        $reappool = $chpid2pool{$chpid};
        delete $chpid2pool{$chpid};
        if ($reappool->processchild($chpid, $chstat)) {
            $windowsize--;
        }
    }

    # Look for expired processes.  Calling checkexpiration on a pool
    # has the side effect of checking for ISUP (or ISUP expiration) for
    # any nodes pending thusly in the pool.  The return value is the
    # number of nodes that the pool has finished processing (if any).
    # Decrement the windowsize appropriately.
    foreach my $pool (@allpools) {
        my $numfinished = $pool->checkexpiration();
        $windowsize -= $numfinished;
    }

    # We may have just fired off a bunch of kills, so chill for a bit to
    # let things quiesce.
    sleep($CHILLTIME);
}

#
# Load monitor state from the plab_nodehist table for the given pnode.
#
sub loadstate($$) {
    my $pool = shift;
    my $pnode = shift;
    my $poolpid = $pool->{'PID'};
    my $pooleid = $pool->{'EID'};
    my $poolpnodes = $pool->{'PNODES'};

    if (!defined($pool) || !defined($pnode)) 
      return;

    my $res = 
      DBQueryFatal("select unix_timestamp(timestamp),component,operation," . 
                   "status " . 
                   " from plab_nodehist where phys_node_id='$pnode' " . 
                   " order by timestamp asc" . 
                   );

    # calculate sequence lengths; store most recent 10
    my @sequences = ();
    my $lastseqstat = '', $lastts = 0;
    if ($res && $res->num_rows()) {
      while (my @row = $res->fetchrow_array()) {
          my ($ts,$com,$op,$status) = @row;

          # filter out entries older than two weeks
          # NOTE: after we create the sequence for this node, we will
          # check the last (most recent) timestamp; if it's older than
          # three days, we reject all sequence state for this node
          # and start clean.  The reason for this is pretty obvious;
          # if a node was good for two weeks, then we don't check for two 
          # weeks (i.e., cause plabmonitord didn't run), we might try to use
          # old state to assume new check intervals, and this might be bad.

          if ($lastts == 0) {
              # first row
              $lastseqstat = $status;
              $lastts = $ts;
              next;
          }
	  
          # @entry = (up/down,seqtime,conseccount)
	  
          # add this one on to the last.
          @sequences[0][1] += ($ts - $lastts);
          if ($lastseqstat eq $status) {
              ++(@sequences[0][2]);
          }
          else {
              # new entry
              my @entry = ();
              if ($status eq 'success') {
                  entry[0] = 'up';
              }
              else {
                  entry[0] = 'down';
              }
              entry[1] = 0;
              entry[2] = 1;
              
	      # save off this sequence
              push @sequences, \@entry;
          }
	  
          $lastseqstat = $status;
          $lastts = $ts;
	  
      }
  }
    
    # remove the oldest N sequences...
    if (scalar(@sequences) $MAX_STATE_SEQUENCES) {
      for (my $i = scalar(@sequences); $i >= $MAX_STATE_SEQUENCES; --$i) {
          undef($sequences[$i]);
      }
    }

    $poolpnodes->{$pnode}->{'history'} = \@sequences;

    Log(STATUSLOG, "plabmonitord, $pnodename, loadstate, ".
      (scalar(@{$poolpnodes->{$pnodename}->{'history'}})).
       " sequences added.");
    
    return;
}

#
# Go through the PID/EID associated with the pool and grab any new nodes
# that have appeared.
#
# XXX: Also, remove nodes that have disappeared (wrong to do here).
#
sub updatenodepool($) {
    my $pool = shift;
    my $poolpid = $pool->{'PID'};
    my $pooleid = $pool->{'EID'};
    my $poolpnodes = $pool->{'PNODES'};

    my $now = time();

    print "Updating node membership in pool: $pool->{'NAME'}\n";

    # XXX: need to change everything to deal with vnodes rather than pnodes.
    my $qres = 
        DBQueryFatal("select r.node_id from reserved as r ".
                     "left join nodes as n on n.node_id=r.node_id ".
                     "left join node_types as nt on n.type = nt.type ".
                     "where r.pid='$poolpid' and ".
                     "      r.eid='$pooleid' and ".
                     "      nt.isplabphysnode = 1 ".
                     "order by rand()");

    if ($qres and $qres->num_rows()) {
        # Find any new nodes that need to be added and add them.
        while (my @row = $qres->fetchrow_array()) {
            my $pnodename = $row[0];
            if (!exists $poolpnodes->{$pnodename} ) {
                print "Adding $pnodename to pool: $pool->{'NAME'}\n";
                $poolpnodes->{$pnodename} = {'name'           => $pnodename,
                                             'entertime'      => $now,
                                             'lastcheckstart' => $NEVER,
                                             'nextchecktime'  => $now + int(rand(120)),
                                             'lastfailtime'   => $NEVER,
                                             'consecfails'    => 0,
                                             'consecsuccess'  => 0,
                                             'setupfails'     => 0};

                Log(STATUSLOG, "plabmonitord, $pnodename, addtopool, ".
                    "nostat, node added to pool $pool->{'NAME'}");
            }
            # Mark this node as still in the pool as of this check.
            $poolpnodes->{$pnodename}->{'updtime'} = $now;
        }
    }

    # Prune out nodes that no longer appear in the pool query.
    # XXX: A node entry should never disappear, and should be
    #      moved explicitly from one pool to another.
    foreach my $pnodename (keys %{$poolpnodes}) {
        if ($poolpnodes->{$pnodename}->{'updtime'} != $now) {
            print "Removing $pnodename from pool: $pool->{'NAME'}\n";
            delete $poolpnodes->{$pnodename};
            Log(STATUSLOG, "plabmonitord, $pnodename, removefrompool, ".
                "nostat, node removed from pool $pool->{'NAME'}");
        }
    }

    return;
}

#
# send mail with given message, and exit (also printing message).
#    
sub fatal($)
{
    local($msg) = $_[0];

    SENDMAIL($TBOPS, "Plab Monitor Died", $msg, $TBOPS);
    die($msg);
}
