#!/usr/bin/perl -wT
#
# EMULAB-COPYRIGHT
# Copyright (c) 2000-2003 University of Utah and the Flux Group.
# All rights reserved.
#
use English;
use Getopt::Std;
use POSIX qw(strftime);
use POSIX ":sys_wait_h";

#
# Monitor the condition of plab nodes by continually trying to setup/teardown
# vnodes on pnodes that are in hwdown. The goal is to move the pnodes out
# of hwdown so that the vnodes on that pnode will be considered okay for
# experiments (see ptopgen). 
# 
sub usage()
{
    print STDERR "Usage: plabmonitor [-d]\n";
    exit(-1);
}
my $optlist = "d";
my $debug   = 0;

#
# Only real root can call this.
# 
if ($UID != 0) {
    print STDERR "You must be root to run this script!\n";
    exit(-1);
}

#
# Configure variables
#
my $TB		= "@prefix@";
my $TBOPS       = "@TBOPSEMAIL@";
my $TBAUTOMAIL  = "@TBAUTOMAILEMAIL@";

# un-taint path
$ENV{'PATH'} = "/bin:/usr/bin:/usr/local/bin:$TB/sbin:$TB/bin";
delete @ENV{'IFS', 'CDPATH', 'ENV', 'BASH_ENV'};

$ENV{'WITH_TB_ADMIN_PRIVS'} = '1';

# Turn off line buffering on output
$| = 1;

# Load the Testbed support stuff.
use lib "@prefix@/lib";
use libdb;
use libtestbed;
use libplabmon;

# Load pool libraries
use plabmon_badpool;
use plabmon_goodpool;

# Be careful not to exit on transient error
$libdb::DBQUERY_MAXTRIES = 30;

# Variables from libdb.
my $PLABDOWN_PID    = PLABDOWN_PID();
my $PLABDOWN_EID    = PLABDOWN_EID();
my $PLABHOLDING_PID = PLABHOLDING_PID();
my $PLABHOLDING_EID = PLABHOLDING_EID();

#
# Parse command arguments. Once we return from getopts, all that should be
# left are the required arguments.
#
my %options = ();
if (! getopts($optlist, \%options)) {
    usage();
}
if (@ARGV) {
    usage();
}
if (defined($options{"d"})) {
    $debug = 1;
}

#
# Function prototypes
#
sub updatenodepool($);
sub fatal($);

#
# Global vars
#
my $LOGFILE      = "$TB/log/plabmonitord";
my $PIDFILE      = "/var/run/plabmonitord.pid";
my $MINSLEEP     = 2;    # Sleep for no less than 2 seconds.
my $MAXWINSIZE   = 40;   # Degree of parallelization.
my $MAXSLEEPTIME = 600;  # Don't ever sleep for longer than this - we need
                         #  to wake up once in a while!
my $CHILLTIME    = 5;    # How long to wait after processing expirations.
my $NEVER        = 0;    # "Never" in seconds since the Epoch.

my $MAXLA        = 20;   # Don't let the system load get out of hand.

#
# daemonize
#
if (!$debug) {
    if (TBBackGround($LOGFILE)) {
        exit(0);
    }
}

#
# Write our pid into the pid file so we can be killed later. 
#
system("echo '$PID' > $PIDFILE") == 0 or
    die("*** $0:\n".
	"    Could not create $PIDFILE!");

# pid -> pool mapping; passed in as param to pool setup funtion.
my %chpid2pool = ();

print "Plab Monitor Daemon starting... pid $$, at ".`date`;

# XXX: testing
#OpenDebugLog("chlog", "$TB/log/chlog.dbg") or die "Can't open debug log!";
#DebugLog("chlog", "Plabmonitord start: Child debug log opened");

#
# Create the node pools.
#
my $badpool  = plabmon_badpool->new("bad", 
                                    $PLABDOWN_PID, 
                                    $PLABDOWN_EID, 
                                    \%chpid2pool);
my $goodpool = plabmon_goodpool->new("good", 
                                     $PLABHOLDING_PID, 
                                     $PLABHOLDING_EID, 
                                     \%chpid2pool);
@allpools = ($badpool, $goodpool);

#
# Handle termination/hangup signals
#
sub termsig($) {
    my $signame = shift;
    print "*** $0: Received $signame - exiting.\n";

    # Whack the whole process group (except top level parent!)
    local $SIG{TERM} = 'IGNORE';
    kill("TERM", -$$);

    while (wait() > 0) {};

    unlink($PIDFILE);

    exit -1;
}

$SIG{TERM} = \&termsig;
$SIG{HUP}  = \&termsig;
$SIG{INT}  = \&termsig;

#
# Main loop: grind around looking for nodes to check in the various
# pools.  Sleep until next node is ready to be processed.
#
my $windowsize = 0;
while (1) {
    my $now = time();
    my $sleeptime = $MAXSLEEPTIME;
    my $reappool;
    my $lastwindowsize = -1;

    # Update pool membership.
    foreach my $pool (@allpools) {
        updatenodepool($pool);
    }

    # Check pools and fire off new checks as window room permits.  If no
    # new node tests were added since the last run through the pools, then
    # bail out.
    my $curLA = getLA();
    while ($windowsize < $MAXWINSIZE && $windowsize != $lastwindowsize
           && $curLA < $MAXLA) {
        $lastwindowsize = $windowsize;
        $curLA = getLA();
        foreach my $pool (@allpools) {
            # if pool still has nodes to test, get them going.
            if ($pool->getnextchecktime() <= $now) {
                $pool->checknextnode();
                $windowsize++;
            }
        }
    }

    # Now adjust the sleep time according to the next node service 
    # time.  The next service time is defined as the soonest time in 
    # the future that a node in any of the pools needs attention 
    # (either to be checked, or to be processed as a result of an 
    # already running check).
    foreach my $pool (@allpools) {
        my $nextservicetime = $pool->getnextservicetime();
        my $servicediff = $nextservicetime - $now;
        $servicediff = $servicediff > $MINSLEEP ? $servicediff : $MINSLEEP;
        $sleeptime = MIN($servicediff, $sleeptime);
    }

    # Go to sleep waiting for the next node to process.
    print "Monitor going to sleep for $sleeptime seconds ".
          "(winsize: $windowsize, LA: $curLA).\n";

    sleep($sleeptime);

    #$now = time(); # Must reset $now after sleep.

    # Handle any children that have exited.
    while((my $chpid = waitpid(-1, WNOHANG)) > 0) {
        my $chstat = $?;
        next if !defined($chpid2pool{$chpid});
        $reappool = $chpid2pool{$chpid};
        delete $chpid2pool{$chpid};
        if ($reappool->processchild($chpid, $chstat)) {
            $windowsize--;
        }
    }

    # Look for expired processes.  Calling checkexpiration on a pool
    # has the side effect of checking for ISUP (or ISUP expiration) for
    # any nodes pending thusly in the pool.  The return value is the
    # number of nodes that the pool has finished processing (if any).
    # Decrement the windowsize appropriately.
    foreach my $pool (@allpools) {
        my $numfinished = $pool->checkexpiration();
        $windowsize -= $numfinished;
    }

    # We may have just fired off a bunch of kills, so chill for a bit to
    # let things quiesce.
    sleep($CHILLTIME);
}

#
# Go through the PID/EID associated with the pool and grab any new nodes
# that have appeared.
#
# XXX: Also, remove nodes that have disappeared (wrong to do here).
#
sub updatenodepool($) {
    my $pool = shift;
    my $poolpid = $pool->{'PID'};
    my $pooleid = $pool->{'EID'};
    my $poolpnodes = $pool->{'PNODES'};

    my $now = time();

    print "Updating node membership in pool: $pool->{'NAME'}\n";

    # XXX: need to change everything to deal with vnodes rather than pnodes.
    my $qres = 
        DBQueryFatal("select r.node_id from reserved as r ".
                     "left join nodes as n on n.node_id=r.node_id ".
                     "left join node_types as nt on n.type = nt.type ".
                     "where r.pid='$poolpid' and ".
                     "      r.eid='$pooleid' and ".
                     "      nt.isplabphysnode = 1 ".
                     "order by rand()");

    if ($qres and $qres->num_rows()) {
        # Find any new nodes that need to be added and add them.
        while (my @row = $qres->fetchrow_array()) {
            my $pnodename = $row[0];
            if (!exists $poolpnodes->{$pnodename} ) {
                print "Adding $pnodename to pool: $pool->{'NAME'}\n";
                $poolpnodes->{$pnodename} = {'name'           => $pnodename,
                                             'entertime'      => $now,
                                             'lastcheckstart' => $NEVER,
                                             'nextchecktime'  => $now + int(rand(120)),
                                             'lastfailtime'   => $NEVER,
                                             'consecfails'    => 0,
                                             'consecsuccess'  => 0,
                                             'setupfails'     => 0};
            }
            # Mark this node as still in the pool as of this check.
            $poolpnodes->{$pnodename}->{'updtime'} = $now;
        }
    }

    # Prune out nodes that no longer appear in the pool query.
    # XXX: A node entry should never disappear, and should be
    #      moved explicitly from one pool to another.
    foreach my $pnodename (keys %{$poolpnodes}) {
        if ($poolpnodes->{$pnodename}->{'updtime'} != $now) {
            print "Removing $pnodename from pool: $pool->{'NAME'}\n";
            delete $poolpnodes->{$pnodename};
        }
    }

    return;
}

#
# send mail with given message, and exit (also printing message).
#    
sub fatal($)
{
    local($msg) = $_[0];

    SENDMAIL($TBOPS, "Plab Monitor Died", $msg, $TBOPS);
    die($msg);
}
