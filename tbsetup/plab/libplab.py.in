# -*- python -*-
#
# EMULAB-COPYRIGHT
# Copyright (c) 2000-2004, 2006, 2007 University of Utah and the Flux Group.
# All rights reserved.
#

"""
Library for interfacing with Plab.  This abstracts out the concepts of
Plab central, slices, and nodes.  All data (except static things like
certificates) is kept in the Emulab DB.  Unlike the regular dslice
svm, this one supports dynamically changing which nodes are in a
slice.

This requires an already obtained dslice certficate and key.  By
default it expects to find these in the @prefix@/etc/plab/
subdirectory.
"""

import sys
sys.path.append("@prefix@/lib")

import os, time
import string
import traceback
import signal
import socket
import httplib
import xml.parsers.expat
import re
import calendar
import shlex

from popen2 import Popen4
from warnings import warn

#
# Testbed and DB access libs
#
from libtestbed import *
from libdb import *

#
# Plab modules to import
#
from mod_PLC import mod_PLC
from mod_dslice import mod_dslice
from mod_PLCNM import mod_PLCNM
from mod_PLC4 import mod_PLC4

agents = {'PLC'    : mod_PLC,
          'dslice' : mod_dslice,
          'PLCNM'  : mod_PLCNM,
          'PLC4'   : mod_PLC4}

#
# Initialize the AOP stuff
#
from aspects import wrap_around
from timer_advisories import initTimeAdvice, timeAdvice
initTimeAdvice("plabtiming")

#
# output control vars
#
verbose = 0
debug = 0

#
# Constants
#
DEF_AGENT = "PLC4";
#
# Add a compatibility agent --- libplab will make all PLC calls on this agent
# in addition to the default agent.
#
COMPAT_AGENT = "PLCNM";
# if this is set, do all PLC calls on COMPAT_AGENT as well as DEF_AGENT
compat_mode = 0

RENEW_TIME = 2*24*60*60  # Renew two days before lease expires

RENEW_TIMEOUT = 1*60     # give the node manager a minute to respond to renew
FREE_TIMEOUT  = 1*60     # give the node manager a minute to respond to free
NODEPROBEINT  = 30

USERNODE = "@USERNODE@"
TBOPS = "@TBOPSEMAIL_NOSLASH@"
MAILTAG = "@THISHOMEBASE@"
SLICE_ALIAS_DIR = "/etc/mail/plab-slice-addrs"

RESERVED_PID = "emulab-ops"
RESERVED_EID = "hwdown"       # start life in hwdown
MONITOR_PID  = "emulab-ops"
MONITOR_EID  = "plab-monitor"

MAGIC_INET2_GATEWAYS = ("205.124.237.10",  "205.124.244.18",
                        "205.124.244.178", )
MAGIC_INET_GATEWAYS =  ("205.124.244.150", "205.124.239.185",
                        "205.124.244.154", "205.124.244.138",
                        "205.124.244.130", )
LOCAL_PLAB_DOMAIN = ".flux.utah.edu"
LOCAL_PLAB_LINKTYPE = "pcplabinet2"

# allowed nil/unknown values (sentinels).
ATTR_NIL_VALUES = ('None',)

# 'critical' node identifiers - those that are actually used to uniquely
# identify a planetlab node
ATTR_CRIT_KEYS = ('HNAME', 'IP', 'PLABID', 'MAC',)

# The amount by which latitude and longitude are allowed to differ before we
# classify them ask changed
LATLONG_DELTA = 0.001

PLABNODE = "@prefix@/sbin/plabnode"
SSH = "@prefix@/bin/sshtb"
NAMED_SETUP = "@prefix@/sbin/named_setup"
PELAB_PUSH  = "@prefix@/sbin/pelab_opspush"

ROOTBALL_URL = "http://localhost:1492/" # ensure this ends in a slash

DEF_PLAB_URL = "www.planet-lab.org"
DEF_SITE_XML = "/xml/sites.xml"
IGNORED_NODES_FILE = "@prefix@/etc/plab/IGNOREDNODES"
ALLOWED_NODES_FILE = "@prefix@/etc/plab/ALLOWEDNODES"

DEF_ROOTBALL_NAME = "@PLAB_ROOTBALL@"
SLICEPREFIX = "@PLAB_SLICEPREFIX@"
NODEPREFIX  = "plab"

BADSITECHARS = re.compile(r"\W+")
PLABBASEPRIO = 20000
PLAB_SVC_SLICENAME = "utah_svc_slice"
PLAB_SVC_SLICEDESC = "Emulab management service slice. Performs periodic " \
                     "checkins with Emulab central, and routes events for " \
                     "other Emulab slices. Slivers in this slice should " \
                     "only interact with other PlanetLab machines, and Emulab."
PLABMON_PID = "emulab-ops"
PLABMON_EID = "plab-monitor"
DEF_SLICE_DESC = "Slice created by Emulab"

PLABEXPIREWARN = 1*WEEK        # one week advance warning for slice expiration.
NODEEXPIREWARN = 2*WEEK+2*DAY  # about two weeks advance warning for slivers.

#
# This is a trigger table for dist'ing out multiple rootballs depending on
# which NM is running on the node.  Since we don't know which version is
# running on a node until we call into (DEF|COMPAT)_AGENT and actually connect
# to the node, it's based off classnames.
#
# The table specifies a prefix to the default rootball name; this rootball
# should be placed in the normal location.
#
# If the plcagent class and nodeagent class are both not in the trigger table,
# we simply push the default rootball.
#
# Note that we could store version info in the database, but that doesn't
# really have long-term value.  Plus, we have to be checking sites.xml all the
# time to catch version changes during rollout.  This way, plabmonitord and
# the web interface know exactly what is the version whenever a node is
# contacted for setup.
#
# For now, only NM4agent has a custom tarball, since v4 nodes are in the
# distinct minority right now.
#
from mod_PLC4 import NM4agent

rootball_triggers = { mod_PLC4 : { NM4agent : 'NM4-' } }

#
# var to track failed renewals
#
failedrenew = []

#
# Disable line buffering
#
sys.stdout = os.fdopen(sys.stdout.fileno(), sys.stdout.mode, 0)

#
# Ensure SIGPIPE doesn't bite us:
#
signal.signal(signal.SIGPIPE, signal.SIG_IGN)


#
# Plab abstraction
#

#
# Multiple attribute change exception
#
class MultiChangeError(Exception):
    def __init__(self, nodeid, chattrs={}):
        self.nodeid = nodeid
        self.chattrs = chattrs
        pass
    pass


#
# Class responsible for parsing planetlab sites file
#
class siteParser:

    def __init__(self):
        self.parser = xml.parsers.expat.ParserCreate()
        self.parser.StartElementHandler = self.__site_start_elt
        self.parser.EndElementHandler = self.__site_end_elt
        self.__hosts = []
        self.__sitename = ""
        self.__latitude = 0
        self.__longitude = 0
        
    def getPlabNodeInfo(self):
                
        conn = httplib.HTTPSConnection(DEF_PLAB_URL)
        conn.request("GET", DEF_SITE_XML)
        res = conn.getresponse()
        if res.status != 200:
            raise RuntimeError, "HTTP Error getting site list:\n" \
                  "Code: %d Reason: %s" % \
                  (res.status, res.reason)
        try:
            self.parser.ParseFile(res)
            pass
        except xml.parsers.expat.ExpatError, e:
            print "Error parsing XML file, lineno: %d, offset: %d:\n%s" % \
                  (e.lineno, e.offset, xml.parsers.expat.ErrorString(e.code))
            raise

        return self.__hosts

    def __site_start_elt(self, name, attrs):
        
        if name == "PLANETLAB_SITES":
            pass
        
        elif name == "SITE":
            self.__sitename = attrs['SHORT_SITE_NAME']
            if attrs.has_key('LATITUDE'):
                self.__latitude = attrs['LATITUDE']
            else:
                self.__latitude = 0
            if attrs.has_key('LONGITUDE'):
                self.__longitude = attrs['LONGITUDE']
            else:
                self.__longitude = 0
            pass
        
        elif name == "HOST":
            if not attrs.has_key('MAC'):
                attrs['MAC'] = "None"
                pass
            if not attrs.has_key('BWLIMIT'):
                attrs['BWLIMIT'] = "-1"
                pass
            if not attrs.has_key('IP'):
                print "node %s did not have IP!" % attrs['NAME']
                pass
            else:
                self.__hosts.append({
                    'HNAME'     : attrs['NAME'],
                    'IP'        : attrs['IP'],
                    'PLABID'    : attrs['NODE_ID'],
                    'MAC'       : attrs['MAC'],
                    'BWLIMIT'   : attrs['BWLIMIT'],
                    'SITE'      : self.__sitename,
                    'LATITUDE'  : self.__latitude,
                    'LONGITUDE' : self.__longitude,
                    'STATUS'    : attrs['STATUS']
                    })
                pass
            pass
        
        else:
            print "Unknown element in site file: %s: %s" % (name, attrs)
            pass
        
        return

    def __site_end_elt(self, name):
        
        if name == "SITE":
            self.__sitename = "Unknown"
            self.__latitude = 0
            self.__longitude = 0
            pass
        return


class Plab:
    def __init__(self, agent=None):
        if not agent:
            self.agent = agents[DEF_AGENT]()
            pass
        if compat_mode:
            self.compat_agent = agents[COMPAT_AGENT]()
        if debug:
            print "Using module: %s" % self.agent.modname
            if compat_mode:
                print "COMPAT: Using module: %s" % self.compat_agent.modname
            pass
        pass

    def createSlice(self, pid, eid):
        """
        Slice factory function
        """
        slice = Slice(self, pid, eid)
        slice._create()
        return slice

    def loadSlice(self, pid, eid):
        """
        Slice factory function
        """
        slice = Slice(self, pid, eid)
        slice._load()
        return slice

    def updateNodeEntries(self, ignorenew = False):
        """
        Finds out which Plab nodes are available, and
        update the DB accordingly.  If ignorenew is True, this will only
        make sure that the data in the DB is correct, and not complete.
        If ignorenew is False (the default), this will do a complete
        update of the DB.  However, this can take some time, as
        information about new nodes (such as link type) must be
        discovered.

        Note that this seemingly innocent funciton actually does a lot of
        magic.  This is the main/only way that Plab nodes get into the
        nodes DB, and this list is updated dynamically.  It also gathers
        static data about new nodes.
        """
        
        print "Getting available Plab nodes ..."

        avail = []
        try:
            parser = siteParser()
            avail = parser.getPlabNodeInfo()
            pass
        # XXX: rewrite to use more elegant exception info gathering.
        except:
            extype, exval, extrace = sys.exc_info()
            print "Error talking to agent: %s: %s" % (extype, exval)
            if debug:
                #print extrace
                traceback.print_exc()
                pass
            
            print "Going back to sleep until next scheduled poll"
            return

        if debug:
            print "Got advertisement list:"
            print avail
            pass

        ignored_nodes = self.__readNodeFile(IGNORED_NODES_FILE)
        allowed_nodes = self.__readNodeFile(ALLOWED_NODES_FILE)

        # Enforce node limitations, if any.
        # XXX: This is ugly - maybe move to a separate function
        #      that takes a list of filter functions.  I know!!
        #      Create a generator out of a set of filter functions
        #      and the initial node list! :-)  Python geek points to me if
        #      I ever get around to it...  KRW
        if len(allowed_nodes) or len(ignored_nodes):
            allowed = []
            for nodeent in avail:
                if nodeent['PLABID'] in ignored_nodes:
                    continue
                elif len(allowed_nodes):
                    if nodeent['IP'] in allowed_nodes:
                        allowed.append(nodeent)
                        pass
                    pass
                else:
                    allowed.append(nodeent)
                    pass
                pass
            if verbose:
                print "Advertisements in allowed nodes list:\n%s" % allowed
                pass
            avail = allowed
            pass

        # Check for duplicate node attributes (sanity check)
        availdups = self.__findDuplicateAttrs(avail)
        if len(availdups):
            SENDMAIL(TBOPS, "Duplicates in plab advertised node list",
                     "Duplicate attributes:\n"
                     "%s\n\n"
                     "Let plab support know!" % availdups,
                     TBOPS)
            raise RuntimeError, \
                  "Duplicate attributes in plab node listing:\n%s" % availdups

        # Get node info we already have.
        known = self.__getKnownPnodes()
        if debug:
            print "Got known pnodes:"
            print known
            pass

        # Create list of nodes to add or update
        toadd    = []  # List of node entries to add to DB
        toupdate = []  # List of node entries to update in the DB
        for nodeent in avail:
            # Replace sequences of bad chars in the site entity with
            # a single "-".
            nodeent['SITE'] = BADSITECHARS.sub("-", nodeent['SITE'])
            # Determine if we already know about this node.
            matchres = self.__matchPlabNode(nodeent, known)
            if not matchres:
                toadd.append(nodeent)
                pass
            elif len(matchres[1]):
                toupdate.append((nodeent,matchres))
                pass
            pass

        # Process the list of nodes to add
        addstr = ""
        if len(toadd):
            # Are we ignoring new entries?
            if ignorenew:
                if verbose:
                    print "%d new Plab nodes, but ignored for now" % len(toadd)
                    pass
                pass
            # If not ignoring, do the addition/update.
            else:
                print "There are %d new Plab nodes." % len(toadd)
                for nodeent in toadd:
                    # Get the linktype here so we can report it in email.
                    self.__findLinkType(nodeent)
                    if debug:
                        print "Found linktype %s for node %s" % \
                              (nodeent['LINKTYPE'], nodeent['IP'])
                        pass
                    # Add the node.
                    self.__addNode(nodeent)
                    # Add a line for the add/update message.
                    nodestr = "%s\t\t%s\t\t%s\t\t%s\t\t%s\n" % \
                              (nodeent['PLABID'],
                               nodeent['IP'],
                               nodeent['HNAME'],
                               nodeent['SITE'],
                               nodeent['LINKTYPE'])
                    addstr += nodestr
                    pass
                pass
            pass

        # Process node updates.
        updstr = ""
        chgerrstr = ""
        if len(toupdate):
            print "There are %d plab node updates." % len(toupdate)
            for (nodeent,(nodeid,diffattrs)) in toupdate:
                try:
                    self.__updateNodeMapping(nodeid, diffattrs)
                    pass
                except MultiChangeError, e:
                    print "%s not updated: Too many attribute changes." % \
                          e.nodeid
                    chgerrstr += "%s:\n" % e.nodeid
                    for (attr,(old,new)) in e.chattrs.items():
                        chgerrstr += "\t%s:\t%s => %s\n" % (attr,old,new)
                        pass
                    chgerrstr += "\n"
                    continue
                self.__updateNode(nodeid, nodeent)
                # Add a line for the add/update message.
                nodestr = nodeid + "\n"
                for (attr,(old,new)) in diffattrs.items():
                    nodestr += "\t%s:\t%s => %s\n" % (attr,old,new)
                    pass
                updstr += nodestr + "\n"
                pass
            pass

        # Do node features updates separately since very few nodes are usually
        # updated, whereas we must do status separately from other fields.
        # XXX: munge this in with other fields later.
        upfeatures = []
        for nodeent in avail:
            # Determine if we already know about this node.
            try:
                matchres = self.__matchPlabNode(nodeent, known)
                if matchres:
                    upfeatures.append((nodeent,matchres))
                    pass
                pass
            except:
                pass
            pass
        
        for (nodeent,(nodeid,other)) in upfeatures:
            self.__updateNodeFeatures(nodeid,nodeent)
            pass
        
        if chgerrstr:
            SENDMAIL(TBOPS,
                     "Two or more changes detected for some plab nodes",
                     "Two or more distinguishing attributes have changed "
                     "on the following planetlab nodes:\n\n%s\n" % chgerrstr,
                     TBOPS)
            pass

        if len(toadd) or len(toupdate):
            # We need to update DNS since we've added hosts..
            print "Forcing a named map update ..."
            os.spawnl(os.P_WAIT, NAMED_SETUP, NAMED_SETUP)
            print "Pushing out site_mapping ..."
            os.spawnl(os.P_WAIT, PELAB_PUSH, PELAB_PUSH)
            # Now announce that we've added/updated nodes.
            SENDMAIL(TBOPS,
                     "Plab nodes have been added/updated in the DB.",
                     "The following plab nodes have been added to the DB:\n"
                     "PlabID\t\tIP\t\tHostname\t\tSite\t\tLinktype\n\n"
                     "%s\n\n"
                     "The following plab nodes have been updated in the DB:\n"
                     "\n%s\n\n" % \
                     (addstr, updstr),
                     TBOPS)
            print "Done adding new Plab nodes."
            pass
        return

    def __matchPlabNode(self, plabent, knownents):
        """
        Helper function.  Returns a two-element tuple or null.
        Null is returned when the node does not match any in the
        knownents list (none of it's attributes match those of any
        in the list).  If a match (or partial match) is found, a two
        element tuple is returned.  The first element is the emulab
        node id that matched, and the second is a dictionary containing
        thos elements that differed between the two (in the case of a
        partial match).
        """
        for nid in knownents:
            ent = knownents[nid]
            same = {}
            diff = {}
            for attr in ent:
                if ent[attr] in ATTR_NIL_VALUES:
                    continue
                elif (attr == "LATITUDE") or (attr == "LONGITUDE"):
                    # Special rules for latitude and longitude to avoid
                    # FP errors
                    nasty = False
                    try:
                        x = float(ent[attr])
                        x = float(plabent[attr])
                        pass
                    except:
                        nasty = True
                        pass
                    if (not nasty and ent[attr] != None and plabent[attr] != None) \
                           and (ent[attr] != "" and plabent[attr] != "") \
                           and ((float(ent[attr]) > \
                                 (float(plabent[attr]) + LATLONG_DELTA)) \
                                or (float(ent[attr]) < \
                                    (float(plabent[attr]) - LATLONG_DELTA))):
                        diff[attr] = (ent[attr], plabent[attr])
                    else:
                        same[attr] = ent[attr]
                        pass
                elif ent[attr] == plabent[attr]:
                    same[attr] = ent[attr]
                    pass
                else:
                    diff[attr] = (ent[attr], plabent[attr])
                    pass
                pass
            # Only consider these to be the same if at least one 'critical'
            # attr is the same
            if len(same):
                for attr in same:
                    if attr in ATTR_CRIT_KEYS:
                        return (nid, diff)
            pass
        return ()

    def __getKnownPnodes(self):
        """
        getFree helper function.  Returns a dict of IP:node_id pairs
        for the Plab nodes that currently exist in the DB.
        """
        res = DBQueryFatal("select plab_mapping.node_id,plab_id,"
                           "plab_mapping.hostname,IP,mac,site,latitude,"
                           "longitude,bwlimit"
                           " from plab_mapping"
                           " left join widearea_nodeinfo on"
                           "    plab_mapping.node_id = "
                           "    widearea_nodeinfo.node_id")
        
        ret = {}
        for (nodeid, plabid, hostname, ip, mac, site,
             latitude, longitude, bwlimit) in res:
            ret[nodeid] = {'PLABID'    : plabid,
                           'HNAME'     : hostname,
                           'IP'        : ip,
                           'MAC'       : mac,
                           'SITE'      : site,
                           'LATITUDE'  : latitude,
                           'LONGITUDE' : longitude,
                           'BWLIMIT'   : bwlimit}
            pass
        # Check for duplicate node attributes: report any that are found.
        dups = self.__findDuplicateAttrs(ret.values())
        if len(dups):
            SENDMAIL(TBOPS, "Duplicate plab node attributes in the DB!",
                     "Duplicate node attrs:\n"
                     "%s\n\n"
                     "Fix up please!" % dups,
                     TBOPS)
            raise RuntimeError, \
                  "Duplicate node attributes in DB:\n%s" % dups            
        return ret

    def __findDuplicateAttrs(self, nodelist):
        """
        Find duplicate node attributes in the node list passed in.
        """
        attrs = {}
        dups = {}
        
        for ent in nodelist:
            for attr in ATTR_CRIT_KEYS:
                entry = "%s:%s" % (attr, ent[attr])
                if attrs.has_key(entry) and \
                   ent[attr] not in ATTR_NIL_VALUES:
                    print "Duplicate node attribute: %s" % entry
                    if not dups.has_key(entry):
                        dups[entry] = [attrs[entry],]
                        pass
                    dups[entry].append(ent['PLABID'])
                else:
                    attrs[entry] = ent['PLABID']
                    pass
                pass
            pass
        return dups
        
    def __findLinkType(self, nodeent):
        """
        getFree helper function.  Figures out the link type of the given
        host.  This first performs a traceroute and checks for the U of
        U's I2 gateway to classify Internet2 hosts.  If this test fails,
        it checks if the hostname is international.  If this test fails,
        this simply specifies an inet link type.

        This can't detect DSL links..
        """
        # Is host international (or flux/emulab local)?
        from socket import gethostbyaddr, getfqdn, herror
        
        if not nodeent.has_key('HNAME'):
            try:
                (hname, ) = gethostbyaddr(ip)
                nodeent['HNAME'] = getfqdn(hname)
                pass
            except herror:
                nodeent['HNAME'] = nodeent['IP']
                print "Warning: Failed to get hostname for %s" % nodeent['IP']
                pass
            pass
        
        tld = nodeent['HNAME'].split(".")[-1].lower()
        if not tld in ("edu", "org", "net", "com", "gov", "us", "ca"):
            nodeent['LINKTYPE'] = "pcplabintl"
            return
        
        # Is it us?
        if nodeent['HNAME'].endswith(LOCAL_PLAB_DOMAIN):
            nodeent['LINKTYPE'] = LOCAL_PLAB_LINKTYPE
            return
        
        # Is host on I2?
        traceroute = os.popen("traceroute -nm 10 -q 1 %s" % nodeent['IP'])
        trace = traceroute.read()
        traceroute.close()

        for gw in MAGIC_INET2_GATEWAYS:
            if trace.find(gw) != -1:
                nodeent['LINKTYPE'] = "pcplabinet2"
                return

        for gw in MAGIC_INET_GATEWAYS:
            if trace.find(gw) != -1:
                nodeent['LINKTYPE'] = "pcplabinet"
                return
        else:
            print "Warning: Unknown gateway for host %s" % nodeent['IP']

        # We don't know - must manually classify.
        nodeent['LINKTYPE'] = "*Unknown*"
        return

    def __addNode(self, nodeent):
        """
        updateNodeEntries() helper function.  Adds a new Plab pnode and
        associated vnode to the DB.  The argument is a dictionary containing
        the new node's attributes.
        """
        # Generate/grab variables to be used when creating the node.
        defosid, controliface = self.__getNodetypeInfo()
        hostonly = nodeent['HNAME'].replace(".", "-")
        nidnum, priority = self.__nextFreeNodeid()
        nodeid = "%s%d" % (NODEPREFIX, nidnum)
        vnodeprefix = "%svm%d" % (NODEPREFIX, nidnum)
        print "Creating pnode %s as %s, priority %d." % \
              (nodeent['IP'], nodeid, priority)

        # Do the stuff common to both node addition and update first
        # Note that if this fails, we want the exception generated to
        # percolate up to the caller immediately, so don't catch it.
        self.__updateNode(nodeid, nodeent)

        # Now perform stuff specific to node addition
        try:
            res_exptidx = TBExptIDX(RESERVED_PID, RESERVED_EID)
            mon_exptidx = TBExptIDX(MONITOR_PID, MONITOR_EID)
            
            DBQueryFatal("replace into nodes"
                         " (node_id, type, phys_nodeid, role, priority,"
                         "  op_mode, def_boot_osid,"
                         "  allocstate, allocstate_timestamp,"
                         "  eventstate, state_timestamp, inception)"
                         " values (%s, %s, %s, %s, %s,"
                         "  %s, %s, %s, now(), %s, now(), now())",
                         (nodeid, 'pcplabphys', nodeid,
                          'testnode', priority*100,
                          'ALWAYSUP', defosid,
                          'FREE_CLEAN',
                          'ISUP'))

            DBQueryFatal("replace into node_hostkeys"
                         " (node_id)"
                         " values (%s)",
                         (nodeid))

            DBQueryFatal("replace into node_utilization"
                         " (node_id)"
                         " values (%s)",
                         (nodeid))

            DBQueryFatal("replace into reserved"
                         " (node_id, exptidx, pid, eid, rsrv_time, vname)"
                         " values (%s, %s, %s, %s, now(), %s)",
                         (nodeid, res_exptidx,
                          RESERVED_PID, RESERVED_EID, hostonly))

            # XXX: This should probably be checked and updated if necessary
            #      when updating.
            DBQueryFatal("replace into node_auxtypes"
                         " (node_id, type, count)"
                         " values (%s, %s, %s)",
                         (nodeid, nodeent['LINKTYPE'], 1))
            
            DBQueryFatal("replace into node_auxtypes"
                         " (node_id, type, count)"
                         " values (%s, %s, %s)",
                         (nodeid, 'pcplab', 1))
            
            DBQueryFatal("replace into node_status"
                         " (node_id, status, status_timestamp)"
                         " values (%s, %s, now())",
                         (nodeid, 'down'))

            DBQueryFatal("insert into plab_mapping"
                         " (node_id, plab_id, hostname, IP, mac, create_time)"
                         " values (%s, %s, %s, %s, %s, now())",
                         (nodeid, nodeent['PLABID'], nodeent['HNAME'],
                          nodeent['IP'], nodeent['MAC']))

            #
            # NowAdd the site_mapping entry for this node.
            #
            
            # See if we know about the associated site - grab idx if so
            siteidx = 0
            nodeidx = 1
            siteres = DBQueryFatal("select site_idx, node_idx from "
                                   " plab_site_mapping where site_name=%s",
                                   nodeent['SITE']);
            if len(siteres):
                # There are already nodes listed for this site, so get
                # the next node id.
                siteidx = siteres[0][0]
                for (foo, idx) in siteres:
                    if idx > nodeidx: nodeidx = idx
                    pass
                nodeidx += 1
                pass
            else:
                # No nodes listed for site, so get the largest site_idx
                # in the DB so far, and increment cuz we're going to add
                # a new one.
                maxres = DBQueryFatal("select MAX(site_idx) from "
                                      " plab_site_mapping")
                try:
                    siteidx = int(maxres[0][0]) + 1
                    pass
                except ValueError:
                    siteidx = 1
                    pass
                pass
            # Create site_mapping entry, optionally creating new site idx
            # via not specifying the site_idx field (field is auto_increment)
            DBQueryFatal("insert into plab_site_mapping "
                         " values (%s, %s, %s, %s)",
                         (nodeent['SITE'], siteidx, nodeid, nodeidx))

            # Create a single reserved plab vnode for the managment sliver.
            n = 1
            vprio = (priority * 100) + n
            sshdport = 38000 + n
            vnodeid = "%s-%d" % (vnodeprefix, n)
            vnodetype = "pcplab"
            if verbose:
                print "Creating vnode %s, priority %d" % (vnodeid, vprio)
                pass
                    
            DBQueryFatal("insert into nodes"
                         " (node_id, type, phys_nodeid, role, priority,"
                         "  op_mode, def_boot_osid, update_accounts,"
                         "  allocstate, allocstate_timestamp,"
                         "  eventstate, state_timestamp, sshdport)"
                         " values (%s, %s, %s, %s, %s,"
                         "  %s, %s, %s, %s, now(), %s, now(), %s)",
                         (vnodeid, vnodetype, nodeid, 'virtnode', vprio,
                          'PCVM', defosid, 1,
                          'FREE_CLEAN',
                          'SHUTDOWN', sshdport))

            DBQueryFatal("insert into node_hostkeys"
                         " (node_id)"
                         " values (%s)",
                         (vnodeid))
            
            DBQueryFatal("insert into node_status"
                         " (node_id, status, status_timestamp)"
                         " values (%s, %s, now())",
                         (vnodeid, 'up'))
            
            # Put the last vnode created into the special monitoring expt.
            DBQueryFatal("insert into reserved"
                         " (node_id, exptidx, pid, eid, rsrv_time, vname)"
                         " values (%s, %s, %s, %s, now(), %s)",
                         (vnodeid, mon_exptidx,
                          MONITOR_PID, MONITOR_EID, vnodeid))
            pass
        
        except:
            print "Error adding PLAB node to DB: someone needs to clean up!"
            tbmsg = "".join(traceback.format_exception(*sys.exc_info()))
            SENDMAIL(TBOPS, "Error adding new plab node to DB: %s\n" %
                     nodeid, "Some operation failed while trying to add a"
                     " newly discovered plab node to the DB:\n %s"
                     "\n Please clean up!\n" % tbmsg, TBOPS)
            raise
        return

    def __updateNodeFeatures(self,nodeid,nodeent):
        """
        Record the status of this node in the node_features
        table.
        """
        # XXX Make this atomic
        #
        try:
            # Note that we have to pass '%' as an arg to DBQuery, sigh
            DBQueryFatal("delete from node_features where node_id=%s" \
                         " and feature like %s",
                         (nodeid,'plabstatus-%'))
            
            if nodeent.has_key('STATUS'):
                # Kind of a hack - we assume most people will want Production
                # nodes
                if nodeent['STATUS'] == "Production" :
                    weight = 0.0
                    pass
                else:
                    weight = 1.0
                    pass
                DBQueryFatal("insert into node_features" \
                             " (node_id, feature, weight)" \
                             " values (%s,%s,%s)",
                             (nodeid,
                              'plabstatus-%s' % nodeent['STATUS'],
                              weight))
                pass
            pass
        except:
            print "Error updating plab node STATUS feature " \
                  "for node %s!" % nodeid
            traceback.print_exc()
            
        
        return None
    
    def __updateNode(self, nodeid, nodeent):
        """
        updateNodeEntries() helper function.  Updates attributes for plab
        nodes passed in via the nodeent argument.
        """
        # Get the name of the control interface for plab nodes.
        defosid, controliface = self.__getNodetypeInfo()

        haslatlong = (('LATITUDE' in nodeent and 'LONGITUDE' in nodeent) and
            (nodeent['LATITUDE'] != 0 or nodeent['LONGITUDE'] != 0))
        try:
            DBQueryFatal("replace into widearea_nodeinfo"
                         " (node_id, contact_uid, contact_idx, hostname, site,"
                         "  latitude, longitude, bwlimit)"
                         " values (%s, %s, %s, %s, %s, %s, %s, %s)",
                         (nodeid, 'nobody', '0', nodeent['HNAME'],
                          nodeent['SITE'],
                          # Poor man's ternary operator
                          haslatlong and nodeent['LATITUDE'] or "NULL",
                          haslatlong and nodeent['LONGITUDE'] or "NULL",
                          nodeent['BWLIMIT']))

            DBQueryFatal("replace into interfaces"
                         " (node_id, card, port, IP, interface_type,"
                         " iface, role)"
                         " values (%s, %s, %s, %s, %s, %s, %s)",
                         (nodeid, 0, 1, nodeent['IP'], 'plab_fake',
                          controliface, 'ctrl'))

            pass
        except:
            print "Error updating PLAB node in DB: someone needs to clean up!"
            tbmsg = "".join(traceback.format_exception(*sys.exc_info()))
            SENDMAIL(TBOPS, "Error updating plab node in DB: %s\n" % nodeid,
                     "Some operation failed while trying to update"
                     " plab node %s in the DB:\n\n%s"
                     "\nPlease clean up!\n" % (nodeid, tbmsg), TBOPS)
            raise
        return


    def __updateNodeMapping(self, nodeid, chattrs):
        """
        Updates changed node attributes in the plab mapping table.
        """
        uid = os.getuid()
        dbuid = uid == 0 and "root" or UNIX2DBUID(uid)

        # mapping from attrs to column names
        attrmap = {'PLABID' : 'plab_id',
                   'HNAME'  : 'hostname',
                   'IP'     : 'IP',
                   'MAC'    : 'mac'}

        # Get the intersection of mapping (critical) keys with those that
        # have changed.
        changedcritkeys = set(ATTR_CRIT_KEYS) & set(chattrs.keys())
        # nothing to do if none of the mapping attributes have changed.
        if not changedcritkeys:
            return
        # If the node has more than two critical attrs that have changed,
        # then move it to hwdown and raise an exception.
        if len(changedcritkeys) > 2:
            crattrs = {}
            for chkey in changedcritkeys:
                crattrs[chkey] = chattrs[chkey]
                pass
            errmsg = "More than 2 plab node attrs have changed!\n\n%s\n\n" \
                     "%s has been moved to hwdown." % (crattrs, nodeid)
            MarkPhysNodeDown(nodeid)
            TBSetNodeLogEntry(nodeid, dbuid, TB_NODELOGTYPE_MISC, errmsg)
            raise MultiChangeError(nodeid, crattrs)

        # Update mapping table entry.
        updstr = ",".join(map(lambda x: "%s='%s'" %
                              (attrmap[x],chattrs[x][1]), changedcritkeys))
        DBQueryFatal("update plab_mapping set %s where node_id='%s'" %
                     (updstr, nodeid))
        updmsg = "Plab node %s attributes updated:\n\n%s" % (nodeid, chattrs)
        TBSetNodeLogEntry(nodeid, dbuid, TB_NODELOGTYPE_MISC, updmsg)

        # updateNodeEtries() already sends mail.
        #SENDMAIL(TBOPS,
        #         "Plab node %s attributes updated." % nodeid, updmsg, TBOPS)
        return

    def __getNodetypeInfo(self):
        """
        addNode helper function.  Returns a (defosid, controliface) 
        tuple for the Plab pnode type.  Caches the result since
        it doesn't change.
        """
        if not hasattr(self, "__getNodetypeInfoCache"):
            if debug:
                print "Getting node type info"
                pass

            dbres = DBQueryFatal("select attrkey,attrvalue "
                                 " from node_type_attributes as a "
                                 " where type = 'pcplabphys' and "
                                 "       (a.attrkey='default_osid' or "
                                 "        a.attrkey='control_interface') "
                                 " order by attrkey")
            
            assert (len(dbres) == 2), "Failed to get node type info"
            attrdict = {}
            for attrkey, attrvalue in dbres:
                attrdict[attrkey] = attrvalue;
                pass
            self.__getNodetypeInfoCache = \
                                        (attrdict["default_osid"],
                                         attrdict["control_interface"])
            pass
        
        return self.__getNodetypeInfoCache

    def __nextFreeNodeid(self):
        """
        addNode helper function.  Returns a (nodeid, priority) tuple of
        the next free nodeid and priority for Plab nodes.
        """
        if debug:
            print "Getting next free nodeid"
        DBQueryFatal("lock tables nextfreenode write")
        try:
            res = DBQueryFatal("select nextid, nextpri from nextfreenode"
                               " where nodetype = 'pcplab'")
            assert (len(res) == 1), "Unable to find next free nodeid"
            DBQueryFatal("update nextfreenode"
                         " set nextid = nextid + 1, nextpri = nextpri + 1"
                         " where nodetype = 'pcplab'")
            ((nodeid, priority), ) = res
            pass
        finally:
            DBQueryFatal("unlock tables")
            pass
        
        return nodeid, priority

    def __readNodeFile(self, filename):
        """
        Helper function - read in list of nodes from a file, seperated
        by arbitrary amounts of whitespace.  No comments allowed.
        """
        nodelist = []
        if os.access(filename, os.F_OK):
            nodefile = open(filename, "r+")
            nodelist = nodefile.read().split()
            nodefile.close()
            pass
        return nodelist

    def renew(self, inpid = None, ineid = None, force = False):
        """
        Renews all of the Plab leases regardless of when they expire.  Note
        that all times are handled in the UTC time zone.  We don't trust
        MySQL to do the right thing with times (yet).
        """

        global failedrenew # XXX
        
        now = int(time.time())
        
        if not inpid:
            res = DBQueryFatal("select pid, eid from plab_slices");
            pass
        else:
            if not ineid:
                raise RuntimeError, "renew: Must provide eid with pid."
            res = ((inpid, ineid),)
            pass
        
        loadedSlices = {}
        newfail = []
        failsoon = []
        ret = 0

        print "Renewing Plab leases at %s ..." % time.ctime()

        for (pid, eid) in res:

            try:
                slice = loadedSlices[(pid, eid)]
                pass
            except KeyError:
                slice = self.loadSlice(pid, eid)
                loadedSlices[(pid, eid)] = slice
                pass
            
            res = slice.renew(force)
            entry = (pid, eid, slice.leaseend)
            
            if not res:
                print "Failed to renew lease for %s/%s" % \
                      entry[:2]
                if entry not in failedrenew:
                    newfail.append(entry)
                    pass
                if (slice.leaseend - now) < PLABEXPIREWARN:
                    failsoon.append(entry)
                    pass
                pass
            else:
                if entry in failedrenew:
                    failedrenew.remove(entry)
                    pass
                    
        if newfail:
            failedrenew += newfail
            failstr = ""
            for n in newfail:
                failstr += "%s/%s (expires: %s UTC)\n" % \
                           (n[:2] + (time.asctime(time.gmtime(n[2])),))
                pass
            
            SENDMAIL(TBOPS, "Lease renewal(s) failed",
                     "Failed to renew the following leases:\n%s" %
                     failstr + "\n\nPlease check the plabrenew log", TBOPS)
            pass

        if failsoon:
            failstr = ""
            for n in failsoon:
                failstr += "%s/%s: (expires: %s UTC)\n" % \
                           (n[:2] + (time.asctime(time.gmtime(n[2])),))
                pass
            SENDMAIL(TBOPS, "Warning: PLAB leases have expired, or will soon",
                     "The following plab leases have expired, or will soon:\n"
                     + failstr + "\n\nPlease look into it!", TBOPS)
            pass

        return
    
    pass # end class Plab
# AOP wrappers for class Plab
wrap_around(Plab.createSlice, timeAdvice)

#
# Slice abstraction
#
class Slice:

    def __init__(self, plab, pid, eid, slicename = None):
        self.plab = plab
        self.pid, self.eid = pid, eid
        self.slicemeta = None
        self.slicemeta_legacy = None
        self.exptidx = None
        self.slicename = slicename
        self.description = DEF_SLICE_DESC
        return
    
    def _create(self):
        """
        Creates a new slice that initially contains no nodes.  Don't call
        this directly, use Plab.createSlice instead.
        """

        adminbit = 0
        if self.pid == PLABMON_PID and self.eid == PLABMON_EID:
            self.slicename   = PLAB_SVC_SLICENAME
            self.description = PLAB_SVC_SLICEDESC
            adminbit = 1
            pass

        res = DBQueryFatal("select idx, expt_name from experiments "
                           "where pid=%s "
                           "and eid=%s",
                           (self.pid, self.eid))
        if not len(res):
            raise RuntimeError, \
                  "Didn't get any results while looking up info on " \
                  "experiment %s/%s" % (self.pid, self.eid)
        (eindex, descr) = res[0]
        
        if not self.slicename:
            self.slicename = "%s_%s" % (SLICEPREFIX, eindex)
            pass

        self.description = descr
        self.exptidx = eindex

        print "Creating Plab slice %s." % self.slicename

        try:
            res, tmpslicemeta, self.leaseend = \
                 self.plab.agent.createSlice(self)
            
            # Do compat calls right after main agent calls.
            if compat_mode:
                try:
                    self.plab.compat_agent.createSlice(self)
                except:
                    print "Warning: compat agent failed in createSlice; " \
                          "\n  watch for inconsistent DB state!"
                    pass
                pass

            # see if we have two tickets to insert (support the legacy ticket
            # or not)
            if type(tmpslicemeta) == tuple:
                self.slicemeta = tmpslicemeta[0]
                self.slicemeta_legacy = tmpslicemeta[1]
                insertFieldsStr = "(exptidx,pid,eid,slicename,slicemeta," \
                                  "slicemeta_legacy,leaseend,admin)"
                insertValuesStr = "(%s,%s,%s,%s,%s,%s,%s,%s)"
                insertValuesTuple = (self.exptidx,self.pid,self.eid,
                                     self.slicename,
                                     self.slicemeta,self.slicemeta_legacy,
                                     time.strftime("%Y-%m-%d %H:%M:%S",
                                                   time.gmtime(self.leaseend)),
                                     adminbit)
                pass
            else:
                self.slicemeta = tmpslicemeta
                insertFieldsStr = "(exptidx,pid,eid,slicename,slicemeta," \
                                  "leaseend,admin)"
                insertValuesStr = "(%s, %s, %s, %s, %s, %s, %s)"
                insertValuesTuple = (self.exptidx,self.pid,self.eid,
                                     self.slicename,self.slicemeta,
                                     time.strftime("%Y-%m-%d %H:%M:%S",
                                                   time.gmtime(self.leaseend)),
                                     adminbit)
                pass

            qstr = "insert into plab_slices " + insertFieldsStr + \
                   " values " + insertValuesStr
            
            DBQueryFatal(qstr,insertValuesTuple)
            pass
        except:
            self.plab.agent.deleteSlice(self)
            
            if compat_mode:
                try:
                    self.plab.compat_agent.deleteSlice(self)
                except:
                    print "Warning: compat agent failed in deleteSlice; " \
                          "\n  watch for inconsistent DB state!"
                    pass
                pass

            DBQueryFatal("delete from plab_slices where slicename=%s",
                         (self.slicename,))
            raise

        # Setup mailing alias for the slice.  All mail currently filters
        # in via the 'emulabman' alias.  A procmail filter there will
        # redirect it to the appropriate user.
        try:
            qres = DBQueryFatal("select u.uid, u.usr_email from users as u "
                                "left join experiments as e "
                                "on u.uid_idx = e.swapper_idx "
                                "where e.pid=%s and e.eid=%s",
                                (self.pid, self.eid))
            if not len(qres):
                raise RuntimeError, \
                      "Didn't get any results while looking up user info " \
                      "for experiment %s/%s" % (self.pid, self.eid)
            (username, usremail) = qres[0]
            command = "%s -host %s /bin/echo %s \> %s/%s" % \
                      (SSH, USERNODE, usremail,
                       SLICE_ALIAS_DIR, self.slicename)
            os.system(command)
        except:
            print "Could not setup email alias for slice: %s!" % self.slicename
            traceback.print_exc()
            pass

        return res

    def _load(self):
        """
        Loads an already allocated slice from the DB.  Don't call this
        directly, use Plab.loadSlice instead.

        XXX This should probably be made lazy, since not all operations
        really need it
        """
        if verbose:
            print "Loading slice for pid/eid %s/%s" % (self.pid, self.eid)
            pass

        # grab our exptidx
        res = DBQueryFatal("select idx, expt_name from experiments "
                           "where pid=%s "
                           "and eid=%s",
                           (self.pid, self.eid))
        if not len(res):
            raise RuntimeError, \
                  "Didn't get any results while looking up info on " \
                  "experiment %s/%s" % (self.pid, self.eid)
        (eindex, descr) = res[0]
        
        if not self.slicename:
            self.slicename = "%s_%s" % (SLICEPREFIX, eindex)
            pass
        
        self.description = descr
        self.exptidx = eindex
            
        res = DBQueryFatal("select slicename, slicemeta, "
                           "  slicemeta_legacy, leaseend "
                           " from plab_slices "
                           " where pid = %s and eid = %s",
                           (self.pid, self.eid))
        assert (len(res) > 0), \
               "No slice found for %s-%s" % (self.pid, self.eid)
        assert (len(res) == 1), \
               "Multiple slices found for %s-%s" % (self.pid, self.eid)
        ((self.slicename,self.slicemeta,self.slicemeta_legacy,leaseend),) = res
        self.leaseend = calendar.timegm(time.strptime(str(leaseend),
                                                      "%Y-%m-%d %H:%M:%S"))
        return

    def renew(self, force = False):
        """
        Renews slice lease.  We want this to be the maximum allowed by law...
        Store the expiration time in UTC.
        """
        print "Renewing lease for slice %s" % self.slicename

        try:
            ret = self.plab.agent.renewSlice(self, force)

            if compat_mode:
                try:
                    self.plab.compat_agent.renewSlice(self)
                except:
                    print "Warning: compat agent failed in renewSlice; " \
                          "\n  watch for inconsistent DB state!"
                    pass
                pass
            
            DBQueryFatal("update plab_slices "
                         " set slicemeta=%s, leaseend=%s, slicemeta_legacy=%s "
                         " where slicename=%s",
                         (self.slicemeta,
                          time.strftime("%Y-%m-%d %H:%M:%S",
                                        time.gmtime(self.leaseend)),
                          self.slicemeta_legacy,
                          self.slicename))
            pass
        except:
            print "slice.renew: Slice renewal failed:"
            traceback.print_exc()
            ret = 0
            pass

        # Renew individual slivers, if necessary.  Any that fail to renew
        # and are close to expiration need to be noted.  They will be
        # reported after renewal has been attempted on all nodes.
        now = int(time.time())
        nodes = map(lambda x: x[0], self.getSliceNodes())
        reportfailed = []
        for nodeid in nodes:
            try:
                node = self.loadNode(nodeid)
                pass
            except AssertionError:
                print "Node %s doesn't really exist in %s" % \
                      (nodeid, self.slicename)
                continue
            if node.renew():
                print "Failed to renew node: %s (expires %s UTC)" % \
                      (nodeid, time.asctime(time.gmtime(node.leaseend)))
                print "Timediff: %s" % (node.leaseend - now)
                if node.leaseend - now < NODEEXPIREWARN:
                    reportfailed.append((nodeid, node.leaseend))
                    pass
                pass
            del node
            pass

        # Report any nodes that are near to expiration
        if len(reportfailed) > 0:
            tbstr = ""
            for nodeid, leaseend in reportfailed:
                tbstr += "Node: %s, Leaseend: %s UTC\n" % \
                         (nodeid, time.asctime(time.gmtime(leaseend)))
                pass
            SENDMAIL(TBOPS, "Plab nodes in danger of expiration: %s/%s" % \
                     (self.pid, self.eid),
                     "The following slivers in %s/%s will expire "
                     "soon:\n\n%s" % \
                     (self.pid, self.eid, tbstr),
                     TBOPS)
        
        return ret

    def destroy(self):
        """
        Frees all nodes in this slice and destroys the slice.  Note
        that this will really pound the DB if there are many nodes left
        in the slice, but those should be removed by Emulab before the
        slice is destroyed.
        """
        print "Destroying Plab slice %s." % self.slicename
        res = DBQueryFatal("select node_id from plab_slice_nodes"
                           " where slicename = %s",
                           (self.slicename))
        print "\tRemoving any remaining nodes in slice.."
        for (nodeid,) in res:
            node = self.loadNode(nodeid)
            node.free()
            del node  # Encourage the GC'er

        osigs = disable_sigs(TERMSIGS)

        try:
            self.plab.agent.deleteSlice(self)
            pass
        except:
            print "Failed to delete slice!"
            traceback.print_exc()
            pass

        if compat_mode:
            try:
                self.plab.compat_agent.deleteSlice(self)
            except:
                print "Warning: compat agent failed in deleteSlice; " \
                      "\n  watch for inconsistent DB state!"
                pass
            pass
        
        try:
            print "\tRemoving slice DB entry."
            DBQueryFatal("delete from plab_slices where slicename = %s",
                         (self.slicename,))
        except:
            print "Error deleting slice from DB!"
            tbstr = "".join(traceback.format_exception(*sys.exc_info()))
            SENDMAIL(TBOPS, "Error deleting slice from DB",
                     "Slice deletion error:\n\n%s" % tbstr, TBOPS)
            enable_sigs(osigs)
            raise

        try:
            command = "%s -host %s /bin/rm -f %s/%s" % \
                      (SSH, USERNODE, SLICE_ALIAS_DIR, self.slicename)
            os.system(command)
        except:
            print "Could not remove email alias for slice: %s!" % \
                  self.slicename
            traceback.print_exc()
            pass
            
        
        enable_sigs(osigs)

    def createNode(self, nodeid, force=False):
        """
        Node factory function
        """
        # XXX: KRW - The following is a hack to help me with testing.
        if not nodeid.startswith("plab"):
            IP = socket.gethostbyname(nodeid)
            qres = DBQueryFatal("select n.node_id from nodes as n left join "
                                "interfaces as i on n.node_id = i.node_id "
                                "where i.IP = %s", (IP,))
            assert (len(qres) > 0), "Node does not exist in DB: %s" % nodeid
            nodeid = qres[0][0] + "-20"
        node = Node(self, nodeid)
        node._create(force)
        return node

    def loadNode(self, nodeid):
        """
        Node factory function
        """
        node = Node(self, nodeid)
        node._load()
        return node

    def updateSliceMeta(self):
        """
        Grab current slice metadata from Planetlab and store in db
        """
        try:
            # Handle legacy tickets for compat purposes.
            self.slicemeta = self.plab.agent.getSliceMeta(self)
            self.slicemeta_legacy = self.plab.agent.getSliceMetaLegacy(self)
            DBQueryFatal("update plab_slices set "
                         "slicemeta=%s,slicemeta_legacy=%s where slicename=%s",
                         (self.slicemeta,self.slicemeta_legacy,self.slicename))
            pass
        except:
            print "Error updating slice metadata!"
            tbstr = "".join(traceback.format_exception(*sys.exc_info()))
            SENDMAIL(TBOPS, "Error updating slice metadata",
                     "Slice metadata update error:\n\n%s" % tbstr, TBOPS)
            raise

    def getSliceNodes(self):
        """
        Return a tuple containing the nodes that belong to this slice
        """
        # Grab set of plab nodes belonging to expt and their IPs:
        return DBQueryFatal("select r.node_id, i.IP, w.hostname "
                            " from reserved as r "
                            " left join nodes as n1 "
                            "  on r.node_id = n1.node_id "
                            " left join nodes as n2 "
                            "  on n1.phys_nodeid = n2.node_id "
                            " left join widearea_nodeinfo as w "
                            "  on n2.node_id = w.node_id "
                            " left join interfaces as i "
                            "  on w.node_id = i.node_id "
                            " where r.pid=%s and r.eid=%s "
                            " and n1.type=%s and i.role=%s",
                            (self.pid, self.eid, "pcplab", "ctrl"))
    pass  # end of class Slice
# AOP wrappers for class Slice
wrap_around(Slice._create, timeAdvice)
wrap_around(Slice.destroy, timeAdvice)

#
# Node abstraction
#
class Node:
    def __init__(self, slice, nodeid, pollNode = False):
        self.slice = slice
        self.nodeid = nodeid
        (self.IP,self.hostname,self.phys_nodeid) = self.__findHostInfo()
        self.leaseend = 0
        self.nodemeta = None
        self.pollNode = pollNode
        # must be set in mod_<PLCAGENT>.createNode if you want to use
        # multiple rootball and triggering support
        self.nmagent = None
        return

    def __logNodeHist(self,component,operation,status,msg):
        try:
            DBQueryFatal("insert into plab_nodehist values "
                         "(NULL,%s,%s,%s,%s,%s,%s,%s)",
                         (self.nodeid,self.phys_nodeid,
                          time.strftime("%Y-%m-%d %H:%M:%S",
                                        time.localtime(time.time())),
                          component,operation,status,str(msg)))
        except:
            # do nothing
            print "Warning: could not log (%s,%s,%s,%s) into plab_nodehist!" % \
                  (component,operation,status,msg)
            pass
        pass
    
    # XXX: may want to rethink signal handling here.
    def _create(self, force=False):
        """
        Creates a new node.  This physically allocates the node into the
        slice through the dslice agent and node manager.  Note that no
        node setup is performed.  Don't call this directly, use
        Slice.createNode instead.
        """
        
        # First, make sure there isn't already an entry in the DB
        try:
            self._load()
        except:
            pass
        else:
            if force:
                print "Node entry exists in DB, but creation forced anyway."
            else:
                raise RuntimeError, "Entry for plab node %s already exists " \
                      "in the DB" % self.nodeid
            pass

        print "Creating Plab node %s on %s." % (self.nodeid, self.IP)
        res = None
        try:
            res, self.nodemeta, self.leaseend = \
                 self.slice.plab.agent.createNode(self)
            self.__logNodeHist('node','create','success','')
        except:
            self.__logNodeHist('node','create','failure',
                               traceback.format_exception(*sys.exc_info()))
            raise
        
        DBQueryFatal("replace into plab_slice_nodes"
                     " (exptidx, pid, eid, slicename, node_id,"
                     " nodemeta, leaseend)"
                     " values (%s, %s, %s, %s, %s, %s, %s)",
                     (self.slice.exptidx, self.slice.pid, self.slice.eid,
                      self.slice.slicename, self.nodeid,
                      self.nodemeta,
                      time.strftime("%Y-%m-%d %H:%M:%S",
                                    time.gmtime(self.leaseend))))
        if self.pollNode:
            TIMESTAMP("Waiting for %s to respond" % self.nodeid)
            while True:
                try:
                    self.__perform("/bin/true")
                    pass
                except:
                    time.sleep(NODEPROBEINT)
                    pass
                else: break
                pass
            TIMESTAMP("Node %s ready." % self.nodeid)
            pass        

        TIMESTAMP("createnode finished on %s." % self.nodeid)
        return

    def _load(self):
        """
        Loads an already allocated node from the DB.  Don't call this
        directly, use Slice.loadNode instead.
        """
        if verbose:
            print "Loading node %s" % self.nodeid
        res = DBQueryFatal("select slicename, nodemeta, leaseend "
                           " from plab_slice_nodes where node_id = %s",
                           (self.nodeid))
        assert (len(res) > 0), \
               "Node %s (slice %s) not found" % \
               (self.nodeid, self.slice.slicename)
        assert (len(res) == 1), \
               "Multiple nodes found for nodeid %s" % self.nodeid
        ((slicename, self.nodemeta, leaseend), ) = res
        assert (slicename == self.slice.slicename), \
               "Node %s loaded by slice %s, but claims to be in slice %s" % \
               (self.nodeid, self.slice.slicename, slicename)
        if not leaseend:
            self.leaseend = 0
            pass
        else:
            self.leaseend = calendar.timegm(time.strptime(str(leaseend),
                                                          "%Y-%m-%d %H:%M:%S"))
            pass
        
        return

    def free(self):
        """
        Frees the node and kills the VM.  Note that this does not
        shutdown anything inside the vserver.  Warning: forks a process
        to carry out the actual work!
        """
        res = ForkCmd(self._free, timeout=FREE_TIMEOUT,
                      disable_sigs_parent=TERMSIGS,
                      disable_sigs_child=TERMSIGS)
        return res[0] | res[1]
        
    def _free(self):
        """
        Frees the node and kills the VM.  Note that this does not
        shutdown anything inside the vserver.  Don't call this directly;
        instead, use Node.free()
        """
        deleted = 0
        TIMESTAMP("freenode %s started." % self.nodeid)
        print "Freeing Plab node %s." % self.nodeid
        
        # Remove the DB entry first.
        try:
            DBQueryFatal("delete from plab_slice_nodes where node_id = %s",
                         (self.nodeid,))
        except:
            print "Uh oh, couldn't remove plab sliver record from the DB!"
            tbstr = "".join(traceback.format_exception(*sys.exc_info()))
            SENDMAIL(TBOPS, "Error: Couldn't remove plab vnode from DB",
                     "Unable to delete entry for sliver %s from the DB:"
                     "\n\n%s" % (self.nodeid, tbstr), TBOPS)
            pass

        deleted = 0
        try:
            deleted = self.slice.plab.agent.freeNode(self)
            # Uncomment to increase logging
            #self.__logNodeHist('node','free','success','')
        except:
            self.__logNodeHist('node','free','failure',
                               traceback.format_exception(*sys.exc_info()))
            raise
        
        TIMESTAMP("freenode %s finished." % self.nodeid)
        return not deleted

    def renew(self):
        """
        Renew the lease for this node.  Note that this method
        forks and runs another private method to actually do the
        work!
        """
        res = ForkCmd(self._renew, timeout = RENEW_TIMEOUT,
                      disable_sigs_parent = TERMSIGS)
        return res[0] | res[1]

    def _renew(self):
        res = None
        try:
            res, self.nodemeta, self.leaseend = \
                 self.slice.plab.agent.renewNode(self)
            self.__logNodeHist('node','renew','success','')
        except:
            self.__logNodeHist('node','renew','failure',
                               traceback.format_exception(*sys.exc_info()))
            raise
        
        DBQueryFatal("update plab_slice_nodes"
                     " set nodemeta = %s, leaseend = %s"
                     " where node_id = %s",
                     (self.nodemeta,
                      time.strftime("%Y-%m-%d %H:%M:%S",
                                    time.gmtime(self.leaseend)),
                      self.nodeid))
        TIMESTAMP("renewnode %s finished." % self.nodeid)
        return 0

    def emulabify(self, rootballpath = DEFAULT_DATA_PATH,
                  rootballname = DEF_ROOTBALL_NAME):
        """
        Performs the necessary steps to turn this node into an
        Emulab/Plab node.  Primarily, this unpacks the magic files on to
        the node.
        """
        # check to see if we should use a custom rootball
        rrootballname = rootballname
        try:
            if (not self.nmagent == None) \
                   and (not self.slice.plab.agent == None):
                tpc = self.slice.plab.agent.__class__
                tnc = self.nmagent.getAgentClass()
                if rootball_triggers.has_key(tpc) \
                       and rootball_triggers[tpc].has_key(tnc):
                    # found a valid prefix for the rootball; update the name
                    rrootballname = rootball_triggers[tpc][tnc] + rootballname
                    if debug:
                        print "Updated rootball name from %s to %s" \
                              % (rootballname,rrootballname)
                        pass
                    pass
                else:
                    if debug:
                        print "rbtriggers: %s; looking for %s/%s" \
                              % (str(rootball_triggers),str(tpc),str(tnc))
                        pass
                    pass
                pass
            else:
                if debug:
                    print "One of the agents was null!"
                    pass
                pass
            pass
        except:
            print "Warning: exception while trying to update rootball name"
            traceback.print_exc()
            pass
        
        TIMESTAMP("emulabify started on %s." % self.nodeid)
        print "Overlaying Emulab files on %s ..." % self.nodeid
        try:
            self.__copy(DEFAULT_DATA_PATH + "fixsudo.sh", "/tmp/fixsudo.sh",
                        tries=3,interval=5)
            self.__perform("-tt sh /tmp/fixsudo.sh", quiet = True,
                           tries=3,interval=5)
            pass
        except RuntimeError:
            print "fixsudo failed on %s; attempting to carry on anyway.." % \
                  self.nodeid
            pass
        try:
            self.addToGroup(self.slice.slicename, "root")
            pass
        except RuntimeError:
            print "Adding slice user to 'root' group on %s failed; " \
                  "attempting to carry on anyway." % self.nodeid
            pass
        try:
            self.unpackRootball(rootballpath, rrootballname)
            # Uncomment to increase logging
            #self.__logNodeHist('node','emulabify','success','')
        except:
            self.__logNodeHist('node','emulabify','failure',
                               traceback.format_exception(*sys.exc_info()))
            raise
        TIMESTAMP("emulabify finished on %s." % self.nodeid)

    def addToGroup(self, user, group):
        if verbose:
            print "Adding %s to group %s on node %s" % \
                  (user, group, self.nodeid)
        self.__perform("sudo /usr/sbin/usermod -G %s %s" % (group, user))

    def unpackRootball(self, rbpath, rbname, destpath = "/"):
        """
        Unpacks a locally stored gzip'd tarball to the specified path
        (default /) on the remote node.  Always done as remote root.
        """
        if verbose:
            print "Unpacking rootball %s to %s on %s" % \
                  (rbpath, destpath, self.nodeid)
        try:
            if debug:
                print "Trying to grab rootball through loopback service"
            self.__perform("sudo wget -q -nH -P /tmp " +
                           ROOTBALL_URL + rbname)
        except RuntimeError:
            print "Warning: couldn't get rootball via local service on %s: " \
                  "Falling back to remote transfer." % self.nodeid
            self.__copy(rbpath + rbname, "/tmp/" + rbname)
            pass
            
        self.__perform("sudo tar -jxf /tmp/" + rbname + " -C %s" % destpath,
                       quiet = True)
        return

    def __perform(self, command, quiet = False, tries=1, interval=5):
        """
        Executes the given command on the remote node via sshtb, run as
        the slice user.
        """
        if debug:
            print "Performing '%s' on %s" % (command, self.nodeid)
        command = "%s -host %s %s" % (SSH, self.nodeid, command)
        (success,rtries) = (False,tries)
        while not success and rtries > 0:
            rtries -= 1
            try:
                retval = self.__execute(command, quiet)
                success = True
            except:
                if rtries == 0:
                    raise
                else:
                    print "Warning: perform %s on %s failed, try %d of %d" \
                          % (command,self.nodeid,tries-rtries,tries)
                    try:
                        time.sleep(interval)
                    except:
                        pass
                    pass
                pass
            pass
        return retval
    
    def __copy(self, localfile, remotefile, tries=1, interval=5):
        """
        Copies a file from the local system to the remote node, doing so
        as the slice user.
        """
        if debug:
            print "Copying %s to %s on %s" % \
                  (localfile, remotefile, self.nodeid)
            pass
        (success,rtries) = (False,tries)
        while not success and rtries > 0:
            rtries -= 1
            try:
                # We're using rsync now.
                command = "rsync -e '%s -host' %s %s:%s" % \
                          (SSH, localfile, self.nodeid, remotefile)
                retval = self.__execute(command)
                success = True
            except:
                if rtries == 0:
                    raise
                else:
                    print "Warning: copy %s to %s on %s failed, try %d of %d" \
                          % (localfile,remotefile,self.nodeid,
                             tries-rtries,tries)
                    try:
                        time.sleep(interval)
                    except:
                        pass
                    pass
                pass
            pass
        return retval
    
    def __execute(self, command, quiet = False):
        """
        Executes the given command, optionally squelching the output.
        """
        # Split up the command into a list to exec (avoid
        # intermediate shell invocation).
        cmdlist = shlex.split(command)

        # Catch termination signals and kill child if we get one.
        def catchkill(signum, frame):
            if verbose:
                print "Received signal", signum, "while running command."
                pass
            e = OSError("Received signal %s" % signum)
            e.killed = 1
            raise e
        
        sig = {}
        sig["INT"]  = signal.signal(signal.SIGINT, catchkill)
        sig["TERM"] = signal.signal(signal.SIGTERM, catchkill)
        sig["HUP"]  = signal.signal(signal.SIGHUP, catchkill)

        # Now run the command, catching it's output and handling signals.
        cmdobj = Popen4(cmdlist)
        try:
            cmdout = cmdobj.fromchild.read()
            cmdstatus = cmdobj.wait()
            signal.signal(signal.SIGINT, sig["INT"])
            signal.signal(signal.SIGTERM, sig["TERM"])
            signal.signal(signal.SIGHUP, sig["HUP"])
            if (not quiet) and cmdout:
                print cmdout
                pass
            if cmdstatus:
                raise RuntimeError, "'%s' failed (excode: %s). output:\n%s" % \
                      (command, cmdstatus, cmdout)
            pass
        except OSError, e:
            if hasattr(e,"killed") and e.killed:
                print "Received kill while running: %s" % command
                try:
                    os.kill(cmdobj.pid, signal.SIGTERM)
                    cmdobj.wait()
                    pass
                except:
                    print "Got exception while trying to kill off child proc"
                    traceback.print_exc()
                    pass
                os._exit(256)
                pass
            else:
                print "Received unhandled OSError while running command"
                traceback.print_exc()
                signal.signal(signal.SIGINT, sig["INT"])
                signal.signal(signal.SIGTERM, sig["TERM"])
                signal.signal(signal.SIGHUP, sig["HUP"])
                raise e
            pass
        
        return

    def __findIP(self):
        """
        Figures out and returns the IP of the remote node.
        """
        res = DBQueryFatal("select i.IP from nodes as nv"
                           " left join interfaces as i on"
                           "  nv.phys_nodeid=i.node_id"
                           " where nv.node_id=%s"
                           " limit 1",
                           (self.nodeid))
        if (not res or len(res) == 0):
            # XXX: send email
            print "Warning: no IP found for nodeid %s" % self.nodeid
            IP = "0.0.0.0"
            pass
        else:
            ((IP, ), ) = res
            pass
        if debug:
            print "IP is %s for node %s" % (IP, self.nodeid)
        return IP

    def __findHostname(self):
        """
        Grabs the publicly-routable hostname of the remote node.
        """
        
        res = DBQueryFatal("select pm.hostname,i.IP from nodes as nv"
                           " left join interfaces as i"
                           "  on nv.phys_nodeid=i.node_id"
                           " left join plab_mapping as pm"
                           "  on i.IP=pm.IP"
                           " where nv.node_id='%s'" % (self.nodeid))
        if (not res or len(res) == 0):
            print "Warning: no hostname found for nodeid %s" % self.nodeid
            hostname = None
            pass
        else:
            ((hostname,IP),) = res
            pass
        if debug:
            print "hostname is %s for node %s" % (hostname,IP)
            pass
        
        return hostname

    #
    # Returns (IP,hostname,phys_nodeid).
    #
    def __findHostInfo(self):
        """
        Grabs the publicly-routable IP and hostname of the remote node,
        and also our phys_nodeid for it.
        """
        res = DBQueryFatal("select i.IP,pm.hostname,nv.phys_nodeid "
                           " from nodes as nv"
                           " left join interfaces as i"
                           "  on nv.phys_nodeid=i.node_id"
                           " left join plab_mapping as pm"
                           "  on i.IP=pm.IP"
                           " where nv.node_id='%s'" % (self.nodeid))
        if (not res or len(res) == 0):
            print "Warning: no hostinfo found for nodeid %s" % self.nodeid
            (IP,hostname,phys_nodeid) = (None,None,None)
            pass
        else:
            ((IP,hostname,phys_nodeid),) = res
            pass
        if debug:
            print "hostname is %s for node %s" % (hostname,IP)
            pass
        
        return (IP,hostname,phys_nodeid)
    
    pass  # end of class Node
# AOP wrappers for class Node
wrap_around(Node._create, timeAdvice)
wrap_around(Node.free, timeAdvice)
wrap_around(Node.emulabify, timeAdvice)
