#!/usr/bin/perl -wT
#
# EMULAB-COPYRIGHT
# Copyright (c) 2000-2007, 2010 University of Utah and the Flux Group.
# All rights reserved.
#
use strict;
use Getopt::Std;
use POSIX 'setsid';	 # For &daemonize
use POSIX ":sys_wait_h"; # For &WNOHANG
use Sys::Syslog;
use English;
use Socket;
use Errno;
use Cwd 'realpath';

#
# This also kills a running frisbee.
#
sub usage()
{
    print "Usage: $0 [-d] [-k] <imageid or path>\n";
    print "-k:	Kill running frisbee.\n";
    print "-d:	Print debugging output.\n";
    exit(1);
}
my $optlist  = "dk";
my $debug    = 0;
my $killmode = 0;

# Configure variables
my $TB		= "@prefix@";
my $TBOPS	= "@TBOPSEMAIL@";
my $BOSSNODE_IP = "@BOSSNODE_IP@";
my $BASEADDR    = "@FRISEBEEMCASTADDR@";
my $BASEPORT    = "@FRISEBEEMCASTPORT@";
my $ELABINELAB  = @ELABINELAB@;

#
# Untaint the path
# 
$ENV{'PATH'} = "/bin:/usr/bin";
delete @ENV{'IFS', 'CDPATH', 'ENV', 'BASH_ENV'};

#
# Turn off line buffering on output
#
$| = 1;

use lib "@prefix@/lib";
use libdb;
use libtestbed;
use libtblog;
use User;
use Image;

# Protos.
sub Refresh();
sub LockTables();
sub UnlockTables();
sub PickAddress();
sub SetAddress($);
sub SetPid($);
sub TestBusy();
sub KeepBusy();
sub ClearPid();
sub ClearEntry();
sub Fatal($);
sub debug($);

# Defines
my $FRISBEED	= "$TB/sbin/frisbeed";
my $LOGFILE	= "$TB/log/frisbeelauncher";
my $FRISBEEIMAGE= "$TB/sbin/frisbeeimage";
my $child_pid   = 0;
my $dlfilename  = 0;

my $STD_BW	= 72000000; 	# 71.6Mb/sec w/1000HZ kernel
my $USR_BW	= 54000000;	# 53.7Mb/sec w/1000HZ kernel

#
# Parse command arguments. Once we return from getopts, all that should be
# left are the required arguments.
#
my %options = ();
if (! getopts($optlist, \%options)) {
    usage();
}
if (defined($options{"d"})) {
    $debug = 1;
}
if (defined($options{"k"})) {
    $killmode = 1;
}
usage()
    if (! @ARGV);

#
# Verify user and get his DB uid and other info for later. Note that
# root can run this script, so we might not get an actual user.
#
my $this_user = User->ThisUser();

#
# Determine if we have an imageid or a filename and take
# appropriate action
#
my $image;
my $imageid;
my $filename;
if ($ARGV[0] =~ /^(\/.+)$/) {
    $filename = $1;

    if (!-R $filename) {
	Fatal("You do not have permission to read the file: $filename");
    }

    if ($UID != 0) {
	my $fn = realpath($filename);
	my @valid_prefixes = qw(/groups /proj /users /share);
	push @valid_prefixes, "/scratch" if "@FSDIR_SCRATCH@";
	my $test = join('|', map {"^$_"} @valid_prefixes);
	if ($fn !~ /$test/) {
	    Fatal("$fn (after resolving symbolic links) must be in one of: @valid_prefixes");
	}
    }
    
} else {
    #
    # Grab the Image.
    #
    $image = Image->Lookup($ARGV[0]);
    if (! defined($image)) {
	Fatal("No such image in the Emulab Database.\n");
    }
    $imageid  = $image->imageid();
    $filename = $image->path();
    #
    # Make sure that the user has sufficient permissions.
    #
    if (defined($this_user) &&
	!$image->AccessCheck($this_user,
			     ($killmode ? TB_IMAGEID_DESTROY :
			      TB_IMAGEID_READINFO))) {
	Fatal("Not enough permission!");
    }

    if (!$killmode && !$ELABINELAB && ! -R $filename) {
	Fatal("You do not have permission to read the image file for".
	      "$image: $filename\n");
    }
}

#
# Pick an address to use before locking the DB.  Die if unsucessful,
# set address if sucessful.  If something goes wrong later or there is
# already a laucher active, we will wind up wasting this address,
# but hey, we can make more!
#
my $naddress = PickAddress()
    if (!$killmode);

#
# Need to lock the tables here, so we can lock out anyone else from
# messing with the image.
#
LockTables();

# Try to discover if some other process is handling this address
debug("creating table row if it doesn't already exist\n");
my $path_db = DBQuoteSpecial($filename);
my $imageid_db = defined $imageid ? $imageid : "NULL";
DBQueryFatal("insert ignore into frisbee_blobs (path,imageid) values ($path_db, $imageid_db)")
    unless $killmode;
my $idx;
my $address;
my $pid;
my $load_busy;
my $frisbee_query = DBQueryFatal("select idx,load_address,frisbee_pid,load_busy,imageid ".
				 "  from frisbee_blobs where path = $path_db");
if ($frisbee_query->num_rows) {
    my $imageid_check;
    ($idx,$address, $pid, $load_busy,$imageid_check) =  $frisbee_query->fetchrow_array();
    # XXX: If $imageid is defined make sure it matches $imageid_check
}
#debug("idx=$idx address=$address pid=$pid busy=$load_busy\n");

if ($killmode) {
    #
    # Killmode. We do some sanity checking cause there is a small race 
    # inherent in trying to use the pid via the DB without locking (below).
    #
    # No point in leaving table locked; not going to modify it.
    #
    UnlockTables();

    # Nothing running.
    exit(0)
	if (!$address && !$pid);

    if (!$address && $pid) {
	#
	# This makes no sense. Send email, but keep going. 
	#
	my $mesg = "Inconsistent DB state. PID ($pid) but no load address!\n".
	    "Trying to recover from this unfortunate situation.\n";
	
	SENDMAIL($TBOPS,
		 "Frisbee Killer Inconsistency",
		 "File: $filename\n".
		 $mesg);
    }
    elsif ($address && !$pid) {
	#
	# Okay, minor problem. It is possible we caught the launcher between
	# setting the address and setting the pid. Wait a moment, and then
	# try again. If still no pid, bail.
	#
	sleep(1);
	Refresh();

	# Okay, situation resolved itself; other frisbeelauncher bailed.
	exit(0)
	    if (!$address && !$pid);

	#
	# Still inconsistent so bail.
	# 
	if ($address && !$pid) {
	    my $mesg = "Inconsistent DB state. Load address but no PID!";
	
	    SENDMAIL($TBOPS,
		     "Frisbee Killer Failed!",
		     "File: $filename\n".
		     $mesg);
	
	    Fatal($mesg);
	}
    }

    #
    # Okay, address and pid. Kill if its really running. The killed
    # process will clear the address and pid, but if there is none,
    # then clear it here.
    #
    if (kill(0, $pid) || ! $!{ESRCH}) {
	if (! kill('TERM', $pid)) {
	    SENDMAIL($TBOPS,
		     "Frisbee Killer Failed!",
		     "Failed to stop frisbee daemon for $filename\n".
		     "Could not kill(TERM) process $pid: $? $!");

	    Fatal("Failed to stop frisbee daemon for $filename!");
	}
    }
    else {
	# The original process is gone, so just clear the DB state. 
	ClearEntry();
    }
    exit(0);
}

#
# Keep the current frisbeed running for another time period.
#
if ($address) {
    KeepBusy();
    UnlockTables();
    debug("A server ($address) is already running for image $filename\n");
    exit(0);
}

# This would be inconsistent.
if ($pid) {
    #
    # But lets try and recover. If the pid is gone, we can just keep going
    # and not worry. 
    #
    if (kill(0, $pid) || ! $!{ESRCH}) {
	my $mesg = "Inconsistent DB state. No load address but process $pid running!";
	UnlockTables();

	SENDMAIL($TBOPS,
		 "Frisbee Startup Failure!",
		 "File: $filename\n".
		 $mesg);
	Fatal($mesg);
    }
    else {
	ClearPid();
	$pid = undef;
    }
}

#
# Ok, no process is already running for this image, we will use the new
# address chosen earlier.
#
$address = $naddress;
SetAddress($address);
UnlockTables();
debug("Picked address $address\n");

#
# When running inside an inner Emulab, try to get the image from the
# outer emulab when it does not exist locally. Of course, it could still
# be a bogus image.
#
# We do this before going into the background as that is what os_setup
# expects.  Note that we set a signal handler so we can remove any partially
# downloaded image if interrupted.  We also record our pid so that -k will
# work in another frisbeelauncher instance.
#
if ($ELABINELAB && ! -e $filename && defined $imageid) {
    debug("Fetching image $filename ($imageid) from real boss\n");
    $SIG{HUP} = $SIG{INT} = $SIG{TERM} = \&cleanup;
    SetPid($PID);
    $EUID = $UID;
    $dlfilename = $filename;
    system("$FRISBEEIMAGE $imageid");
    $dlfilename = 0;
    $EUID = 0;
    if ($?) {
	Fatal("No such image file: $filename!");
    }
}

# Run in the background
if (my $childpid = TBBackGround($LOGFILE)) {
    #
    # Delay a moment, and they look for an exit status.
    # This is intended to catch startup problems.
    #
    # XXX TBBackGround should do this!
    #
    sleep(1);
    my $foo = waitpid($childpid, &WNOHANG);
    if ($foo) {
	LockTables();
	ClearEntry();
	UnlockTables();
	Fatal("Error $? backgrounding frisbeelauncher!");
    }
    exit(0);
}
TBdbfork();

# Set up a signal handler that will clean up in case we get killed
$SIG{HUP} = $SIG{INT} = $SIG{TERM} = \&cleanup;

# Set our pid. This happens outside the lock which could lead to races,
# but that is unlikely. Look for it above though.
SetPid($PID);

#
# Drop root permissions, if we have them
#
if ($EUID == 0) {
    $EUID = $UID;
}

my $args = "-i $BOSSNODE_IP";

#
# Select the appropriate bandwidth
#
if ($filename =~ /^$TB\/images/ && !$ELABINELAB) {
    $args .= " -W $STD_BW";
} else {
    $args .= " -W $USR_BW";
}

#
# Force multicast keepalives if necessary
#
if ($ELABINELAB) {
    $args .= " -K 15";
}

my $firsttry = 1;

# Now, we actually launch Frisbee
while (1) {
        #
        # Each time the server exits, test the busy bit to see if
	# it should keep going. This has to be done with tables locked
	# since another caller is going to bump it.
	#
    	LockTables();
	last
	    if (! TestBusy());
	UnlockTables();
	
	if ($child_pid = fork()) {
		# Wait for child to exit
		waitpid($child_pid, 0);

		if ($?) {
		    #
		    # If this is the first time we are firing up this server
		    # and the port is already in use, try another port.
		    #
		    # If a server was running, died, and now we can no longer 
		    # get the port, something else might be wrong so just die
		    # in the usual way.
		    #
		    my $err = $?;
		    if ($firsttry && ($err >> 8) == EADDRINUSE()) {
			warn("Frisbeed bind failed for address $address, ".
			     "picking another address\n");
			$address = PickAddress();
			LockTables();
			SetAddress($address);
			UnlockTables();
			next;
		    }
		    SENDMAIL($TBOPS, "Frisbeed Failed!",
			     "File: $filename\n".
			     "Address: $address\n\n".
			     "Process $child_pid exited with value $err.\n".
			     "Please look at the syslog for frisbeed!\n\n".
			     "NOTE: Another frisbeed will not start!\n");
		    #
		    # Dump early. This will leave the address in
		    # in the DB, so that another one will not start
		    # until the matter is resolved by someone. 
		    #
		    ClearPid();
		    exit(1);
		}
		else {
		    $firsttry = 0;
		}
	}
	else {
		# Child branch
		# The database format for address is host:port - however,
		# we need to give them as seperate arguments to frisbeed.
		if ($address =~ /(.*):(.*)/) {
		    my $addr = $1;
		    my $port = $2;

		    # pass args in as array to avoid shell and hence problems
		    # with unsafe characters in $filename
		    if (!exec($FRISBEED, split(' ', "$args -m $addr -p $port"), $filename)) {
			Fatal("$$: Unable to exec $FRISBEED");
		    }
		}
		Fatal("$$: Bad address format: $address!");
	}
}
debug("Done.\n");
ClearEntry();
UnlockTables();
exit(0);

######################################################################
# Subroutines
######################################################################

# Only print if -d option was given. Also add $$ on the beginning of the
# string, to ease debugging
sub debug($)
{
    my ($msg) = @_;

    print "$$: $msg"
	if ($debug);
}

sub Refresh()
{
    my $frisbee_query = DBQueryFatal("select load_address,frisbee_pid,load_busy ".
                                     "  from frisbee_blobs where idx = $idx");
    if ($frisbee_query->num_rows) {
        ($address,$pid,$load_busy) =  $frisbee_query->fetchrow_array();
    } else {
        undef $address;
        undef $pid;
        undef $load_busy;
    }
}

# Lock the tables used in this script
sub LockTables()
{
    debug("Locking tables\n");
    DBQueryFatal("lock table frisbee_blobs write");
}

# Unlock the tables used in this script
sub UnlockTables()
{
    DBQueryFatal("unlock tables");
    debug("Unlocked tables\n");
}

#
# Pick out an address to use.
# DB tables must be *unlocked* for this to work!
#
sub PickAddress()
{
    my $idx;
    my $index_query =
	DBQueryFatal("update emulab_indicies set idx=LAST_INSERT_ID(idx+1) ".
		     "where name='frisbee_index'");

    if ($index_query->affectedrows <= 0) {
	Fatal("emulab_indicies frisbee_index entry does not exist!".
	      " See sql/updates/4/226 in the source tree.");
    } else {
	$idx = $index_query->insertid();
    }

    my ($a,$b,$c,$d) = split /\./, $BASEADDR;
    $b = 1 if (!defined($b));
    $c = 1 if (!defined($c));
    $d = 1 if (!defined($d));

    $d += $idx;
    if ($d > 254) {
	$c += int($d / 254);
	$d = $d % 254 + 1;
    }
    if ($c > 254) {
	$b += int($c / 254);
	$c = $c % 254 + 1;
    }
    if ($b > 254) {
	my $mesg = "No more multicast addresses!";

	SENDMAIL($TBOPS,
		 "FrisbeeLauncher Failed!",
		 "File: $filename\n".
		 $mesg);

	Fatal($mesg);
    }

    my $address = "${a}.${b}.${c}.${d}";
    my $port    = $BASEPORT + ((($c << 8) | $d) & 0x7FFF);
    
    return "${address}:${port}";
}

#
# Set the load address and busy bit.
# Always called with tables locked.
#
sub SetAddress($)
{
    my ($address) = @_;

    DBQueryFatal("update frisbee_blobs set load_address = \"$address\", load_busy = 1 where idx=$idx");
    Refresh();
}

#
# Clear out the address (and pid) registered to this process
# Might be called with tables locked.
#
sub ClearEntry()
{
    debug("Clearing out registered load_address and pid\n");

    DBQueryFatal("delete from frisbee_blobs where idx=$idx");
    Refresh();
}

#
# Set and clear the frisbee process ID.
# Always called with tables unlocked.
#
sub SetPid($)
{
    my ($pid) = @_;
    
    DBQueryFatal("update frisbee_blobs set frisbee_pid = $pid where idx=$idx");
    Refresh();
}
sub ClearPid()
{
    DBQueryFatal("update frisbee_blobs set frisbee_pid = 0 where idx=$idx");
    Refresh();
}

#
# Test the busy indicator, and set to zero.
# Always called with tables locked.
#
sub TestBusy()
{
    my $busy = $load_busy;
    if ($busy) {
	DBQueryFatal("update frisbee_blobs set load_busy = 0 where idx=$idx");
	Refresh();
    }	
    return $busy;
}

#
# Bump the busy indicator to keep the frisbeed going.
#
sub KeepBusy()
{
    DBQueryFatal("update frisbee_blobs set load_busy=GREATEST(load_busy,1) " .
		 "where idx=$idx");
    Refresh();
    return 0;
}



#
# Kill off our child process, if started, and clear out registered address
# Also, die off
#
sub cleanup
{
	print STDERR "$$: Killed, cleaning up\n";
	if ($dlfilename) {
	    $SIG{HUP} = $SIG{INT} = $SIG{TERM} = 'IGNORE';
	    kill('TERM', 0);
	    $dlfilename = 0;
	}
	if ($child_pid) {
	    kill(15, $child_pid);
	}
	ClearEntry();
	exit(1);
}

sub Fatal($)
{
    my ($msg) = @_;
    
    tbdie("*** $0:\n".
	  "    $msg\n");
}
