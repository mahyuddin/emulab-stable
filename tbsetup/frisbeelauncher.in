#!/usr/bin/perl -wT
#
# EMULAB-COPYRIGHT
# Copyright (c) 2000-2002, 2004 University of Utah and the Flux Group.
# All rights reserved.
#
use Getopt::Std;
use POSIX 'setsid'; # For &daemonize
use Sys::Syslog;
use English;

#
# This also kills a running frisbee.
#
sub usage()
{
    print "Usage: $0 [-d] [-k] <imageid>\n";
    print "-k:	Kill running frisbee.\n";
    print "-d:	Print debugging output.\n";
    exit(1);
}
my $optlist  = "dk";
my $debug    = 0;
my $killmode = 0;

# Configure variables
my $TB		= "@prefix@";
my $TBOPS	= "@TBOPSEMAIL@";
my $BOSSNODE_IP = "@BOSSNODE_IP@";

#
# Untaint the path
# 
$ENV{'PATH'} = "/bin:/usr/bin";
delete @ENV{'IFS', 'CDPATH', 'ENV', 'BASH_ENV'};

#
# Turn off line buffering on output
#
$| = 1;

use lib "@prefix@/lib";
use libdb;
use libtestbed;

# Defines
my $FRISBEED	= "$TB/sbin/frisbeed";
my $BASEADDR	= "234.5.6";
my $BASEPORT	= "3564";
my $LOGFILE	= "$TB/log/frisbeelauncher";

my $STD_BW	= 72000000; 	# 71.6Mb/sec w/1000HZ kernel
my $USR_BW	= 54000000;	# 53.7Mb/sec w/1000HZ kernel

#
# Parse command arguments. Once we return from getopts, all that should be
# left are the required arguments.
#
%options = ();
if (! getopts($optlist, \%options)) {
    usage();
}
if (defined($options{"d"})) {
    $debug = 1;
}
if (defined($options{"k"})) {
    $killmode = 1;
}
$imageid = shift @ARGV;

#
# Untaint the argument.
#
if ($imageid =~ /^([-\@\w\+.]+)$/) {
    $imageid = $1;
}
else {
    die("Invalid image '$imageid' contains illegal characters.\n");
}

# Grab the filename to give to frisbee
my $filename = &get_filename($imageid);

#
# Make sure that the user has sufficient permissions.
#
if (!TBImageIDAccessCheck($UID, $imageid,
			  ($killmode ? TB_IMAGEID_DESTROY :
			   TB_IMAGEID_READINFO))) {
    die("*** $0:\n".
	"    Not enough permission!\n");
}

if (!$killmode && ! -R $filename) {
    die("*** You do not have permission to read the image file for\n".
	"imageid $imageid: $filename\n");
}

#
# Need to lock the tables here, so we can lock out anyone else from
# messing with the image (and so we can pick an address atomically). 
#
&lock_tables;

# Try to discover if some other process is handling this address
($address, $pid) = get_address($imageid);

if ($killmode) {
    #
    # Killmode. We do some sanity checking cause there is a small race 
    # inherent in trying to use the pid via the DB without locking (below).
    #
    # No point in leaving table locked; not going to modify it.
    #
    unlock_tables();

    # Nothing running.
    exit(0)
	if (!$address && !$pid);

    if (!$address && $pid) {
	#
	# This makes no sense. Just send email.
	#
	my $mesg = "Inconsistent DB state. PID ($pid) but no load address!";
	
	SENDMAIL($TBOPS,
		 "Frisbee Killer Failed!",
		 "Imageid: $imageid\n".
		 $mesg);
	
	die("*** $0:\n".
	    "    $mesg\n");
    }
    if ($address && !$pid) {
	#
	# Okay, minor problem. It is possible we caught the launcher between
	# setting the address and setting the pid. Wait a moment, and then
	# try again. If still no pid, bail.
	#
	sleep(1);
	($address, $pid) = get_address($imageid);

	# Okay, situation resolved itself; other frisbeelauncher bailed.
	exit(0)
	    if (!$address && !$pid);

	#
	# Still inconsistent so bail.
	# 
	if ($address && !$pid) {
	    my $mesg = "Inconsistent DB state. Load address but no PID!";
	
	    SENDMAIL($TBOPS,
		     "Frisbee Killer Failed!",
		     "Imageid: $imageid\n".
		     $mesg);
	
	    die("*** $0:\n".
		"    $mesg\n");
	}
    }

    #
    # Okay, address and pid. We could clear the pid from the DB,
    # preventing another killer from thinking it is running, but not
    # much point since it is not likely to happen. If it turns out to
    # be a problem we can change the way this works.
    #
    unlock_tables();
    if (! kill('TERM', $pid)) {
	SENDMAIL($TBOPS,
		 "Frisbee Killer Failed!",
		 "Failed to stop frisbee daemon for $imageid\n".
		 "Could not kill(TERM) process $pid: $? $!");

	die("*** $0:\n".
	    "    Failed to stop frisbee daemon for $imageid!\n");
    }
    exit(0);
}

if ($address && &keepbusy($imageid)) {
        &unlock_tables;
	&debug("A server ($address) is already running for image $imageid\n");
	exit (0);
}

# This would be inconsistent.
if ($pid) {
    my $mesg = "Inconsistent DB state. No load address but PID ($pid) set!";
	
    SENDMAIL($TBOPS,
	     "Frisbee Startup Failed!",
	     "Imageid: $imageid\n".
	     $mesg);
	
    die("*** $0:\n".
	"    $mesg\n");
}

# Pick an address: Die if unsucessful, set address and unlock if sucessful
$address = &pick_address;
&debug("Picked address $address\n");

if (!$address) {
	&unlock_tables;
	die "Unable to find a free address to send on\n";
}

&set_address($imageid,$address);
&unlock_tables;

# Run in the background
if (TBBackGround($LOGFILE)) {
    exit(0);
}

# Set up a signal handler that will clean up in case we get killed
$SIG{HUP} = $SIG{INT} = $SIG{TERM} = \&cleanup;

# Set our pid. This happens outside the lock which could lead to races,
# but that is unlikely. Look for it above though.
set_pid($imageid, $PID);

#
# Drop root permissions, if we have them
#
if ($EUID == 0) {
	$EUID = $UID;
}

#
# Select the appropriate bandwidth
#
my $BW;
if ($filename =~ /^$TB\/images/) {
    $BW = $STD_BW;
} else {
    $BW = $USR_BW;
}

# Now, we actually launch Frisbee
while (1) {
        #
        # Each time the server exits, test the busy bit to see if
	# it should keep going. This has to be done with tables locked
	# since another caller is going to bump it.
	#
	&lock_tables();
	if (! &testbusy($imageid)) {
		last;
	}
	&unlock_tables();
	
	if ($child_pid = fork()) {
		# Wait for child to exit
		waitpid($child_pid, 0);

		if ($?) {
			SENDMAIL($TBOPS, "Frisbeed Failed!",
				 "Imageid: $imageid\n".
				 "Address: $address\n\n".
				 "Process $child_pid exited with value $?.\n".
				 "Please look at the syslog for frisbeed!\n\n".
				 "NOTE: Another frisbeed will not start!\n");
			#
			# Dump early. This will leave the address in
			# in the DB, so that another one will not start
			# until the matter is resolved by someone. 
			#
			set_pid($imageid, 0);
			exit(1);
		}
	}
	else {
		# Child branch
		# The database format for address is host:port - however,
		# we need to give them as seperate arguments to frisbeed.
		if ($address =~ /(.*):(.*)/) {
			my $addr = $1;
			my $port = $2;

			if (!exec("$FRISBEED -W $BW -m $addr -i $BOSSNODE_IP ".
				  "-p $port $filename")) {
				die("$$: Unable to exec $FRISBEED\n");
			}
		}
		die("$$: Bad address format: $address.\n");
	}
}

&clear_address;
&unlock_tables();
exit(0);

######################################################################
# Subroutines
######################################################################

# Only print if -d option was given. Also add $$ on the beginning of the
# string, to ease debugging
sub debug {
	if ($debug) { print "$$: ", @_ };
}

# Grab the address for the passed-in imageid
sub get_address {
	my ($imageid) = @_;

	my $sth =
	    DBQueryFatal("SELECT load_address,frisbee_pid ".
			 "FROM images WHERE imageid='$imageid'");

	my @row = $sth->fetchrow;
	if (!@row) {
		die "No such imageid: $imageid\n";
	}

	return ($row[0], $row[1]);
}

# Grab the filename for the passed-in imageid
sub get_filename {
	my ($imageid) = @_;
	my $image_query = "SELECT path FROM images WHERE " .
		"imageid='$imageid'";

	my $sth = DBQueryFatal($image_query);

	my @row = $sth->fetchrow;
	if (!@row) {
		die "No such imageid: $imageid\n";
	}

	return $row[0];
}


# Lock the tables used in this script - waits indefinitely until it
# succeeds
sub lock_tables {
	while (1) {
		&debug("Locking tables\n");
		my $sth = DBQuery("LOCK TABLES images WRITE"); 
		if (!$sth) {
			print "DB Error locking tables. Waiting a bit ...\n";
			sleep(10);
		} else {
			last;
		}
	}
}

# Unlock the tables used in this script
sub unlock_tables {
	&debug("Unlocking tables\n");
	DBQueryFatal("UNLOCK TABLES"); 
}

# Pick out an address to use
sub pick_address {
	my $address_query = "SELECT load_address FROM images WHERE " .
		"load_address IS NOT NULL and load_address != ''";
	my $sth = DBQueryFatal($address_query);

	my %used_addrs = (); # Loading addresses already taken
	while (@row = $sth->fetchrow) {
		$row[0] =~ /^$BASEADDR\.(\d+):(\d+)$/;
		# $1 is the address, $2 the port number
		if ($1 && $2) {
			$used_addrs{$1} = $2;
		}
	}

	my $address;
	for (my $i = 1; $i < 255; $i++) {
		if (!$used_addrs{$i}) {
			my $port = $BASEPORT + ($i - 1);
			$address = "${BASEADDR}.${i}:${port}";
			last;
		}
	}

	return $address;
}

# Pass in an imageid, and an address
sub set_address {
	my ($imageid,$address) = @_;

	DBQueryFatal("UPDATE images SET load_address='$address',load_busy=1 " .
		     "WHERE imageid='$imageid'");
}

# Pass in an imageid and a pid.
sub set_pid {
	my ($imageid,$pid) = @_;

	DBQueryFatal("UPDATE images SET frisbee_pid=$pid " .
		     "WHERE imageid='$imageid'");
}

# Pass in an imageid and a pid.
sub clear_pid {
	my ($imageid) = @_;

	DBQueryFatal("UPDATE images SET frisbee_pid=0 " .
		     "WHERE imageid='$imageid'");
}

# Bump the busy indicator to keep the frisbeed going.
sub keepbusy($imageid) {
	my ($imageid) = @_;

	DBQueryFatal("UPDATE images SET load_busy=GREATEST(load_busy,1) " .
		     "WHERE imageid='$imageid'");

	return 1;
}

# Test the busy indicator, and set to zero.
sub testbusy($imageid) {
	my ($imageid) = @_;

	my $query_result =
	    DBQueryFatal("select load_busy from images ".
			 "WHERE imageid='$imageid'");

	my @row = $query_result->fetchrow;
	if (!@row) {
	        return 0;
	}
	
	if ($row[0]) {
	    DBQueryFatal("UPDATE images SET load_busy=0 ".
			 "WHERE imageid='$imageid'");
	}
	return $row[0];
}

# Kill off our child process, if started, and clear out registered address
# Also, die off
sub cleanup {
	print STDERR "$$: Killed, cleaning up\n";
	if ($child_pid) {
		kill 15, $child_pid;
	}
	&clear_address;
	exit(1);
}

# Clear out the address (and pid) registered to this process
sub clear_address {
	&debug("Clearing out registered load_address and pid\n");
	# Now, clear out the load_address we had set up
	DBQueryFatal("update images set ".
		     "load_address='',load_busy=0,frisbee_pid=0 ".
		     "where imageid='$imageid'");
}
