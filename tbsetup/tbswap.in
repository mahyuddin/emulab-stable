#!/usr/bin/perl -w

#
# EMULAB-COPYRIGHT
# Copyright (c) 2000-2005 University of Utah and the Flux Group.
# All rights reserved.
#
use English;

# Returns 0 on success.
# Returns 1 on non-assign_wrapper failure.
# Returns (1 | assign_wrapper's errorcode) on assign_wrapper failure.
# Returns |0x40 if update caused a swapout. Icky.
# Returns -1 on uncontrolled error (die called).

# XXX: handle error cases for update? (backup the db?)
# XXX: Shouldn't do idempotent stuff twice for update.
# XXX: repush/calc routing for update??? (tbprerun)
# XXX: previz for update???              (tbprerun)
# XXX: make snmpit faster for update.
#
# XXX: for update, expt is swapped out on os_setup fail.
#      (we only recover if assign fails)

sub usage()
{
    print STDERR "Usage: $0 -force { in | out | update [-reboot] [-eventsys_restart] } pid eid\n";
    exit(-1);
}

#
# Configure variables
#
my $TBROOT         = "@prefix@";
my $TBOPS          = "@TBOPSEMAIL@";
my $TBLOGS         = "@TBLOGSEMAIL@";
my $THISHOMEBASE   = "@THISHOMEBASE@";
my $TESTMODE       = @TESTMODE@;
my $DISABLE_EVENTS = "@DISABLE_EVENT_SCHED@";
my $piper          = "$TBROOT/sbin/locpiper";

# Untaint the path
$ENV{'PATH'} = "/usr/bin:$TBROOT/libexec:$TBROOT/libexec/ns2ir" . 
    ":$TBROOT/sbin:$TBROOT/bin";

#
# Testbed Support libraries
#
use lib "@prefix@/lib";
use libdb;
use libtestbed;
use libadminctrl;
use libadminmfs;
use libtblog;

#require exitonwarn; # exitonwarn isn't really a module, so just require it

#
# Actual swap-in and swap-out functions, defined below.
#
sub doSwapout($);
sub doSwapin($);

#
# Firewall stuff
# XXX maybe should be elsewhere
#
sub FWSETUP()     { return 1; }
sub FWADDNODES()  { return 2; }
sub FWDELNODES()  { return 3; }
sub FWTEARDOWN()  { return 4; }
sub doFW($$$$);

# XXX fixme: should not be hardwired!
my $cnetstack = "-S Control";
my $cnetvlanname = "Control";


sub REAL()    { return 4; }
sub CLEANUP() { return 3; }
sub RETRY()   { return 2; }
sub UPDATE()  { return 1; }
sub UPDATE_RECOVER()  { return 0; }

#
# Grab global enable of linkdelays.
#
my $enablelinkdelays = TBGetSiteVar("general/linux_endnodeshaping");

#
# Turn off line buffering on output
#

$| = 1;

my $updateReboot   = 0;
my $updateReconfig = 1;
my $update_Eventsys_restart = 0;
my $elabinelab     = 0;
my $force  = 0;
my $errors = 0;
my $updatehosed = 0;
my $state;
my $canceled;
my $os_setup_pid;
my $cleanvlans;
my $nextState;

#
# First argument is either "in", "out", or "update";
# this value goes into $swapop.
#

my $swapop = shift;	

if (!$swapop || 
    (($swapop ne "in") && 
     ($swapop ne "out") &&
     ($swapop ne "update"))) {
    usage();
}

#
# Get other arguments.
#

while ($#ARGV > 1) {
    $arg = shift;
    if ($arg eq "-force") {
	$force = 1;
    } elsif ($arg eq "-reboot") {
	$updateReboot = 1;
	$updateReconfig = 0;
    } elsif ($arg eq "-noreconfig") {
	$updateReboot   = 0;
	$updateReconfig = 0;
    } elsif ($arg eq "-eventsys_restart" && $swapop eq "update") {
	$update_Eventsys_restart = 1;
    } else {
	usage();
    }
}
if ($#ARGV < 1) {
    usage();
}
my ($pid,$eid) = @ARGV;

#
# Untaint the arguments.
#
if ($pid =~ /^([-\@\w.]+)$/) {
    $pid = $1;
}
else {
    die("Tainted argument $pid!\n");
}
if ($eid =~ /^([-\@\w.]+)$/) {
    $eid = $1;
}
else {
    die("Tainted argument $eid!\n");
}

#
# Set Error reporting info
# 
tblog_set_info($pid,$eid,$UID);

#
# Turn on timestamps
#
TBDebugTimeStampsOn();

# Need this below.
my ($dbuid, $uname, $umail);
if (UNIX2DBUID($UID, \$dbuid)) {
    UserDBInfo($dbuid, \$uname, \$umail);
}

#
# Print starting message.
#
my $exptidx;
TBExptIDX($pid, $eid, \$exptidx);

print "Beginning swap-$swapop for $pid/$eid ($exptidx). " .
    TBTimeStampWithDate() . "\n";
TBDebugTimeStamp("tbswap $swapop started");

#
# Get experiment state; verify that experiment exists.
#
if (! ($state = ExpState($pid, $eid))) {
    tbdie "No such experiment $pid/$eid";
}
# Sanity check the current state. 
if (!$force) {
    if ($swapop eq "in") {
	tbdie("Experiment should be ACTIVATING. Currently $state.")
	    if ($state ne EXPTSTATE_ACTIVATING);
    }
    elsif ($swapop eq "out") {
	tbdie("Experiment should be SWAPPING. Currently $state.")
	    if ($state ne EXPTSTATE_SWAPPING);
    }
    elsif ($swapop eq "update") {
	tbdie("Experiment should be MODIFY_RESWAP. Currently $state.")
	    if ($state ne EXPTSTATE_MODIFY_RESWAP);
    }
}
# Get elabinelab status. See below.
if (! TBExptIsElabInElab($pid, $eid, \$elabinelab)) {
    tbdie("Could not get elabinelab status for experiment $pid/$eid");
}

#
# See if the experiment is firewalled
#
my $firewalled = TBExptFirewall($pid, $eid);

#
# Do actual swapping
#
if ($swapop eq "out") {
    #
    # Swap out
    #
    $errors = doSwapout(REAL);
}
elsif ($swapop eq "update") {
    #
    # Before swapout, do cursory admission control to see if the
    # modified experiment will be swappable. assign_wrapper does a
    # more stringent check using assign.
    #
    print STDERR "Checking with Admission Control ...\n";
    if (! TBAdmissionControlCheck($UID, $pid, $eid, undef)) {
	print STDERR "Admission control failure!\n";
	print "Failingly finished swap-$swapop for $pid/$eid. " .
	    TBTimeStamp() . "\n";
	TBDebugTimeStamp("tbswap $swapop finished (failed)");
	exit(1);
    }
    
    #
    # Update.
    #
    # Phase One -- swap experiment partially out.
    #
    print STDERR "Backing up physical state...\n";
    TBExptBackupPhysicalState($pid,$eid);

    $errors = doSwapout(UPDATE);

    if ($errors) {
	#
	# Clean up the mess, leaving the experiment in the SWAPPED state,
	# 
	print STDERR "Cleaning up after errors.\n";
	doSwapout(CLEANUP);
	$updatehosed = 1;
    }
    else {
	#
	# Phase Two -- swap experiment back in.
	#
	$errors = doSwapin(UPDATE);

	if ($errors) {
	    #
	    # There were errors; see if we can recover.
	    #
	    my $CanRecover = 1;

	    if ($errors != 7) {
		print STDERR "Update failure occurred _after_ assign phase; ";
		$CanRecover = 0;
	    }

	    if ($CanRecover) {
		print STDERR "Recovering virtual and physical state.\n";

		if (TBExptRemoveVirtualState($pid, $eid) ||
		    TBExptRestoreVirtualState($pid, $eid) ||
		    TBExptRestorePhysicalState($pid,$eid)) {
		    print STDERR "Could not restore backed-up state; ";
		    $CanRecover = 0;
		}
		else {
		    print STDERR "Doing a recovery swap-in of old state.\n";

		    if (doSwapin(UPDATE_RECOVER)) {
			print STDERR "Could not swap in old physical state; ";
			$CanRecover = 0;
		    }
		}
	    }

	    #
	    # Some part of the recovery failed; must swap it out. swapexp
	    # (caller) will then have to do more clean up, hence the special
	    # exit status indicated by $updatehosed.
	    # 
	    if (! $CanRecover) {
		print STDERR "Recovery aborted! Swapping experiment out.\n";
		doSwapout(CLEANUP);
		$updatehosed = 1;
	    }
	    else {
		print STDERR "Update recovery successful.\n";
	    }
	}
    }
}
elsif ($swapop eq "in") {
    #
    # Swap in
    #
    my $retries = 2;

    #
    # Before real swapin, do cursory admission control. assign_wrapper does
    # a more stringent check using assign.
    #
    print STDERR "Checking with Admission Control ...\n";
    if (! TBAdmissionControlCheck($UID, $pid, $eid, undef)) {
	print STDERR "Admission control failure!\n";
	print "Failingly finished swap-$swapop for $pid/$eid. " .
	    TBTimeStamp() . "\n";
	TBDebugTimeStamp("tbswap $swapop finished (failed)");
	exit(1);
    }
    
    $errors = doSwapin(REAL);

    #
    # Attempt a retry if: 
    #   a) there were errors, 
    #   b) doswapin() indicated (via return code 3) a retry is appropriate,
    #   c) we haven't tried too many times already.
    #   d) The cancelflag has not been set.
    #   e) $TESTMODE == 0.
    #
    while ($errors == 3 && $retries && !$canceled && !$TESTMODE) {
	$retries--;

	print STDERR "Cleaning up after errors; will try again.\n";
	doSwapout(RETRY);

	print STDERR "Trying again...\n";
	$errors = doSwapin(RETRY);
    }
    if ($errors || $canceled) {
	print STDERR "Cleaning up after " .
	    ($canceled ? "cancelation" : "errors") . ".\n";
	doSwapout(CLEANUP);
    }
}

#
# Write appropriate message and exit.
#
if ($errors) {
    print "Failingly finished swap-$swapop for $pid/$eid. ".TBTimeStamp()."\n";
    TBDebugTimeStamp("tbswap $swapop finished (failed)");

    # Pass out magic value to indicate that update failed!
    exit(1 | ($updatehosed ? 0x40 : 0));
}
print "Successfully finished swap-$swapop for $pid/$eid. " .TBTimeStamp()."\n";
TBDebugTimeStamp("tbswap $swapop finished (succeeded)");
exit(0);

#################################

##
#
# doSwapout - Swaps experiment out.
#
#             If in REAL or CLEANUP,
#             this function will free all nodes for the 
#             experiment.
#
#             If in RETRY or UDPATE,
#             only nodes not in RES_READY will be freed.
#
#             Returns 0 on success, >0 on failure.
#
##

sub doSwapout($) {
    my $type = shift; # REAL==4, CLEANUP==3, RETRY==2, UPDATE==1.
    my $swapout_errors = 0;

    #
    # wait for os_setup;
    # this only applies if called after a failed doswapin.
    #
    if ($os_setup_pid) {
	print "Waiting for os_setup to finish\n";
	waitpid($os_setup_pid, 0);
	undef $os_setup_pid;
    }

    print "Getting files accessed via NFS.\n";
    TBDebugTimeStamp("nfstrace started");
    if (lc $THISHOMEBASE eq "emulab.net") {
	if (defined($umail)) {
	    SENDMAIL("$TBLOGS",
		     "Files accessed by $pid/$eid via NFS",
		     `nfstrace get $pid $eid`,
		     "$uname <$umail>");
	}
    }
    else {
	system("nfstrace get $pid $eid");
    }
    TBDebugTimeStamp("nfstrace finished");

    if (! $TESTMODE) { 
	if (! ($DISABLE_EVENTS || $elabinelab)) {
	    if ($type >= RETRY ||
		($update_Eventsys_restart && $type == UPDATE) ) {
		print "Stopping the event system\n";
		if (system("eventsys_control stop $pid $eid")) {
		    tberror "Failed to stop the event system.";
		    $swapout_errors = 1;
		}

		#
		# Stop the location piper.
		#
		if (-x $piper) {
		    print "Stopping the location piper\n";
		    if (system("$piper -k $pid $eid")) {
			tberror "Failed to stop location piper.";
			$swapout_errors = 1;
		    }
		}
	    }
	}
	
	#
	# Do teardown of inner elab. We must do this before we teardown the
	# vlans since the inner control network is a vlan, and we want that
	# active so inner boss can reboot the inner nodes (avoid power cycle).
	#
	if ($elabinelab && $type >= CLEANUP) {
	    print "Tearing down elabinelab. This could take a while.\n";
	    if (system("elabinelab -k $pid $eid")) {
		tberror "Failed to teardown elabinelab!";
		$swapout_errors = 1;
	    }
	}

	#
	# Clean up any VLANs in experiment.
	#
	# When modifying an elabinelab experiment, leave the vlans intact
	# so that the inner networks are not suddenly disconnected!
	#
	if (! ($elabinelab && $type == UPDATE)) {
	    TBDebugTimeStamp("snmpit started");
	    print STDERR "Removing VLANs.\n";
	    if (system("snmpit -r $pid $eid")) {
		tberror "Failed to reset VLANs";
		$swapout_errors = 1;
	    } else {
		$cleanvlans = 0;
	    }
	    TBDebugTimeStamp("snmpit finished");
	}
    }

    if ($type >= CLEANUP) {
	#
	# We're not attempting a retry;
	#
	# Stop all of the vnodes.
	#
	if (! $TESTMODE) { 	
	    print "Tearing down virtual nodes.\n";
	    TBDebugTimeStamp("vnode_setup -k started");
	    if (system("vnode_setup -d -k $pid $eid")) {
		tberror "Failed to tear down vnodes.";
		$swapout_errors = 1;
	    }
	    TBDebugTimeStamp("vnode_setup finished");
	}

	#
	# Nodes behind a firewall are treated special.
	# See undoFWNodes for details.
	#
	if ($firewalled && undoFWNodes($pid, $eid)) {
	    return 1;
	}

	#
	# Perform swapout time admin actions.  Right now there is at most
	# one of these.  It isn't really a general mechanism, just a hook
	# for state saving or data collection during swapout.
	# A couple of important "fer now" notes:
	#
	#	We don't do this for firewalled experiments.  We need a way
	#	to "tag" the saved disk state to ensure it doesn't get
	#	instantiated outside of a firewall.
	#
	#	We only do this on REAL swapouts, and not on CLEANUPs.
	#	There are some types of CLEANUPs where we may want to
	#	do this, in particular an invocation caused by a failed
	#	modify operation, where the admin action is to save the
	#	experiment state.  So we will need to revisit this.
	#
	my %soaction = ();
	if ($type == REAL && !$firewalled) {
	    TBExptGetSwapoutAction($pid, $eid, \%soaction);
	}
	if ($soaction{'command'} && doSwapoutAction($pid, $eid, %soaction)) {
	    return 1;
	}

	#
	# remove all nodes from the experiment.
	# (nfree will send them to RES_FREE_DIRTY)
	#
	print STDERR "Freeing nodes.\n";
	TBDebugTimeStamp("nfree started");
	if (system("nfree $pid $eid")) {
	    tberror "Could not free nodes.";
	    $swapout_errors = 1;
	}
	TBDebugTimeStamp("nfree finished");

	#
	# Since this is an actual swapout, 
	# reset our count of swap out nag emails sent.
	#
	DBQueryWarn("update experiments set swap_requests='',sim_reswap_count='0' ".
		    "where eid='$eid' and pid='$pid'");
    } else {
	#
	# $type == RETRY or $type == UPDATE.
	# Therefore, don't deallocate nodes which have been successfully
	# incorporated into the experiment (i.e., are RES_READY).
	# (nfree will send deallocated nodes to RES_FREE_DIRTY)
	#
	my @failedpnodes = ();
	my @failedvnodes = ();
	
	my $db_result =
	    DBQueryFatal("select rv.node_id,n.allocstate,nt.isvirtnode ".
                         "  from reserved as rv ".
			 "left join nodes as n on n.node_id = rv.node_id ".
			 "left join node_types as nt on nt.type=n.type ".
			 "where rv.pid='$pid' and rv.eid='$eid'");

	while (my ($node,$allocstate,$isvirt) = $db_result->fetchrow_array) {
	    if ($allocstate ne TBDB_ALLOCSTATE_RES_READY()) {
		if ($isvirt) {
		    push(@failedvnodes, $node);
		}
		else {
		    push(@failedpnodes, $node);
		}
	    }
	}

	#
	# Tear down failed vnodes. Perhaps not needed?
	# 
	if (!$TESTMODE && @failedvnodes > 0) {
	    print "Tearing down failed virtual nodes.\n";
	    TBDebugTimeStamp("vnode_setup -k started");
	    if (system("vnode_setup -d -k $pid $eid @failedvnodes")) {
		tberror "Failed to tear down vnodes.";
		$swapout_errors = 1;
	    }
	    TBDebugTimeStamp("vnode_setup -k finished");
	}

	#
	# Release all failed nodes.
	# 
	if (@failedpnodes > 0 || @failedvnodes > 0) {
	    print STDERR "Freeing failed nodes.\n";
	    
	    TBDebugTimeStamp("nfree started");
	    #
	    # Specify -x switch so when a physical node gets freed,
	    # any virtual nodes (owned by this experiment)
	    # sitting on top of it are freed as well.
	    #
	    if (system("nfree -x $pid $eid " .
		       join(" ", (@failedpnodes, @failedvnodes)))) {
		tberror "Could not free nodes.";
		$swapout_errors = 1;
	    }
	    TBDebugTimeStamp("nfree finished");
	}
    }

    if (! $TESTMODE) {
	#
	# If the experiment has no Plab dslice nodes left, but still has
	# a Plab slice, destroy the slice
	#

	# Does the slice exist?
	$db_result =
	    DBQueryFatal("select slicename from plab_slices ".
			 "where pid='$pid' and eid='$eid'");

	if ($db_result->numrows) {
	    # Are there any dslice nodes left?
	    $db_result =
		DBQueryFatal("select n.node_id from nodes as n ".
			     "left join node_types as nt on n.type = nt.type ".
			     "left join reserved as r ".
			     " on r.node_id = n.node_id ".
			     "where r.pid='$pid' and r.eid='$eid' ".
			     " and nt.isplabdslice = 1");

	    if (!$db_result->numrows) {
		print "Destroying Planetlab slice.\n";
		TBDebugTimeStamp("plabslice destroy started");
		if (system("plabslice destroy $pid $eid")) {
		    tberror "Failed to destroy Plab dslice.";
		    $swapout_errors = 1;
		}
		TBDebugTimeStamp("plabslice destroy finished");
	    }
	}
    }

    if (! $TESTMODE) {
	#
	# All of these errors are non-fatal on swapout. We find out about them
	# via email sent from the individual scripts.
	#

	#
	# Only reset mountpoints if this is an actual swapout, and
	# not a failed swapin(cleanup), update, or retry.
	#
	if ($type == REAL) {
	    print "Resetting mountpoints.\n";
	    TBDebugTimeStamp("exports started");
	    if (system("exports_setup")) {
		tberror "Failed to reset mountpoints.";
	    }
	    TBDebugTimeStamp("exports finished");
	}

	#
	# Resetting named maps and email lists is fast and idempotent,
	# so whatever.
	#
	print "Resetting named maps.\n";
	TBDebugTimeStamp("named started");
	if (system("named_setup")) {
	    tbwarn "Failed to reset named map.";
	}
	TBDebugTimeStamp("named finished");

	print "Resetting email lists.\n";
	TBDebugTimeStamp("genelists started");
	if (system("genelists -t")) {
	    tbwarn "Failed to reset email lists.";
	}
	TBDebugTimeStamp("genelists finished");
    }

    #
    # Wipe the DB clean except during UPDATE or RETRY. In those
    #    cases, assign_wrapper will reset the DB after reading
    #    the info.
    #
    if ( $type >= CLEANUP ) {
	print STDERR "Resetting DB.\n";
	TBExptRemovePhysicalState( $pid, $eid );
    }

    return $swapout_errors;
}

##
#
# doSwapin - Swaps experiment in.
#
#            Returns:
#              0 - successful swapin
#              1 - failed swapin; cleanup required.
#              3 - failed swapin; cleanup required; can retry.
#              7 - failed swapin; assign failed; no cleanup.
##

sub doSwapin($) {
    my $type = shift; # REAL==4, RETRY==2, UPDATE==1, UPDATE_RECOVER=0.
    # Just the physnodes ...
    my @deleted_pnodes = ();

    #
    # assign_wrapper does all the virtual to physical mapping 
    # and updating the DB state.
    #
    
    if ($type > UPDATE_RECOVER) {
        #
        # Hacky test to allow disabling of linkdelays if the node is going
        # to run Linux. See sitevar above.
        #
	if (! $enablelinkdelays) {
	    $db_result =
		DBQueryFatal("select distinct e.pid,e.eid,vl.vnode,vn.osname ".
			 "  from experiments as e ".
			 "left join virt_lans as vl on vl.pid=e.pid and ".
			 "     vl.eid=e.eid ".
			 "left join virt_nodes as vn on vn.pid=e.pid and ".
			 "     vn.eid=e.eid and vn.vname=vl.vnode ".
			 "left join os_info as o on o.osname=vn.osname and ".
			 "  (o.pid=vl.pid or o.pid='" . TBOPSPID() . "') ".
			 "where (vl.uselinkdelay!=0 or e.uselinkdelays!=0 or ".
			 "       e.forcelinkdelays!=0) and ".
			 "     (o.os is NULL or o.os='Linux') and ".
			 "     e.pid='$pid' and e.eid='$eid'");

	    if ($db_result->numrows) {
		print "*** Endnodeshaping is disabled on Linux Images!\n";
		print "*** You must modify your experiment to swap it in.\n";
		return 1;
	    }
	}
	
	print "Mapping to physical reality ...\n";
	TBDebugTimeStamp("assign_wrapper started");

	#
	# Pass the -u (update) switch into assign_wrapper, which turns on
	# update mode. When doing a retry, must also fix the current nodes
	# to avoid stuff jumping around when simply trying to replace a node
	# that did not boot.
	#
	my $exitcode;
	my $wrapper = "assign_wrapper -u";
	$wrapper .= " -f"
	    if ($type == RETRY);
	
	if (system("$wrapper $pid $eid")) {
	    $exitcode = $? >> 8;

	    tberror "Failed ($exitcode) to map to reality.";

	    # Wrapper sets this bit when recovery is possible.
	    if ($exitcode & 64) {
		# We can recover. 
		return 7;
	    }
	    else {
		# No recovery, no retry.
		return 1;
	    }
	}
	TBDebugTimeStamp("assign_wrapper finished");

	print "Mapped to physical reality!\n";
    }

    # Check cancel flag before continuing. No retry, 
    TBGetCancelFlag($pid, $eid, \$canceled);
    return 1
	if ($canceled);

    #
    # Look for any nodes in RES_TEARDOWN. These need to be released,
    # and if a virtnode, they need to be torn down. We cannot wait for
    # the virtnodes to go down with the physnode they are hosted on,
    # so teardown and release the virtnodes first, and then do the
    # physnodes.
    #
    # Errors are fatal; no recovery or retry.
    #
    if ($type == UPDATE) {
	my $allocstate = TBDB_ALLOCSTATE_RES_TEARDOWN();
	
	$db_result =
	    DBQueryFatal("select r.node_id,nt.isvirtnode,nt.isremotenode ".
			 "  from reserved as r ".
			 "left join nodes as n on n.node_id=r.node_id ".
			 "left join node_types as nt on nt.type=n.type ".
			 "where r.pid='$pid' and r.eid='$eid' and ".
			 "      n.allocstate='$allocstate'");

	if ($db_result->numrows) {
	    my @virtnodes = ();
	    my @physnodes = ();
	    
	    print "Tearing down and releasing unused nodes\n";

	    # First teardown/release virtnodes. 
	    while (my ($node,$isvirt,$isrem) = $db_result->fetchrow_array()) {
		if ($isvirt) {
		    push(@virtnodes, $node);
		}
		elsif (!$isrem) {
		    push(@physnodes, $node);
		}
	    }
	    # See below.
	    @deleted_pnodes = @physnodes;
	    
	    if (@virtnodes) {
		TBDebugTimeStamp("vnode_setup started");
		
		if (system("vnode_setup -k $pid $eid @virtnodes")) {
		    print "Failed to tear down unused virtnodes!\n";
		    return 1;
		}
		TBDebugTimeStamp("vnode_setup finished");
		
		if (system("nfree $pid $eid @virtnodes")) {
		    print "Failed to nfree unused virtnodes!\n";
		    return 1;
		}
	    }
	    if (@physnodes) {
		if ($elabinelab) {
		    print "Removing nodes from inner elab.\n";
		    if (system("elabinelab -r $pid $eid @physnodes")) {
			tberror "Failed to remove inner nodes!";
			return 1;
		    }
		}

		#
		# If the experiment is firewalled, cleanup the nodes
		# we are releasing.
		# 
		if ($firewalled && undoFWNodes($pid, $eid, @deleted_pnodes)) {
		    return 1;
		}
		
		if (system("nfree $pid $eid @physnodes")) {
		    print "Failed to nfree unused physnodes!\n";
		    return 1;
		}
	    }
	}
    }

    # Exit here if we are testing.
    if ($TESTMODE) {
	print "Testing run - Stopping here.\n";
	return 0;
    }

    #
    # Handle tarballs - we might need to fetch some from URLs if the user
    # asked for that.
    #
    print "Fetching tarballs and RPMs (if any) ...\n";
    TBDebugTimeStamp("tarfiles_setup started");

    if (system("tarfiles_setup $pid $eid")) {
	#
	# No recovery for now - what would we do?
	#
	tberror "Failed to set up tarballs.";
	return 1;
    }
    TBDebugTimeStamp("tarfiles_setup finished");

    #
    # If there are any Plab dslice nodes in the experiment, create the
    # dslice now
    #
    if ($type > UPDATE_RECOVER) {
	# Are there any Plab nodes?
	$db_result =
	    DBQueryFatal("select n.node_id from nodes as n ".
			 "left join node_types as nt on n.type = nt.type ".
			 "left join reserved as r on r.node_id = n.node_id ".
			 "where r.pid='$pid' and r.eid='$eid' ".
			 " and nt.isplabdslice = 1");

	if ($db_result->numrows) {
	    # Does slice already exist?
	    $db_result =
		DBQueryFatal("select slicename from plab_slices ".
			     "where pid='$pid' and eid='$eid'");

	    if (! $db_result->numrows) {
		my @plabnodes = ();
		
		while (my ($node) = $db_result->fetchrow_array()) {
		    push(@plabnodes, $node);
		}
		
		print "Creating Planetlab slice.\n";
		TBDebugTimeStamp("plabslice create started");
		if (system("plabslice create $pid $eid")) {
		    tberror "Failed to create Plab dslice";
		    return 3;
		}
		TBDebugTimeStamp("plabslice alloc finished");
	    }
	}
    }

    # Check cancel flag before continuing. No retry, 
    TBGetCancelFlag($pid, $eid, \$canceled);
    return 1
	if ($canceled);

    #
    # These things need to get started before the nodes come up, so we'll
    # do them before the os_setup. Everything else can done in parallel with
    # os_setup. (Actually, these probably can too, since they should finish
    # long before the nodes reboot, but better safe than sorry)
    #
    print "Setting up mountpoints.\n";
    TBDebugTimeStamp("mountpoints started");
    if (system("exports_setup")) {
	tberror "Failed to setup mountpoints.";
	return 1;
    }
    TBDebugTimeStamp("mountpoints finished");

    TBDebugTimeStamp("named started");
    print "Setting up named maps.\n";
    if (system("named_setup")) {
	tbwarn "Failed to add node names to named map.";
	#
	# This is a non-fatal error.
	#
    }
    TBDebugTimeStamp("named finished");

    print "Cleaning NFS traces.\n";
    TBDebugTimeStamp("nfstrace gc started");
    if (system("nfstrace gc $pid $eid")) {
	tberror "Failed to setup nfstrace.";
	return 1;
    }
    TBDebugTimeStamp("nfstrace gc finished");

    # Check cancel flag before continuing. No retry, 
    TBGetCancelFlag($pid, $eid, \$canceled);
    return 1
	if ($canceled);

    #
    # Setup any control-net firewall.
    # This must be done before reloading and rebooting nodes.
    #
    if ($firewalled && ($type == REAL || $type == UPDATE) &&
	doFW($pid, $eid, (($type == UPDATE) ? FWADDNODES : FWSETUP), undef)) {
	return 1;
    }

    #
    # If user specified -reboot to update,
    # and we are successfully performing the update,
    # then mark all nodes in experiment so os_setup will reboot them.
    #
    if (($type == UPDATE) &&
	($updateReboot || $updateReconfig)) {
	print STDERR "Marking nodes for reboot/reconfig.\n";
	$db_result =
	    DBQueryFatal("select r.node_id,n.allocstate from reserved as r ".
			 "left join nodes as n on n.node_id=r.node_id ".
			 "where r.pid='$pid' and r.eid='$eid'");

	while (my ($node,$allocstate) = $db_result->fetchrow_array) {
	    #
	    # If the node is INIT_CLEAN, leave it alone. It will still get
	    # rebooted, but will not falsely be tagged as dirty. This is
	    # important for vnodes too, where INIT_CLEAN indicated the vnode
	    # does not even exist yet (plab nodes).
	    #
	    if ($allocstate ne TBDB_ALLOCSTATE_RES_INIT_CLEAN()) {
		TBSetNodeAllocState($node,
				    ($updateReboot ?
				     TBDB_ALLOCSTATE_RES_INIT_DIRTY() :
				     TBDB_ALLOCSTATE_RES_RECONFIG()));
	    }
	}
    }

    #
    # Lets run gentopofile again, so we get ltmap right. This will come out
    # later, most likely.
    #
    TBDebugTimeStamp("gentopofile started");
    print "Generating ltmap (again) ...\n";

    if (system("gentopofile $pid $eid")) {
        tberror("gentopofile failed!");
	return 1;
    }
    TBDebugTimeStamp("gentopofile finished");

    #
    # Since it'll take a while for the nodes to reboot, we'll start now, and
    # wait for the os_setup to finish, down below
    #
    print "Resetting OS and rebooting.\n";
    TBDebugTimeStamp("launching os_setup");
    if (!($os_setup_pid = fork())) { 
	exec("os_setup $pid $eid") or return 1;
    } elsif ($os_setup_pid == -1) {
	tberror "Fork failed.";
	return 1;
    }

    #
    # XXX
    # Don't add any steps between here and the waitpid() call below
    # without verifying that 1) It's OK for nodes to come up before
    # the step has completed and 2) It's OK for the command to run in
    # parallel with os_setup (no DB dependencies, etc.)
    #

    print "Setting up VLANs.\n";
    TBDebugTimeStamp("snmpit started");
    if (system("snmpit -t $pid $eid")) {
	tberror "Failed to set up VLANs.";
	return 1;
    }
    TBDebugTimeStamp("snmpit finished");

    #
    # An error now means that the VLANS need to be cleaned up.
    #
    $cleanvlans = 1;

    print "Setting up email lists.\n";
    TBDebugTimeStamp("genelists started");
    if (system("genelists -t")) {
	tbwarn "Failed to update email lists.";
	#
	# This is a non-fatal error.
	# 
    }
    TBDebugTimeStamp("genelists finished");

    #
    # Don't clear port counters on UPDATE.
    # (XXX should clear new nodes' port counters.)

    if ($type >= RETRY) {
	print "Clearing port counters.\n";
	TBDebugTimeStamp("portstats started");
	if (system("portstats -z -a -q $pid $eid")) {
	    tbwarn "Failed to clear port counters.";
	    #
	    # This is a non-fatal error.
	    # 
	}
	TBDebugTimeStamp("portstats finished");
    }

    #
    # OK, let's see how that os_setup did
    #
    $kid = waitpid($os_setup_pid,0);
    if ($kid == $os_setup_pid) {
	undef $os_setup_pid; # Make sure doswapout() doesn't wait for it.
	if ($CHILD_ERROR) {
	    tberror "Failed to reset OS and reboot nodes.";
	    #
	    # If there is a firewall involved, it could be that the
	    # firewall rules are preventing essential communication,
	    # so don't retry.
	    #
	    # XXX should only do this if the user has specified additional
	    # rules.  But right now, I may screw up too!
	    #
	    if ($firewalled) {
		print STDERR "Not retrying, ".
		    "firewall may be preventing setup.\n";
		return 1;
	    }

	    #
	    # Use returncode from os_setup process to
	    # set global $retry flag, indicating to caller
	    # that it may be beneficial to attempt
	    # a doSwapin() again.
	    #
            if (($CHILD_ERROR >> 8) == 1) {
		return 3;
	    } else {
		print STDERR "Not retrying due to error type.\n";
		return 1;
	    }
	}
    } else {
	undef $os_setup_pid;
	tberror "Error waiting for os_setup to finish.";
	return 1;
    }

    #
    # Okay, start the event system now that we know all the nodes have
    # rebooted (os_setup is done). This only takes a moment (puts itself
    # in the background), so its not enough of a delay to worry about.
    # Don't do this during an update, since we didn't kill the 
    # event system previously, so starting it again will fail!
    # 
    if (! ($DISABLE_EVENTS || $elabinelab)) {
	#
	# For the robot testbed, start the location piper *before* the event
	# system.
	#
	if (-x $piper && ($type != UPDATE && $type != UPDATE_RECOVER)) {
	    print "Starting the location piper.\n";
	    if (system("$piper $pid $eid")) {
		tberror "Failed to start the location piper.";
		return 1;
	    }
	}
	
	if ( $update_Eventsys_restart || 
	    ($type != UPDATE && $type != UPDATE_RECOVER) ) {
	    print "Starting the event system.\n";
	    TBDebugTimeStamp("eventsys_control started");
	    if (system("eventsys_control start $pid $eid")) {
		tberror "Failed to start the event system.";
		return 1;
	    }
	    TBDebugTimeStamp("eventsys_control finished");
	}
    }

    #
    # Do linktest if user requested it at swapin.
    #
    my $query_result =
	DBQueryFatal("select linktest_level,linktest_pid from experiments ".
		     "where pid='$pid' and eid='$eid'");
    my ($linktest_level,$linktest_pid) = $query_result->fetchrow_array();

    # Temporary. Only studly users get to control linktest level.
    # Mere users always get at least level three.
    $query_result =
	DBQueryFatal("select stud from users where uid='$dbuid'");
    my ($studly) = $query_result->fetchrow_array();

    if (! $studly) {
	$linktest_level = ($linktest_level <= 3 ? 3 : $linktest_level);
    }
 
    if ($linktest_level && ($type == REAL || $type == UPDATE)) {
	if ($linktest_pid) {
	    print STDERR "*** Linktest is already running! $linktest_pid\n";
	}
	else {
	    #
	    # Run it. No worries about failures.
	    #
	    my $optarg = "-l $linktest_level -t 600 -m";
    
	    print "Starting linktest ... this could take a while!'\n";
	    if (system("linktest_control $optarg $pid $eid") != 0) {
		print STDERR "*** Linktest run returned non-zero status!\n";
	    }
	}
    }

    #
    # ElabinElab setup. This might not be the right place for this!
    #
    if ($elabinelab && !$TESTMODE && ($type == REAL || $type == UPDATE)) {
	my $optarg = ($type == UPDATE ? "-u" : "");
	
	print "Setting up elabinelab. This could take a while!\n";
	TBDebugTimeStamp("elabinelab setup started");
	if (system("elabinelab $optarg $pid $eid")) {
	    tberror "Failed to setup elabinelab!";
	    return 1;
	}
	TBDebugTimeStamp("ElabInElab setup finished");
    }

    #
    # Tell the event scheduler to START.
    # 
    if (! ($DISABLE_EVENTS || $elabinelab)) {
	if ( $update_Eventsys_restart || 
	    ($type != UPDATE && $type != UPDATE_RECOVER) ) {
	    TBDebugTimeStamp("Starting event time");
	    if (system("tevc -e $pid/$eid now __ns_sequence start")) {
		print STDERR "*** Failed to start event time.\n";
		return 1;
	    }
	}
    }

    return 0;
}

#
# Setup and teardown experiment firewall.
#
# XXX note that right now, we just setup the switch infrastructure
# first, and then just let everything else go.  Firewalled nodes will
# not boot until the firewall is up since the VLAN is isolated til then.
# The firewall will boot ok since it still talks to the real control net.
#
# XXX for tearing down firewalls, we assume that nodes have been "cleansed"
# and it is safe to put ports back into the default control net VLAN.
#
sub doFW($$$$) {
    my ($pid, $eid, $action, $nodelist) = @_;
    my ($fwnode, $fwvlanname, $fwvlan, $fwport, $fwvid);
    my %nodenames;

    #
    # See if there is a firewall, fetching node/VLAN info if so.
    # If not, we are all done.
    #
    if (!TBExptFirewall($pid, $eid, \$fwnode, \$fwvid, \$fwvlan)) {
	return 0;
    }

    if ($action == FWSETUP) {
	$fwvid = TBGetUniqueIndex("cnet_vlanid");

	print "Setting up control net firewall.\n";
    }
    else {
	if ($action == FWADDNODES) {
	    print "Adding nodes to control net firewall.\n";
	}
	elsif ($action == FWDELNODES) {
	    print "Removing nodes from control net firewall.\n";
	}
	else {
	    print "Tearing down control net firewall.\n";
	}

	# Prior setup didn't succeed, nothing to do
	if (!defined($fwvid)) {
	    return 0;
	}
    }

    # See below.
    if (defined($nodelist)) {
	foreach my $node (@$nodelist) {
	    $nodenames{$node} = $node;
	}
    }

    # XXX vlanid in the DB is currently an int, we need a more unique name
    $fwvlanname = "fw$fwvid";

    #
    # Find all the experiment nodes and their control interface switch ports
    #
    # XXX this may be replaced by a call to SNMPIT that just specifies
    # the pid/eid.  In that case someone else will first have to poplulate
    # the vlans table with this same info. 
    #
    my $db_result =
	DBQueryWarn("SELECT r.node_id,w.card1 ".
		    "  FROM wires AS w, reserved AS r ".
		    "WHERE r.node_id=w.node_id1 AND r.pid='$pid' ".
		    "  AND r.eid='$eid' AND w.type='Control'");
    return 1
	if (!$db_result);

    my $portlist = "";
    while (my ($node,$cif) = $db_result->fetchrow_array()) {
	print "$node $cif\n";
	if ($node eq $fwnode) {
	    $fwport = "$node:$cif";
	}
	elsif (defined($nodelist)) {
 	    print "foo @$nodelist\n";
	    # Only nodes we are moving in/out of the experiment.
	    $portlist .= " $node:$cif"
		if (exists($nodenames{$node}));
	}
	else {
	    $portlist .= " $node:$cif";
	}
    }
    if (!defined($fwport)) {
	tberror "Firewall node '$fwnode' not found in $pid/${eid}!";
	return 0;
    }
    if ($portlist eq "") {
	#
	# We catch this up in swapexp; admin users can specify just a firewall,
	# but mere users must have at least one firewalled node. Just print
	# the warning though. 
	# 
	tberror "No firewalled nodes in $pid/${eid}!";
    }

    #
    # XXX hack commands til we nail down the API
    #
    my $fwsetupstr1 = "snmpit $cnetstack -m $fwvlanname $portlist";
    my $fwsetupstr2 = "snmpit $cnetstack -N $fwvlanname";
    my $fwsetupstr3 = "snmpit $cnetstack -T $fwport $cnetvlanname $fwvlanname";
    my $fwtakedownstr0 = "snmpit $cnetstack -e $fwport";
    my $fwtakedownstr1 = ($portlist eq "" ? "true" :
			  "snmpit $cnetstack -m $cnetvlanname $portlist");
    my $fwtakedownstr2 = "snmpit $cnetstack -o $fwvlanname";
    my $fwtakedownstr3 = "snmpit $cnetstack -U $fwport";
    my $fwtakedownstr4 = "snmpit $cnetstack -m $cnetvlanname $fwport";

    if ($action == FWSETUP) {
	TBDebugTimeStamp("snmpit firewall setup: VLAN");
	print "doFW: '$fwsetupstr1'\n";
	if (system($fwsetupstr1)) {
	    tberror "Failed to setup Firewall control net VLAN.";
	    return 1;
	}
	#
	# XXX we don't need to rely on the format of the output of
	# the snmpit 
	#
	my @snmpit_out = split(' ', `$fwsetupstr2`);
	if ($? || @snmpit_out != 3 || $snmpit_out[2] !~ /^\d+$/) {
	    tberror "Could not get VLAN number for firewall VLAN, ".
		    "is your snmpit out of date?\n";
	    return 1;
	}
	my $fwvlan = $snmpit_out[2];

	TBDebugTimeStamp("snmpit firewall setup: trunk");
	print "doFW: '$fwsetupstr3'\n";
	if (system($fwsetupstr3)) {
	    tberror "Failed to setup Firewall trunk on port $fwport.";
	    if (system($fwtakedownstr1)) {
		tberror "Could not return $portlist to Control VLAN!";
	    }
	    if (system($fwtakedownstr2)) {
		tberror "Could not destroy VLAN $fwvlanname ($fwvlan)!";
	    }
	    return 1;
	}
	TBDebugTimeStamp("snmpit firewall setup done");

	# Record VLAN info now that everything is done
	TBSetExptFirewallVlan($pid, $eid, $fwvid, $fwvlan);
    }
    elsif ($action == FWADDNODES) {
	TBDebugTimeStamp("snmpit firewall port addition");
	print "doFW: '$fwsetupstr1'\n";
	if (system($fwsetupstr1)) {
	    tberror "Failed to add nodes to Firewall control net VLAN.";
	    return 1;
	}
	TBDebugTimeStamp("snmpit firewall setup done");
    }
    elsif ($action == FWDELNODES) {
	TBDebugTimeStamp("snmpit firewall port deletion");
	print "doFW: '$fwtakedownstr1'\n";
	if (system($fwtakedownstr1)) {
	    tberror "Failed to remove nodes from Firewall control net VLAN.\n";
	    return 1;
	}
	TBDebugTimeStamp("snmpit firewall setup done");
    }
    else {
	TBDebugTimeStamp("snmpit re-enable fw control port: $fwport");
	print "doFW: '$fwtakedownstr0'\n";
	my $failed = 0;
	if (system($fwtakedownstr0)) {
	    tberror "Could not re-enable firewall control port $fwport!";
	    $failed = 1;
	}
	TBDebugTimeStamp("snmpit firewall teardown: VLAN");
	print "doFW: '$fwtakedownstr1'\n";
	if (system($fwtakedownstr1)) {
	    tberror "Could not return $portlist to Control VLAN!";
	    $failed = 1;
	}
	print "doFW: '$fwtakedownstr2'\n";
	if (system($fwtakedownstr2)) {
	    tberror "Could not destroy VLAN $fwvlanname ($fwvlan)!";
	    $failed = 1;
	}
	TBDebugTimeStamp("snmpit firewall teardown: trunk");
	print "doFW: '$fwtakedownstr3'\n";
	if (system($fwtakedownstr3)) {
	    tberror "Could not tear down trunk on $fwport!";
	    $failed = 1;
	}
	print "doFW: '$fwtakedownstr4'\n";
	if (system($fwtakedownstr4)) {
	    tberror "Could not return $fwport to Control VLAN!";
	    $failed = 1;
	}
	if ($failed) {
	    return 1;
	}
	TBDebugTimeStamp("snmpit firewall teardown done");

	# Clean VLAN info from DB
	TBClearExptFirewallVlan($pid, $eid);
    }
    return 0;
}

#
# Undo the firewall state for a set of nodes in the indicated experiment.
# If no nodes are specified, we remove all nodes and tear down the firewall.
#
# This function takes care of ensuring that all such nodes have been
# neutered prior to being released:
#
# Change the OSID of all nodes (firewall included) to reboot into
# the admin MFS and then power cycle them.  We must power cycle to
# ensure nodes don't spoof a simple reboot request and pretend to
# come up in the MFS.  The power "cycle" is actually an "off"
# followed by an "on", since true power cycling of large numbers
# of nodes may be done in batches to avoid network (or power)
# overload on restart.  Skewed reboots like this open a window of
# vulnerability where nodes rebooted later might be able, before
# they are rebooted, to spoof the reload server for nodes that have
# just rebooted.  So we first turn everyone off, then batched power
# ons are safe.
#
# Note that we take down the firewall while the nodes are turned
# off.  This is a convenient time while we know no nodes are in
# transition.  Plus, since we take down the firewall too, other
# nodes would not be able to reboot if we left the firewall up.
#
# BIG SECURITY ASSUMPTION: we are assuming that upon power on,
# no node can somehow reboot from the hard disk instead of
# from the network.  If it does, it is out from behind the
# firewall and can wreak havoc.
#
sub undoFWNodes($$;@) {
    my ($pid, $eid, @nodes) = @_;
    my $doall = 0;
    my $fwerr     = 0;
    my @fwstate   = ();

    if (!defined(@nodes) || @nodes == 0) {
	@nodes = ExpNodes($pid, $eid, 1);
	$doall = 1;
    }

    #
    # There has to at least be a firewall node to be interesting
    #
    if (@nodes == 0) {
	return 0;
    }

    if ($doall) {
	print "Taking down experiment firewall.\n";
    } else {
	my $fwnode;
	TBExptFirewall($pid, $eid, \$fwnode);
	if (grep {$_ eq $fwnode} @nodes) {
	    tberror "Cannot remove firewall node from an experiment!";
	    return 1;
	}
	print "Removing firewalled nodes from experiment.\n";
    }

    #
    # First turn off all the machines.
    # If we fail, the firewall in left in place, and some nodes may
    # be powered off.
    #
    print STDERR "Powering down firewalled nodes.\n";
    TBDebugTimeStamp("Powering down nodes");
    system("power off @nodes");
    if ($?) {
	$fwerr = "Failed to power off all nodes!";
	@fwstate = ("Firewall is still in place",
		    "Some nodes may NOT be powered off",
		    "Nodes NOT switched to admin MFS");
	goto done;
    }

    #
    # Force all nodes into admin mode.
    # If we fail, the firewall is left in place.
    #
    my %myargs;
    $myargs{'name'} = "tbswap";
    $myargs{'on'} = 1;
    $myargs{'clearall'} = 1;
    if (TBAdminMfsSelect(\%myargs, undef, @nodes)) {
	$fwerr = "Failed to force all nodes into admin mode!";
	@fwstate = ("Firewall is still in place",
		    "All nodes are powered off",
		    "Not all nodes have been switched to admin MFS");
	goto done;
    }

    #
    # Once all nodes have been turned off and their DB state changed
    # to force MFS booting, we can take modify the switch firewall state,
    # either tearing down the firewall ($doall) entirely or just moving
    # the indicated nodes out from behind it (!$doall).
    #
    # If this fails, we warn and punt.  The switch or DB state could
    # be screwed up at this point.
    #
    if ($doall) {
	if (doFW($pid, $eid, FWTEARDOWN, undef)) {
	    $fwerr = "Failed to tear down firewall!";
	    @fwstate = ("Firewall may NOT be in place",
			"All nodes are powered off",
			"All nodes set to admin mode",
			"Switch/DB firewall state could be inconsistent!");
	    goto done;
	}
    } else {
	my @deleted = @nodes;
	if (doFW($pid, $eid, FWDELNODES, \@deleted)) {
	    $fwerr = "Failed to remove nodes from firewall VLAN!";
	    @fwstate = ("Nodes may still be in firewall VLAN",
			"All nodes are powered off",
			"All nodes set to admin mode");
	    goto done;
	}
    }

    #
    # Now we power on the nodes and let them boot into the MFS,
    # where they will run the disk bootblock zapper.
    #
    # If this fails, we power off all the nodes again and get a
    # little edgy in our error messages to emphasize the gravity
    # of the situation.  Someday we could just move the failed
    # nodes into a special firewalled holding experiment, and
    # let the experiment swapout finish, freeing up the nodes that
    # did succeed.
    #
    print STDERR "Booting nodes into admin MFS and zapping bootblocks.\n";
    TBDebugTimeStamp("Booting admin MFS/zapping bootblocks");
    my @failed = ();
    %myargs = ();
    $myargs{'name'} = "tbswap";
    $myargs{'command'} = "sudo /usr/local/bin/diskzap";
    $myargs{'poweron'} = 1;
    if (TBAdminMfsRunCmd(\%myargs, \@failed, @nodes)) {
	$fwerr = "Failed to invalidate bootblocks on @failed!";
	@fwstate = ("Firewall is NOT in place",
		    "All nodes set to admin mode");
	system("power off @nodes");
	if ($?) {
	    push(@fwstate, "Some nodes may NOT be powered off");
	} else {
	    push(@fwstate, "All nodes are powered off");
	}
	push(@fwstate, "MAKE SURE THESE NODES DO NOT BOOT FROM DISK!");
    }
done:
    #
    # If we had a failure when tearing down the firewall completely,
    # we act as though the panic button had been pressed (set panic
    # bit in DB, disable cnet port, and inform tbops).  This hopefully
    # ensures that everything will get cleaned up correctly.  This may
    # eventually prove to be overkill.
    #
    # If we failed while removing some nodes from behind the firewall
    # we don't get quite so cranky.
    #
    if ($fwerr) {
	my $op;

	if ($doall) {
	    my ($fwnode, $fwport);
	    if (!TBExptFirewallAndPort($pid, $eid, \$fwnode, \$fwport) ||
		system("snmpit -d ${fwnode}:${fwport}") != 0) {
		push(@fwstate, "Firewall cnet interface NOT disabled");
	    } else {
		push(@fwstate, "Firewall cnet interface disabled");
	    }
	    TBExptSetPanicBit($pid, $eid, 2);
	    $op = "Swapout";
	} else {
	    $op = "Modify";
	}

	tberror "$fwerr" . "\nINFORMING $TBOPS!";
	if (defined($umail)) {
	    SENDMAIL("$uname <$umail>",
		     "Firewalled experiment $op failed".
		     " for $pid/$eid",
		     "$op of firewalled experiment $pid/$eid".
		     " by $dbuid failed!\n".
		     "Admin intervention required:\n\n$fwerr\n\n".
		     "Current state of @nodes:\n\n".
		     join("\n", @fwstate) . "\n",
		     "$uname <$umail>",
		     "Cc: $TBOPS");
	}
	return 1;
    }

    return 0;
}

#
# Monitor the progress of swapout image creation.
# This is a lot like regular image creation: we make sure that progress
# is being made (the image is growing) and abort if not.
#
sub doSwapoutProgress($%)
{
    my ($mystate, $status) = @_;
    my $perminute = int(60 / $mystate->{'_interval'});
    my $iterations = $mystate->{'_iterations'};

    my @running = grep { $status->{$_} eq "none" } keys(%$status);
    if (@running == 0) {
	return 0;
    }

    #
    # Make a generic progress report
    #
    if ((++$iterations % $perminute) == 0) {
	print "swapimage: still running after ",
	$iterations / $perminute,
	" minutes: @running\n";
    }

    #
    # Of the nodes still running, determine which are not making progress
    # and fail them.
    # 
    my $curtime = time();
    foreach my $node (@running) {
	my $nstate = $mystate->{$node};
	my $fname = $nstate->{'name'};
	my $fsize = $nstate->{'size'};
	my $ftime = $nstate->{'time'};

	# XXX
	$ftime = ($curtime - $mystate->{'_interval'})
	    if ($ftime == 0);

	#
	# If no progress, see if we should timeout
	#
	my $cursize = (stat($fname))[7];
	if (!defined($cursize) || $cursize == $fsize) {
	    if ($curtime - $ftime > $mystate->{'_timeout'}) {
		tbwarn("$node: no progress saving state after " .
		       int(($curtime - $ftime) / 60) .
		       " minutes, terminating state save for this node\n");
		$status->{$node} = "timeout";
	    }
	    if (defined($cursize)) {
		print "$node: imagefile has not grown (still at $cursize bytes) in the last";
	    } else {
		print "$node: imagefile does not exist after";
	    }
	} else {
	    $nstate->{'size'} = $cursize;
	    $nstate->{'time'} = $curtime;
	    print "$node: imagefile grew from $fsize to $cursize in";
	}
	print " ", int($curtime - $ftime), " seconds\n";
    }

    $mystate->{'_iterations'} = $iterations;

    return 1;
}

#
# Handle swapout time actions.
# Returns zero if successful, non-zero otherwise.
#
sub doSwapoutAction($$%)
{
    my ($pid, $eid, %soaction) = @_;

    # swapout disk image related state
    my $statesavecmd = "/usr/local/bin/create-swapimage";
    my $stateinterval = 60;
    my $statetimeout = (5 * 60);
    my %state = ();

    my %nodes = ExpNodeVnames($pid, $eid, 1);
    my @pnodes = keys(%nodes);
    if (@pnodes > 0) {
	print STDERR "Performing swapout admin MFS actions.\n";
	TBDebugTimeStamp("Performing swapout actions");
	my @failed = ();
	my %myargs = ();
	$myargs{'name'} = "tbswap";
	$myargs{'command'} = $soaction{'command'};
	if (defined($soaction{'timeout'})) {
	    $myargs{'timeout'} = $soaction{'timeout'};
	}
	$myargs{'timestamp'} = 1;

	#
	# If this is swapout disk state saving, we do lots o stuff.
	#
	if ($soaction{'command'} =~ /^$statesavecmd/) {
	    #
	    # Setup a progress function
	    #
	    $myargs{'pfunc'} = \&doSwapoutProgress;
	    $myargs{'pinterval'} = $stateinterval;
	    $myargs{'pcookie'} = \%state;

	    $state{'_interval'} = $stateinterval;
	    $state{'_timeout'} = $statetimeout;
	    $state{'_iterations'} = 0;
	    my $swapdir = "/proj/$pid/exp/$eid/swapinfo";
	    my @enodes = ();
	    foreach my $node (@pnodes) {
		my $vname = $nodes{$node};

		#
		# XXX time saving hack.
		#
		# If the swap state files don't exist, don't bother to boot
		# the node into the MFS.  Complain about unsaved nodes unless
		# they are delay nodes.
		#
		if (! -r "$swapdir/$vname.part" || ! -r "$swapdir/$vname.sig") {
		    # XXX should do this based on role, not name
		    if ($vname !~ /^tbs?delay\d+$/) {
			tbwarn "no swap info for $node ($vname), ".
			    "not saving disk state!";
		    }
		    next;
		}
		push(@enodes, $node);
		$state{$node} = {
		    'name' => "$swapdir/$vname-swap.ndz",
		    'time' => 0,
		    'size' => 0
		};
	    }
	    @pnodes = @enodes;
	}

	if (TBAdminMfsRunCmd(\%myargs, \@failed, @pnodes)) {
	    if ($soaction{'isfatal'}) {
		tberror
		    "Failed to run '" . $soaction{'command'} . "' on @failed!";
		return 1;
	    }
	    tbwarn
		"Failed to run '" . $soaction{'command'} . "' on @failed!";
	}
    }

    return 0;
}
