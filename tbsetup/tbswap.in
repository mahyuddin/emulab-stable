#!/usr/bin/perl -w

#
# EMULAB-COPYRIGHT
# Copyright (c) 2000-2004 University of Utah and the Flux Group.
# All rights reserved.
#
use English;

# Returns 0 on success.
# Returns 1 on non-assign_wrapper failure.
# Returns (1 | assign_wrapper's errorcode) on assign_wrapper failure.
# Returns |0x40 if update caused a swapout. Icky.
# Returns -1 on uncontrolled error (die called).

# XXX: handle error cases for update? (backup the db?)
# XXX: Shouldn't do idempotent stuff twice for update.
# XXX: repush/calc routing for update??? (tbprerun)
# XXX: previz for update???              (tbprerun)
# XXX: make snmpit faster for update.
#
# XXX: for update, expt is swapped out on os_setup fail.
#      (we only recover if assign fails)

sub usage()
{
    print STDERR "Usage: $0 -force { in | out | update [-reboot] [-eventsys_restart] } pid eid\n";
    exit(-1);
}

#
# Configure variables
#
my $TBROOT         = "@prefix@";
my $TESTMODE       = @TESTMODE@;
my $DISABLE_EVENTS = "@DISABLE_EVENT_SCHED@";

# Untaint the path
$ENV{'PATH'} = "/usr/bin:$TBROOT/libexec:$TBROOT/libexec/ns2ir" . 
    ":$TBROOT/sbin:$TBROOT/bin";

#
# Testbed Support libraries
#
use lib "@prefix@/lib";
use libdb;
use libtestbed;
require exitonwarn; # exitonwarn isn't really a module, so just require it

#
# Actual swap-in and swap-out functions, defined below.
#
sub doSwapout($);
sub doSwapin($);

#
# Firewall stuff
# XXX maybe should be elsewhere
#
sub FWSETUP()  { return 1; }
sub FWTEARDOWN()  { return 2; }
sub doFW($$$);

# XXX fixme: should not be hardwired!
my $cnetstack = "-S cisco2";
my $cnetvlanname = "Control";


sub REAL()    { return 4; }
sub CLEANUP() { return 3; }
sub RETRY()   { return 2; }
sub UPDATE()  { return 1; }
sub UPDATE_RECOVER()  { return 0; }

#
# Turn off line buffering on output
#

$| = 1;

my $updateReboot   = 0;
my $updateReconfig = 1;
my $update_Eventsys_restart = 0;
my $elabinelab     = 0;
my $force  = 0;
my $errors = 0;
my $updatehosed = 0;
my $state;
my $canceled;
my $os_setup_pid;
my $cleanvlans;
my $nextState;

#
# First argument is either "in", "out", or "update";
# this value goes into $swapop.
#

my $swapop = shift;	

if (!$swapop || 
    (($swapop ne "in") && 
     ($swapop ne "out") &&
     ($swapop ne "update"))) {
    usage();
}

#
# Get other arguments.
#

while ($#ARGV > 1) {
    $arg = shift;
    if ($arg eq "-force") {
	$force = 1;
    } elsif ($arg eq "-reboot") {
	$updateReboot = 1;
	$updateReconfig = 0;
    } elsif ($arg eq "-noreconfig") {
	$updateReboot   = 0;
	$updateReconfig = 0;
    } elsif ($arg eq "-eventsys_restart" && $swapop eq "update") {
	$update_Eventsys_restart = 1;
    } else {
	usage();
    }
}
if ($#ARGV < 1) {
    usage();
}
my ($pid,$eid) = @ARGV;

#
# Untaint the arguments.
#
if ($pid =~ /^([-\@\w.]+)$/) {
    $pid = $1;
}
else {
    die("Tainted argument $pid!\n");
}
if ($eid =~ /^([-\@\w.]+)$/) {
    $eid = $1;
}
else {
    die("Tainted argument $eid!\n");
}

TBDebugTimeStampsOn();

#
# Print starting message.
#

print "Beginning swap-$swapop for $pid/$eid. " . TBTimeStamp() . "\n";
TBDebugTimeStamp("tbswap $swapop started");

#
# Get experiment state; verify that experiment exists.
#
if (! ($state = ExpState($pid, $eid))) {
    die("*** $0:\n".
	"    No such experiment $pid/$eid\n");
}
# Sanity check the current state. 
if (!$force) {
    if ($swapop eq "in") {
	die("*** $0:\n".
	    "    Experiment should be ACTIVATING. Currently $state.\n")
	    if ($state ne EXPTSTATE_ACTIVATING);
    }
    elsif ($swapop eq "out") {
	die("*** $0:\n".
	    "    Experiment should be SWAPPING. Currently $state.\n")
	    if ($state ne EXPTSTATE_SWAPPING);
    }
    elsif ($swapop eq "update") {
	die("*** $0:\n".
	    "    Experiment should be MODIFY_RESWAP. Currently $state.\n")
	    if ($state ne EXPTSTATE_MODIFY_RESWAP);
    }
}
# Get elabinelab status. See below.
if (! TBExptIsElabInElab($pid, $eid, \$elabinelab)) {
    die("*** $0:\n".
	"    Could not get elabinelab status for experiment $pid/$eid\n");
}

#
# See if the experiment is firewalled
#
my $firewalled = TBExptFirewall($pid, $eid);

#
# Do actual swapping
#
if ($swapop eq "out") {
    #
    # Swap out
    #
    $errors = doSwapout(REAL);
}
elsif ($swapop eq "update") {

    #
    # Disallow modification of firewalled experiments til we figure
    # out how to do it right.
    #
    if ($firewalled) {
	print STDERR "Cannot modify firewalled experiment right now.\n";
	print "Failingly finished swap-$swapop for $pid/$eid. ".TBTimeStamp()."\n";
	TBDebugTimeStamp("tbswap $swapop finished (failed)");
	exit(1);
    }

    #
    # Update.
    #
    # Phase One -- swap experiment partially out.
    #
    print STDERR "Backing up physical state...\n";
    TBExptBackupPhysicalState($pid,$eid);

    $errors = doSwapout(UPDATE);

    if ($errors) {
	#
	# Clean up the mess, leaving the experiment in the SWAPPED state,
	# 
	print STDERR "Cleaning up after errors.\n";
	doSwapout(CLEANUP);
	$updatehosed = 1;
    }
    else {
	#
	# Phase Two -- swap experiment back in.
	#
	$errors = doSwapin(UPDATE);

	if ($errors) {
	    #
	    # There were errors; see if we can recover.
	    #
	    my $CanRecover = 1;

	    if ($errors != 7) {
		print STDERR "Update failure occurred _after_ assign phase; ";
		$CanRecover = 0;
	    }

	    if ($CanRecover) {
		print STDERR "Recovering virtual and physical state.\n";

		if (TBExptRemoveVirtualState($pid, $eid) ||
		    TBExptRestoreVirtualState($pid, $eid) ||
		    TBExptRestorePhysicalState($pid,$eid)) {
		    print STDERR "Could not restore backed-up state; ";
		    $CanRecover = 0;
		}
		else {
		    print STDERR "Doing a recovery swap-in of old state.\n";

		    if (doSwapin(UPDATE_RECOVER)) {
			print STDERR "Could not swap in old physical state; ";
			$CanRecover = 0;
		    }
		}
	    }

	    #
	    # Some part of the recovery failed; must swap it out. swapexp
	    # (caller) will then have to do more clean up, hence the special
	    # exit status indicated by $updatehosed.
	    # 
	    if (! $CanRecover) {
		print STDERR "Recovery aborted! Swapping experiment out.\n";
		doSwapout(CLEANUP);
		$updatehosed = 1;
	    }
	    else {
		print STDERR "Update recovery successful.\n";
	    }
	}
    }
}
elsif ($swapop eq "in") {
    #
    # Swap in
    #
    my $retries = 2;
    
    $errors = doSwapin(REAL);

    #
    # Attempt a retry if: 
    #   a) there were errors, 
    #   b) doswapin() indicated (via return code 3) a retry is appropriate,
    #   c) we haven't tried too many times already.
    #   d) The cancelflag has not been set.
    #   e) $TESTMODE == 0.
    #
    while ($errors == 3 && $retries && !$canceled && !$TESTMODE) {
	$retries--;

	print STDERR "Cleaning up after errors; will try again.\n";
	doSwapout(RETRY);

	print STDERR "Trying again...\n";
	$errors = doSwapin(RETRY);
    }
    if ($errors || $canceled) {
	print STDERR "Cleaning up after " .
	    ($canceled ? "cancelation" : "errors") . ".\n";
	doSwapout(CLEANUP);
    }
}

#
# Write appropriate message and exit.
#
if ($errors) {
    print "Failingly finished swap-$swapop for $pid/$eid. ".TBTimeStamp()."\n";
    TBDebugTimeStamp("tbswap $swapop finished (failed)");

    # Pass out magic value to indicate that update failed!
    exit(1 | ($updatehosed ? 0x40 : 0));
}
print "Successfully finished swap-$swapop for $pid/$eid. " .TBTimeStamp()."\n";
TBDebugTimeStamp("tbswap $swapop finished (succeeded)");
exit(0);

#################################

##
#
# doSwapout - Swaps experiment out.
#
#             If in REAL or CLEANUP,
#             this function will free all nodes for the 
#             experiment.
#
#             If in RETRY or UDPATE,
#             only nodes not in RES_READY will be freed.
#
#             Returns 0 on success, >0 on failure.
#
##

sub doSwapout($) {
    my $type = shift; # REAL==4, CLEANUP==3, RETRY==2, UPDATE==1.
    my $swapout_errors = 0;

    #
    # wait for os_setup;
    # this only applies if called after a failed doswapin.
    #
    if ($os_setup_pid) {
	print "Waiting for os_setup to finish\n";
	waitpid($os_setup_pid, 0);
	undef $os_setup_pid;
    }

    if (! $TESTMODE) { 
	if (! ($DISABLE_EVENTS || $elabinelab)) {
	    if ($type >= RETRY ||
		($update_Eventsys_restart && $type == UPDATE) ) {
		print "Stopping the event system\n";
		if (system("eventsys_control stop $pid $eid")) {
		    print STDERR "*** Failed to stop the event system.\n";
		    $swapout_errors = 1;
		}
	    }
	}
	
	#
	# Do teardown of inner elab. We must do this before we teardown the
	# vlans since the inner control network is a vlan, and we want that
	# active so inner boss can reboot the inner nodes (avoid power cycle).
	#
	if ($elabinelab) {
	    print "Tearing down elabinelab. This could take a while.\n";
	    if (system("elabinelab -k $pid $eid")) {
		print STDERR "*** Failed to teardown elabinelab!\n";
		$swapout_errors = 1;
	    }
	}

	#
	# Clean up any VLANs in experiment.
	#
	TBDebugTimeStamp("snmpit started");
	print STDERR "Removing VLANs.\n";
	if (system("snmpit -r $pid $eid")) {
	    print STDERR "*** Failed to reset VLANs\n";
	    $swapout_errors = 1;
	} else {
	    $cleanvlans = 0;
	}
	TBDebugTimeStamp("snmpit finished");
    }

    if ($type >= CLEANUP) {
	#
	# We're not attempting a retry;
	#
	# Stop all of the vnodes.
	#
	if (! $TESTMODE) { 	
	    print "Tearing down virtual nodes.\n";
	    TBDebugTimeStamp("vnode_setup -k started");
	    if (system("vnode_setup -d -k $pid $eid")) {
		print STDERR "*** Failed to tear down vnodes.\n";
		$swapout_errors = 1;
	    }
	    TBDebugTimeStamp("vnode_setup finished");
	}

	if ($firewalled) {
	    # XXX put all nodes into admin mode
	    print STDERR "Confining firewalled nodes.\n";
	    TBDebugTimeStamp("moving nodes to purgatory");

	    #
	    # Once all nodes are safely in the admin MFS, we can take
	    # down the firewall
	    #
	    doFW($pid, $eid, FWTEARDOWN);
	}

	#
	# remove all nodes from the experiment.
	# (nfree will send them to RES_FREE_DIRTY)
	#
	print STDERR "Freeing nodes.\n";
	TBDebugTimeStamp("nfree started");
	if (system("nfree $pid $eid")) {
	    print STDERR "*** Could not free nodes.\n";
	    $swapout_errors = 1;
	}
	TBDebugTimeStamp("nfree finished");

	#
	# Since this is an actual swapout, 
	# reset our count of swap out nag emails sent.
	#
	DBQueryWarn("update experiments set swap_requests='',sim_reswap_count='0' ".
		    "where eid='$eid' and pid='$pid'");
    } else {
	#
	# $type == RETRY or $type == UPDATE.
	# Therefore, don't deallocate nodes which have been successfully
	# incorporated into the experiment (i.e., are RES_READY).
	# (nfree will send deallocated nodes to RES_FREE_DIRTY)
	#
	my @failedpnodes = ();
	my @failedvnodes = ();
	
	my $db_result =
	    DBQueryFatal("select rv.node_id,n.allocstate,nt.isvirtnode ".
                         "  from reserved as rv ".
			 "left join nodes as n on n.node_id = rv.node_id ".
			 "left join node_types as nt on nt.type=n.type ".
			 "where rv.pid='$pid' and rv.eid='$eid'");

	while (my ($node,$allocstate,$isvirt) = $db_result->fetchrow_array) {
	    if ($allocstate ne TBDB_ALLOCSTATE_RES_READY()) {
		if ($isvirt) {
		    push(@failedvnodes, $node);
		}
		else {
		    push(@failedpnodes, $node);
		}
	    }
	}

	#
	# Tear down failed vnodes. Perhaps not needed?
	# 
	if (!$TESTMODE && @failedvnodes > 0) {
	    print "Tearing down failed virtual nodes.\n";
	    TBDebugTimeStamp("vnode_setup -k started");
	    if (system("vnode_setup -d -k $pid $eid @failedvnodes")) {
		print STDERR "*** Failed to tear down vnodes.\n";
		$swapout_errors = 1;
	    }
	    TBDebugTimeStamp("vnode_setup -k finished");
	}

	#
	# Release all failed nodes.
	# 
	if (@failedpnodes > 0 || @failedvnodes > 0) {
	    print STDERR "Freeing failed nodes.\n";
	    
	    TBDebugTimeStamp("nfree started");
	    #
	    # Specify -x switch so when a physical node gets freed,
	    # any virtual nodes (owned by this experiment)
	    # sitting on top of it are freed as well.
	    #
	    if (system("nfree -x $pid $eid " .
		       join(" ", (@failedpnodes, @failedvnodes)))) {
		print STDERR "*** Could not free nodes.\n";
		$swapout_errors = 1;
	    }
	    TBDebugTimeStamp("nfree finished");
	}
    }

    if (! $TESTMODE) {
	#
	# If the experiment has no Plab dslice nodes left, but still has
	# a Plab slice, destroy the slice
	#

	# Does the slice exist?
	$db_result =
	    DBQueryFatal("select slicename from plab_slices ".
			 "where pid='$pid' and eid='$eid'");

	if ($db_result->numrows) {
	    # Are there any dslice nodes left?
	    $db_result =
		DBQueryFatal("select n.node_id from nodes as n ".
			     "left join node_types as nt on n.type = nt.type ".
			     "left join reserved as r ".
			     " on r.node_id = n.node_id ".
			     "where r.pid='$pid' and r.eid='$eid' ".
			     " and nt.isplabdslice = 1");

	    if (!$db_result->numrows) {
		print "Destroying Planetlab slice.\n";
		TBDebugTimeStamp("plabslice destroy started");
		if (system("plabslice destroy $pid $eid")) {
		    print STDERR "*** Failed to destroy Plab dslice\n";
		    $swapout_errors = 1;
		}
		TBDebugTimeStamp("plabslice destroy finished");
	    }
	}
    }

    if (! $TESTMODE) {
	#
	# All of these errors are non-fatal on swapout. We find out about them
	# via email sent from the individual scripts.
	#

	#
	# Only reset mountpoints if this is an actual swapout, and
	# not a failed swapin(cleanup), update, or retry.
	#
	if ($type == REAL) {
	    print "Resetting mountpoints.\n";
	    TBDebugTimeStamp("exports started");
	    if (system("exports_setup")) {
		print STDERR "*** Failed to reset mountpoints.\n";
	    }
	    TBDebugTimeStamp("exports finished");
	}

	#
	# Resetting named maps and email lists is fast and idempotent,
	# so whatever.
	#
	print "Resetting named maps.\n";
	TBDebugTimeStamp("named started");
	if (system("named_setup")) {
	    print "*** WARNING: Failed to reset named map.\n";
	}
	TBDebugTimeStamp("named finished");

	print "Resetting email lists.\n";
	TBDebugTimeStamp("genelists started");
	if (system("genelists -t")) {
	    print "*** WARNING: Failed to reset email lists.\n";
	}
	TBDebugTimeStamp("genelists finished");
    }

    #
    # Wipe the DB clean except during UPDATE or RETRY. In those
    #    cases, assign_wrapper will reset the DB after reading
    #    the info.
    #
    if ( $type >= CLEANUP ) {
	print STDERR "Resetting DB.\n";
	TBExptRemovePhysicalState( $pid, $eid );
    }

    return $swapout_errors;
}

##
#
# doSwapin - Swaps experiment in.
#
#            Returns:
#              0 - successful swapin
#              1 - failed swapin; cleanup required.
#              3 - failed swapin; cleanup required; can retry.
#              7 - failed swapin; assign failed; no cleanup.
##

sub doSwapin($) {
    my $type = shift; # REAL==4, RETRY==2, UPDATE==1, UPDATE_RECOVER=0. 

    #
    # assign_wrapper does all the virtual to physical mapping 
    # and updating the DB state.
    #

    if ($type > UPDATE_RECOVER) {
	print "Mapping to physical reality ...\n";
	TBDebugTimeStamp("assign_wrapper started");

	#
	# Pass the -u (update) switch into assign_wrapper, which turns on
	# update mode. When doing a retry, must also fix the current nodes
	# to avoid stuff jumping around when simply trying to replace a node
	# that did not boot.
	#
	my $exitcode;
	my $wrapper = "assign_wrapper -u";
	$wrapper .= " -f"
	    if ($type == RETRY);
	
	if (system("$wrapper $pid $eid")) {
	    $exitcode = $? >> 8;

	    print STDERR "*** Failed ($exitcode) to map to reality.\n";

	    # Wrapper sets this bit when recovery is possible.
	    if ($exitcode & 64) {
		# We can recover. 
		return 7;
	    }
	    else {
		# No recovery, no retry.
		return 1;
	    }
	}
	TBDebugTimeStamp("assign_wrapper finished");

	print "Mapped to physical reality!\n";
    }

    # Check cancel flag before continuing. No retry, 
    TBGetCancelFlag($pid, $eid, \$canceled);
    return 1
	if ($canceled);

    #
    # Look for any nodes in RES_TEARDOWN. These need to be released,
    # and if a virtnode, they need to be torn down. We cannot wait for
    # the virtnodes to go down with the physnode they are hosted on,
    # so teardown and release the virtnodes first, and then do the
    # physnodes.
    #
    # Errors are fatal; no recovery or retry.
    #
    if ($type == UPDATE) {
	my $allocstate = TBDB_ALLOCSTATE_RES_TEARDOWN();
	
	$db_result =
	    DBQueryFatal("select r.node_id,nt.isvirtnode,nt.isremotenode ".
			 "  from reserved as r ".
			 "left join nodes as n on n.node_id=r.node_id ".
			 "left join node_types as nt on nt.type=n.type ".
			 "where r.pid='$pid' and r.eid='$eid' and ".
			 "      n.allocstate='$allocstate'");

	if ($db_result->numrows) {
	    my @virtnodes = ();
	    my @physnodes = ();
	    
	    print "Tearing down and releasing unused nodes\n";

	    # First teardown/release virtnodes. 
	    while (my ($node,$isvirt,$isrem) = $db_result->fetchrow_array()) {
		if ($isvirt) {
		    push(@virtnodes, $node);
		}
		elsif (!$isrem) {
		    push(@physnodes, $node);
		}
	    }
	    if (@virtnodes) {
		TBDebugTimeStamp("vnode_setup started");
		
		if (system("vnode_setup -k $pid $eid @virtnodes")) {
		    print "Failed to tear down unused virtnodes!\n";
		    return 1;
		}
		TBDebugTimeStamp("vnode_setup finished");
		
		if (system("nfree $pid $eid @virtnodes")) {
		    print "Failed to nfree unused virtnodes!\n";
		    return 1;
		}
	    }
	    if (@physnodes) {
		if (system("nfree $pid $eid @physnodes")) {
		    print "Failed to nfree unused physnodes!\n";
		    return 1;
		}
	    }
	}
    }

    # Exit here if we are testing.
    if ($TESTMODE) {
	print "Testing run - Stopping here.\n";
	return 0;
    }

    #
    # Handle tarballs - we might need to fetch some from URLs if the user
    # asked for that.
    #
    print "Fetching tarballs and RPMs (if any) ...\n";
    TBDebugTimeStamp("tarfiles_setup started");

    if (system("tarfiles_setup $pid $eid")) {
	#
	# No recovery for now - what would we do?
	#
	print STDERR "*** Failed to set up tarballs.\n";
	return 1;
    }
    TBDebugTimeStamp("tarfiles_setup finished");

    #
    # If there are any Plab dslice nodes in the experiment, create the
    # dslice now
    #
    if ($type > UPDATE_RECOVER) {
	# Are there any Plab nodes?
	$db_result =
	    DBQueryFatal("select n.node_id from nodes as n ".
			 "left join node_types as nt on n.type = nt.type ".
			 "left join reserved as r on r.node_id = n.node_id ".
			 "where r.pid='$pid' and r.eid='$eid' ".
			 " and nt.isplabdslice = 1");

	if ($db_result->numrows) {
	    # Does slice already exist?
	    $db_result =
		DBQueryFatal("select slicename from plab_slices ".
			     "where pid='$pid' and eid='$eid'");

	    if (! $db_result->numrows) {
		my @plabnodes = ();
		
		while (my ($node) = $db_result->fetchrow_array()) {
		    push(@plabnodes, $node);
		}
		
		print "Creating Planetlab slice.\n";
		TBDebugTimeStamp("plabslice create started");
		if (system("plabslice create $pid $eid")) {
		    print STDERR "*** Failed to create Plab dslice\n";
		    return 3;
		}
		TBDebugTimeStamp("plabslice alloc finished");
	    }
	}
    }

    # Check cancel flag before continuing. No retry, 
    TBGetCancelFlag($pid, $eid, \$canceled);
    return 1
	if ($canceled);

    #
    # These things need to get started before the nodes come up, so we'll
    # do them before the os_setup. Everything else can done in parallel with
    # os_setup. (Actually, these probably can too, since they should finish
    # long before the nodes reboot, but better safe than sorry)
    #
    print "Setting up mountpoints.\n";
    TBDebugTimeStamp("mountpoints started");
    if (system("exports_setup")) {
	print STDERR "*** Failed to setup mountpoints.\n";
	return 1;
    }
    TBDebugTimeStamp("mountpoints finished");

    TBDebugTimeStamp("named started");
    print "Setting up named maps.\n";
    if (system("named_setup")) {
	print STDERR "*** WARNING: Failed to add node names to named map.\n";
	#
	# This is a non-fatal error.
	#
    }
    TBDebugTimeStamp("named finished");

    # Check cancel flag before continuing. No retry, 
    TBGetCancelFlag($pid, $eid, \$canceled);
    return 1
	if ($canceled);

    #
    # Setup any control-net firewall.
    # This must be done before reloading and rebooting nodes.
    #
    if ($firewalled && doFW($pid, $eid, FWSETUP)) {
	return 1;
    }

    #
    # If user specified -reboot to update,
    # and we are successfully performing the update,
    # then mark all nodes in experiment so os_setup will reboot them.
    #
    if (($type == UPDATE) &&
	($updateReboot || $updateReconfig)) {
	print STDERR "Marking nodes for reboot/reconfig.\n";
	$db_result =
	    DBQueryFatal("select r.node_id,n.allocstate from reserved as r ".
			 "left join nodes as n on n.node_id=r.node_id ".
			 "where r.pid='$pid' and r.eid='$eid'");

	while (my ($node,$allocstate) = $db_result->fetchrow_array) {
	    #
	    # If the node is INIT_CLEAN, leave it alone. It will still get
	    # rebooted, but will not falsely be tagged as dirty. This is
	    # important for vnodes too, where INIT_CLEAN indicated the vnode
	    # does not even exist yet (plab nodes).
	    #
	    if ($allocstate ne TBDB_ALLOCSTATE_RES_INIT_CLEAN()) {
		TBSetNodeAllocState($node,
				    ($updateReboot ?
				     TBDB_ALLOCSTATE_RES_INIT_DIRTY() :
				     TBDB_ALLOCSTATE_RES_RECONFIG()));
	    }
	}
    }

    #
    # Since it'll take a while for the nodes to reboot, we'll start now, and
    # wait for the os_setup to finish, down below
    #
    print "Resetting OS and rebooting.\n";
    TBDebugTimeStamp("launching os_setup");
    if (!($os_setup_pid = fork())) { 
	exec("os_setup $pid $eid") or return 1;
    } elsif ($os_setup_pid == -1) {
	print STDERR "*** Fork failed.\n";
	return 1;
    }

    #
    # XXX
    # Don't add any steps between here and the waitpid() call below
    # without verifying that 1) It's OK for nodes to come up before
    # the step has completed and 2) It's OK for the command to run in
    # parallel with os_setup (no DB dependencies, etc.)
    #

    print "Setting up VLANs.\n";
    TBDebugTimeStamp("snmpit started");
    if (system("snmpit -t $pid $eid")) {
	print STDERR "*** Failed to set up VLANs.\n";
	return 1;
    }
    TBDebugTimeStamp("snmpit finished");

    #
    # An error now means that the VLANS need to be cleaned up.
    #
    $cleanvlans = 1;

    print "Setting up email lists.\n";
    TBDebugTimeStamp("genelists started");
    if (system("genelists -t")) {
	print STDERR "*** WARNING: Failed to update email lists.\n";
	#
	# This is a non-fatal error.
	# 
    }
    TBDebugTimeStamp("genelists finished");

    #
    # Don't clear port counters on UPDATE.
    # (XXX should clear new nodes' port counters.)

    if ($type >= RETRY) {
	print "Clearing port counters.\n";
	TBDebugTimeStamp("portstats started");
	if (system("portstats -z -a -q $pid $eid")) {
	    print STDERR "*** WARNING: Failed to clear port counters.\n";
	    #
	    # This is a non-fatal error.
	    # 
	}
	TBDebugTimeStamp("portstats finished");
    }

    #
    # OK, let's see how that os_setup did
    #
    $kid = waitpid($os_setup_pid,0);
    if ($kid == $os_setup_pid) {
	undef $os_setup_pid; # Make sure doswapout() doesn't wait for it.
	if ($CHILD_ERROR) {
	    print STDERR "*** Failed to reset OS and reboot nodes.\n";
	    #
	    # If there is a firewall involved, it could be that the
	    # firewall rules are preventing essential communication,
	    # so don't retry.
	    #
	    # XXX should only do this if the user has specified additional
	    # rules.  But right now, I may screw up too!
	    #
	    if ($firewalled) {
		print STDERR "Not retrying, ".
		    "firewall may be preventing setup.\n";
		return 1;
	    }

	    #
	    # Use returncode from os_setup process to
	    # set global $retry flag, indicating to caller
	    # that it may be beneficial to attempt
	    # a doSwapin() again.
	    #
            if (($CHILD_ERROR >> 8) == 1) {
		return 3;
	    } else {
		print STDERR "Not retrying due to error type.\n";
		return 1;
	    }
	}
    } else {
	undef $os_setup_pid;
	print STDERR "*** Error waiting for os_setup to finish.\n";
	return 1;
    }
    TBDebugTimeStamp("os_setup finished");

    #
    # Okay, start the event system now that we know all the nodes have
    # rebooted (os_setup is done). This only takes a moment (puts itself
    # in the background), so its not enough of a delay to worry about.
    # Don't do this during an update, since we didn't kill the 
    # event system previously, so starting it again will fail!
    # 
    if (! ($DISABLE_EVENTS || $elabinelab)) {
	if ( $update_Eventsys_restart || 
	    ($type != UPDATE && $type != UPDATE_RECOVER) ) {
	    print "Starting the event system.\n";
	    TBDebugTimeStamp("eventsys_control started");
	    if (system("eventsys_control start $pid $eid")) {
		print STDERR "*** Failed to start the event system.\n";
		return 1;
	    }
	    TBDebugTimeStamp("eventsys_control finished");
	}
    }

    #
    # ElabinElab setup. This might not be the right place for this!
    #
    if ($elabinelab && !$TESTMODE &&  $type == REAL) {
	print "Setting up elabinelab. This could take a while!\n";
	TBDebugTimeStamp("elabinelab setup started");
	if (system("elabinelab $pid $eid")) {
	    print STDERR "*** Failed to setup elabinelab!\n";
	    return 1;
	}
	TBDebugTimeStamp("elabinelab setup finished");
    }

    return 0;
}

#
# Setup and teardown experiment firewall.
#
# XXX note that right now, we just setup the switch infrastructure
# first, and then just let everything else go.  Firewalled nodes will
# not boot until the firewall is up since the VLAN is isolated til then.
# The firewall will boot ok since it still talks to the real control net.
#
# XXX for tearing down firewalls, we assume that nodes have been "cleansed"
# and it is safe to put ports back into the default control net VLAN.
#
sub doFW($$$) {
    my ($pid, $eid, $action) = @_;
    my ($fwnode, $fwvlanname, $fwvlan, $fwport, $fwvid);

    #
    # See if there is a firewall, fetching node/VLAN info if so.
    # If not, we are all done.
    #
    if (!TBExptFirewall($pid, $eid, \$fwnode, \$fwvid, \$fwvlan)) {
	return 0;
    }

    if ($action == FWSETUP) {
	$fwvid = TBGetUniqueIndex("cnet_vlanid");

	print "Setting up control net firewall.\n";
    } else {
	print "Tearing down control net firewall.\n";

	# Prior setup didn't succeed, nothing to do
	if (!defined($fwvid)) {
	    return 0;
	}
    }

    # XXX vlanid in the DB is currently an int, we need a more unique name
    $fwvlanname = "fw$fwvid";

    #
    # Find all the experiment nodes and their control interface switch ports
    #
    # XXX this may be replaced by a call to SNMPIT that just specifies
    # the pid/eid.  In that case someone else will first have to poplulate
    # the vlans table with this same info. 
    #
    my $db_result =
	DBQueryFatal("SELECT r.node_id,w.card1 ".
		     "  FROM wires AS w, reserved AS r ".
		     "WHERE r.node_id=w.node_id1 AND r.pid='$pid' ".
		     "  AND r.eid='$eid' AND w.type='Control'");

    my $portlist = "";
    while (my ($node,$cif) = $db_result->fetchrow_array()) {
	if ($node eq $fwnode) {
	    $fwport = "$node:$cif";
	} else {
	    $portlist .= " $node:$cif";
	}
    }
    if (!defined($fwport)) {
	print STDERR "*** Firewall node '$fwnode' not found in $pid/$eid?!\n";
	return 0;
    }
    if ($portlist eq "") {
	print STDERR "*** No firewalled nodes in $pid/$eid?!\n";
	return 0;
    }

    #
    # XXX hack commands til we nail down the API
    #
    my $fwsetupstr1 = "snmpit $cnetstack -m $fwvlanname $portlist";
    my $fwsetupstr2 = "snmpit $cnetstack -T $fwport $cnetvlanname $fwvlanname";
    my $fwtakedownstr1 = "snmpit $cnetstack -m $cnetvlanname $portlist";
    my $fwtakedownstr2 = "snmpit $cnetstack -o $fwvlanname";
    my $fwtakedownstr3 = "snmpit $cnetstack -U $fwport";
    my $fwtakedownstr4 = "snmpit $cnetstack -m $cnetvlanname $fwport";

    if (0) {
    # XXX debug fer now
    TBDebugTimeStamp("    setup1: $fwsetupstr1");
    TBDebugTimeStamp("    setup2: $fwsetupstr2");
    TBDebugTimeStamp(" teardown1: $fwtakedownstr1");
    TBDebugTimeStamp(" teardown2: $fwtakedownstr2");
    TBDebugTimeStamp(" teardown3: $fwtakedownstr3");
    TBDebugTimeStamp(" teardown4: $fwtakedownstr4");
    if ($action == FWSETUP) {
	my $lan = 100 + $fwvid;
	$fwsetupstr1    = "/bin/echo VLAN \#$lan on cisco2";
	$fwsetupstr2    = "true";
    } else {
	$fwtakedownstr1 = "true";
	$fwtakedownstr2 = "true";
	$fwtakedownstr3 = "true";
	$fwtakedownstr4 = "true";
    }
    }

    if ($action == FWSETUP) {
	TBDebugTimeStamp("snmpit firewall setup: VLAN");
	my $snmpit_out = `$fwsetupstr1`;
	if ($? != 0 || $snmpit_out !~ /VLAN #(\d+) on /) {
	    print STDERR "*** Failed to setup Firewall control net VLAN.\n";
	    return 1;
	}
	my $fwvlan = $1;

	TBDebugTimeStamp("snmpit firewall setup: trunk");
	if (system($fwsetupstr2)) {
	    print STDERR "*** Failed to setup Firewall trunk on port $fwport.\n";
	    if (system($fwtakedownstr1)) {
		print STDERR
		    "*** Could not return $portlist to Control VLAN!\n";
	    }
	    if (system($fwtakedownstr2)) {
		print STDERR
		    "*** Could not destroy VLAN $fwvlanname ($fwvlan)!\n";
	    }
	    return 1;
	}
	TBDebugTimeStamp("snmpit firewall setup done");

	# Record VLAN info now that everything is done
	TBSetExptFirewallVlan($pid, $eid, $fwvid, $fwvlan);
    } else {
	TBDebugTimeStamp("snmpit firewall teardown: VLAN");
	my $failed = 0;
	if (system($fwtakedownstr1)) {
	    print STDERR
		"*** Could not return $portlist to Control VLAN!\n";
	    $failed = 1;
	}
	if (system($fwtakedownstr2)) {
	    print STDERR
		"*** Could not destroy VLAN $fwvlanname ($fwvlan)!\n";
	    $failed = 1;
	}
	TBDebugTimeStamp("snmpit firewall teardown: trunk");
	if (system($fwtakedownstr3)) {
	    print STDERR
		"*** Could not tear down trunk on $fwport!\n";
	    $failed = 1;
	}
	if (system($fwtakedownstr4)) {
	    print STDERR
		"*** Could not return $fwport to Control VLAN!\n";
	    $failed = 1;
	}
	if ($failed) {
	    return 1;
	}
	TBDebugTimeStamp("snmpit firewall teardown done");

	# Clean VLAN info from DB
	TBSetExptFirewallVlan($pid, $eid, undef, undef);
    }
    return 0;
}
