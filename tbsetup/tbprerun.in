#!/usr/bin/perl -w

#
# EMULAB-COPYRIGHT
# Copyright (c) 2000-2004 University of Utah and the Flux Group.
# All rights reserved.
#

use English;

# tbprerun

# This is the first program in the
# tbprerun/tbswapin/tbswapout/.../tbend sequences.  It's main purpose
# is to interpret the NS file and create the appropriate entries in
# virt_nodes and virt_lans.  After this script ends successfully the
# NS file is no longer necessary.
#
sub usage()
{
    print STDERR "Usage: $0 [-force] pid eid nsfile\n";
    exit(-1);
}
my $force  = 0;
my $state;

#
# Configure variables
#
my $TBROOT   = "@prefix@";
my $TESTMODE = @TESTMODE@;
my $wrapper  = "$TBROOT/libexec/assign_wrapper";
my $batchexp = "$TBROOT/bin/batchexp";
my $template = "$TBROOT/lib/ns2ir/elabinelab.ns";
my $endexp   = "$TBROOT/bin/endexp";
my $exptidx;

# Untaint the path
$ENV{'PATH'} = "/usr/bin:/bin:$TBROOT/libexec:$TBROOT/libexec/ns2ir" . 
    ":$TBROOT/libexec/vis:$TBROOT/sbin:$TBROOT/bin";

#
# Testbed Support libraries
#
use lib "@prefix@/lib";
use libdb;
use libtestbed;

#
# Turn off line buffering on output
#
$| = 1;

#
# Parse args
#
if (!@ARGV) {
    usage();
}
if ($ARGV[0] eq "-force") {
    $force = 1;
    shift;
}

if (@ARGV != 3) {
    usage();
}
my ($pid,$eid,$nsfile) = @ARGV;

if (! -r $nsfile) {
    die("*** $0:\n".
	"    NS File '$nsfile' does not exist!\n");
}

print "Beginning pre run for $pid/$eid. " . TBTimeStamp() . "\n";
TBDebugTimeStamp("tbprerun started");

if (! ($state = ExpState($pid, $eid))) {
    die("*** $0:\n".
	"    No such experiment $pid/$eid\n");
}

if (! ($gid = ExpGroup($pid,$eid))) {
    die("*** $0:\n".
	"    Unable to get group for $pid/$eid\n");
}

#
# These are the valid states for running this script.
#
if (!$force &&
    !($state eq EXPTSTATE_PRERUN || $state eq EXPTSTATE_MODIFY_PARSE ||
      $state eq EXPTSTATE_MODIFY_REPARSE)) {
    die("*** $0:\n".
	"    Experiment is not in the proper state: $state\n");
}

#
# Cleanup if something goes wrong.
#
sub cleanup {
    print STDERR "Cleaning up after errors.\n";
    if ($state eq EXPTSTATE_PRERUN) {
	# Must kill the prerender process before we remove virt state.
	print "Killing the renderer.\n";
	system("prerender -r $pid $eid");
    }
    print "Removing experiment state.\n";
    TBExptRemoveVirtualState($pid, $eid );
}

#
# Fatal error.
#
sub fatal($)
{
    my ($mesg) = @_;
    
    cleanup();
    die("*** $0:\n".
	"    $mesg\n");
}

# Need this below.
TBExptIDX($pid, $eid, \$exptidx)
    or fatal("Failed to get experiment index for $pid/$eid!");

# Must kill any prerender process first!
system("prerender -r $pid $eid");

# Kill old virtual state.
TBExptRemoveVirtualState($pid, $eid);

# This setups virt_nodes, virt_names including all IP address calculation
# and tb-* handling.
print "Running parser ... " . TBTimeStamp() . "\n";
TBDebugTimeStamp("parser started");
if (system("parse-ns $pid $gid $eid $nsfile")) {
    fatal("Parsing failed!");
}
TBDebugTimeStamp("parser finished");
print "Parser done! " . TBTimeStamp() . "\n";

#
# Put the nsfile into the DB, now that we know it parses okay.
#
$nsfile_string = `cat $nsfile`;

if ($nsfile_string) {
    $nsfile_string = DBQuoteSpecial($nsfile_string);

    if (length($nsfile_string) >= DBLIMIT_NSFILESIZE()) {
	fatal("NS File is way too big!");
    }
    if (!DBQueryWarn("delete from nsfiles where eid='$eid' and pid='$pid'") ||
	!DBQueryWarn("insert into nsfiles (pid, eid, nsfile) ".
		     "VALUES('$pid', '$eid', $nsfile_string)")) {
	fatal("Error storing the NS file into the database!");
    }
}

#
# In update mode, do not start the renderer until later. If update fails we
# want to try to restore old render info rather then rerunning. 
# 
if ($state eq EXPTSTATE_PRERUN) {
    TBDebugTimeStamp("prerender started in background");
    print "Precomputing visualization ...\n";
    system("prerender -t $pid $eid");
}

#
# See if using the new ipassign.
#
my $query_result =
    DBQueryWarn("select use_ipassign, ipassign_args " .
		"from experiments where pid='$pid' and eid='$eid'");

if (!$query_result || ($query_result->num_rows() != 1)) {
    fatal("Error getting ipassign arguments!");
}
my ($use_ipassign, $ipassign_args) = $query_result->fetchrow();
if ($use_ipassign) {
    if (!defined $ipassign_args) {
	$ipassign_args = "";
    }
    TBDebugTimeStamp("ipassign_wrapper started");
    print "Doing IP assignment ...\n";
    
    if (system("ipassign_wrapper $ipassign_args $pid $eid")) {
	fatal("ipassign_wrapper failed!");
    }
}

#
# Fire up the route calculator. 
# 
TBDebugTimeStamp("static route calculator started");
print "Setting up static routes (if requested) ... \n";

if (system("staticroutes $pid $eid")) {
    fatal("Static route calculation failed!");
}

#
# Generate a topo map that is used by the remote nodes to create the
# routes (ddijk) and the /etc/hosts file.
#
TBDebugTimeStamp("gentopofile started");
print "Generating topomap ...\n";

if (system("gentopofile $pid $eid")) {
    fatal("gentopofile failed!");
}

#
# Do an assign_prerun to set the min/max nodes. Generates a top file too.
# This is the only DB state that is modified during a top only run.
#
TBDebugTimeStamp("assign prerun started");
print "Doing a pre-assign ...\n";
if (system("$wrapper -t $pid $eid")) {
    fatal("assign prerun failed!");
}

#
# If security level indicates that the experiment needs to be run ElabInElab
# then must generate a parallel experiment for the container. When the user
# swaps in the original experiment, it will really be this experiment that
# is swapped in. Its sorta bogus, but hey its a prototype.
#
my $security_level;
if (! TBExptSecurityLevel($pid, $eid, \$security_level)) {
    fatal("Could not get security_level from DB!");
}

if ($security_level >= TBDB_SECLEVEL_ORANGE()) {
    my $elabinelab_eid = $eid . "-" . "elabinelab";
    my $tempnsfile     = "/tmp/$pid-$elabinelab_eid-$$.nsfile";
    my $maxnodes;
    my $elabinelab_exptidx;

    if (! TBExptMinMaxNodes($pid, $eid, undef, \$maxnodes)) {
	fatal("Could not get max nodes from DB!");
    }

    #
    # Munge the template.
    #
    system("cat $template | sed -e 's/\@MAXPCS\@/$maxnodes/' ".
	   "                    -e 's/\@SECURITY_LEVEL\@/$security_level/' ".
	   "    >$tempnsfile");

    TBDebugTimeStamp("recursive batchexp started");
    print "Creating elabinelab container experiment.\n";
    if (system("$batchexp -q -i -w -f -n ".
	       "  -L 'ElabInElab Container for $eid' ".
	       "  -E 'ElabInElab Container for $eid - DO NOT DELETE' ".
	       "  -p $pid -e $elabinelab_eid $tempnsfile")) {
	fatal("Could not create elabinelab container experiment!");
    }
    TBDebugTimeStamp("recursive batchexp finished");

    #
    # Link the two experiments together.
    #
    if (! (DBQueryWarn("update experiments set ".
		       " elabinelab_eid='$eid' ".
		       "where pid='$pid' and eid='$elabinelab_eid'") &&
	   DBQueryWarn("update experiments set ".
		       "  elabinelab_eid='$elabinelab_eid' ".
		       "where pid='$pid' and eid='$eid'"))) {
	system("$endexp -w -q $pid $elabinelab_eid");
	fatal("Could not update DB for cross linking experiments!");
    }
    #
    # This stats stuff is not done in testmode.
    # 
    if (! $TESTMODE) {
	# IDX for newly created elabinelab experiment.
	TBExptIDX($pid, $elabinelab_eid, \$elabinelab_exptidx)
	    or fatal("Failed to get experiment index for $pid/$elabinelab_eid!");

	# Cross link the other experiment (code below is for this experiment).
	DBQueryWarn("update experiment_stats set ".
		    "   elabinelab_exptidx=$exptidx ".
		    "where pid='$pid' and eid='$elabinelab_eid' and ".
		    "      exptidx='$elabinelab_exptidx'");
    }
}

#
# This stats stuff is not done in testmode.
# 
if (! $TESTMODE) {
    #
    # Deal with ElabInElab stuff, which is updated after the parse and prerun.
    # Want to move this to the stats records. Ditto for the security stuff,
    # which was handled above.
    #
    my $elabinelab = 0;
    my $elabinelab_eid;
    my $elabinelab_exptidx;

    TBExptIsElabInElab($pid, $eid, \$elabinelab, \$elabinelab_eid)
	or fatal("Failed to get ElabInElab attributes!");

    if ($elabinelab || $security_level) {
	DBQueryWarn("update experiment_stats set ".
		    "   elabinelab=$elabinelab, ".
		    "   security_level=$security_level ".
		    "where pid='$pid' and eid='$eid' and exptidx='$exptidx'");
    }

    if ($elabinelab_eid) {
	TBExptIDX($pid, $elabinelab_eid, \$elabinelab_exptidx)
	    or fatal("Failed to get experiment index for $pid/$elabinelab_eid!");
    
	DBQueryWarn("update experiment_stats set ".
		    "   elabinelab_exptidx=$elabinelab_exptidx ".
		    "where pid='$pid' and eid='$eid' and exptidx='$exptidx'");
    }
}

TBDebugTimeStamp("tbprerun finished");
print "Pre run finished. " . TBTimeStamp() . "\n";
exit(0);

