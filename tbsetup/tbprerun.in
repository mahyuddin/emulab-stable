#!/usr/bin/perl -w

#
# EMULAB-COPYRIGHT
# Copyright (c) 2000-2004 University of Utah and the Flux Group.
# All rights reserved.
#

use English;

# tbprerun

# This is the first program in the
# tbprerun/tbswapin/tbswapout/.../tbend sequences.  It's main purpose
# is to interpret the NS file and create the appropriate entries in
# virt_nodes and virt_lans.  After this script ends successfully the
# NS file is no longer necessary.
#
sub usage()
{
    print STDERR "Usage: $0 [-force] pid eid nsfile\n";
    exit(-1);
}
my $force = 0;
my $state;

#
# Configure variables
#
my $TBROOT   = "@prefix@";

# Untaint the path
$ENV{'PATH'} = "/usr/bin:/bin:$TBROOT/libexec:$TBROOT/libexec/ns2ir" . 
    ":$TBROOT/libexec/vis:$TBROOT/sbin:$TBROOT/bin";

#
# Testbed Support libraries
#
use lib "@prefix@/lib";
use libdb;
use libtestbed;

#
# Turn off line buffering on output
#
$| = 1;

#
# Parse args
#
if (!@ARGV) {
    usage();
}
if ($ARGV[0] eq "-force") {
    $force = 1;
    shift;
}

if (@ARGV != 3) {
    usage();
}
my ($pid,$eid,$nsfile) = @ARGV;

if (! -r $nsfile) {
    die("*** $0:\n".
	"    NS File '$nsfile' does not exist!\n");
}

print "Beginning pre run for $pid/$eid. " . TBTimeStamp() . "\n";
TBDebugTimeStamp("tbprerun started");

if (! ($state = ExpState($pid, $eid))) {
    die("*** $0:\n".
	"    No such experiment $pid/$eid\n");
}

if (! ($gid = ExpGroup($pid,$eid))) {
    die("*** $0:\n".
	"    Unable to get group for $pid/$eid\n");
}

#
# These are the valid states for running this script.
#
if (!$force &&
    !($state eq EXPTSTATE_PRERUN || $state eq EXPTSTATE_MODIFY_PARSE ||
      $state eq EXPTSTATE_MODIFY_REPARSE)) {
    die("*** $0:\n".
	"    Experiment is not in the proper state: $state\n");
}

#
# Cleanup if something goes wrong.
#
sub cleanup {
    print STDERR "Cleaning up after errors.\n";
    # Must kill the prerender process before we remove virt state.
    system("prerender -r $pid $eid");

    # When doing a modify, this is handled elsewhere. 
    if ($state eq EXPTSTATE_PRERUN) {
	print "Removing experiment state ... " . TBTimeStamp() . "\n";
	TBExptRemoveVirtualState($pid, $eid );
    }
}

# Must kill any prerender process first!
system("prerender -r $pid $eid");

# Kill old virtual state.
TBExptRemoveVirtualState($pid, $eid);

# This setups virt_nodes, virt_names including all IP address calculation
# and tb-* handling.
print "Running parser ... " . TBTimeStamp() . "\n";
TBDebugTimeStamp("parser started");
if (system("parse-ns $pid $gid $eid $nsfile")) {
    cleanup();
    die("*** $0:\n".
	"    Parsing failed!\n");
}
TBDebugTimeStamp("parser finished");
print "Parser done! " . TBTimeStamp() . "\n";

#
# Put the nsfile into the DB, now that we know it parses okay.
#
$nsfile_string = `cat $nsfile`;

if ($nsfile_string) {
    $nsfile_string = DBQuoteSpecial($nsfile_string);

    if (length($nsfile_string) >= DBLIMIT_NSFILESIZE()) {
	cleanup();
	die("*** $0:\n".
	    "    NS File is way too big!\n");
    }
    if (!DBQueryWarn("delete from nsfiles where eid='$eid' and pid='$pid'") ||
	!DBQueryWarn("insert into nsfiles (pid, eid, nsfile) ".
		     "VALUES('$pid', '$eid', $nsfile_string)")) {
	cleanup();
	die("*** $0:\n".
	    "    Error storing the NS file into the database!\n");
    }
}

TBDebugTimeStamp("prerender started in background");
print "Precomputing visualization ...\n";
system("prerender -t $pid $eid");

TBDebugTimeStamp("routes started");
print "Setting up static routes (if requested) ... \n";

#
# Find out which route calculator we're supposed to use
#
my $result = DBQueryWarn("select use_ipassign, ipassign_args " .
    "from experiments where pid='$pid' and eid='$eid'");
if (!$result || ($result->num_rows() != 1)) {
	cleanup();
	die("*** $0:\n".
	    "    Error determining route calculator!\n");
}
my ($use_ipassign, $ipassign_args) = $result->fetchrow();
if ($use_ipassign) {
    if (!defined $ipassign_args) {
	$ipassign_args = "";
    }
    if (system("ipassign_wrapper $ipassign_args $pid $eid")) {
	cleanup();
	die("*** $0:\n".
	    "    Static route calculation failed!\n");
    }
} else {
    if (system("staticroutes $pid $eid")) {
	cleanup();
	die("*** $0:\n".
	    "    Static route calculation failed!\n");
    }
}

#
# Generate a linkmap for new router calculation. This is done as an option
# to staticroutes, and is really fast, so we can do it all the time. We
# of course have to run it after ipassign_wrapper runs so that the IPs are
# set. Note the routertype slot in the DB indicates to not generate static
# routes now, when we are using the new distributed Dijkstra setup.
#
# Eventually staticroutes and ipassign_wrapper should look at routertype
# slot and generate this map when it equals 'static-ddijk'.
#
if (system("staticroutes -j -f $pid $eid")) {
    cleanup();
    die("*** $0:\n".
	"    staticroutes linkmap generation failed!\n");
}

#
# Generate a topo map that is used by the remote nodes to create the
# routes (ddijk) and the /etc/hosts file.
#
if (system("gentopofile $pid $eid")) {
    cleanup();
    die("*** $0:\n".
	"    gentopofile failed!\n");
}

TBDebugTimeStamp("routes finished");
print "Static routing done! " . TBTimeStamp() . "\n";

TBDebugTimeStamp("tbprerun finished");
print "Pre run finished. " . TBTimeStamp() . "\n";
exit(0);

