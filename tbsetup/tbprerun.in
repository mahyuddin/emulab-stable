#!/usr/bin/perl -w
#
# EMULAB-COPYRIGHT
# Copyright (c) 2000-2006 University of Utah and the Flux Group.
# All rights reserved.
#
use English;
use Getopt::Std;

# tbprerun

# This is the first program in the
# tbprerun/tbswapin/tbswapout/.../tbend sequences.  It's main purpose
# is to interpret the NS file and create the appropriate entries in
# virt_nodes and virt_lans.  After this script ends successfully the
# NS file is no longer necessary.
#
sub usage()
{
    print STDERR "Usage: $0 [-f] pid eid nsfile\n";
    exit(-1);
}
my $optlist = "fz";
my $force   = 0;
my $zeemode = 0;
my $zeeopt  = "";
my $state;

#
# Configure variables
#
my $TBROOT   = "@prefix@";
my $TESTMODE = @TESTMODE@;
my $TBLOGS   = "@TBLOGSEMAIL@";
my $OPSDBSUPPORT= @OPSDBSUPPORT@;
my $wrapper  = "$TBROOT/libexec/assign_wrapper";
my $batchexp = "$TBROOT/bin/batchexp";
my $template = "$TBROOT/lib/ns2ir/elabinelab.ns";
my $endexp   = "$TBROOT/bin/endexp";
my $dbcontrol= "$TBROOT/sbin/opsdb_control";
my $exptidx;

# Untaint the path
$ENV{'PATH'} = "/usr/bin:/bin:$TBROOT/libexec:$TBROOT/libexec/ns2ir" . 
    ":$TBROOT/libexec/vis:$TBROOT/sbin:$TBROOT/bin";

#
# Testbed Support libraries
#
use lib "@prefix@/lib";
use libdb;
use libtestbed;
use libtblog;

#
# Turn off line buffering on output
#
$| = 1;

#
# Parse command arguments. Once we return from getopts, all that should be
# left are the required arguments.
#
%options = ();
if (! getopts($optlist, \%options)) {
    usage();
}
if (defined($options{"f"})) {
    $force = 1;
}
if (defined($options{"z"})) {
    $zeemode = 1;
    $zeeopt  = "-p";
}
if (@ARGV != 3) {
    usage();
}
my ($pid,$eid,$nsfile) = @ARGV;

if (! -r $nsfile) {
    tbdie("NS File '$nsfile' does not exist!");
}

print "Beginning pre run for $pid/$eid. " . TBTimeStamp() . "\n";
TBDebugTimeStamp("tbprerun started");

if (! ($state = ExpState($pid, $eid))) {
    tbdie("No such experiment $pid/$eid");
}

if (! ($gid = ExpGroup($pid,$eid))) {
    tbdie("Unable to get group for $pid/$eid");
}

#
# These are the valid states for running this script.
#
if (!$force &&
    !($state eq EXPTSTATE_PRERUN || $state eq EXPTSTATE_MODIFY_PARSE ||
      $state eq EXPTSTATE_MODIFY_REPARSE)) {
    tbdie("Experiment is not in the proper state: $state");
}

#
# Cleanup if something goes wrong.
#
sub cleanup {
    print STDERR "Cleaning up after errors.\n";
    if ($state eq EXPTSTATE_PRERUN) {
	# Must kill the prerender process before we remove virt state.
	print "Killing the renderer.\n";
	system("prerender -r $pid $eid");
    }
    print "Removing experiment state.\n";
    TBExptRemoveVirtualState($pid, $eid );
}

#
# Fatal error.
#
sub fatal($)
{
    my ($mesg) = @_;
    
    cleanup();
    tbdie($mesg);
}

# Need this below.
TBExptIDX($pid, $eid, \$exptidx)
    or fatal("Failed to get experiment index for $pid/$eid!");

# Must kill any prerender process first!
system("prerender -r $pid $eid");

# Kill old virtual state.
TBExptRemoveVirtualState($pid, $eid);

# This setups virt_nodes, virt_names including all IP address calculation
# and tb-* handling.
print "Running parser ... " . TBTimeStamp() . "\n";
TBDebugTimeStamp("parser started");
if (system("parse-ns $zeeopt $pid $gid $eid $nsfile")) {
    fatal("Parsing failed!");
}
TBDebugTimeStamp("parser finished");
print "Parser done! " . TBTimeStamp() . "\n";

#
# XXX Until link agent runs on linux.
#
my $events_result =
    DBQueryFatal("select ev.pid,ev.eid,vl.vnode,vl.vname,vn.osname,o.OS ".
		 "  from eventlist as ev ".
		 "left join event_objecttypes as ev_ob on ".
		 "  ev.objecttype=ev_ob.idx ".
		 "left join virt_lans as vl on vl.vname=ev.vname and ".
		 "  vl.pid=ev.pid and vl.eid=ev.eid ".
		 "left join virt_nodes as vn on vn.pid=ev.pid and ".
		 "  vn.eid=ev.eid and vn.vname=vl.vnode ".
		 "left join os_info as o on o.osname=vn.osname and".
		 "  (o.pid=ev.pid or o.pid='emulab-ops') ".
		 "left join experiments as e on e.pid=ev.pid and ".
		 "  e.eid=ev.eid ".
		 "where ev.pid='$pid' and ev.eid='$eid' and ".
		 "  (vl.uselinkdelay!=0 or e.uselinkdelays!=0 or ".
		 "   e.forcelinkdelays!=0) and ev_ob.type='LINK' and ".
		 "  (o.os is NULL or o.os='Linux' or o.os='Fedora')");
if ($events_result->num_rows) {
    fatal("Oops, cannot send static events to linkdelay agents on Linux!");
}

#
# Need to know if wrapping an experiment.
#
my $elabinelab = 0;
my $elabinelab_eid;

TBExptIsElabInElab($pid, $eid, \$elabinelab, \$elabinelab_eid)
    or fatal("Failed to get ElabInElab attributes!");

#
# If we are, rerun the parser so that we can pass in the proper info
# this time around. This is a side effect of allowing the elabinelab
# bit, and the elabinelab eid, to be specified in the NS file. If we
# did this on the command line, then we could skip this step, but I
# think ease of use is better if it can be in the NS file. Remember,
# the user can clear the elabinelab_eid field, so must rerun to clear
# out the nodes. What if they clear the elabinelab bit too? Ick, not
# going to worry about that.
#
if ($elabinelab) {
    # Inner experiment better exist.
    fatal("Inner experiment $elabinelab_eid does not exist!")
	if (defined($elabinelab_eid) && !ExpState($pid, $elabinelab_eid));
    
    # Again, kill virtual state.
    TBExptRemoveVirtualState($pid, $eid);

    print "Re-Running parser ... " . TBTimeStamp() . "\n";
    TBDebugTimeStamp("parser started");
    if (system("parse-ns $pid $gid $eid $nsfile")) {
	fatal("Parsing failed!");
    }
    TBDebugTimeStamp("parser finished");
    print "Parser done! " . TBTimeStamp() . "\n";
}

#
# Put the nsfile into the DB, now that we know it parses okay.
#
$nsfile_string = `cat $nsfile`;

if ($nsfile_string) {
    $nsfile_string = DBQuoteSpecial($nsfile_string);

    if (length($nsfile_string) >= DBLIMIT_NSFILESIZE()) {
	fatal("NS File is way too big!");
    }
    if (!DBQueryWarn("delete from nsfiles where eid='$eid' and pid='$pid'") ||
	!DBQueryWarn("insert into nsfiles (pid, eid, nsfile) ".
		     "VALUES('$pid', '$eid', $nsfile_string)")) {
	fatal("Error storing the NS file into the database!");
    }
}

#
# In update mode, do not start the renderer until later. If update fails we
# want to try to restore old render info rather then rerunning. 
# 
if ($state eq EXPTSTATE_PRERUN && !$zeemode) {
    TBDebugTimeStamp("prerender started in background");
    print "Precomputing visualization ...\n";
    system("prerender -t $pid $eid");
}

#
# See if using the new ipassign.
#
my $query_result =
    DBQueryWarn("select use_ipassign, ipassign_args " .
		"from experiments where pid='$pid' and eid='$eid'");

if (!$query_result || ($query_result->num_rows() != 1)) {
    fatal("Error getting ipassign arguments!");
}
my ($use_ipassign, $ipassign_args) = $query_result->fetchrow();
if ($use_ipassign) {
    if (!defined $ipassign_args) {
	$ipassign_args = "";
    }
    TBDebugTimeStamp("ipassign_wrapper started");
    print "Doing IP assignment ...\n";
    
    if (system("ipassign_wrapper $ipassign_args $pid $eid")) {
	fatal("ipassign_wrapper failed!");
    }
}

#
# Fire up the route calculator. 
#
if (!$zeemode) {
    TBDebugTimeStamp("static route calculator started");
    print "Setting up static routes (if requested) ... \n";

    if (system("staticroutes $pid $eid")) {
	fatal("Static route calculation failed!");
    }
}

#
# Generate a topo map that is used by the remote nodes to create the
# routes (ddijk) and the /etc/hosts file.
#
TBDebugTimeStamp("gentopofile started");
print "Generating topomap ...\n";

if (system("gentopofile $pid $eid")) {
    fatal("gentopofile failed!");
}

if ($OPSDBSUPPORT) {
    TBDebugTimeStamp("opsdb_control started");
    
    if (system("$dbcontrol addexpdb $pid $eid")) {
	fatal("$dbcontrol addexpdb failed!");
    }
}

if (!$elabinelab) {
    TBDebugTimeStamp("verify-ns started");
    print "Verifying parse ...\n";
    
    if (system("verify-ns $pid $gid $eid $nsfile")) {
	if (1) {
	    SENDMAIL($TBLOGS,
		     "NS Verify failure for $pid/$eid",
		     "'verify-ns' failed for $pid/$eid\n".
		     "\nIf it is not a user error nstb_compat.tcl is ".
		     "probably out of date.\n");
	}
	else {
	    fatal("verify-ns failed!");
	}
    }
}

#
# Do an assign_prerun to set the min/max nodes. Generates a top file too.
# This is the only DB state that is modified during a top only run.
#
if (!$zeemode) {
    TBDebugTimeStamp("assign prerun started");
    print "Doing a pre-assign ...\n";
    if (system("$wrapper -t $pid $eid")) {
	fatal("assign prerun failed!");
    }
}

#
# If security level indicates that the experiment needs to be run ElabInElab
# then must generate a parallel experiment for the container. When the user
# swaps in the original experiment, it will really be this experiment that
# is swapped in. Its sorta bogus, but hey its a prototype.
#
my $security_level;
if (! TBExptSecurityLevel($pid, $eid, \$security_level)) {
    fatal("Could not get security_level from DB!");
}

if (0 && $security_level >= TBDB_SECLEVEL_ORANGE()) {
    my $elabinelab_eid = $eid . "-" . "elabinelab";
    my $tempnsfile     = "/tmp/$pid-$elabinelab_eid-$$.nsfile";
    my $maxnodes;
    my $elabinelab_exptidx;

    if (! TBExptMinMaxNodes($pid, $eid, undef, \$maxnodes)) {
	fatal("Could not get max nodes from DB!");
    }

    #
    # Munge the template.
    #
    system("cat $template | sed -e 's/\@MAXPCS\@/$maxnodes/' ".
	   "                    -e 's/\@SECURITY_LEVEL\@/$security_level/' ".
	   "    >$tempnsfile");

    TBDebugTimeStamp("recursive batchexp started");
    print "Creating elabinelab container experiment.\n";
    if (system("$batchexp -q -i -w -f -n ".
	       "  -L 'ElabInElab Container for $eid' ".
	       "  -E 'ElabInElab Container for $eid - DO NOT DELETE' ".
	       "  -p $pid -e $elabinelab_eid $tempnsfile")) {
	fatal("Could not create elabinelab container experiment!");
    }
    TBDebugTimeStamp("recursive batchexp finished");

    #
    # Link the two experiments together.
    #
    if (! (DBQueryWarn("update experiments set ".
		       " elabinelab_eid='$eid' ".
		       "where pid='$pid' and eid='$elabinelab_eid'") &&
	   DBQueryWarn("update experiments set ".
		       "  elabinelab_eid='$elabinelab_eid' ".
		       "where pid='$pid' and eid='$eid'"))) {
	system("$endexp -w -q $pid $elabinelab_eid");
	fatal("Could not update DB for cross linking experiments!");
    }
    #
    # This stats stuff is not done in testmode.
    # 
    if (! $TESTMODE) {
	# IDX for newly created elabinelab experiment.
	TBExptIDX($pid, $elabinelab_eid, \$elabinelab_exptidx)
	    or fatal("Failed to get experiment index for $pid/$elabinelab_eid!");

	# Cross link the other experiment (code below is for this experiment).
	DBQueryWarn("update experiment_stats set ".
		    "   elabinelab_exptidx=$exptidx ".
		    "where pid='$pid' and eid='$elabinelab_eid' and ".
		    "      exptidx='$elabinelab_exptidx'");
    }
}

#
# If wrapping an experiment, copy over type/fixnode info to wrapper.
# We already made sure the experiment was created with enough nodes (see
# the parser) but now we have to make sure that the type/fixnode stuff will
# correspond to what the wrapped experiment really wants. It is a lot easier
# to do this here then in the parser.
#
if ($elabinelab && defined($elabinelab_eid)) {
    my $outer_result;
    my $inner_result;
    my $maxnodes;

    if (! ($inner_result =
	   DBQueryWarn("select type,fixed from virt_nodes ".
		       "where pid='$pid' and eid='$elabinelab_eid'"))) {
	fatal("Could not get virt_node info for $pid/$elabinelab_eid!");
    }
    if (! ($outer_result =
	   DBQueryWarn("select vname from virt_nodes ".
		       "where pid='$pid' and eid='$eid' and ".
		       "      inner_elab_role='node'"))) {
	fatal("Could not get virt_node info for $pid/$eid!");
    }

    #
    # Move over info for each real node in the inner experiment. Delay
    # nodes will be extra nodes in the outer experiment, but those do
    # not currently get type/fix info since the the user has no way to
    # do that in the NS file.
    # 
    while (my ($type,$fixed) = $inner_result->fetchrow_array()) {
	my ($vname) = $outer_result->fetchrow_array();

	fatal("Not enough nodes in outer experiment!")
	    if (!defined($vname));

	DBQueryWarn("update virt_nodes set ".
		    "  type='$type',fixed='$fixed' ".
		    "where pid='$pid' and eid='$eid' and vname='$vname'")
	    or fatal("Could not get virt_node info for $pid/$eid!");
    }
}

#
# This stats stuff is not done in testmode.
# 
if (! $TESTMODE) {
    #
    # Deal with ElabInElab stuff, which is updated after the parse and prerun.
    # Want to move this to the stats records. Ditto for the security stuff,
    # which was handled above.
    #
    my $elabinelab_exptidx;

    if ($elabinelab || $security_level) {
	DBQueryWarn("update experiment_stats set ".
		    "   elabinelab=$elabinelab, ".
		    "   security_level=$security_level ".
		    "where pid='$pid' and eid='$eid' and exptidx='$exptidx'");
    }

    if ($elabinelab_eid) {
	TBExptIDX($pid, $elabinelab_eid, \$elabinelab_exptidx)
	    or fatal("Failed to get experiment index for $pid/$elabinelab_eid!");
    
	DBQueryWarn("update experiment_stats set ".
		    "   elabinelab_exptidx=$elabinelab_exptidx ".
		    "where pid='$pid' and eid='$eid' and exptidx='$exptidx'");
    }
}

TBDebugTimeStamp("tbprerun finished");
print "Pre run finished. " . TBTimeStamp() . "\n";
exit(0);

