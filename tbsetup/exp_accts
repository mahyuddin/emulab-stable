#!/usr/local/bin/perl -w

### Really run with -T
### Close all my pipes

###
### exp_accts - Makes accounts for all users in this experiment's project.
###
### Adds accounts to currently booted OS only.
###

###
### Todo:
###      - create the user / make key / put in auth keys in tb machine
###        (tried: cannot due to permissions problems on plastic)
###

use Mysql;

my $d = 1;			#debug flag

if ($#ARGV < 0) { 
    die("Usage: exp_accts <eid>\n".
	"Makes accounts for all users in an experiment's project.\n");
}
my $eid = $ARGV[0];
if ( !($eid =~ /^[A-Za-z0-9\.\-\_ ]+$/) ) { 
    die("Invalid eid '$eid' contains illegal characters.\n"); 
}

##
## Check for valid user
##
open(WHO,"/usr/bin/whoami 2>&1 |");
chop($_ = <WHO>);
close(WHO);
if ($_ ne "root") { die("This won't work unless you're root.\n"); }

##
## Open database
##
my $dbh = Mysql->connect("localhost","tbdb","script","none");

##
## Check that we have a valid EID. If the EID
## doesn't exist, it's invalid.
##
my $cmd = "select eid from experiments where eid='$eid'";
my $sth = $dbh->query($cmd);
my $rows =0;
## Must put in check that $sth defined. May be undefined if
## command above is syntactically incorrect.
while ($sth->fetchrow_array) {
    $rows += 1;
}
if ( $rows != 1 ) { die("Invalid eid '$eid' (not in database).\n"); }


##
## Select user parameters for users in given experiment.
## Join: exp.pid -> p.pid
##
$cmd = 
  "select u.uid,u.usr_pswd,u.unix_uid,u.usr_name ".
  "from experiments as e ".
  "left join projects as p on e.pid = p.pid ".
  "left join proj_memb as pm on p.pid = pm.pid ".
  "left join users as u on u.uid = pm.uid ".
  "where e.eid = '$eid'";
$sth = $dbh->query($cmd);
my %passwd = ();
my %unix_uid = ();
my %fullname = ();
while (@row = $sth->fetchrow_array) {
    $passwd{$row[0]} = $row[1];
    $unix_uid{$row[0]} = $row[2];
    $fullname{$row[0]} = $row[4];
}

##
## Select group ID for experiment.
##
$cmd = 
  "select unix_gid from groups as g ".
  "left join proj_grps as pg on g.gid = pg.gid ".
  "left join projects as p on pg.pid = p.pid ".
  "left join experiments as e on e.pid = p.pid ".
  "where e.eid = '$eid'";
$sth = $dbh->query($cmd);
my $unix_gid = 65533;		# "nogroup"...
if (@row = $sth->fetchrow_array) {
    $unix_gid = $row[0];
}
print "Unix GID: $unix_gid\n" if $d;

##
## Select machines.
##
$cmd = 
  "select IP from interfaces as ip ".
  "left join reserved as r on r.node_id=ip.node_id ".
  "left join experiments as e on r.eid = e.eid ".
  "where e.eid = '$eid'";
$sth = $dbh->query($cmd);
my @nodes = ();
while (@row = $sth->fetchrow_array) {
    push(@nodes,$row[0]);
}

if ($d) {
    print "Nodes: ";
    foreach (@nodes) {
	if ($_) { print "$_\t\n"; }
    }
}

##
## For each machine, ping to see if its alive.
## If alive, determine if its FreeBSD or Linux and
## create the user accounts. 
##
my $last = "";
my $OS = "";
my $IP = "";
foreach $IP (@nodes) {
    ## If this machine is not the same as the last one, get the OS
    ## Check also that the IP address is valid (some interfaces might
    ## not have an IP address. Do we really have to check that the node
    ## is not the same node as in last iteration? -lkw
    if ( $IP ne $last && $IP =~ /[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+/) {
        $last = $IP;
        if (-e "/bin/ping") {
            open(PING,"/bin/ping -c 1 $IP 2>&1 |");
        } else {
            open(PING,"/sbin/ping -c 1 $IP 2>&1 |");
        }
        do { } until ( <PING> =~ /transmitted, (\d+) packets received/ );
        print "Got $1 ping packet(s) back from $IP.\n" if $d;
        if ( $1 > 0 ) {
            open(UNAME,"su1 ssh $IP uname -a 2>&1 |");
            $_ = <UNAME>;
            print "back from uname:$_";
	    ## FreeBSD says "155.99.214.129: Connection refused"
	    ##    and can also say "Host key doesn't match..."  
            if ( ($_=~/^Sorry/) || ($_=~/^$IP/) || ($_=~/^Host key/) ) { 
		die("Uname failed on $IP:$_\n"); 
	    } else { 
		@temp = split(" ",$_); 
		$OS = $temp[$0]; 
	    }
        } 

        print "OS for $IP is $OS\n" if $d;
        if ($OS eq "Linux") {  
	    

	    ## 1) Use groupadd to add group
	    ## 2) Use useradd to add users
	    ##
	    ## Rather than use useradd's defaults (which are normally)
	    ## fine, we're explicit.
	    
	    open(GROUPADD, "/usr/sbin/groupadd -g $unix_gid $eid 2>&1 |");
	    foreach my $name (keys %passwd) {
		open(USERADD, "/usr/sbin/useradd -c $fullname{$user} -d /home/$user -p $passwd{$user} -s /bin/tcsh -u $unix_uid{$user} -m $user 2>&1 |");
	    }

	} elsif ($OS eq "FreeBSD") { 

	    ## 1) Append new account info to master.passwd
	    ## 2) Create secure (spwd.db) and insecure (pwd.db) password 
	    ##    databases and
	    ## 3) Create passwd entries
	    ## 4) Create home directories

	    my $addon = "";
	    foreach my $name (keys %passwd) {
		$addon = "$addon$user:$passwd{$user}:$unix_uid{$user}:$unix_gid:$fullname{$user}:/home/$user:/bin/tcsh\n";

		print $addon;
	    }

	    open(SCP, "scp -p $IP:/etc/master.passwd /tmp/master.passwd.$IP");
	    open(OUT, ">>/etc/master.passwd");
	    print OUT $addon;
	    close(OUT);
	    open(SCP, "scp -p /tmp/master.passwd.$IP $IP:/etc/master.passwd");
 
	    ## Create secure and insecure databases (/etc/[s]*pwd.db)
#	    open (MKDB, "ssh $IP /usr/sbin/pwd_mkdb /etc/master.passwd 2>&1 |");
	    ## Update /etc/passwd
#	    open (MKDB, "ssh $IP /usr/sbin/pwd_mkdb -p /etc/master.passwd 2>&1 |");

#/usr/sbin/pwd_mkdb: corrupted entry
#/usr/sbin/pwd_mkdb: at line #14
#/usr/sbin/pwd_mkdb: /etc/master.passwd: Inappropriate file type or format
		
	} else {  
	    die "Unknown OS ($OS) on machine $IP.\n";
	}
    }
}

