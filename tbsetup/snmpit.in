#!/usr/bin/perl -w

#
# EMULAB-COPYRIGHT
# Copyright (c) 2000-2003 University of Utah and the Flux Group.
# All rights reserved.
#


#
# snmpit - A tool for setting up VLANs on SNMP-controllable switches
#

#
# Configure variables
#

use lib '@prefix@/lib';
my $TESTMODE = @TESTMODE@;
my $TB = '@prefix@';
my $COMMUNITY ='@SNMP_RW_COMMUNITY@';

use libdb;
use snmpit_lib;

use English;
use Getopt::Long;
use strict;

#
# Defaults
#
my $debug = 0;

if (!$COMMUNITY) {
    $COMMUNITY = "public";
}

######################################################################
# Step 1 - Process command-line arguments
#
# We have a fairly complex set of command line arguments, and we
# need to make sure that the user only specifies one command at a
# time.
######################################################################
sub usage {
    print << "END";
Usage: $0 [-h] [-v] [-n] [-i device]
	  [-l] [-s] [-g]
	  [-m name [ports]]
	  [-o name]
          [-r pid eid]
	  [-t pid eid]
	  [-d ports] [-e ports] [-a ports]
	  [-p <10|100> ports] [-u <half|full> ports]
	  [-c]
General:
  -h          Display this help message
  -v          Verbose mode
  -n          Test mode - don't actually make any changes
  -i <device> Operate on <device>, overriding default device list. Can be
                  given multiple times

VLAN Control:
  -t <pid> <eid>    Create all VLANs from database tables for an experiment
  -r <pid> <eid>    Remove all VLANs from database tables for an experiment
  -l                List all VLANs
  -w                Used with -l, includes device-specific VLAN number
  -m <name> [ports] Create a new VLAN with name <name>, if it doesn't exist,
                        and put [ports] in it
  -y <type>         When used with -m, the new VLAN becomes a private VLAN
                        of type <type>
  -x <primary>      When used with -y, assocates the new private VLAN with
                        the primary VLAN named <primary>
  -z <port>         Used with -y and -x, to specify which port is to be used
                        with the private VLAN
  -o <name>         Delete the VLAN with name <name>
  -c                Delete ALL VLANs, and recreate from the database. ** USE
                        WITH EXTREME CAUTION **

Port Control:
  -s                     List all ports, and show configuration information
  -g                     Get port statistics
  -d <ports>             Disable <ports>
  -e <ports>             Enable <ports>
  -a <ports>             Enable auto-negotiation of port speed/duplex
  -p <10|100> <ports>    Set speed of <ports> to 10 or 100 Mbps
  -u <half|full> <ports> Set duplex of <ports> to half or full

More than one operation can be specified - However, beware that the order in
which operations will occur is undefined, and some combinations of operations
(ie. -d and -e) are non-sensical.
END

    return 1;
}


my %opt = ();
GetOptions(\%opt, 'a','c','d','e','g','h','i=s@','l','m=s@','n','o=s@','p=s',
    'r','s','t','u=s','v','w','y=s','x=s','z=s');
# Unused: b,f,j,q,w

if ($opt{h}) {
    exit &usage;
}

if ($opt{v}) {
    $debug = $opt{v};
    print "Debug level is $debug\n";
}

#
# Values that may have been passed on the command line
#
my $pid;
my $eid;
my @ports;

#
# Some operations have mandatory agruments - for others, make sure that
# the user didn't give any extraneous arguments
#
if ($opt{t} || $opt{r}) {
    #
    # Options that take 'pid eid'
    #
    if (@ARGV < 2) {
	warn "ERROR: pid/eid reqired!\n";
	exit &usage;
    } else {
	($pid, $eid) = (shift @ARGV, shift @ARGV);
    }
} elsif ($opt{d} || $opt{e} || $opt{a} || $opt{p} || $opt{u} || $opt{m}) {
    #
    # Options that take a list of ports
    #
    @ports = @ARGV;
} else {
    #
    # Everything else
    #
    if (@ARGV) {
	warn "ERROR: Too many arguments!\n";
	exit &usage;
    }
}

#
# Determine which operation we're performing. This is just for convenience,
# so that we can use switch-like constructs later. While we're at it, we
# pull out any arguments that were given in the $opt{} values.
#
my @commands;

#
# Simple commands
#
if ($opt{l}) { push @commands, ["listvlans"]; }
if ($opt{s}) { push @commands, ["listports"]; }
if ($opt{g}) { push @commands, ["getstats"]; }
if ($opt{t}) { push @commands, ["tables"]; }
if ($opt{r}) { push @commands, ["reset"]; }
if ($opt{c}) { push @commands, ["recreate"]; }

#
# Commands that can appear once, and take an agurment
#
if ($opt{d}) { push @commands, ["portcontrol","disable"]; }
if ($opt{e}) { push @commands, ["portcontrol","enable"]; }
if ($opt{a}) { push @commands, ["portcontrol","auto"]; }

#
# Commands that can occur more than once
#
if ($opt{m}) {
    foreach my $name (@{$opt{m}}) {
	push @commands, ["make",$name];
    }
}

if ($opt{o}) {
    foreach my $name (@{$opt{o}}) {
	push @commands, ["remove",$name];
    }
}

#
# Commands that require 'translation' of their arguments
#
if ($opt{p}) {
    #
    # We'll put the argument in the form needed by the portControl function
    #
    if ($opt{p} =~ /^100/) {
	push @commands, ["portcontrol","100mbit"];
    } elsif ($opt{p} =~ /^10/) {
	push @commands, ["portcontrol","10mbit"];
    } else {
	die "Bad port speed: $opt{p}. Valid values are 10 and 100\n";
    }
}
if ($opt{u}) {
    #
    # We'll put the argument in the form needed by the portControl function
    #
    if ($opt{u} =~ /half/) {
	push @commands, ["portcontrol","half"];
    } elsif ($opt{u} =~ /full/) {
	push @commands, ["portcontrol","full"];
    } else {
	die "Bad port duplex: $opt{u}. Valid values are full and half\n";
    }
}

if (!@commands) {
    die "No operation given\n";
}

#
# Options that affect other commands
#

#
# Arguments for making private VLANs
#
# Build up a list of extra arguments to be passed to createVlan()
my @pvlanArgs = ();
if ($opt{y}) {
    #
    # Make sure the private VLAN type they gave is valid, and make sure they
    # gave the other required arugments for certain types
    #
    if ($opt{y} ne "primary" && $opt{y} ne "isolated" &&
	$opt{y} ne "community") {
	die "Unknown private VLAN type $opt{y}\n";
    }
    @pvlanArgs = $opt{y};
    if ($opt{y} ne "primary") {
	if (!$opt{x} || !$opt{z}) {
	    warn "**** -x and -z must be given when -y is $opt{y}!\n";
	    exit &usage;
	}
	#
	# Fix up ports given in the module/port format, like we do below for
	# ports from @ARGV
	#
	if ($opt{z} =~ /^\d+\/\d+?$/) {
	    if ($opt{i} && @{$opt{i}} == 1) {
		$opt{z} = $opt{i}->[0] . "." . $opt{z};
	    } else {
		die "The module/port format is only legal if exactly one -i " .
		    "argument has been given\n";
	    }
	}
	push @pvlanArgs,$opt{x},$opt{z};
    }
}

######################################################################
# Step 3 - Set up the stack objects
#
# Determine which devices to talk to, and make the appropriate
# stack objects
######################################################################

#
# If this is an operation on an experiment, make sure that they have permission
# to modify that experiment
#
if ($pid && $eid) {
    #
    # First, make sure the experiment exists
    #
    if (!ExpState($pid,$eid)) {
	die "There is no experiment $eid in project $pid\n";
    }
    if (!TBExptAccessCheck($UID,$pid,$eid,TB_EXPT_MODIFY)) {
	die "You do not have permission to modify experiment $pid/$eid\n";
    }
}

#
# If their operation involves a set of ports, make sure that the caller has
# access to the nodes that the ports are on
#

if (@ports) {
    #
    # Allow ports to be given in one of two forms: node:port, or switch.port.
    # Only admins can do the latter, of course...
    #
    my (@nodes, @switchports);
    foreach my $port (@ports) {
	if ($port =~ /^([^:]+):\d+$/) {
	    push @nodes, $1;
	} elsif ($port =~ /^([^.]+)\.\d+(\/\d+)?$/) {
	    push @switchports, $port;
	} elsif ($port =~ /^\d+\/\d+?$/) {
	    if ($opt{i} && @{$opt{i}} == 1) {
		$port = $opt{i}->[0] . "." . $port;
		push @switchports, $port;
	    } else {
		die "The module/port format is only legal if exactly one -i " .
		    "argument has been given\n";
	    }
	} else {
	    die "Bad format for port $port\n"
	}
    }

    if (!TBNodeAccessCheck($UID,TB_NODEACCESS_MODIFYVLANS,@nodes)) {
	die "You do not have permission to modify some or all of the nodes\n" .
		"that will be affected by the operation you requested\n";
    }

    if (@switchports && !TBAdmin()) {
	die "Only admins are allowed to modify switch ports directly\n";
    }
}

if ($TESTMODE) {
    print "Test mode, exiting without touching hardware\n";
    exit(0);
}

#
# snmpit_lib fills out some hashes for speed of lookup later. Initialize
# them now
#
snmpit_lib::init($debug);

my $exitval = 0;
foreach my $command (@commands) {

    #
    # Pull the operation and the arugments to it.
    #
    my ($operation,@args) = @$command;

    debug("Operation is $operation\n");

    #
    # Discover the set of devices we need to talk to. This differs depending
    # on the operation which we're performing. We also get a list of all ports
    # and vlan IDs involved in this operation, if appropriate
    #
    my @devicenames;
    my @vlans;
    SWITCH: for ($operation) {
	(/listvlans/ || /getstats/ || /make/ || /remove/) && do {
	    @devicenames = $opt{i}? @{$opt{i}} : getTestSwitches();
	    last;
	};
	(/listports/) && do {
	    @devicenames = $opt{i}? @{$opt{i}} :
	    (@ports? getDeviceNames(@ports) : getTestSwitches());
	    last;
	};
	(/tables/) && do {
	    @vlans = getExperimentVlans($pid,$eid);
	    @ports = getVlanPorts(@vlans);
	    @devicenames = $opt{i}? @{$opt{i}} : getTestSwitches();
	    last;
	};
	(/reset/) && do {
	    #
	    # When we reset, we operate on all test switches, just to be safe
	    #
	    @vlans = getExperimentVlans($pid,$eid);
	    @devicenames = $opt{i}? @{$opt{i}} : getTestSwitches();
	    last;
	};
	(/portcontrol/) && do {
	    @devicenames = $opt{i}? @{$opt{i}} : getDeviceNames(@ports);
	    last;
	};
	(/recreate/) && do {
	    #
	    # Safety check - cannot be used with -i . We have to operate on
	    # all experimental switches
	    #
	    if ($opt{i}) {
		die "-c and -i cannot be used together\n";
	    }
	    @devicenames = getTestSwitches();
	    last;
	};
    }

    debug("Device names: " . join(",",@devicenames) . "\n");
    debug("Ports: " . join(",",@ports) . "\n");

    #
    # Find out which stack each device belongs to
    #
    my %stacks = ();
    foreach my $devicename (@devicenames) {
	my $stack = getSwitchStack($devicename);
	if (defined($stack)) {
	    push @{$stacks{$stack}}, $devicename;
	}
    }

    #
    # Now, make the object for each stack that we discovered
    #
    my @stacks;
    foreach my $stack_id (keys %stacks) {
	my ($stack_type, $supports_private, $single_domain, $community)
		= getStackType($stack_id);
	#
	# Safety check - make sure the stack supports private VLANs if -y was
	# given
	#
	if ($opt{y} && !$supports_private) {
	    die "Switch stack $stack_id does not support private VLANs\n";
	}

	#
	# If we got back a special community to use for this switch, use it -
	# otherwise, use the default we got from configure
	#
	if (!$community) {
	    $community = $COMMUNITY;
	}

	my $stack;
	debug("Stack $stack_id has type $stack_type\n");
	SWITCH: for ($stack_type) {
	    /cisco/ && do {
		require snmpit_cisco_stack;
		$stack = new snmpit_cisco_stack($stack_id,$debug,$community,
		    $supports_private, $single_domain, @{$stacks{$stack_id}});
		last;
	    }; # /cisco/
	    /intel/ && do {
		require snmpit_intel_stack;
		$stack = new snmpit_intel_stack($stack_id,$debug,$community,
		    @{$stacks{$stack_id}});
		last;
	    };

	    # 'default' case
	    die "Unknown stack type $stack_type for stack $stack_id\n";
	}

	#
	# Check for error in object creation and bail
	#
	if (!$stack) {
	    die "Unable to connect to one or more switches, exiting\n";
	} else {
	    push @stacks, $stack;
	}
    }

######################################################################
# Step 4 - Actually perfrom the operation
#
# Finally, we just call the helper function for the operation that
# is to be performed.
######################################################################
    if ($opt{n}) {
	print "Test mode, skipping operation\n";
	next;
    }

    SWITCH: for ($operation) {
	/listvlans/ && do {
	    $exitval += doListVlans(\@stacks);
	    last;
	}; # /listvlans/ && do 
	/listports/ && do {
	    $exitval += doListPorts(\@stacks);
	    last;
	}; # /listports/ && do
	/getstats/ && do {
	    $exitval += doGetStats(\@stacks);
	    last;
	}; # /ports/ && do
	/tables/ && do {
	    $exitval += doVlansFromTables(\@stacks,@vlans);
	    last;
	}; # /tables/ && do
	/reset/ && do {
	    $exitval += doReset(\@stacks,@vlans);
	    last;
	};
	/make/ && do {
	    my ($vlan_name) = @args;
	    $exitval += doMakeVlan(\@stacks,$vlan_name,@ports);
	    last;
	};
	/remove/ && do {
	    my ($vlan_name) = @args;
	    $exitval += doDeleteVlan(\@stacks,$vlan_name);
	    last;
	};
	/portcontrol/ && do {
	    my ($portcommand) = @args;
	    $exitval += doPortControl(\@stacks,$portcommand,@ports);
	    last;
	};
	/recreate/ && do {
	    $exitval += doRecreateVlans(\@stacks);
	    last;
	};
    }
}

exit $exitval;

######################################################################
# Subs
######################################################################

#
# Print given message to STDERR, only if debug mode is on
#
sub debug($) {
    if ($debug) {
	print STDERR @_;
    }
}

#
# Lists all vlans on all stacks
#
sub doListVlans ($) {

    my $stacks = shift;
    
    my %vlans;

    #
    # We need to 'coallate' the results from each stack by putting together
    # the results from each stack, based on the VLAN identifier
    #
    foreach my $stack (@$stacks) {
	my @vlanList = $stack->listVlans();
	foreach my $vlan (@vlanList) {
	    my ($id,$ddep,$memberref) = @$vlan;
	    ${$vlans{$id}}[0] = $ddep;
	    push @{${$vlans{$id}}[1]}, @$memberref;
	}
    }

    #
    # These need to be declared here for the benefit of the format string
    # See perlform(1) for help with formats
    #
    my ($vlan_id,$ddep,$pideid,$vname,$members);
    #
    # Check to see if they want device-specific VLAN numbers, which makes the
    # display more cramped, but is useful for debugging
    #
    if (!$opt{w}) { 
	print << "END";
VLAN     Project/Experiment VName     Members
--------------------------------------------------------------------------------
END
	format vlanlist =
@<<<<<<< @<<<<<<<<<<<<<<<<< @<<<<<<<< ^<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
$vlan_id,$pideid,           $vname,   $members
~~                                    ^<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
                                      $members
.
	$FORMAT_NAME = 'vlanlist';
    } else {
    	print << "END";
VLAN     Number Project/Experiment VName     Members
--------------------------------------------------------------------------------
END
	format vlanlist2 =
@<<<<<<< @<<<<< @<<<<<<<<<<<<<<<<< @<<<<<<<< ^<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
$vlan_id,$ddep, $pideid,           $vname,   $members
~~                                           ^<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
                                             $members
.
	$FORMAT_NAME = 'vlanlist2';
}

    foreach $vlan_id (sort {tbsort($a,$b)} keys %vlans) {
	my $memberref;
	($ddep,$memberref) = @{$vlans{$vlan_id}};

	#
	# Find which, if any, experiment this VLAN belongs to.
	#
	my $result = DBQueryFatal("select pid, eid, virtual from " .
				  "vlans where id='$vlan_id'");
	my ($eid,$pid);
	($pid,$eid,$vname) = $result->fetchrow();

	#
	# Permissions check - people only get to see their own VLANs
	#
	if ((!$eid) || (!$pid)) {
	    if (!TBAdmin()) {
		&debug("Failed TBAdmin check\n");
		next;
	    }
	} elsif (!TBExptAccessCheck($UID,$pid,$eid,TB_EXPT_READINFO)) {
	    &debug("Failed TBExptAccessCheck($UID,$pid,$eid)\n");
	    next;
	}


	if (!$vname) { $vname = ""; }
	$members = join(" ",@$memberref);

	#
	# Setup $pideid for a more compact display
	#
	if ($eid && $pid) {
	    $pideid = "$pid/$eid";
	} else {
	    $pideid = "";
	}
	write;
    }

    return 0;
}

#
# Lists all ports on all stacks
#
sub doListPorts($) {

    my $stacks = shift;

    #
    # Get a listing from all stacks
    #
    my @portList = ();
    foreach my $stack (@$stacks) {
	push @portList, $stack->listPorts;
    }

    #
    # See perlform(1) for help with formats
    #
    my ($port,$enabled,$up,$speed,$duplex);
    print << "END";
Port      Enabled Up   Speed      Duplex
--------------------------------------------
END
    format portlist =
@<<<<<<<< @<<<<<< @<<< @<<<<<<<<< @<<<<<<<<<
$port,    $enabled,$up,$speed,$duplex
.
    $FORMAT_NAME = 'portlist';
    foreach my $line (sort {tbsort($$a[0],$$b[0])} @portList) {
	($port,$enabled,$up,$speed,$duplex) = @$line;
	#
	# Only let people see information about ports in their experiments
	#
	$port =~ /^(.+):/;
	my $node = $1;

	&debug("node is $node\n");
	if (!$node) {
	    if (!TBAdmin($UID)) {
		next;
	    }
	} elsif (!TBNodeAccessCheck($UID,TB_NODEACCESS_READINFO,$node)) {
	    next;
	}
	write;
    }

    return 0;
}

#
# Get statistics for all ports on all stacks
#
sub doGetStats($) {

    my $stacks = shift;

    #
    # Get a listing from all stacks
    #
    my @statList = ();
    foreach my $stack (@$stacks) {
	push @statList, $stack->getStats();
    }

    my ($port, $inoctets, $inunicast, $innunicast, $indiscards, $inerr,
        $inunk, $outoctets, $outunicast, $outnunicast, $outdiscards,
	$outerr,$outq);
    #
    # See perlform(1) for help with formats
    #
    print << "END";
          In         InUnicast  InNUnicast In         In         Unknown    Out        OutUnicast OutNUcast  Out       Out         OutQueue
Port      Octets     Packets    Packets    Discards   Errors     Protocol   Octets     Packets    Packets    Discards  Errors      Length
---------------------------------------------------------------------------------------------------------------------------------------------
END
    format stats =
@<<<<<<<< @>>>>>>>>> @>>>>>>>>> @>>>>>>>>> @>>>>>>>>> @>>>>>>>>> @>>>>>>>>> @>>>>>>>>> @>>>>>>>>> @>>>>>>>>> @>>>>>>>>> @>>>>>>>>> @>>>>>>>>> 
$port,    $inoctets, $inunicast,$innunicast,$indiscards,$inerr,  $inunk,    $outoctets,$outunicast,$outnunicast,$outdiscards,$outerr,$outq
.
    $FORMAT_NAME = 'stats';
    foreach my $line (sort {tbsort($a,$b)} @statList) {
	($port, $inoctets, $inunicast, $innunicast, $indiscards, $inerr,
	 $inunk, $outoctets, $outunicast, $outnunicast, $outdiscards,
	 $outerr, $outq) = @$line;
	write;
    }

    return 0;
}

#
# Creates all VLANs given. Looks up identifiers in the database to determine
# the membership.
#
sub doVlansFromTables($@) {
    my $stacks = shift;
    my @vlans = @_;

    my $errors = 0;

    if (@$stacks > 1) {
	die "VLAN creation accross multiple stacks is not yet supported\n" .
	    "Stacks are " . join(",",@$stacks) . "\n";
    }
    my ($stack) = @$stacks;

    foreach my $vlan (@vlans) {
	my @ports = getVlanPorts($vlan);
	if ($stack->vlanExists($vlan)) {
	    print "  VLAN $vlan already exists\n";
	    $errors += $stack->setPortVlan($vlan,@ports);
	} else {
	    if (!$stack->createVlan($vlan,\@ports)) {
		warn "ERROR: Failed to create VLAN with id $vlan\n";
		#
		# Don't try to put ports in a VLAN if it couldn't be created
		#
		$errors++;
	    }
	}

	#
	# Set the speed and duplex of each interface depending on the
	# value in the database
	#
	foreach my $port (@ports) {
	    my ($speed,$duplex) = getInterfaceSettings($port);
	    #
	    # If either is not set, we do nothing. We could make
	    # a 0 mean 'auto'
	    #
	    # For now, we ignore it if the switch doesn't support the commands.
	    if ($speed) {
		my $cmd = $speed . "mbit";
		my $rv = $stack->portControl($cmd, $port);
		if ($rv > 0) {
		    $errors += $rv;
		}

	    }
	    if ($duplex) {
		my $rv = $stack->portControl($duplex, $port);
		if ($rv > 0) {
		    $errors += $rv;
		}
	    }
	}
    }

    return $errors;
}

#
# Remove all VLANs given from every switch in the stack. All ports in the
# VLANs are removed, irrespective of what the database says membership should
# be
#
sub doReset($@) {
    my $stacks = shift;
    my @vlans = @_;

    my $errors = 0;
    #
    # Just remove the VLAN from evey satck on which it exists. We keep a
    # list and do them all at once for efficiency.
    #
    foreach my $stack (@$stacks) {
	my @existant_vlans = $stack->existantVlans(@vlans);
	if (!$stack->removeVlan(@existant_vlans)) {
	    $errors++;
	}
    }
    return $errors;
}

#
# Create a vlan with name $vlan_name. It is not an error to try to create a
# VLAN that already exists, as this can be used to add ports to an existing
# VLAN. If ports are given, they are put into the VLAN.
#
sub doMakeVlan($$@) {
    my $stacks = shift;
    my $vlan_name = shift;
    my @ports = @_;

    my $errors = 0;

    if (@$stacks > 1) {
	die "VLAN creation accross multiple stacks is not yet supported\n" .
	    "Stacks are " . join(",",@$stacks) . "\n";
    }
    my ($stack) = @$stacks;

    #
    # Create it if it doesn't already exist
    #
    if ($stack->vlanExists($vlan_name)) {
	print "VLAN $vlan_name already exists\n";
	#
	# Put requested ports into the VLAN
	#
	if (@ports) {
	    print "Putting ports in VLAN ...\n";
	    my $perrors = $stack->setPortVlan($vlan_name,@ports);
	    print "VLAN change ";
	    print $perrors? "failed":"succeeded",".\n";
	    $errors += $perrors;

	}
    } else {
	print "Creating VLAN $vlan_name ...\n";
	my $ok = $stack->createVlan($vlan_name,\@ports,@pvlanArgs);
	print "VLAN creation ";
	print $ok? "succeeded":"failed",".\n";
	if (!$ok) {
	    $errors++;
	}
    }

    return $errors;
}

#
# Delete the given VLAN, if it exists
#
sub doDeleteVlan($@) {
    my $stacks = shift;
    my @vlan_names = @_;

    my $errors = 0;

    my %exists = ();
    foreach my $stack (@$stacks) {
	my @existant_vlans;
	foreach my $vlan_name (@vlan_names) {
	    if ($stack->vlanExists($vlan_name)) {
		$exists{$vlan_name} = 1;
		push @existant_vlans, $vlan_name;
	    }
	}
	if (@existant_vlans) {
	    print "Deleting VLAN(s) " . join(",",@existant_vlans) . " ...\n";
	    my $ok = $stack->removeVlan(@existant_vlans);
	    print "VLAN deletion ";
	    print $ok? "succeeded":"failed",".\n";
	    if (!$ok) {
		$errors++;
	    }
	}
    }

    foreach my $vlan_name (@vlan_names) {
	if (!$exists{$vlan_name}) {
	    print "VLAN $vlan_name does not exist\n";
	    $errors++;
	}
    }

    return $errors;
}

#
# Send $command to @ports.
# TODO: List of commands
#
sub doPortControl($$@) {
    my $stacks = shift;
    my $command = shift;
    my @ports = @_;

    if (@$stacks > 1) {
	die "Port control accross multiple stacks is not yet supported\n" .
	    "Stacks are " . join(",",@$stacks) . "\n";
    }
    my ($stack) = @$stacks;

    print "Applying command '$command' to ports " . join(",",@ports) . " ...\n";
    my $errors = $stack->portControl($command,@ports);
    print "Port command ";
    print $errors? "failed":"succeeded",".\n";

    return $errors;

}

#
# Remove all VLANs from the switch, and re-create them from the database
# tables.
#
sub doRecreateVlans($) {
    my $stacks = shift;

    #
    # Make sure the user REALLY wants to do this
    #

    if (!TBAdmin()) {
	warn "Sorry, only admins get to use this function\n";
	return 0;
    }

    warn "WARNING: Using this function will cause all VLANS to be\n";
    warn "deleted and re-created. This will cause temporary disruption,\n";
    warn "and you will lose all hand-created VLANs. This function operates\n";
    warn "on ALL experimental switches.\n";
    warn "\nAre you SURE you want to do this? (yes/no)\n";

    my $doit = <>;

    if (!($doit =~ /^y/i)) {
	warn "Not recreating VLANs\n";
	return 0;
    } else {
	warn "Okay, recreating VLANs\n";
    }

    #
    # Get a list of all VLANs on all of the given switches, so that we can
    # nuke them.
    #
    my @vlansToNuke = ();
    foreach my $stack (@$stacks) {
	my @stackVlans = $stack->listVlans();
	foreach my $vlan (@stackVlans) {
	    my $id = $$vlan[0];
	    #
	    # Special case - don't try to delete the 'switch-control' VLAN,
	    # because that's the one we're talking to the switches on.
	    #
	    if ($id ne 'switch-control') {
		push (@vlansToNuke,$id);
	    }
	}
    }

    debug("Going to nuke " . join(',',@vlansToNuke) . "\n");

    doDeleteVlan($stacks,@vlansToNuke);

    #
    # Get a list of all experiments, so that we can re-create their VLANs
    #
    my @expts = ();
    my $result = DBQueryFatal("select pid,eid from experiments ".
    	"where state = '". EXPTSTATE_ACTIVE. "'");
    while (my ($pid,$eid) = $result->fetchrow()) {
	my @vlans = getExperimentVlans($pid,$eid);
	doVlansFromTables($stacks,@vlans);
    }

    return 1;

}
