#!/usr/local/bin/perl -w
#########################################################################
# snmpit - A General Purpose SNMP Tool                                  #
# (specialized for Intel 510T, Cisco 6509 and APC power controllers)    #
#                                                                       #
# Run with -h option to see command line syntax/options.                #
#                                                                       #
#########################################################################

my $TB;
my $DBNAME = "@TBDBNAME@";

BEGIN {
  $TB     = "@prefix@";
  # This needs to go in BEGIN so it happens before the use clauses...
  push(@INC,$TB."/lib");
}

my $debug = 0;
#If there is debug, turn it on right now...
if ( join(" ",@ARGV) =~ /-debug\s*(\d*)/ ) {
  if ( defined $1 && $1 ne "") { $debug = $1; } else { $debug = 1; }
  print "DEBUG MODE ON: Set to level $debug\n";
}

use English;

#Uncomment this when we really need to be able to handle intel switches
#use snmpit_intel;
use snmpit_cisco;
use snmpit_apc;
use snmpit_lib;

$| = 1; # Turn off line buffering on output

my $device;
my $pid;
my $eid;
my $t = 0; #VLANs from db table
my $reset = 0; #reset VLANs
my $n;     #VLAN # to move ports into
my %vlantable = ();
my @vlanlist = ();
my %vlansbyname = ();
my %vlanids = ();

&myMain;

# Numerically sort
sub num { $a <=> $b; }

sub myMain {

  my $i = "";	#IP addr.
  my @p = ();	#Port numbers
  my $d = 0;    #Disable (bool)
  my $e = 0;	#Enable (bool)
  my $a = "";	#Auto Negotiation (enable/disable) (two-way switch)
  my $dup = "";	#Duplex (half/full)
  my $spd = 0;	#Speed (10/100)
  my $s = 0;	#Show port configs
  my $g = 0;	#Get Statistics
  my $f = "";	#AutoVLAN filename
  my $l = 0;	#List all VLANs on switch
  my $m = "";	#Create VLAN - name
  my @vlan =();	#VLAN Members - list of MAC Addresses
  my @r = ();	#VLAN(s) to be removed
  my $u = 0;	#Wait for Update of VLAN tables
  my $b = 0;	#Block (bool) (two-way switch)
  my $c = 1;	#Confirm Changes (bool) (two-way switch)
  my $v = 0;	#Verbose (bool) !Must default quiet; switch only turns on!

  #power control
  my $powerop=0;
  my @outlets=();

  &ParseArgs(\@ARGV,\$i,\@p,\$d,\$e,\$a,\$dup,\$spd,\$s,\$f,\$l,\$m,\@vlan,
	     \@r,\$u,\$b,\$c,\$v,\$g,
	     \$powerop,\@outlets);

  if ($d) {
    my $rv = $device->portControl("disable",@p);
    print "Port disable for @p had $rv failures.\n";
  } elsif ($e) {
    my $rv = $device->portControl("enable",@p);
    print "Port enable for @p had $rv failures.\n";
  }
  if ($spd) {
    my $rv = $device->portControl($spd,@p);
    print "Port speed change for @p had $rv failures.\n";
  }
  if ($dup) {
    my $rv = $device->portControl($dup,@p);
    print "Port duplex change for @p had $rv failures.\n";
  }
  if ($a) {
    my $rv = $device->portControl("auto",@p);
    print "Port auto-configuration change for @p had $rv failures.\n";
  }
  if ($n) {
    my $rv = $device->portControl("VLAN$n",@p);
    print "Port VLAN change for @p had $rv failures.\n";
  }

  #Show always goes after changes, so that they are reflected.
  if ($s) { $device->showPorts; }
  if ($g) { $device->getStats; }

  if (@vlan) {
    getvlans();
    if (vlanexists($m,@vlan)) {
      print "VLAN $m exists with ",join(" ",sort @vlan),"\n";
    } else {
      $device->vlanLock;
      $device->setupVlan($m,@vlan);
      $device->vlanUnlock;
    }
  }

  if ($f) {
    getvlans();
    my @VLANS= ();
    my @names= ();
    my $m="";
    my @vlan=();
    &ReadIRFile(\$f,\@names,\@VLANS);
    $device->vlanLock;
    while (@VLANS) {
      @vlan = @{shift(@VLANS)};
      $m = shift @names;
      if (vlanexists($m,@vlan)) {
	print "VLAN $m exists with ",join(" ",sort @vlan),"\n";
      } else {
	print "Making $m with ",join(' ',sort @vlan),"\n" if $debug;
	$device->setupVlan($m,@vlan);
      }
    }
    $device->vlanUnlock;
  }

  if ($t) {
    getvlans();
    $device->vlanLock;
    my @vlan;
    foreach $id (keys %vlantable) {
      @vlan = sort split(" ",$vlantable{$id});
      if (vlanexists($id,@vlan)) {
	print "VLAN $id exists with ",join(" ",@vlan),"\n";
      } else {
	print "Making VLAN '$id' with @vlan\n" if $debug;
	$device->setupVlan($id,@vlan);
      }
    }
    $device->vlanUnlock;
  }

  if ($reset) {
    getvlans();
    $device->vlanLock;
    my @vlan;
    foreach $id (keys %vlantable) {
      @vlan = sort split(" ",$vlantable{$id});
      if (vlanexists($id,@vlan)) {
	if ( ($num = vlannum($id)) > 0) {
	  print "VLAN #$num $id exists with ",join(" ",@vlan),"\n";
	  $device->removeVlan($num);
	} else {print STDERR "Couldn't find VLAN nubmer for '$id'\n";}
      } else {print STDERR "Couldn't find VLAN '$id' (",join(" ",@vlan),")\n";}
    }
    $device->vlanUnlock;
  }

  if (@r) {
    $device->vlanLock;	
    foreach my $x (sort num @r) {
      $device->removeVlan($x);
    }
    $device->vlanUnlock;
  }

  #List VLANs is always last so that changes made are reflected
  if ($l) {
    my @vlans;
    getvlans();
    @vlans = @vlanlist;
    print "ID  Name\t\t\t    Members of VLAN\n";
    print "-"x75,"\n";
    my $id;
    my $name;
    my $memberstr;
    # I'm trying out using formats. See perldoc perlform for details.
    format vlan = 
@<< @<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< ^<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
$id,$name,                          $memberstr
~~                                  ^<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
                                    $memberstr
.
    $FORMAT_NAME = "vlan";
    while (@vlans) {
      ($id,$name,$memberstr) = split ("\t",shift @vlans);
      write;
    }
    $FORMAT_NAME = "STDOUT"; # Go back to the normal format
  }

  if ($powerop) {
    foreach $outlet (@outlets) {
      $device->power($powerop,$outlet);
    }
  }
}

sub getvlans {
  if ( @vlanlist ) { return; }
  @vlanlist = $device->listVlans;
  foreach $entry (@vlanlist) {
    my ($id,$name,$memberstr) = split ("\t", $entry);
    $vlansbyname{$name} = $memberstr;
    $vlanids{$name} = $id;
    print "vlans: #$id -> $name -> $memberstr\n" if $debug;
  }
}

sub vlanexists {
  my $m = shift;
  my $members = join(" ",sort @_);
  print "Checking $m ($members)...\n" if $debug;
  if (defined $vlansbyname{$m} && $vlansbyname{$m} eq $members) {
    print "Found $m == $vlansbyname{$m}\n" if $debug;
    return 1;
  }
  return 0;
}

sub vlannum {
  my $n = shift;
  print "Checking $n...\n" if $debug;
  if (defined $vlanids{$n}) {
    print "Found $n == $vlanids{$n}\n" if $debug;
    return $vlanids{$n};
  }
  return 0;
}

sub ParseArgs {
  local(*CMDS,*i,*p,*d,*e,*a,*dup,*spd,*s,*f,*l,*m,*vlan,*r,*u,*b,*c,*v,*g,
	*powerop,*outlets) = @_;
  my $help=0;
  if (@main::CMDS < 1) {$help = 1; }
  print "Command line was: snmpit ",join(" ",@ARGV),"\n" if $debug;
  while (@CMDS != 0 && $CMDS[0] =~ /^(-|\+)/) {
    $_ = shift(@CMDS);
    if (/^-i(.*)/) {$i = ($1 ? $1 : shift(@CMDS));}
    elsif (/^-p(.*)/) {
      my $Range ="";
      do {
	$Range = ($1 ? $1 : shift(@CMDS));
	#print "Range=$Range\n";
	if ( $Range =~ /^(\d*)\.\.(\d*)$/ ) {
	  #print "1Pushing ",$1..$2,"*\n";
	  push(@p, $1..$2);
	} else {
	  #print "2Pushing ",$Range,"*\n";
	  push(@p, $Range);
	}
      }
      while (@CMDS>0 && ! ($CMDS[0] =~ /^(-|\+)(.*)/ ) );
    }
    elsif (/^-debug(.*)/) {
      if ( defined($CMDS[0]) && !($CMDS[0] =~ /^-/)) { 
	shift (@CMDS); # possibly ignore number
      }
      $v=1; # debug is already set, so don't do it here
    }
    elsif (/^-h(.*)/) {$help = 2;}
    elsif (/^-off(.*)/) {$powerop = "off";}
    elsif (/^-on(.*)/) {$powerop = "on";}
    elsif (/^-cyc(.*)/) {$powerop = "cyc";}
    elsif (/^-a(.*)/) {$a="disable";}
    elsif (/^\+a(.*)/) {$a="enable";}
    elsif (/^-dup(.*)/) {$dup = ($1 ? $1 : shift(@CMDS));}
    elsif (/^-spd(.*)/) {$spd = ($1 ? $1 : shift(@CMDS));}
    elsif (/^-n(.*)/) {$n = ($1 ? $1 : shift(@CMDS));}
    elsif (/^-d(.*)/) {$d = 1;}
    elsif (/^-e(.*)/) {$e = 1;}
    elsif (/^-s(.*)/) {$s = 1;}
    elsif (/^-g(.*)/) {$g = 1;}
    elsif (/^-l(.*)/) {$l = 1;}
    elsif (/^-u(.*)/) {$u = 1;}
    elsif (/^-f(.*)/) {$f = ($1 ? $1 : shift(@CMDS));}
    elsif (/^-t(.*)/) {$t = 1; $pid = ($1 ? $1 : shift(@CMDS));
		       $eid = shift(@CMDS); }
    elsif (/^-reset(.*)/) {$reset = 1; $pid = ($1 ? $1 : shift(@CMDS));
			   $eid = shift(@CMDS); }
    elsif (/^-m(.*)/) {$m = ( !(@CMDS==0 || $CMDS[0] =~ /^(-|\+)(.*)/) ?
			      ($1 ? $1 : shift(@CMDS)) : "");}
    elsif (/^-vlan(.*)/) {
      push(@vlan, ($1 ? $1 : shift(@CMDS)));
      while ( @CMDS>0 && ! ($CMDS[0] =~ /^(-|\+)(.*)/ ) ) {
	push(@vlan, shift(@CMDS));
      }
    }
    elsif (/^-r(.*)/) {
      my @tmp = ();
      @r = ();
      push(@tmp, ($1 ? $1 : shift(@CMDS)));
      while ( @CMDS>0 && ! ($CMDS[0] =~ /^(-|\+)(.*)/ ) ) {
	push(@tmp, shift(@CMDS));
      }
      foreach $n (@tmp) {
	if ($n =~ /^[0-9]+$/) { push(@r, $n); }
      }
      print "remove: '@r' ($#r)\n" if $debug;
      if ($#r < 0) { die("Which VLANs should I remove?\n"); }
      if (join(" ",@r) =~ /[^0-9 ]/) { die("Removal list '@r' invalid.\n"); }
    }
    elsif (/^-v(.*)/) {$v = 1;}
    elsif (/^-b(.*)/) {$b = 0;}
    elsif (/^\+b(.*)/) {$b = 1;}
    elsif (/^-c(.*)/) {$c = 0;}
    elsif (/^\+c(.*)/) {$c = 1;}
    elsif (/^-([1-8])$/) { push(@outlets, $1);}
    else {die("Unknown Option: $_\n");}
  }
  #print "Done\ni=$i p=",@p," d=$d e=$e a=$a dup=$dup s=$spd s=$s f=$f l=$l",
  #  "m=$m vlan=",@vlan," r=",@r,"u=$u b=$b c=$c v=$v g=$g ".
  #  "powerop=$powerop\n" if $debug;
  if ($help) {
    print
      "snmpit - A general purpose SNMP tool\n",
      "Syntax:\n",
      " snmpit [-h] [-v] -i<ip>\n",
      "\t[-u] [-l] [-f<filename>] [-m<vlan name>] [-vlan<port>]\n",
      "\t[-t <pid> <eid>] [-reset <pid> <eid>] [-r<vlan #> <vlan #> ... ]\n",
      "\t[+b|-b] [+c|-c] [-g] [-s] [-p <port> <port x>..<port y> ... ]\n",
      "\t[-d|-e] [+a|-a] [-spd<speed>] [-dup<duplex>] [-n<vlan #>]\n";
    # Hidden Power control functionality
    # "\t[ [-on|-off|-cyc] | [-<n>] ]\n";
  }
  if ($help > 1) {
    print
      "\nGeneral:\n",
      "  -h     Display this help message\n",
      "  -v     Verbose mode (now ",($v?"on":"off"),")\n",
      "  -i     IP address or switch name\n",
      "\nVLAN Control:\n",
      "  -u     Wait for Update of VLAN tables (takes ~10 seconds)\n",
      "  -l     List all VLANs on switch (ell, not #1)\n",
      "  -m     Make a VLAN called <name> (optional)\n",
      "  -vlan  Put ports in new VLAN (may be <node>:<if> or MAC)\n",
      "  -f     File mode - Automatically set up group of VLANs\n",
      "  -t     Use Table in database to set up VLANs for pid/eid\n",
      "  -reset Reset VLAN(s) for nodes in pid/eid\n",
      "  -r     Remove VLAN(s) (specify VLAN number)\n",
      "\nPort Control:\n",
      "  +b/-b  Blocking mode (now ",($b?"on":"off"),")\n",
      "  +c/-c  Confirm Changes (now ",($c?"on":"off"),")\n",
      "  -g     Get Statistics\n",
      "  -s     Show Port Configurations\n",
      "  -p     List of port numbers and ranges (port = <node>:<if>)\n",
      "  -d     Disable port(s)\n",
      "  -e     Enable port(s)\n",
      "  +a/-a  Enable/Disable Port Auto-Negotiation of speed/duplex\n",
      "  -spd   Port Speed (10 or 100 Mbits)\n",
      "  -dup   Port Duplex (half or full)\n",
      "  -n     Change port VLAN #\n";
    # Hidden Power control functionality
    # "  -on   Turn on outlets\n",
    # "  -off  Turn off outlets\n",
    # "  -cyc  Power Cycle outlets\n",
    # "  -(n)  Outlet #(n) (n=1-8)\n";
  }
  #Unused letters of the alphabet:
  # j, k, q, w, x, y, z
  #
  #If help only, end here...
  die("\b\n") if ($help);
  #Now die on any combinations that don't make sense...
  die("What shall I do?\n")
    if (!($d||$e||$a||$spd||$dup||$n||$s||$g||@vlan||$f||$t||$reset||@r||$l
	  ||$powerop));
  die("Can't enable and disable at the same time.\n") if ($d && $e);
  die("Can't use auto with duplex or speed.\n") if(($a=~/en/)&&($dup||$spd)); 
  die("Which ports do I control?\n") if (!@p&&($d||$e||$dup||$spd||$a||$n));
  $dup = "\L$dup\E";		#lowercase it all...
  die("Invalid duplex $dup: Must be full or half\n")
    if(!($dup=~/^full$|^half$|^$/));
  die("Invalid speed $spd: Must be 10 or 100\n")
    if (!($spd=~/^10$|^100$|^0$/));
  if (defined($spd) && ($spd != 0)) { $spd= "${spd}mbit"; }
  die("Only one of -f, -t, -reset, and -vlan may be used.\n")
    if (($f && @vlan) || ($reset && $t) || ($t && @vlan) ||
	($reset && @vlan) || ($f && $t) || ($f && $reset));
  die("Project and expt must be specified with -t: '-t <pid> <eid>'\n")
    if ($t && ((!defined $pid) || (!defined $eid)));
  die("Project and expt must be specified with -reset: '-reset <pid> <eid>'\n")
    if ($reset && ((!defined $pid) || (!defined $eid)));
  # If everything is okay so far, initialize snmpit_lib
  snmpit_lib::init($DBNAME, $debug);
  if (!defined($i)||!$i||$i eq "") { $i = "cisco"; }
  if ( defined Dev($i) ) {
    if (! ($i =~ /[a-zA-Z]/) ) { $i = Dev($i); } # i is now name
    print "Found device $i (",Dev($i),")..." if $debug;
    if ($i =~ /cisco/i) {
      print "Making new snmpit_cisco\n" if $debug;
      $device = new snmpit_cisco
	(Dev($i),"debug=$debug","block=$b","confirm=$c","verbose=$v");
#    elsif ($i =~ /intel/i) {
#      print "Making new snmpit_intel\n" if $debug;
#      $device = new snmpit_intel
#	(Dev($i),"debug=$debug","block=$b","confirm=$c","verbose=$v");
    } else {
      print "Making new snmpit_apc\n" if $debug;
      $device = new snmpit_apc
	(Dev($i),"debug=$debug","block=$b","confirm=$c","verbose=$v");
    }
  } else {
    die ("'$i' is not a known device.\n");
  }
  if ($debug) {
    if (ref($device)) {
      print "Checking type:\n";
      print $device->isa(snmpit_intel)||"0"," for intel\n";
      print $device->isa(snmpit_cisco)||"0"," for cisco\n";
      print $device->isa(snmpit_apc)||"0"," for APC\n";
    } else { print "Type '$device' is not a ref!\n"; }
  }
  if ( $i =~ /[a-zA-Z]/) { $i = Dev($i); }
  die("\"$i\" is not a switch. Illegal operation requested.\n")
    if ( ($device->isa(snmpit_apc) )  &&
	 ($d||$e||$a||$spd||$dup||$n||$s||$g||@vlan||$f||@r||$l));
  die("\"$i\" is not a power controller.\n")
    if (! $device->isa(snmpit_apc) && ($powerop || @outlets) );
  my $num=0;
  if ($device->isa(snmpit_intel)) {
    while( @p != 0 && $num < @p ) {
      die("Invalid port ",$p[$num],": Must be 1-24\n")
	if ($p[$num] =~ /\D/ || $p[$num]>24 || $p[$num]<1);
      $num++;
    }
  }
  print "original ports: \t@p\n" if ($debug && @p);
  @p = map(lc,@p);
  @p = map {
    my $orig = $_;
    my $pnum = 0;
    if ($_ =~ /^[0-9\.]+$/) { $_ = portnum($i.":$_"); }
    if (!defined $_) {
      die("Invalid port '$orig' not known. Try '<node>:<if>'.\n");
    }
    print "$_ => ",macport($_)," => ",portnum($_),"\n" if $debug;
    if (defined portnum($_)) {
      @_ = split(":", portnum($_));
      $pnum = $_[1];
    } else { die("Invalid port '$orig' not known. Try 'pcX:Y'.\n"); }
    if (! NodeCheck($_) ) { die("You are not authorized to control $_.\n"); }
    $_;
  } @p;
  print "translated ports: \t@p\n" if ($debug && @p);
  $num=0;
  while(@vlan != 0 && $num < @vlan) {
    $vlan[$num] = lc $vlan[$num];
    print "Checking node $vlan[$num] for validity...\n" if $debug;
    if (defined macport($vlan[$num])) {
      if ($vlan[$num]=~/^([a-f]|\d)*$/i) {
	$vlan[$num]=macport($vlan[$num]);
      }
      print "Found node $vlan[$num]\n" if $debug;
    } else {
      # Allow people to specify addresses with colons or dots
      $vlan[$num] =~ s/[:\.]//g;
      if (defined macport($vlan[$num])) {
	$vlan[$num]=macport($vlan[$num]);
	print "Found node $vlan[$num]\n" if $debug;
      } else {
	die("Invalid VLAN member '$vlan[$num]': must be 'pcX:Y' or MAC.\n");
      }
    }
    $num++;
  }
  if ($t || $reset) {
    if ( ! vlanid("$pid:$eid")) {
      print "There were no VLANs in the database table for '$pid' '$eid'\n";
      exit(0);
    } else {
      foreach $id ( split(" ",vlanid("$pid:$eid")) ) {
	my $members = vlanmemb($id);
	$vlantable{$id} = $members;
	print "id: $id\t$members\n" if $debug;
	foreach $node (split (" ",$members)) {
	  if (!defined macport($node)) {
	    die("Invalid node found in VLANs table: '$node'\n");
	  }
	}
      }
    }
  }
  if ($powerop) {
    $num=0;
    while(@outlets != 0 && $num < @outlets) {
      die("Invalid Outlet \"",$outlets[$num],"\": Must be 1 to 8.\n")
	if (! ($outlets[$num]=~ /^[1-8]$/ ));
      $num++;
    }
  }
}

sub ReadIRFile {
  local(*f,*names,*VLANS) = @_;
  my %exists = ();
  my $skip = 1;
  my $name = "";
  print "Opening '$f' to read vlans...\n" if $debug;
  if ( -e "$TB/etc/$f") {
    open(IR,"$TB/etc/$f")
      || die("Couldn't open $TB/etc/$f\n");
  } elsif ( -e "$f" ) {
    open(IR,"$f")
      || die("Couldn't open $f\n");
  } else {
    die("Couldn't locate $f for VLAN setup.\n");
  }
  print "Opened $f for reading...\n" if $debug;
  while (<IR>) {
    chomp;
    if ( /^\#/ ) { next; }	 #skip comments
    if ( /^start vlan/i ) { $skip = 0 ; next; }
    if ($skip) { next; }
    if ( /^end vlan/i ) { $skip = 1 ; next; }
    # If I'm in the right section, turn the line into a VLAN
    my @v= split;
    $name = shift @v;
    my $num=0;
    while (@v != 0 && $num < @v) {
      $v[$num] = lc $v[$num];
      print "Checking node $v[$num] for validity...\n" if $debug;
      if (defined macport($v[$num])) {
	if ($v[$num]=~/^([a-f]|\d)*$/i) {
	  $v[$num]=macport($v[$num]);
	  print "Found node $v[$num]\n" if $debug;
	}
      } else {
	# Allow people to specify addresses with colons or dots
	$v[$num] =~ s/[:\.]//g;
	if (defined macport($v[$num])) {
	  $v[$num]=macport($v[$num]);
	  print "Found node $v[$num]\n" if $debug;
	} else {
	  die("Invalid VLAN member '$v[$num]': must be 'pcX:Y' or MAC.\n");
	}
      }
      $num++;
    }
    @v = sort @v;
    if (!defined $exists{ join(' ',@v) }) {
      print "Read VLAN $name with: ",join (" ",@v),"\n" if $debug;
      push( @VLANS, \@v);
      push(@names, $name);
      $exists{join(' ',@v)} = 1;
    }
  }
  close (IR);
}
