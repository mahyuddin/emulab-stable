#!/usr/bin/perl -w

#
# snmpit - A tool for setting up VLANs on SNMP-controllable switches
#

#
# Configure variables
#

use lib '@prefix@/lib';
my $TESTMODE = @TESTMODE@;
my $TB = '@prefix@';

use libdb;
use snmpit_lib;

use English;
use Getopt::Std;
use strict;

#
# Defaults
#
my $debug = 0;

######################################################################
# Step 1 - Process command-line arguments
#
# We have a fairly complex set of command line arguments, and we
# need to make sure that the user only specifies one command at a
# time.
######################################################################
sub usage {
    print << "END";
Usage: $0 [-h] [-v] [-i device] 
	  [-l] [-s] [-g]
	  [-m name [ports]]
	  [-o name]
          [-r pid eid]
	  [-t pid eid]
General:
  -h          Display this help message
  -v          Verbose mode
  -i <device> Operate on <device>, overriding default device list

VLAN Control:
  -t <pid> <eid>    Create all VLANs from database tables for an experiment
  -r <pid> <eid>    Remove all VLANs from database tables for an experiment
  -l                List all VLANs
  -m <name> [ports] Create a new VLAN with name <name>, if it doesn't exist,
                        and put [ports] in it
  -o <name>         Delete the VLAN with name <name>

Port Control:
  -s         List all ports, and show configuration information
  -g         Get port statistics
  -d <ports> Disable <ports>
  -e <ports> Enable <ports>
  -a <ports> Enable auto-negotiation of port speed/duplex
  -p <ports> Set speed of <ports> to 10 or 100 Mbps
  -u <ports> Set duplex of <ports> to half or full


END

    return 1;
}


my $opts = 'hlvstri:m:o:p:u:deag';
my %opt = ();
getopts($opts,\%opt);

if ($opt{h}) {
    exit &usage;
}

if ($opt{v}) {
    $debug = $opt{v};
    print "Debug level is $debug\n";
}

#
# Make sure the user specified exactly one operation
#
my @commandOpts = ('l','m','o','s','t','r','d','e','a','p','u','g');
if (!exactlyOne(map {$opt{$_}} @commandOpts)) {
    warn "ERROR: You must specify exactly one of " .
	    join(",", map {"-$_"} @commandOpts) . "\n";
    exit &usage;
}

#
# Values that may have been passed on the command line
#
my $pid;
my $eid;
my @ports;

#
# Some operations have mandatory agruments - for others, make sure that
# the user didn't give any extraneous arguments
#
if ($opt{t} || $opt{r}) {
    #
    # Options that take 'pid eid'
    #
    if (@ARGV != 2) {
	warn "ERROR: pid/eid reqired!\n";
	exit &usage;
    } else {
	($pid, $eid) = @ARGV;
    }
} elsif ($opt{d} || $opt{e} || $opt{a} || $opt{p} || $opt{u} || $opt{m}) {
    #
    # Options that take a list of ports
    #
    @ports = @ARGV;
} else {
    #
    # Everything else
    #
    if (@ARGV) {
	warn "ERROR: Too many arguments!\n";
	exit &usage;
    }
}

#
# Determine which operation we're performing. This is just for convenience,
# so that we can use switch-like constructs later. While we're at it, we
# pull out any arguments that were given in the $opt{} values.
#
my $operation;
my $vlan_name;
my $portcommand;
if ($opt{l}) {
    $operation = "listvlans";
} elsif ($opt{s}) {
    $operation = "listports";
} elsif ($opt{g}) {
    $operation = "getstats";
} elsif ($opt{t}) {
    $operation = "tables";
} elsif ($opt{r}) {
    $operation = "reset";
} elsif ($opt{m}) {
    $operation = "make";
    $vlan_name = $opt{m};
} elsif ($opt{o}) {
    $operation = "remove";
    $vlan_name = $opt{o};
} elsif ($opt{d}) {
    $operation = "portcontrol";
    $portcommand = "disable";
} elsif ($opt{e}) {
    $operation = "portcontrol";
    $portcommand = "enable";
} elsif ($opt{a}) {
    $operation = "portcontrol";
    $portcommand = "auto";
} elsif ($opt{p}) {
    $operation = "portcontrol";
    #
    # We'll put the argument in the form needed by the portControl function
    #
    if ($opt{p} =~ /^100/) {
	$portcommand = "100mbit";
    } elsif ($opt{p} =~ /^10/) {
	$portcommand = "10mbit";
    } else {
	die "Bad port speed: $opt{p}. Valid values are 10 and 100\n";
    }
} elsif ($opt{u}) {
    #
    # We'll put the argument in the form needed by the portControl function
    #
    $operation = "portcontrol";
    if ($opt{u} =~ /half/) {
	$portcommand = "half";
    } elsif ($opt{u} =~ /full/) {
	$portcommand = "full";
    } else {
	die "Bad port duplex: $opt{u}. Valid values are full and half\n";
    }
} else {
    die "No operation given\n";
}

debug("Operation is $operation\n");

######################################################################
# Step 3 - Set up the stack objects
#
# Determine which devices to talk to, and make the appropriate
# stack objects
######################################################################

if ($TESTMODE) {
    print "Test mode, exiting without touching hardware\n";
    exit(0);
}

#
# snmpit_lib fills out some hashes for speed of lookup later. Initialize
# them now
#
snmpit_lib::init($debug);

#
# Discover the set of devices we need to talk to. This differs depending
# on the operation which we're performing. We also get a list of all ports
# and vlan IDs involved in this operation, if appropriate
#
my @devicenames;
my @vlans;
SWITCH: for ($operation) {
    (/listvlans/ || /getstats/) && do {
	@devicenames = $opt{i}? $opt{i} : getTestSwitches();
    };
    (/listports/ || /make/ || /remove/) && do {
	@devicenames = $opt{i}? $opt{i} :
	    (@ports? getDeviceNames(@ports) : getTestSwitches());
	last;
    };
    (/tables/) && do {
	@vlans = getExperimentVlans($pid,$eid);
	@ports = getVlanPorts(@vlans);
	@devicenames = $opt{i}? $opt{i} : getDeviceNames(@ports);
    };
    (/reset/) && do {
	#
	# When we reset, we operate on all test switches, just to be safe
	#
	@vlans = getExperimentVlans($pid,$eid);
	@devicenames = $opt{i}? $opt{i} : getTestSwitches();
    };
    (/portcontrol/) && do {
	@devicenames = $opt{i}? $opt{i} : getDeviceNames(@ports);
    };
}

debug("Device names: " . join(",",@devicenames) . "\n");
debug("Ports: " . join(",",@ports) . "\n");

#
# If this is an operation on an experiment, make sure that they have permission
# to modify that experiment
#
if ($pid && $eid) {
    #
    # First, make sure the experiment exists
    #
    if (!ExpState($pid,$eid)) {
	die "There is no experiment $eid in project $pid\n";
    }
    if (!TBExptAccessCheck($UID,$pid,$eid,TB_EXPT_MODIFY)) {
	die "You do not have permission to modify experiment $pid/$eid\n";
    }
}

#
# If their operation involves a set of ports, make sure that the caller has
# access to the nodes that the ports are on
#
if (@ports) {
    my @nodes = map /^([^:]+)/, @ports;
    if (!TBNodeAccessCheck($UID,TB_NODEACCESS_MODIFYVLANS,@nodes)) {
	die "You do not have permission to modify some or all of the nodes\n" .
		"that will be affected by the operation you requested\n";
    }
}

#
# Find out which stack each device belongs to
#
my %stacks = ();
foreach my $devicename (@devicenames) {
    my $stack = getSwitchStack($devicename);
    if (defined($stack)) {
	push @{$stacks{$stack}}, $devicename;
    }
}

#
# Now, make the object for each stack that we discovered
#
my @stacks;
foreach my $stack_id (keys %stacks) {
    #
    # XXX: For now, we assume that the stack is a Cisco stack. We'll need
    # more database information to be able to distinguish stack types
    #
    use snmpit_cisco_stack;
    my $stack = new snmpit_cisco_stack($stack_id,$debug,
	@{$stacks{$stack_id}});
    push @stacks, $stack;
}

######################################################################
# Step 3 - Actually perfrom the operation
#
# Finally, we just call the helper function for the operation that
# is to be performed. Note that all functions use the global @stacks
# variable, so it isn't passed to every one.
######################################################################

my $exitval;
SWITCH: for ($operation) {
    /listvlans/ && do {
	$exitval = doListVlans();
	last;
    }; # /vlans/ && do 
    /listports/ && do {
	$exitval = doListPorts();
	last;
    }; # /ports/ && do
    /getstats/ && do {
	$exitval = doGetStats();
	last;
    }; # /ports/ && do
    /tables/ && do {
	$exitval = doVlansFromTables(@vlans);
	last;
    }; # /tables/ && do
    /reset/ && do {
	$exitval = doReset(@vlans);
	last;
    };
    /make/ && do {
	$exitval = doMakeVlan($vlan_name,@ports);
	last;
    };
    /remove/ && do {
	$exitval = doDeleteVlan($vlan_name);
	last;
    };
    /portcontrol/ && do {
	$exitval = doPortControl($portcommand,@ports);
    };
}

exit $exitval;

######################################################################
# Subs
######################################################################

#
# Return true if exactly one element of the given array is true
#
sub exactlyOne (@) {
    my $one = 0;
    foreach my $value ( @_ ) {
	if ($value) {
	    if ($one) {
		return 0; # More than one
	    } else {
		$one = 1; # This is the first
	    }
	}
    }
    return $one;
}

#
# Print given message to STDERR, only if debug mode is on
#
sub debug($) {
    if ($debug) {
	print STDERR @_;
    }
}

#
# Lists all vlans on all stacks
#
sub doListVlans () {
    
    my %vlans;

    #
    # We need to 'coallate' the results from each stack by putting together
    # the results from each stack, based on the VLAN identifier
    #
    foreach my $stack (@stacks) {
	# TODO: Add a way to print ddep 
	my @vlanList = $stack->listVlans();
	foreach my $vlan (@vlanList) {
	    my ($id,$ddep,$memberref) = @$vlan;
	    push @{${$vlans{$id}}[1]}, @$memberref;
	}
    }

    #
    # These need to be declared here for the benefit of the format string
    # See perlform(1) for help with formats
    #
    my ($vlan_id,$pideid,$vname,$members);
    print << "END";
VLAN  Project/Experiment   VName      Members
--------------------------------------------------------------------------------
END
    format vlanlist =
@<<<< @<<<<<<<<<<<<<<<<<<< @<<<<<<<<< ^<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
$vlan_id,$pideid,          $vname,    $members
~~                                    ^<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
                                      $members
.

    $FORMAT_NAME = 'vlanlist';
    foreach $vlan_id (sort {tbsort($a,$b)} keys %vlans) {
	my ($ddep,$memberref) = @{$vlans{$vlan_id}};

	#
	# Find which, if any, experiment this VLAN belongs to.
	#
	my $result = DBQueryFatal("select pid, eid, virtual from " .
				  "vlans where id='$vlan_id'");
	my ($eid,$pid);
	($pid,$eid,$vname) = $result->fetchrow();

	#
	# Permissions check - people only get to see
	#
	if ((!$eid) || (!$pid)) {
	    if (!TBAdmin()) {
		&debug("Failed TBAdmin check\n");
		next;
	    }
	} elsif (!TBExptAccessCheck($UID,$pid,$eid,TB_EXPT_READINFO)) {
	    &debug("Failed TBExptAccessCheck($UID,$pid,$eid)\n");
	    next;
	}


	if (!$vname) { $vname = ""; }
	$members = join(" ",@$memberref);

	#
	# Setup $pideid for a more compact display
	#
	if ($eid && $pid) {
	    $pideid = "$pid/$eid";
	} else {
	    $pideid = "";
	}
	write;
    }

    return 0;
}

#
# Lists all ports on all stacks
#
sub doListPorts() {

    #
    # Get a listing from all stacks
    #
    my @portList = ();
    foreach my $stack (@stacks) {
	push @portList, $stack->listPorts;
    }

    #
    # See perlform(1) for help with formats
    #
    my ($port,$enabled,$up,$speed,$duplex);
    print << "END";
Port      Enabled Up   Speed      Duplex
----------------------------------------
END
    format portlist =
@<<<<<<<< @<<<<<< @<<< @<<<<<<<<< @<<<
$port,    $enabled,$up,$speed,$duplex
.
    $FORMAT_NAME = 'portlist';
    foreach my $line (sort {tbsort($$a[0],$$b[0])} @portList) {
	($port,$enabled,$up,$speed,$duplex) = @$line;
	#
	# Only let people see information about ports in their experiments
	#
	$port =~ /^(.+):/;
	my $node = $1;

	&debug("node is $node\n");
	if (!$node) {
	    if (!TBAdmin($UID)) {
		next;
	    }
	} elsif (!TBNodeAccessCheck($UID,TB_NODEACCESS_READINFO,$node)) {
	    next;
	}
	write;
    }

    return 0;
}

#
# Get statistics for all ports on all stacks
#
sub doGetStats() {

    #
    # Get a listing from all stacks
    #
    my @statList = ();
    foreach my $stack (@stacks) {
	push @statList, $stack->getStats();
    }

    my ($port, $inoctets, $inunicast, $innunicast, $indiscards, $inerr,
        $inunk, $outoctets, $outunicast, $outnunicast, $outdiscards,
	$outerr,$outq);
    #
    # See perlform(1) for help with formats
    #
    print << "END";
          In         InUnicast  InNUnicast In         In         Unknown    Out        OutUnicast OutNUcast  Out       Out         OutQueue
Port      Octets     Packets    Packets    Discards   Errors     Protocol   Octets     Packets    Packets    Discards  Errors      Length
---------------------------------------------------------------------------------------------------------------------------------------------
END
    format stats =
@<<<<<<<< @>>>>>>>>> @>>>>>>>>> @>>>>>>>>> @>>>>>>>>> @>>>>>>>>> @>>>>>>>>> @>>>>>>>>> @>>>>>>>>> @>>>>>>>>> @>>>>>>>>> @>>>>>>>>> @>>>>>>>>> 
$port,    $inoctets, $inunicast,$innunicast,$indiscards,$inerr,  $inunk,    $outoctets,$outunicast,$outnunicast,$outdiscards,$outerr,$outq
.
    $FORMAT_NAME = 'stats';
    foreach my $line (sort {tbsort($a,$b)} @statList) {
	($port, $inoctets, $inunicast, $innunicast, $indiscards, $inerr,
	 $inunk, $outoctets, $outunicast, $outnunicast, $outdiscards,
	 $outerr, $outq) = @$line;
	write;
    }

    return 0;
}
#
# Creates all VLANs given. Looks up identifiers in the database to determine
# the membership.
#
sub doVlansFromTables(@) {
    my @vlans = @_;

    my $errors = 0;

    if (@stacks > 1) {
	die "VLAN creation accross multiple stacks is not yet supported\n";
    }
    my ($stack) = @stacks;

    foreach my $vlan (@vlans) {
	my @ports = getVlanPorts($vlan);
	if ($stack->vlanExists($vlan)) {
	    print "  VLAN $vlan already exists\n";
	    $errors += $stack->setPortVlan($vlan,@ports);
	} else {
	    if (!$stack->createVlan($vlan)) {
		warn "ERROR: Failed to create VLAN with id $vlan\n";
		#
		# Don't try to put ports in a VLAN if it couldn't be created
		#
		$errors++;
	    } else {
		$errors += $stack->setPortVlan($vlan,@ports);
	    }
	}
    }

    return $errors;
}

#
# Remove all VLANs given from every switch in the stack. All ports in the
# VLANs are removed, irrespective of what the database says membership should
# be
#
sub doReset(@) {
    my @vlans = @_;

    my $errors = 0;
    foreach my $vlan (@vlans) {
	#
	# Just remove the VLAN from evey satck on which it exists
	#
	foreach my $stack (@stacks) {
	    if ($stack->vlanExists($vlan)) {
		if (!$stack->removeVlan($vlan)) {
		    $errors++;
		}
	    }
	}
    }
    return $errors;
}

#
# Create a vlan with name $vlan_name. It is not an error to try to create a
# VLAN that already exists, as this can be used to add ports to an existing
# VLAN. If ports are given, they are put into the VLAN.
#
sub doMakeVlan($@) {
    my $vlan_name = shift;
    my @ports = @_;

    my $errors = 0;

    if (@stacks > 1) {
	die "VLAN creation accross multiple stacks is not yet supported\n";
    }
    my ($stack) = @stacks;

    #
    # Create it if it doesn't already exist
    #
    if ($stack->vlanExists($vlan_name)) {
	print "VLAN $vlan_name already exists\n";
    } else {
	print "Creating VLAN $vlan_name ...\n";
	my $ok = $stack->createVlan($vlan_name);
	print "VLAN creation ";
	print $ok? "succeeded":"failed",".\n";
	if (!$ok) {
	    $errors++;
	}
    }

    #
    # Put requested ports into the VLAN
    #
    if (@ports) {
	print "Putting ports in VLAN ...\n";
	my $perrors = $stack->setPortVlan($vlan_name,@ports);
	print "VLAN change ";
	print $perrors? "failed":"succeeded",".\n";
	$errors += $perrors;

    }

    return $errors;
}

#
# Delete the given VLAN, if it exists
#
sub doDeleteVlan($) {
    my $vlan_name = shift;

    my $errors = 0;

    my $exists = 0;
    foreach my $stack (@stacks) {
	if ($stack->vlanExists($vlan_name)) {
	    $exists = 1;
	    print "Deleting VLAN $vlan_name ...\n";
	    my $ok = $stack->removeVlan($vlan_name);
	    print "VLAN deletion ";
	    print $ok? "succeeded":"failed",".\n";
	    if (!$ok) {
		$errors++;
	    }
	}
    }

    if (!$exists) {
	print "VLAN $vlan_name does not exist\n";
	$errors++;
    }

    return $errors;
}

#
# Send $command to @ports.
# TODO: List of commands
#
sub doPortControl($@) {
    my $command = shift;
    my @ports = @_;

    if (@stacks > 1) {
	die "Port control accross multiple stacks is not yet supported\n";
    }
    my ($stack) = @stacks;

    print "Applying command '$command' to ports " . join(",",@ports) . " ...\n";
    my $errors = $stack->portControl($command,@ports);
    print "Port command ";
    print $errors? "failed":"succeeded",".\n";

    return $errors;

}

