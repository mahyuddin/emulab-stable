#!/usr/local/bin/perl -w
#########################################################################
# snmpit - A General Purpose SNMP Tool                                  #
# (specialized for Intel 510T, Cisco 6509 and APC power controllers)    #
#                                                                       #
# Run with -h option to see command line syntax/options.                #
#                                                                       #
#########################################################################

my $TB;
my $DBNAME = "@TBDBNAME@";

BEGIN { 
  #
  # Configure variables
  #
  $TB     = "@prefix@";

  # This needs to go in BEGIN so it happens before the use clauses...
  push(@INC,$TB."/lib");
}

use English;

#Uncomment this when we really need to be able to handle intel switches
#use snmpit_intel;
use snmpit_cisco;
use snmpit_lib;

snmpit_lib::init($DBNAME);

$| = 1; # Turn off line buffering on output

my $debug = 0;
#If there is debug, turn it on right now...
if ( join(" ",@ARGV) =~ /-debug\s*(\d*)/ ) { 
  if ( defined $1 && $1 ne "") { $debug = $1; } else { $debug = 1; }
  print "DEBUG MODE ON: Set to level $debug\n";
}

my $device;
my $pid;
my $eid;
my $t = 0;

&myMain;

# Numerically sort
sub num { $a <=> $b; }

sub myMain {

  my $i = "";	#IP addr.
  my @p = ();	#Port numbers
  my $d = 0;    #Disable (bool)
  my $e = 0;	#Enable (bool)
  my $a = "";	#Auto Negotiation (enable/disable) (two-way switch)
  my $dup = "";	#Duplex (half/full)
  my $spd = 0;	#Speed (10/100)
  my $s = 0;	#Show port configs
  my $g = 0;	#Get Statistics
  my $f = "";	#AutoVLAN filename
  my $t = "";   #VLANs from db table - "pid/eid"
  my $l = 0;	#List all VLANs on switch
  my $m = "";	#Create VLAN - name
  my @vlan =();	#VLAN Members - list of MAC Addresses
  my @r = ();	#VLAN(s) to be removed
  my $u = 0;	#Wait for Update of VLAN tables
  my $b = 0;	#Block (bool) (two-way switch)
  my $c = 1;	#Confirm Changes (bool) (two-way switch)
  my $v = 0;	#Verbose (bool) !Must default quiet; switch only turns on!

  #power control
  my $on=0;
  my $off=0;
  my $cyc=0;
  my $all=0;
  my @outlets=();

  &ParseArgs(\@ARGV,\$i,\@p,\$d,\$e,\$a,\$dup,\$spd,\$s,\$f,\$l,\$m,\@vlan,
	     \@r,\$u,\$b,\$c,\$v,\$g,
	     \$on,\$off,\$cyc,\$all,\@outlets);

#  print "\ni=$i p=",@p," d=$d e=$e a=$a dup=$dup spd=$spd s=$s f=$f l=$l",
#  "m=$m vlan=",@vlan," r=",@r,"u=$u b=$b c=$c v=$v g=$g on=$on ",
#  "off=$off cyc=$cyc all=$all device=$device\n" if $debug;

  my $sess2;
  if ($device eq "APC") {
    use SNMP;
    $SNMP::debugging = ($debug - 5) if $debug > 5;
    &SNMP::addMibDirs('/usr/local/share/snmp/mibs');
    &SNMP::addMibFiles('/usr/local/share/snmp/mibs/PowerNet-MIB.txt');
    $SNMP::save_descriptions = 1; # must be set prior to mib initialization
    SNMP::initMib();              # parses default list of Mib modules
    $SNMP::use_enums = 1;         #use enum values instead of only ints
    print "Opening SNMP session to $i..." if $debug;
    $sess2 =new SNMP::Session(DestHost => $i, Community => 'private');
    print "".(defined $sess2 ? "Succeeded" : "Failed")."\n" if $debug;
  }

  #
  # Port Level Control
  #
  if ($d) {
    my $rv = $device->portControl("disable",@p);
    print "Port disable for @p had $rv failures.\n";
  } elsif ($e) {
    my $rv = $device->portControl("enable",@p);
    print "Port enable for @p had $rv failures.\n";
  }

  if ($spd) {
    my $rv = $device->portControl($spd,@p);
    print "Port speed change for @p had $rv failures.\n";
  }

  if ($dup) {
    my $rv = $device->portControl($dup,@p);
    print "Port duplex change for @p had $rv failures.\n";
  }

  if ($a) {
    my $rv = $device->portControl("auto",@p);
    print "Port auto-configuration change for @p had $rv failures.\n";
  }

  #Show always goes after changes, so that they are reflected.
  if ($s) {
    $device->showPorts;
  }

  if ($g) {
    $device->getStats;
  }

  #
  # VLANs
  #
  if (@vlan) {
    #This is to make ONE vlan - for multiple, use -f AutoVLAN from file
    if ($device ne "APC") {
      $device->vlanLock;
      $device->setupVlan($m,@vlan);
      $device->vlanUnlock;
    } else { 
      die("Invalid option 'make VLAN' for device of type $device.\n");
    }
  }

  if ($f) {
    &AutoVLANConfig(\$f);
  }

  if (@r) {
    if ($device ne "APC") {
      $device->vlanLock;	
      foreach my $x (sort num @r) {
	$device->removeVlan($x);
      }
      $device->vlanUnlock;
    } else { 
      die("Invalid option 'remove VLAN' for device of type $device.\n");
    }
  }

  #List VLANs is always after $f and @vlan, so that changes made are reflected
  if ($l) {
    $device->listVlans;
  }

  #
  # Power Control
  #
  if ($off || $on || $cyc) {
    my $CtlOID = ".1.3.6.1.4.1.318.1.1.4.4.2.1.3";
    my $op = "";
    #disable confirmation, and go to blocking mode...
    $c = 0;
    $b = 0;
    if ($all) {
      my $AllOID = ".1.3.6.1.4.1.318.1.1.4.2.1";
      @outlets = ( 0 );
      if ($on)     { $op = "turnAllOnSequence";}
      elsif ($off) { $op = "turnAllOffNow";    }
      else         { $op = "rebootAllSequence";}
      if (! &UpdateField(\$sess2,$AllOID,\@outlets,$op,\$b,\$c,\$v)) {
	print STDERR "Outlet control failed.\n";
      }
    } else {
      if ($on)     { $op = "outletOn";    }
      elsif ($off) { $op = "outletOff";   }
      else         { $op = "outletReboot";}
      if (! &UpdateField(\$sess2,\$CtlOID,\@outlets,\$op,\$b,\$c,\$v)) {
	print STDERR "Outlet #@outlets control failed.\n";
      }
    }
  }
  
}


sub AutoVLANConfig {
  local(*f) = @_;
  my @VLANS= ();
  my @names= ();
  &ReadIRFile(*f,\@names,\@VLANS);
  print "AutoVLAN got VLANs named: ",join (" ",@names),"\n" if $debug;
  $device->vlanLock;
  my $m="";
  my @vlan=();
  while (@VLANS) {
    @vlan = @{shift(@VLANS)};
    $m = shift @names;
    print "Making $m with: ",join(' ',@vlan),"\n" if $debug;
    $device->setupVlan($m,@vlan);
  }
  $device->vlanUnlock;
}


sub UpdateField {
  local(*session,*OID,*ports,*val,*b,*c,*v)= @_;
  print "sess=$session $OID '",join(" ",@ports),"' $val $b $c $v\n" if $debug;
  my $Status = 0;
  my $retval;
  my $i = $session->{DestHost};
  foreach my $port (@ports) {
    print "Checking port $port of $i for $val..." if $v;
    $Status = $session->get([[$OID,$port]]);
    if (!defined $Status) {
      print STDERR "Port $port, change to $val: No answer from device\n";
    } else {
      print "Okay.\nPort $port was $Status\n" if $v;
      if ($Status ne $val) {
	print "Setting $port to $val..." if $v;
	$retval = $session->set([[$OID,$port,$val,"INTEGER"]]);
	print "Set returned '$retval'" if $v;
      }
    }
  }
  1;
}


sub ParseArgs {
  local(*CMDS,*i,*p,*d,*e,*a,*dup,*spd,*s,*f,*l,*m,*vlan,*r,*u,*b,*c,*v,*g,
	*on,*off,*cyc,*all,*outlets) = @_;
  my $help=0; 
  if (@main::CMDS < 1) {$help = 1; }
  print "Command line was: snmpit ",join(" ",@ARGV),"\n" if $debug;
  while (@CMDS != 0 && $CMDS[0] =~ /^(-|\+)/) {
    $_ = shift(@CMDS);
    #print "Item=$_*\n" if $debug;
    #print "i=$i p=",@p," d=$d e=$e a=$a dup=$dup s=$spd s=$s f=$f l=$l",
    #"m=$m vlan=",@vlan," r=",@r,"u=$u b=$b c=$c v=$v g=$g on=$on ",
    #"off=$off cyc=$cyc all=$all\n" if $debug;
    if (/^-i(.*)/) {$i = ($1 ? $1 : shift(@CMDS));}
    elsif (/^-p(.*)/) {
      my $Range ="";
      do {
	$Range = ($1 ? $1 : shift(@CMDS));
	#print "Range=$Range\n";
	if ( $Range =~ /^(\d*)\.\.(\d*)$/ ) {
	  #print "1Pushing ",$1..$2,"*\n";
	  push(@p, $1..$2);
	} else {
	  #print "2Pushing ",$Range,"*\n";
	  push(@p, $Range);
	}
      }
      while (@CMDS>0 && ! ($CMDS[0] =~ /^(-|\+)(.*)/ ) );
    }
    elsif (/^-debug(.*)/) { 
      if (!($CMDS[0] =~ /^-/)) { shift (@CMDS); } # possibly ignore number
      $v=1; # debug is already set, so don't do it here
    } 
    elsif (/^-h(.*)/) {$help = 2;}
    elsif (/^-off(.*)/) {$off = 1;}
    elsif (/^-on(.*)/) {$on = 1;}
    elsif (/^-cyc(.*)/) {$cyc = 1;}
    elsif (/^-all(.*)/) {$all = 1;}
    elsif (/^-a(.*)/) {$a="disable";}
    elsif (/^\+a(.*)/) {$a="enable";}
    elsif (/^-dup(.*)/) {$dup = ($1 ? $1 : shift(@CMDS));}
    elsif (/^-spd(.*)/) {$spd = ($1 ? $1 : shift(@CMDS));}
    elsif (/^-d(.*)/) {$d = 1;}
    elsif (/^-e(.*)/) {$e = 1;}
    elsif (/^-s(.*)/) {$s = 1;}
    elsif (/^-g(.*)/) {$g = 1;}
    elsif (/^-l(.*)/) {$l = 1;}
    elsif (/^-u(.*)/) {$u = 1;}
    elsif (/^-f(.*)/) {$f = ($1 ? $1 : shift(@CMDS));}
    elsif (/^-t(.*)/) {$pid = ($1 ? $1 : shift(@CMDS));
		       $eid = shift(@CMDS); }
    elsif (/^-m(.*)/) {$m = ( !(@CMDS==0 || $CMDS[0] =~ /^(-|\+)(.*)/) ? 
			      ($1 ? $1 : shift(@CMDS)) : "");}
    elsif (/^-vlan(.*)/) {
      push(@vlan, ($1 ? $1 : shift(@CMDS)));
      while ( @CMDS>0 && ! ($CMDS[0] =~ /^(-|\+)(.*)/ ) ) { 
	push(@vlan, shift(@CMDS));
      }
    }
    elsif (/^-r(.*)/) {
      push(@r, ($1 ? $1 : shift(@CMDS)));
      while ( @CMDS>0 && ! ($CMDS[0] =~ /^(-|\+)(.*)/ ) ) { 
	push(@r, shift(@CMDS));
      }
    }
    elsif (/^-v(.*)/) {$v = 1;}
    elsif (/^-b(.*)/) {$b = 0;}
    elsif (/^\+b(.*)/) {$b = 1;}
    elsif (/^-c(.*)/) {$c = 0;}
    elsif (/^\+c(.*)/) {$c = 1;}
    elsif (/^-([1-8])$/) { push(@outlets, $1);}
    else {die("Unknown Option: $_\n");}
  }
  #print "Done\ni=$i p=",@p," d=$d e=$e a=$a dup=$dup s=$spd s=$s f=$f l=$l",
  #"m=$m vlan=",@vlan," r=",@r,"u=$u b=$b c=$c v=$v g=$g on=$on ",
  #"off=$off cyc=$cyc all=$all\n" if $debug;
  if ($help) {
    print
      "snmpit - A general purpose SNMP Tool - Version 1.1\n",
      "Syntax:\n",
      " snmpit [-h] [-v] -i<ip>\n",
      "\t[-u] [-l] [-t <pid> <eid>] [-m<vlan name>] [-vlan<port>]\n",
      "\t[-f<filename>] [-r<vlan #> <vlan #> ... ]\n",
      "\t[+b|-b] [+c|-c] [-g] [-s] [-p <port> <port x>..<port y> ... ]\n",
      "\t[-d|-e] [+a|-a] [-spd<speed>] [-dup<duplex>]\n";
    # Hidden Power control functionality
    #,
    #	    "\t[ [-on|-off|-cyc] [-all] | [-<n>] ]\n";
  }
  if ($help > 1) {
    print
      "\nGeneral:\n",
      "  -h    Display this help message\n",
      "  -v    Verbose mode (now ",($v?"on":"off"),")\n",
      "  -i    IP address or switch name\n",
      "\nVLAN Control:\n",
      "  -u    Wait for Update of VLAN tables (takes ~10 seconds)\n",
      "  -l    List all VLANs on switch (ell, not #1)\n",
      "  -t    Use Table in database to set up VLANs\n",
      "  -m    Make a VLAN called <name> (optional)\n",
      "  -vlan Add port to VLAN (may be <node>:<if> or MAC)\n",
      "  -f    File mode - Automatically set up group of VLANs\n",
      "  -r    Remove VLAN(s) (specify VLAN number)\n",
      "\nPort Control:\n",
      "  +b/-b Blocking mode (now ",($b?"on":"off"),")\n",
      "  +c/-c Confirm Changes (now ",($c?"on":"off"),")\n",
      "  -g    Get Statistics\n",
      "  -s    Show Port Configurations\n",
      "  -p    List of port numbers and ranges (port = <node>:<if>)\n",
      "  -d    Disable port(s)\n",
      "  -e    Enable port(s)\n",
      "  +a/-a Enable/Disable Port Auto-Negotiation of speed/duplex\n",
      "  -spd  Port Speed (10 or 100 Mbits)\n",
      "  -dup  Port Duplex (half or full)\n";
    # Hidden Power control functionality
    #,
    #	    "  -on   Turn on outlets\n",
    #	    "  -off  Turn off outlets\n",
    #	    "  -cyc  Power Cycle outlets\n",
    #	    "  -all  All outlets\n",
    #	    "  -(n)  Outlet #(n) (n=1-8)\n";
  }
  #Unused letters of the alphabet:
  #
  # j, k, n, q, w, x, y, z
  #
  #If help only, end here...
  die("\b\n") if ($help);
  #Now die on any combinations that don't make sense...
  die("What shall I do?\n")
    if (!($d||$e||$a||$spd||$dup||$s||$g||@vlan||$f||$t||@r||$l
	  ||$on||$off||$cyc));

  if (!defined($i)||!$i||$i eq "") { $i = "cisco"; }
  if ( defined Dev($i) ) {
    if (Dev($i) =~ /cisco/i) {
      $device = new snmpit_cisco
	($i,"debug=$debug","block=$b","confirm=$c","verbose=$v");
    } elsif ($i =~ /cisco/i) {
      $device = new snmpit_cisco
	(Dev($i),"debug=$debug","block=$b","confirm=$c","verbose=$v");
#    } elsif ($i =~ /intel/ || Dev($i) =~ /intel/) {
#      $device = new snmpit_intel;
    } else { $device="APC"; }
  } else { 
    die ("\"$i\" is not a known device.\n");
#     my $str= "\"$i\" is not a known device:\nPossible completions are:\n";
#     foreach $name (sort keys %Dev) {
#       if ($name =~ /[a-zA-Z]/) { $str .= "$name/".Dev($name)."\n"; }
#     }
#    die($str);	
  }

# A useful snippet of code for finding out what device we've got...
#  if (ref($device)) {
#    print "Checking type: ",$device->isa(snmpit_intel)," for intel, ";
#    print $device->isa(snmpit_cisco)," for cisco\n";
#  } else { print "Type '$device' is not a ref.\n"; }

  if ( $i =~ /[a-zA-Z]/) { $i = Dev($i); }
  die("\"$i\" is not a switch. Illegal operation requested.\n")
    if ( ($device eq "APC" )  && 
	 ($d||$e||$a||$spd||$dup||$s||$g||@vlan||$f||@r||$l));
  die("\"$i\" is not a power controller.\n") 
    if ( $device ne "APC" && ($on||$off||$cyc) );
  die("Can't enable and disable at the same time.\n") if ($d && $e);
  die("Can't use auto with duplex or speed.\n") if(($a=~/en/)&&($dup||$spd));
  my $n=0;
  if ($device->isa(snmpit_intel)) {
    while( @p != 0 && $n < @p ) {
      die("Invalid port ",$p[$n],": Must be 1-24\n") 
	if ($p[$n] =~ /\D/ || $p[$n]>24 || $p[$n]<1);
      $n++;
    }
  }
  die("Which ports do I reconfigure?\n") if (!@p &&($d||$e||$dup||$spd||$a));
  $dup = "\L$dup\E";		#lowercase it all...
  die("Invalid duplex $dup: Must be full or half\n") 
    if(!($dup=~/^full$|^half$|^$/));
  die("Invalid speed $spd: Must be 10 or 100\n") 
    if (!($spd=~/^10$|^100$|^0$/));
  if (defined($spd) && ($spd != 0)) {
    $spd= "${spd}mbit";
  }
  print "original ports: \t@p\n" if ($debug && @p);
  @p = map(lc,@p);
  @p = map {
    my $orig = $_;
    my $pnum = 0;
    if ($_ =~ /^[0-9\.]+$/) { $_ = portnum($i.":$_"); }
    if (!defined $_) {
      die("Invalid port '$orig' not known. Try '<node>:<if>'.\n"); 
    }
    print "$_ => ",macport($_)," => ",portnum($_),"\n" if $debug;
    if (defined portnum($_)) { 
      @_ = split(":", portnum($_));
      $pnum = $_[1];
    } else { die("Invalid port '$orig' not known. Try 'pcX:Y'.\n"); }
    if (! NodeCheck($_) ) { die("You are not authorized to control $_.\n"); }
    $_;
  } @p;
  print "translated ports: \t@p\n" if ($debug && @p);
  $n=0;
  while(@vlan != 0 && $n < @vlan) {
    $vlan[$n] = lc $vlan[$n];
    print "Checking node $vlan[$n] for validity...\n" if $debug;
    if ($vlan[$n] =~ /(sh\d+)(-\d)?(:\d)?/ ) { $vlan[$n] = "$1-1:0"; }
    if (defined macport($vlan[$n])) { 
      if ($vlan[$n]=~/^([a-f]|\d)*$/i) {
	$vlan[$n]=macport($vlan[$n]);
	print "Found node $vlan[$n]\n";
      }
    } else {
      # Allow people to specify addresses with colons or dots
      $vlan[$n] =~ s/[:\.]//g;
      if (defined macport($vlan[$n])) {
	$vlan[$n]=macport($vlan[$n]);
	print "Found node $vlan[$n]\n";
      } else {
	die("Invalid VLAN member '$vlan[$n]': must be 'pcX:Y' or MAC.\n");
      }
    }
    $n++;
  }
  die("Can't use file mode with manual vlan creation.\n") if ($f && @vlan);
  if ($on || $off || $cyc) {
    $n=0;
    while(@outlets != 0 && $n < @outlets) {
      die("Invalid Outlet \"",$outlets[$n],"\": Must be 1 to 8.\n")
	if (! ($outlets[$n]=~ /^[1-8]$/ ));
      $n++;
    }
  }
}

sub ReadIRFile {
  local(*f,*names,*VLANS) = @_;
  my %exists = ();
  my $skip = 1;
  my $name = "";
  if ( -e "$TB/etc/$f") {
    open(IR,"$TB/etc/$f") 
      || die("Couldn't open $TB/etc/$f\n");
  } elsif ( -e "$f" ) {
    open(IR,"$f") 
      || die("Couldn't open $f\n");
  } else {
    die("Couldn't locate $f for VLAN setup.\n");
  }
  print "Opened $f for reading...\n" if $debug;
  while (<IR>) {
    chomp;
    if ( /^\#/ ) { next; }	 #skip comments
    if ( /^start vlan/i ) { $skip = 0 ; next; }
    if ($skip) { next; }
    if ( /^end vlan/i ) { $skip = 1 ; next; }
    # If I'm in the right section, turn the line into a VLAN
    my @v= split;
    $name = shift @v;
    my $n=0;
    while (@v != 0 && $n < @v) {
      $v[$n] = lc $v[$n];
      print "Checking node $v[$n] for validity...\n" if $debug;
      if ($v[$n] =~ /(sh\d+)(-\d)?(:\d)?/ ) {
	$v[$n] = "$1-1:0";
      }
      if (defined macport($v[$n])) { 
	if ($v[$n]=~/^([a-f]|\d)*$/i) {
	  $v[$n]=macport($v[$n]);
	  print "Found node $v[$n]\n";
	}
      } else {
	# Allow people to specify addresses with colons or dots
	$v[$n] =~ s/[:\.]//g;
	if (defined macport($v[$n])) {
	  $v[$n]=macport($v[$n]);
	  print "Found node $v[$n]\n";
	} else {
	  die("Invalid VLAN member '$v[$n]': must be 'pcX:Y' or MAC.\n");
	}
      }
      $n++;
    }
    @v = sort @v;
    if (!defined $exists{ join(' ',@v) }) {
      print "Read VLAN $name with: ",join (" ",@v),"\n" if $debug;
      push( @VLANS, \@v);
      push(@names, $name);
      $exists{join(' ',@v)} = 1;
    }
  }
  close (IR);
}
