#!/usr/bin/perl -wT
#
# EMULAB-COPYRIGHT
# Copyright (c) 2006 University of Utah and the Flux Group.
# All rights reserved.
#
use English;
use Getopt::Std;

#
# Quickie graph layout.
#
sub usage()
{
    print(STDERR
	  "Usage: template_graph [-a] <guid>\n".
	  "switches and arguments:\n".
	  "-v          - be more chatty\n".
	  "-a          - Show all templates (ignore hidden bit)\n".
	  "-p <prefix> - prefix for output files.\n".
	  "<guid>      - GUID to graph\n");
    exit(-1);
}
my $optlist	 = "vap:";
my %options      = ();
my $verbose      = 0;
my $prefix       = "/tmp/dot$$";
my $showall      = 0;
my $guid;

#
# Configure variables
#
my $TB		= "@prefix@";
my $PROJROOT	= "/proj";
my $EVENTSYS	= @EVENTSYS@;
my $TBOPS	= "@TBOPSEMAIL@";
my $TBLOGS	= "@TBLOGSEMAIL@";
my $TBDOCBASE	= "@TBDOCBASE@";
my $TBBASE	= "@TBBASE@";
my $CONTROL	= "@USERNODE@";

# Protos
sub ParseArgs();

# Locals
my $DOT         = "/usr/local/bin/dot";
my %versions    = ();

#
# Testbed Support libraries
#
use lib "@prefix@/lib";
use libdb;
use libtestbed;
use libtblog;
use libTemplates;

# Be careful not to exit on transient error
$libdb::DBQUERY_MAXTRIES = 0;

#
# Turn off line buffering on output
#
$| = 1;

#
# Set umask for start/swap. We want other members in the project to be
# able to swap/end experiments, so the log and intermediate files need
# to be 664 since some are opened for append.
#
umask(0002);

#
# Untaint the path
#
# un-taint path
$ENV{'PATH'} = '/bin:/usr/bin:/usr/local/bin';
delete @ENV{'IFS', 'CDPATH', 'ENV', 'BASH_ENV'};

# Now parse arguments.
ParseArgs();

# After parsing args.
my $dotfile	= "$prefix.dot";
my $imapfile	= "$prefix.imap";
my $giffile	= "$prefix.gif";

#
# Grab all the parent pointers.
#
my $query_result =
    DBQueryFatal("select vers,parent_vers,hidden,tid ".
		 "  from experiment_templates ".
		 "where guid='$guid' ".
		 "order by vers");

#
# If nothing left, remove the graph entry.
#
if (! $query_result->num_rows) {
    print "Clearing graph entry for template $guid ...\n";
    
    DBQueryFatal("delete from experiment_template_graphs ".
		 "where parent_guid='$guid'");
    exit(0);
}

#
# Build up lists of children.
#
my %hidden	= ();
my %tids        = ();
my %children    = ();
my $rootnode    = 1;	# XXX

while (my ($vers,$parent_vers,$hidden,$tid) =
       $query_result->fetchrow_array()) {
    $tids{$vers}   = $tid;
    $hidden{$vers} = $hidden;

    next
	if (!defined($parent_vers));

    $children{$parent_vers} = []
	if (!exists($children{$parent_vers}));
    push(@{ $children{$parent_vers} }, $vers);
}

#
# If the root node is hidden (a silly thing to do), then we are done.
#
if ($hidden{$rootnode}) {
    print "Root node hidden; clearing graph entry for template $guid ...\n";
    
    DBQueryFatal("delete from experiment_template_graphs ".
		 "where parent_guid='$guid'");
    exit(0);
}

open(DOT, "> $dotfile") or
    tbdie("Could not open $dotfile!");

print DOT "digraph TemplateGraph {\n";
print DOT "  size=\"8,8\"\n";
print DOT "  fontname=\"Courier\"\n";
print DOT "  node [shape=rectangle,fontsize=10,height=0.3,width=0.8,fixedsize=true]\n";
print DOT "  edge [fontsize=8]\n";
print DOT "  subgraph guid {\n";
print DOT "    label = \"$guid\";\n";

# Start with root and decend all children where hidden=0.
my @kids = ($rootnode);

while (@kids) {
    my $vers = shift(@kids);

    my $tid = $tids{$vers};
    my $url = "$TBBASE/template_show.php?guid=$guid&version=$vers";

    my $query_result =
	DBQueryFatal("select name,value from experiment_template_parameters ".
		     "where parent_guid='$guid' and parent_vers='$vers'");

    my $table = "<table cellpadding=0 cellspacing=0 border=0> ".
	"<tr><td>Version:</td><td>$vers</td></tr>".
	"<tr><td>TID:</td><td>$tid</td></tr>";

    if ($query_result->num_rows) {
	$table .= "<tr><td>Parameters:</td>".
	    "<td><table cellpadding=0 cellspacing=0 border=0>";

	while (my ($name, $value) = $query_result->fetchrow_array()) {
	    $table .= "<tr><td>$name</td><td>$value</td></tr>";
	}
	$table .= "</table></td>";
    }

    $table .= "</table>";
	
    my $tooltip = "return escape(\'$table\')";
	
    if (!exists($versions{"$vers"})) {
	print DOT "    $vers [label=\"$tid\",href=\"$url\",".
	    "tooltip=\"$tooltip\"];\n";
	$versions{"$vers"} = $vers;
    }

    foreach my $kid (@{ $children{$vers} }) {
	next
	    if ($hidden{$kid});

	print DOT "    $vers -> $kid;\n";
	push(@kids, $kid);
    }
}
print DOT "  }\n";
print DOT "}\n";
close(DOT);

#
# Now run dot and generate both a gif and an image map file.
#
system("$DOT -Tgif -o $giffile  $dotfile");
system("$DOT -Tcmapx -o $imapfile $dotfile");

#
# Grab the input data. 
#
my $gifdata = `cat $giffile`;
my $imapdata = `cat $imapfile`;

#
# Massage the mapfile; tooltips --> onmouseovers
#
$imapdata =~ s/title=/onmouseover=/g;

print "$imapdata\n";

$gifdata = DBQuoteSpecial($gifdata);
$imapdata = DBQuoteSpecial($imapdata);

DBQueryFatal("replace into experiment_template_graphs set ".
	     "    parent_guid='$guid', ".
	     "    image=$gifdata, ".
	     "    imap=$imapdata");

#unlink($dotfile, $gifdata, $imapdata);
exit(0);


#
# Parse command arguments. Once we return from getopts, all that are
# left are the required arguments.
#
sub ParseArgs()
{
    if (! getopts($optlist, \%options)) {
	usage();
    }

    if (@ARGV != 1) {
	usage();
    }
    #
    # Pick up guid and untaint.
    #
    my $tmp = shift(@ARGV);

    if ($tmp =~ /^([\w]*)$/) {
	$guid = $1;
    }
    else {
	tbdie("Bad data in argument: $tmp");
    }

    if (defined($options{"p"})) {
	$prefix = $options{"p"};

	if ($prefix =~ /^([-\w\.\/]*)$/) {
	    $prefix = $1;
	}
	else {
	    tbdie("Bad data in argument: $prefix");
	}
    }
    if (defined($options{"a"})) {
	$showall = 1;
    }
}
