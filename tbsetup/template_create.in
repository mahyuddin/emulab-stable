#!/usr/bin/perl -wT
#
# EMULAB-COPYRIGHT
# Copyright (c) 2006 University of Utah and the Flux Group.
# All rights reserved.
#
use English;
use strict;
use Getopt::Std;
use POSIX qw(isatty setsid);
use POSIX qw(strftime);
use Errno qw(EDQUOT);

#
# Create a new experiment template. 
#
# Exit codes are important; they tell the web page what has happened so
# it can say something useful to the user. Fatal errors are mostly done
# with die(), but expected errors use this routine. At some point we will
# use the DB to communicate the actual error.
#
# $status < 0 - Fatal error. Something went wrong we did not expect.
# $status = 0 - Everything okay.
# $status > 0 - Expected error. User not allowed for some reason. 
# 
sub usage()
{
    print(STDERR
	  "Usage: create_expt_template [-q] [-w] [-E description]\n".
	  "          [-m guid/vers] [-g gid] <pid> <tid> <input file>\n".
	  "switches and arguments:\n".
	  "-w        - wait for template to be created.\n".
	  "-m <guid> - Modify existing template.\n".
	  "-q        - be less chatty\n".
	  "-E <str>  - A pithy sentence describing the template\n".
	  "-g <gid>  - The group in which to create the experiment\n".
	  "<pid>     - The project in which to create the experiment\n".
	  "<tid>     - The template name (alphanumeric, no blanks)\n".
	  "<input>   - Input file for experiment.\n");
    exit(-1);
}
my $optlist	 = "qwE:g:m:";
my $quiet        = 0;
my $waitmode     = 0;
my $modify       = 0;
my $description;
my $pid;
my $tid;
my $gid;
my $inputfile;
# For modify.
my $parent_guid;
my $parent_vers;
my $parent_template;

#
# Configure variables
#
my $TB		= "@prefix@";
my $EVENTSYS	= @EVENTSYS@;
my $TBOPS	= "@TBOPSEMAIL@";
my $TBLOGS	= "@TBLOGSEMAIL@";
my $TBDOCBASE	= "@TBDOCBASE@";
my $TBBASE	= "@TBBASE@";
my $CONTROL	= "@USERNODE@";

# Locals
my $user_name;
my $user_email;
my $template;
my $dbuid;
my $guid;
my $vers;
my $eid;
my $archive_idx = 0;
# For the END block below.
my $cleaning    = 0;
my $exptcreated = 0;
my $justexit    = 1;

# Programs we need
my $checkquota  = "$TB/sbin/checkquota";
my $batchexp    = "$TB/bin/batchexp";
my $endexp      = "$TB/bin/endexp";
my $makegraph   = "$TB/bin/template_graph";

# Protos
sub ParseArgs();
sub fatal($$);

#
# Testbed Support libraries
#
use lib "@prefix@/lib";
use libdb;
use libtestbed;
use libtblog;
use libArchive;
use Template;
use libaudit;

# Be careful not to exit on transient error
$libdb::DBQUERY_MAXTRIES = 120;

#
# Turn off line buffering on output
#
$| = 1;

#
# Set umask for start/swap. We want other members in the project to be
# able to swap/end experiments, so the log and intermediate files need
# to be 664 since some are opened for append.
#
umask(0002);

#
# Untaint the path
#
# un-taint path
$ENV{'PATH'} = '/bin:/usr/bin:/usr/local/bin';
delete @ENV{'IFS', 'CDPATH', 'ENV', 'BASH_ENV'};

#
# Verify user and get his DB uid.
#
if (! UNIX2DBUID($UID, \$dbuid)) {
    tbdie("You do not exist in the Emulab Database!");
}

#
# Get email info for user.
#
if (! UserDBInfo($dbuid, \$user_name, \$user_email)) {
    tbdie("Cannot determine your name and email address.");
}

#
# Before doing anything else, check for overquota ... lets not waste
# our time. Make sure user sees the error by exiting with 1.
#
if (system("$checkquota $dbuid") != 0) {
    tberror("You are over your disk quota on $CONTROL; ".
	    "please login there and cleanup!");
    exit(1);
}

# Now parse arguments.
ParseArgs();

#
# Make sure UID is allowed to create experiments in this project.
#
if (! TBProjAccessCheck($dbuid, $pid, $gid, TB_PROJECT_CREATEEXPT)) {
    tbdie("You do not have permission to create experiments in $pid/$gid");
}

#
# On modify, must check access to the parent template.
#
if ($modify) {
    $parent_template = Template->Lookup($parent_guid, $parent_vers);

    if (!defined($parent_template)) {
	tbdie("Experiment template $parent_guid/$parent_vers does not exist!");
    }

    if (!$parent_template->AccessCheck($dbuid, TB_EXPT_READINFO)) {
	tbdie("You do not have permission to modify experiment template ".
	      "$parent_guid/$parent_vers");
    }

    $description = $parent_template->description()
	if (!defined($description));
}
else {
    $description = "Created by $dbuid"
	if (! defined($description));
}

#
# In wait mode, block SIGINT until we spin off the background process.
#
if ($waitmode) {
    $SIG{QUIT} = 'IGNORE';
    $SIG{TERM} = 'IGNORE';
    $SIG{INT}  = 'IGNORE';
}

#
# Create a template record now, so we know what it is.
#
my %args = ();

if ($modify) {
    $args{'parent_guid'} = $parent_guid;
    $args{'parent_vers'} = $parent_vers;
}
$args{'pid'}         = $pid;
$args{'gid'}         = $gid;
$args{'tid'}         = $tid;
$args{'uid'}         = $dbuid;
$args{'description'} = DBQuoteSpecial($description);
$args{'description'} =~ s/^\'(.*)\'$/$1/;

if (! ($template = Template->Create(\%args))) {
    tbdie("Could not create a new template record!");
}

#
# At this point, we need to force a cleanup no matter how we exit.
# See the END block below.
#
$justexit = 0;

# Grab stuff we need out of the template.
$guid = $template->guid();
$vers = $template->vers();
$eid  = $template->eid();

#
# Use the logonly option to audit so that we get a record mailed.
#
if (my $childpid = AuditStart(LIBAUDIT_DAEMON, undef, LIBAUDIT_LOGONLY)) {
    #
    # Parent exits normally, unless in waitmode. We have to set
    # justexit to make sure the END block below does not run.
    #
    $justexit = 1;
    
    if (!$waitmode) {
	print("Template $pid/$tid is being created.\n".
 	      "You will be notified via email it is ready to use\n")
	    if (! $quiet);
	exit(0);
    }
    print("Waiting for template $pid/$tid to be created\n")
	if (! $quiet);

    # Give child a chance to run.
    select(undef, undef, undef, 0.25);
	
    #
    # Reset signal handlers. User can now kill this process, without
    # stopping the child.
    #
    $SIG{TERM} = 'DEFAULT';
    $SIG{QUIT} = 'DEFAULT';
    $SIG{INT}  = 'DEFAULT';

    #
    # Wait until child exits or until user gets bored and types ^C.
    #
    waitpid($childpid, 0);
    my $exit_code = $? >> 8;

    print("Done. Exited with status: $?\n")
	if (! $quiet);

    if ($exit_code == 0) {
        # Web interface depends on this line. Bad; need another way to send
        # back the newly generated guid/version.
	print "Template $guid/$vers has been created\n";
    }
    else {
	my $d = tblog_lookup_error();
	print tblog_format_error($d);
    }
    
    exit $exit_code;
}

#
# We need to catch TERM so we can kill the children and do a cleanup.
#
sub handler ($) {
    my ($signame) = @_;
    
    $SIG{TERM} = 'IGNORE';
    my $pgrp = getpgrp(0);
    kill('TERM', -$pgrp);
    sleep(1);
    fatal(-1, "Caught SIG${signame}! Killing template setup ...");
}
$SIG{TERM} = \&handler;
$SIG{QUIT} = 'DEFAULT';

#
# The template gets its own directory structure. 
#
if (my $rval = $template->CreateDirectory()) {
    fatal($rval, "Failed to create directories for template");
}

#
# The description is versioned metadata the user can modify.
#
$template->NewMetadata("description", $description,
		       $dbuid, "template_description") == 0
    or fatal(-1, "Failed to insert metadata record for description");

#
# The TID is versioned metadata the user can modify.
#
$template->NewMetadata("TID", $tid, $dbuid, "tid") == 0
    or fatal(-1, "Failed to insert metadata record for description");

# Now invoke batchexp to preload the experiment. Note special -x option.
system("$batchexp ". 
       "-x " . ($modify ? $parent_template->eid() : "-") . " " .
       "-q -i -f -E 'Experiment Template Preload $guid/$vers' ".
       "-p $pid -e $eid $inputfile");
fatal($? >> 8, "Oops")
    if ($?);

# Need to kill the experiment if we fail after this point.
$exptcreated = 1;

# Input files are kept in the DB, with the template.
fatal(-1, "Could not add NS file to template store")
    if ($template->AddInputFile($inputfile) < 0);

#
# Grab archive index for new templates. 
#
if (!$modify) {
    libArchive::TBExperimentArchiveInfo($pid, $eid, \$archive_idx, undef)
	>= 0 or fatal(-1, "Could not get archive index for new template!");
}
else {
    #
    # Grab the archive index for the parent; the archive is shared.
    #
    $archive_idx = $parent_template->archive_idx();
}

# And update the record.
%args = ();
$args{'archive_idx'} = $archive_idx;

$template->Update(\%args) == 0
    or fatal(-1, "Could not update template record!");

#
# When creating a template, the archive is created (or forked) in batchexp
# but it is not committed. We need to do that now cause this experiment
# is never actually swapped in. Instead each instance is a new fork, and if
# the archive were not committed, it would not look correct.
# Before we do that though, we want to copy the datastore directory to the
# child since we *do* want that stuff shared.
#
if ($modify) {
    print "Committing archive before copying data store\n";
    libArchive::TBCommitExperimentArchive($pid, $eid, "template_modify")
	>= 0 or fatal(-1, "Failed to commit experiment archive!");
    
    $template->CopyDataStore($parent_template, $dbuid) == 0
	or fatal(-1, "Failed to copy data store");

    # and tell the archive library about the above files.
    libArchive::TBExperimentArchiveAddUserFiles($pid, $eid) == 0
	or fatal(-1, "Failed to add datastore files to the archive!");

    # and then do a savepoint prior to the commit below.
    print "Doing another savepoint\n";
    libArchive::TBExperimentArchiveSavePoint($pid, $eid, "CopyDataStore") >= 0
	or fatal(-1, "Failed to do a savepoint on the experiment archive!");
}
print "Doing final commit\n";
libArchive::TBCommitExperimentArchive($pid, $eid, "TemplateCreate")
    >= 0 or fatal(-1, "Failed to commit experiment archive!");

#
# Copy the virt_parameters table to the formal parameters table.
# I am not sure about the need for this table yet, but the only way
# to get the parameters is via the parser, but we want to save this
# info forever (after the underlying experiment is terminated).
#
my $query_result =
    DBQueryWarn("select name,value,description from virt_parameters ".
              "where pid='$pid' and eid='$eid'");

fatal(-1, "Could not get virt_parameters for $pid/$eid")
    if (! $query_result);

while (my ($name, $value, $description) = $query_result->fetchrow_array()) {
    $template->NewFormalParameter($name, $value, $description, $dbuid) == 0
	or fatal(-1, "Could not set formal parameter for $pid/$eid")
}

#
# Copy the rest of the metadata from parent to child.
# XXX This has to be done after the previous step (virt_parameters)
#
if ($modify) {
    $template->CopyMetadata($parent_template, $dbuid) == 0
	or fatal(-1, "Failed to copy metadata records");
}
   
#
# Generate the graph for the template.
#
system("$makegraph $guid");
fatal(-1, "Error generating template graph.")
    if ($?);

#
# Update parent to point to most recent child.
#
if ($modify) {
    %args = ();

    $args{'child_guid'} = $template->guid();
    $args{'child_vers'} = $template->vers();

    $parent_template->Update(\%args) == 0
	or fatal(-1, "Could not update parent template record!");
}

exit(0);

#
# Parse command arguments. Once we return from getopts, all that are
# left are the required arguments.
#
sub ParseArgs()
{
    my %options = ();
    if (! getopts($optlist, \%options)) {
	usage();
    }

    if (@ARGV < 2 || @ARGV > 3) {
	usage();
    }
    #
    # Pick up pid/tid first and untaint.
    #
    $pid = shift(@ARGV);

    if ($pid =~ /^([-\w]+)$/) {
	$pid = $1;
    }
    else {
	tbdie("Bad data in argument: $pid.");
    }
    if (! TBcheck_dbslot($pid, "projects", "newpid",
			 TBDB_CHECKDBSLOT_WARN|TBDB_CHECKDBSLOT_ERROR)) {
	tbdie("Improper project name (id)!");
    }
    
    $tid = shift(@ARGV);

    if ($tid =~ /^([-\w]+)$/) {
	$tid = $1;
    }
    else {
	tbdie("Bad data in argument: $tid.");
    }
    if (! TBcheck_dbslot($tid, "experiments", "eid",
			 TBDB_CHECKDBSLOT_WARN|TBDB_CHECKDBSLOT_ERROR)) {
	tbdie("Improper template name (id)!");
    }
    if (@ARGV) {
	$inputfile = $ARGV[0];

	# Note different taint check (allow /).
	if ($inputfile =~ /^([-\w\.\/]+)$/) {
	    $inputfile = $1;
	}
	else {
	    tbdie("Bad data in input file: $inputfile");
	}

	#
	# Called from ops interactively. Make sure NS file in /proj or /users.
	#
	# Use realpath to resolve any symlinks.
	#
	my $translated = `realpath $inputfile`;
	if ($translated =~ /^([-\w\.\/]+)$/) {
	    $inputfile = $1;
	}
	else {
	    tbdie("Bad data returned by realpath: $translated");
	}

	#
	# The file must reside in an acceptible location. Since this script
	# runs as the caller, regular file permission checks ensure it is a
	# file the user is allowed to use.  So we don't have to be too tight
	# with the RE matching /tmp and /var/tmp files.  Note that
	# /tmp/$guid-$nsref.nsfile is also allowed since this script is
	# invoked directly from web interface which generates a name that
	# should not be guessable.
	#
	if (! ($inputfile =~ /^\/tmp\/[-\w]+-\d+\.nsfile/) &&
	    ! ($inputfile =~ /^\/tmp\/\d+\.ns/) &&
	    ! ($inputfile =~ /^\/var\/tmp\/php\w+/) &&
	    ! TBValidUserDir($inputfile, 0)) {
	    tberror("$inputfile does not resolve to an allowed directory!");
	    # Note positive status; so error goes to user not tbops.
	    exit(1);
	}
    }
    #
    # Optional gid. Defaults to pid.
    #
    if (defined($options{"g"})) {
	$gid = $options{"g"};

	if ($gid =~ /^([-\w]+)$/) {
	    $gid = $1;
	}
	else {
	    tbdie("Bad data in argument: $gid.");
	}
    }
    else {
	$gid = $pid;
    }

    #
    # Parent pointer, for modify. We always create a new template point
    # it to the parent. 
    #
    if (defined($options{"m"})) {
	if ($options{"m"} =~ /^([\w]*)\/([\d]*)$/) {
	    $parent_guid = $1;
	    $parent_vers = $2;
	    $modify      = 1;
	}
	else {
	    tbdie("Bad data in argument: " . $options{"m"});
	}
    }

    if (defined($options{"E"})) {
	if (! TBcheck_dbslot($options{"E"},
			     "experiment_templates", "description",
			     TBDB_CHECKDBSLOT_WARN|TBDB_CHECKDBSLOT_ERROR)) {
	    tbdie("Improper template description!");
	}
	$description = $options{"E"};
    }

    if (defined($options{"q"})) {
	$quiet = 1;
    }
    if (defined($options{"w"})) {
	$waitmode = 1;
    }
}

#
# Cleanup the mess.
#
sub cleanup()
{
    if ($exptcreated) {
	my $exptidx;

	exit(-1)
	    if (!TBExptIDX($pid, $eid, \$exptidx));
		
	system("$endexp -x -q -w $pid $eid");
	exit(-1)
	    if ($?);

	# And delete all the other stuff?
    }
    $template->Delete()
	if (defined($template));
}

sub fatal($$)
{
    my ($errorstat, $msg) = @_;
    
    tberror $msg;
    tbinfo "Cleaning up and exiting with status $errorstat ...";

    #
    # This exit will drop into the END block below.
    # 
    exit($errorstat);
}

END {
    # Normal exit, nothing to do.
    if (!$? || $justexit) {
	return;
    }
    my $saved_exitcode = $?;
    
    if ($cleaning) {
	#
	# We are screwed; a recursive error. Someone will have to clean
	# up by hand. 
	#
	SENDMAIL($TBOPS, 
		 "Template Creation Failure: $pid/$tid",
		 "Recursive error in cleanup! This is very bad.");
	$? = $saved_exitcode;
	return;
    }
    $cleaning = 1;
    cleanup();
    $? = $saved_exitcode;
}

