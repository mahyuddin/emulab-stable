#!/usr/local/bin/perl -wT
use English;

#
# Create accounts.
#
# XXX - The control node is hardwired. Look for $CONTROL.
#
# usage: mkacct-ctrl <userid>
# 

#
# Configure variables
#
my $TB      = "@prefix@";
my $TBOPS   = "@TBOPSEMAIL@";
my $CONTROL = "@USERNODE@";
my $TESTMODE= "@TESTMODE@";

my $HOMEDIR = "/users";
my $PBAG    = "$TB/sbin/paperbag";
my $SSH     = "$TB/bin/sshtb";
my $GROUPADD= "/usr/sbin/pw groupadd";
my $USERADD = "/usr/sbin/pw useradd";
my $USERMOD = "/usr/sbin/pw usermod";
my $CHPASS  = "/usr/bin/chpass";
my $GENELISTS = "$TB/sbin/genelists";

my $user;
my @db_row;
my $query_result;

#
# We don't want to run this script unless its the real version.
#
if ($EUID != 0) {
    die("Must be root! Maybe its a development version?");
}

#
# Untaint the path
# 
$ENV{'PATH'} = "/bin:/usr/bin";
delete @ENV{'IFS', 'CDPATH', 'ENV', 'BASH_ENV'};

#
# Turn off line buffering on output
#
$| = 1;

#
# Load the Testbed support stuff. 
#
use lib "@prefix@/lib";
use libdb;
use libtestbed;

#
# Check args.
#
if ($#ARGV < 0) {
    die("Usage: mkacct-ctrl <userid>\n");
}
$user = $ARGV[0];

#
# Untaint the argument.
#
if ($user =~ /^([a-z0-9]+)$/i) {
    $user = $1;
}
else {
    die("Invalid uid '$user' contains illegal characters.\n");
}

#
# This script always does the right thing, but we prefer that mere users
# do not run it, except when its for themselves. Otherwise, make sure that
# user has group/project root in at least one project, which indicates they
# have some level of responsibility.
#
if ($UID && !TBAdmin($UID)) {
    my $dbuid;

    if (! UNIX2DBUID($UID, \$dbuid)) {
	die("You are not a valid emulab user!\n");
    }
    if ($dbuid ne $user) {
	#
	# Check if group_root/project_root anyplace.
	#
	$query_result =
	    DBQueryFatal("select trust from group_membership ".
			 "where uid='$dbuid' and ".
			 "trust='project_root' or trust='group_root'");

	if ($query_result->numrows == 0) {
	    die("$0: You do not have permission to run this script!\n");
	}
    }
}

#
# Get the user info (the user being created).
#
$query_result =
    DBQueryFatal("select usr_pswd,unix_uid,usr_name,usr_email ".
		 "from users where uid='$user'");
if ($query_result->numrows == 0) {
    fatal("$user is not in the DB. This is bad.\n");
}
@db_row         = $query_result->fetchrow_array();
my $pswd        = $db_row[0];
my $user_number = $db_row[1]; 
my $fullname    = $db_row[2];
my $user_email  = $db_row[3];

#
# Get the group (projects user belongs to) names and numbers. 
#
my @groupnames;
my %groupnumbers;
my @grouplist;
my @tipservers;

#
# Form a list of project (group) membership names. We do this in two
# steps to ensure that we get the default group membership, since we
# want that to be the user's primary group. Not sure this really matters
# all that much, but might as well. 
# 
$query_result =
    DBQueryFatal("select g.unix_name,g.unix_gid from group_membership as m ".
		 "left join groups as g on m.pid=g.pid and m.gid=g.gid ".
		 "where m.uid='$user' and m.pid=m.gid and m.trust!='none'");
if ($query_result->numrows == 0) {
    fatal("$user is not in any groups!\n");
}
while (@db_row = $query_result->fetchrow_array() ) {
    push(@groupnames, $db_row[0]);
    $groupnumbers{$db_row[0]} = $db_row[1];
}

$query_result =
    DBQueryFatal("select g.unix_name,g.unix_gid from group_membership as m ".
		 "left join groups as g on m.pid=g.pid and m.gid=g.gid ".
		 "where m.uid='$user' and m.pid!=m.gid and m.trust!='none'");
while (@db_row = $query_result->fetchrow_array() ) {
    push(@groupnames, $db_row[0]);
    $groupnumbers{$db_row[0]} = $db_row[1];
}

#
# Note hardwired control node. 
# 
my $control_node = $CONTROL;

#
# We need a list of tipservers to build groups on so that the console
# lines can get the appropriate group permissions. 
#
$query_result =
    DBQueryFatal("select * from tipservers");

while (@db_row = $query_result->fetchrow_array() ) {
    push(@tipservers, $db_row[0]);
}

#
# Create groups on both the control and operations nodes. We assume
# FreeBSD for both. 
# 
# All this stuff must be done as root (ssh).
#
$UID = $EUID;

#
# Run genelists to update the email lists. This is a convenient
# spot to do this. Errors are non-fatal; the testbed list will
# will find out about problems via email from genelists. Note that
# this command must be run when EUID==UID==0 because its a setuid
# PERL script.
#
system("$GENELISTS");

foreach my $group ( @groupnames ) {
    my $group_number = $groupnumbers{$group};

    print "Processing group $group (gid $group_number)\n";
    
    # 
    # Create group locally if it does not exist. egrep returns 1 when
    # no matches are found.
    #
    if (system("egrep -q -s '^${group}:' /etc/group")) { 
	print "Adding group $group to paper\n";

	if (system("$GROUPADD $group -g $group_number")) {
	    fatal("Could not add $group ($group_number) to local node!\n");
	}
    }

    #
    # Create group on the control node if it does not exist.
    #
    if (system("$SSH $control_node egrep -q -s '^${group}:' /etc/group")) {
	print "Adding group $group to $control_node.\n";

	if (system("$SSH $control_node $GROUPADD $group -g $group_number")) {
	    fatal("Could not add $group ($group_number) to $control_node!\n");
	}
    }

    #
    # On tipservers too.
    #
    foreach my $tipserver ( @tipservers ) {
	if (system("$SSH $tipserver egrep -q -s '^${group}:' /etc/group")) {
	    print "Adding group $group to $tipserver\n";

	    if (system("$SSH $tipserver $GROUPADD $group -g $group_number")) {
		fatal("Could not add $group ($group_number) to $tipserver!\n");
	    }
	}
    }
}

#
# Construct an appropriate group list for the pw commands. Main project
# is the first on the list, and that becomes the primary group. The rest
# (if any) of the groups become a comma separated list for the -G option.
#
my $groupargument = " ";
my $project       = shift @groupnames;
my $grouplist     = join(",",@groupnames);

#
# Add special groups. These are listed in the DB so that special local
# users can have more unix groups than just the projects/groups they are
# in. These groups must already exist. 
#
if ((my @extragrouplist = TBUnixGroupList($user))) {
    print "Adding extra groups to list: @extragrouplist\n";
    
    if ($grouplist) {
	$grouplist = "$grouplist," . join(",", @extragrouplist);
    }
    else {
	$grouplist = join(",", @extragrouplist);
    }
}

if ($grouplist) {
    $groupargument = "-G $grouplist";
}
else {
    $groupargument = "-G \"\"";
}

#
# Make user on local. We don't give them a password since they are not
# allowed to log in, except via paperbaf. Be sure not overwrite the shell
# for a user who has a real shell. 
#
if (system("egrep -q -s '^${user}:' /etc/passwd")) {
    print "Adding user $user ($user_number) to local node.\n";

    if (system("$USERADD $user -u $user_number -c \"$fullname\" ".
	       "-k /usr/share/skel -m -d $HOMEDIR/$user ".
	       "-g $project $groupargument -s $PBAG")) {
	fatal("Could not add user $user to local node.");
    }
}
else {
    print "Updating user $user ($user_number) record on local node.\n";

    #
    # MAKE SURE not to update the shell
    #
    if (system("$USERMOD $user -u $user_number -c \"$fullname\" ".
	       "-g $project $groupargument")) {
	fatal("Could not modify user $user on local node.");
    }
}

#
# Make user account on control node. We do the password setup as separate
# step since thats easier than trying to both via ssh.
#
# Quote special chars for ssh and the shell on the other side
#
$fullname =~ s/\"/\'/g;
$fullname =~ s/([^\\])([\'\"\(\)])/$1\\$2/g;

if (system("$SSH $control_node egrep -q -s '^${user}:' /etc/passwd")) {
    print "Adding user $user ($user_number) to $control_node.\n";

    if (system("$SSH $control_node '$USERADD ".
	       "$user -u $user_number -c \"$fullname\" ".
	       "-k /usr/share/skel -m -d $HOMEDIR/$user -g $project ".
	       "$groupargument -s /bin/tcsh'")) {
	fatal("Could not add user $user ($user_number) to $control_node.\n");
    }
}
else {
    print "Updating user $user record on $control_node.\n";

    if (system("$SSH $control_node '$USERMOD ".
	       "$user -u $user_number ".
	       "-c \"$fullname\" -g $project $groupargument'")) {
	fatal("Could not modify user $user record on $control_node.");
    }
}
if (system("$SSH $control_node $CHPASS -p $pswd $user")) {
    fatal("Could not change password for user $user on $control_node.\n");
}

#
# Set up the ssh key, but only if not done so already.
#
if (! -e "$HOMEDIR/$user/.ssh/" ) {
    print "Setting up ssh configuration for $user.\n";
    
    mkdir("$HOMEDIR/$user/.ssh", 0700) or
	fatal("Could not mkdir $HOMEDIR/$user/.ssh: $!");
    chown($user_number, $groupnumbers{$project}, "$HOMEDIR/$user/.ssh") or
	fatal("Could not chown $HOMEDIR/$user/.ssh: $!");
    
    # Run commands below as the user
    $EUID = $user_number;
    $UID  = $EUID;

    if (system("/usr/bin/ssh-keygen -P '' -f $HOMEDIR/$user/.ssh/identity")) {
	fatal("Failure in ssh-keygen");
    }
    if (system("/bin/cp $HOMEDIR/$user/.ssh/identity.pub ".
	       "$HOMEDIR/$user/.ssh/authorized_keys")) {
	fatal("Copying over $HOMEDIR/$user/.ssh/identity.pub to auth keys");
    }
    chmod(0600, "$HOMEDIR/$user/.ssh/authorized_keys") or
	fatal("Could not chown $HOMEDIR/$user/.ssh/authorized_keys: $!");
}

#
# Set up a .forward file so that any email to them gets forwarded off.
#
if (! -e "$HOMEDIR/$user/.forward" ) {
    print "Setting up .forward file for $user.\n";

    if (system("echo \"$user_email\" > $HOMEDIR/$user/.forward")) {
	fatal("Could not create $HOMEDIR/$user/.forward");
    }
    chmod(0644, "$HOMEDIR/$user/.forward") or
	fatal("Could not chown $HOMEDIR/$user/.forward");
}

exit(0);

sub fatal {
    local($msg) = $_[0];

    SENDMAIL($TBOPS, "TESTBED: mkacct-ctrl Failed", $msg);
    die("$0: $msg");
}
