#!/usr/bin/perl -w
use English;
use Getopt::Std;

sub usage()
{
    print STDOUT "Usage: ptopgen [-s switch]\n";
    exit(-1);
}
my  $optlist = "s:";


# Settings - Change these to your particular network.
#
# Explanation from Mac:
#
# These are for the imaginary "lan nodes". Internally the way we map
# lans is as a bunch of machines connected in a star to a "lan node"
# that has infinite bw basically, and an infinite number of connections
# available to it. So the first big number is BW (100Gbps), and the
# 1000 means it has 1000 connections to the switch. That number is
# plenty high as it is, since our limit on one switch is under 400.
#
# Speed in in Kbs!
#
my $lannode_switch2switch_speed = 100000000;
my $lannode_switch2switch_links = 1000;

#
# Also bogus. The interfaces table does not hold entries for the switch
# side of each link. It will have to at some point, when we have something
# other than 100Mbs ports (say, gbit ports).
#
# Speed in in Kbs!
#
my $default_switchport_speed    = 100000;

######################################################################

my $TBROOT = "@prefix@";
use lib '@prefix@/lib';
require exitonwarn;
use libdb;

%switches=();
%used_switches=();
my $switchtouse;

my $DEADPID = NODEDEAD_PID();
my $DEADEID = NODEDEAD_EID();

#
# Parse command arguments. Once we return from getopts, all that should be
# left are the required arguments.
#
%options = ();
if (! getopts($optlist, \%options)) {
    usage();
}
if (@ARGV) {
    usage();
}
if (defined($options{"s"})) {
    $switchtouse = $options{"s"};
}

# Read class/type maps
my $result = DBQueryFatal("select class,type,delay_capacity from node_types");
while (($class,$type,$delaycapacity) = $result->fetchrow_array) {
    $classes{$type} = $class;
    $nodetypes{$type} = $delaycapacity;
}
$result->finish;

# switches can't delay
$nodetypes{"switch"} = 0;

# Print switches
if (defined($switchtouse)) {
    print "node $switchtouse switch:1\n";
    $switches{$switchtouse} = 1;
}
else {
    $result =
	DBQueryFatal("select node_id from nodes where role = \"testswitch\"");

    while (($switch) = $result->fetchrow_array) {
	print "node $switch switch:1\n";
	$switches{$switch} = 1;
    }
    $result->finish;
}

# Find available nodes
#
# VIRTNODES HACK: If the node is a virtual node, then in addition to
# to being free, the underlying physnode has to either be free, or
# not in the hwdown group. Either way, the the underlying physnode has
# to be "up", as determined by the autostatus stuff; this will prevent us
# from allocating a dead virtual node to an experiment. 
# This is especially hacky. We need another mechanism for this.
#
$result =
    DBQueryFatal("select a.node_id,a.type from nodes as a ".
		 "left join reserved as b on a.node_id=b.node_id ".
		 "left join reserved as m on a.phys_nodeid=m.node_id ".
		 "left join nodes as n on a.phys_nodeid=n.node_id ".
		 "left join node_types as nt on a.type=nt.type ".
		 "where b.node_id is null and a.role='testnode' and ".
		 "      (nt.isvirtnode=0 || ".
		 "       (n.status='up' and (m.node_id is null || ".
		 "        m.pid!='$DEADPID' || m.eid!='$DEADEID')))");

while (($node,$type) = $result->fetchrow_array) {
    # Shark hack
    if (($shelf,$number) = ($node =~ /^sh(\d+)-(\d+)/)) {
	if ($number == 1) {
	    $nodes{"sh$shelf"} = "shark-shelf";
	}
    } else {
	$nodes{$node} = $type;
    }
}
$result->finish;


$sharklinks = "";
foreach $node (keys(%nodes)) {
    if ($node =~ /^sh/) {
	print "node $node shark-shelf:1\n";
    } else {
	$text = "node $node $nodes{$node}:1 $classes{$nodes{$node}}:1";
	$delay_capacity = $nodetypes{$nodes{$node}};
	if ($delay_capacity > 0) {
	    $text .= " delay:$delay_capacity";
	}
	print "$text\n";
    }
}

# Read interfaces
$result = DBQueryFatal("SELECT node_id,card,port,iface,interface_type" .
		     " from interfaces");
while (($node,$card,$port,$iface,$type) = $result->fetchrow_array) {
    $interfacemap{"$node:$card:$port"} = $iface;
    if ($type ne "") {
	$interfacetypes{"$node:$card:$port"} = $type;
    }
}
$result->finish;

# Read interface types
$result = DBQueryFatal("SELECT type,max_speed from interface_types");
while (($type,$speed) = $result->fetchrow_array) {
    $interfacespeeds{$type} = $speed;
}
$result->finish;

$result = DBQueryFatal("SELECT node_id1,card1,port1,node_id2,card2,port2" .
 		    " from wires where type=\"Node\" or type=\"Trunk\"");
while (($node1,$card1,$port1,$node2,$card2,$port2) = 
       $result->fetchrow_array) {
    if ((defined($nodes{$node1}) || defined($switches{$node1})) && 
	(defined($nodes{$node2}) || defined($switches{$node2}))) {
	$iface1 = get_iface($node1,$card1,$port1);
	$iface2 = get_iface($node2,$card2,$port2);
	$iface1bw = get_ifacebw($node1,$card1,$port1);
	$iface2bw = get_ifacebw($node2,$card2,$port2);
	if ($iface1bw < $iface2bw) {
	    $bw = $iface1bw;
	} else {
	    $bw = $iface2bw;
	}
	if (defined($switches{$node2})) {
	    $used_switches{$node2} = 1;
	}
	if (defined($switches{$node1})) {
	    $used_switches{$node1} = 1;
	}
	if (defined($switches{$node1}) && defined($switches{$node2})) {
	    # interswitch link
	    if (defined($interconnects{"$node1:$node2"})) {
		$interconnects{"$node1:$node2"} += $bw;
	    } else {
		$interconnects{"$node1:$node2"} = $bw;
	    }
	} else {
	    # !!! - Here we use our knowledge that in the wires table links
	    # to the switch always come as node2.
	    print "link link-$node1:$iface1-$node2:$iface2 $node1:$node1/$iface1" .
		" $node2:$iface2 $bw 1\n";
	}
    } 
}
$result->finish;
foreach $interconnect (keys(%interconnects)) {
    ($src,$dst) = split(":",$interconnect);
    print "link link-$interconnect $src $dst $interconnects{$interconnect} 1\n";
}

print $sharklinks;

# Add a bunch of LANs
foreach $switch (keys(%used_switches)) {
    for ($i = 0;$i <= 20;$i++) {
	print "node lan-$switch-$i lan:1\n";
	print "link link-lan-$switch-$i lan-$switch-${i}:lan-$switch-$i " .
	    "$switch ".
	    "$lannode_switch2switch_speed $lannode_switch2switch_links\n";
    }
}


# Print out links
sub get_iface {
    ($node,$card,$port) = @_;
    if (defined($interfacemap{"$node:$card:$port"})) {
	return $interfacemap{"$node:$card:$port"};
    } else {
	# shark hack
	if ($node =~ /^sh/) {
	    return "eth0";
	} else {
	    return "(null)";
	}
	# end shark hack 
    }
};

# Find the bandwidth for an interface
sub get_ifacebw {
    ($node,$card,$port) = @_;
    if (defined($interfacetypes{"$node:$card:$port"})) {
	return $interfacespeeds{$interfacetypes{"$node:$card:$port"}};
    }
    else {
	return $default_switchport_speed;
    }
}
