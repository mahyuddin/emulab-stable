#!/usr/bin/perl -wT

#
# EMULAB-COPYRIGHT
# Copyright (c) 2000-2003 University of Utah and the Flux Group.
# All rights reserved.
#

use English;
use Getopt::Std;

#
# This gets invoked from the Web interface. CD into the proper directory
# and do the tb stuff.
#
sub usage()
{
    print STDOUT
	"Usage: startexp [-f] [-b] [-g gid] <pid> <eid> <nsfile>\n";
    exit(-1);
}
my  $optlist = "bg:f";

#
# Configure variables
#
my $TB       = "@prefix@";
my $DBNAME   = "@TBDBNAME@";
my $TBOPS    = "@TBOPSEMAIL@";
my $TBLOGS   = "@TBLOGSEMAIL@";
my $TBINFO   = "$TB/expinfo";
my $PROJROOT = "/proj";

#
# Testbed Support libraries
#
use lib "@prefix@/lib";
use libdb;
use libtestbed;

my $tbdir    = "$TB/bin/";
my $tbdata   = "tbdata";
my $frontend = 0;
my $nodetach = 0;
my $errorstat= -1;
my $logname;

#
# For debugging all this goo. Leaves the experiment directory intact,
# and placed in a subdir of the project directory.
# 
my $debug    = 1;

#
# Turn off line buffering on output
#
$| = 1;

#
# Set umask for start/swap. We want other members in the project to be
# able to swap/end experiments, so the log and intermediate files need
# to be 664 since some are opened for append.
#
umask(0002);

#
# Untaint the path
# 
$ENV{'PATH'} = '/bin:/usr/bin';
delete @ENV{'IFS', 'CDPATH', 'ENV', 'BASH_ENV'};

#
# Parse command arguments. Once we return from getopts, all that should
# left are the required arguments.
#
%options = ();
if (! getopts($optlist, \%options)) {
    usage();
}
if (@ARGV != 3) {
    usage();
}
my $pid   = $ARGV[0];
my $eid   = $ARGV[1];
my $nsfile= $ARGV[2];
if (defined($options{"f"})) {
    $frontend = 1;
}
if (defined($options{"b"})) {
    $nodetach = 1;
}
if (defined($options{"g"})) {
    $gid = $options{"g"};
}
else {
    $gid = $pid;
}

#
# Untaint the arguments.
#
if ($pid =~ /^([-\@\w]+)$/) {
    $pid = $1;
}
else {
    die("Tainted argument $pid!\n");
}
if ($eid =~ /^([-\@\w]+)$/) {
    $eid = $1;
}
else {
    die("Tainted argument $eid!\n");
}
if ($gid =~ /^([-\@\w]+)$/) {
    $gid = $1;
}
else {
    die("Tainted argument $gid!\n");
}
# Note different taint check (allow /).
if ($nsfile =~ /^([-\w.\/]+)$/) {
    $nsfile = $1;
}
else {
    die("Tainted nsfile name: $nsfile");
}

my $workdir = TBExptWorkDir($pid, $eid);
my $userdir = TBExptUserDir($pid, $eid);
my $repfile = "$eid.report";
my $user_name;
my $user_email;
my $dbuid;

#
# Verify user and get his DB uid.
#
if (! UNIX2DBUID($UID, \$dbuid)) {
    die("*** $0:\n".
	"    Go Away! You do not exist in the Emulab Database.\n");
}

#
# Verify that this person is allowed to start the experiment. 
#
if (! TBProjAccessCheck($dbuid, $pid, $gid, TB_PROJECT_CREATEEXPT)) {
    die("*** $0:\n".
	"    You do not have permission to start experiments in $pid/$gid\n");
}

#
# Get email info for user.
#
if (! UserDBInfo($dbuid, \$user_name, \$user_email)) {
    die("*** $0:\n".
        "    Cannot determine your name and email address.\n");
}

#
# We have to protect against trying to muck with an experiment that is
# currently in transition. We use a "wrapper" state (actually a
# timestamp so we can say when termination was requested) since
# terminating consists of a couple of different experiment states down
# inside the tb scripts.
#
DBQueryFatal("lock tables experiments write");

$query_result =
    DBQueryFatal("select * from experiments where eid='$eid' and pid='$pid'");

if (! $query_result->numrows) {
    die("*** $0:\n".
        "    No experiment record for $pid/$eid exists!\n");
}

my %row		= $query_result->fetchhash();
my $estate	= $row{'state'};
my $ebatchstate = $row{'batchstate'};
my $expt_path   = $row{'path'};
my $expt_name   = $row{'expt_name'};
my $expt_created= $row{'expt_created'};
my $swappablebit= $row{'swappable'};
my $idleswapbit = $row{'idleswap'};
my $autoswapbit = $row{'autoswap'};
my $swappable   = ( $row{'swappable'} ? "Yes" : "No" );
my $idleswap    = ( $row{'idleswap'} ? "Yes" : "No" );
my $autoswap    = ( $row{'autoswap'} ? "Yes" : "No" );
my $noswap      = $row{'noswap_reason'};
my $noidleswap  = $row{'noidleswap_reason'};
my $idleswaptime= $row{'idleswap_timeout'} / 60.0;
my $autoswaptime= $row{'autoswap_timeout'} / 60.0;

my $swapsettings = 
  "Swappable:   $swappable".($swappablebit ? "\n" : " (Reason: $noswap)\n").
  "Idle-Swap:   $idleswap".
  ($idleswapbit ? ", at $idleswaptime hours\n" : " (Reason: $noidleswap)\n").
  "Auto-Swap:   $autoswap".
  ($autoswapbit ? ", at $autoswaptime hours\n" : "\n");

if ($estate ne EXPTSTATE_NEW ||
    $ebatchstate ne BATCHSTATE_ACTIVATING ||
    !defined($row{'expt_name'})) {
    die("*** $0:\n".
	"    Experiment $pid/$eid is not in the proper state!\n");
}

if (! chdir($workdir)) {
    die("*** $0:\n".
	"    Could not chdir to $workdir: $!\n");
}
DBQueryFatal("unlock tables");

#
# The rest of this goes into the background so that the user sees
# immediate response. We will send email later when the experiment
# is actually torn down.
#
if (! $nodetach) {
    $logname = TBExptCreateLogFile($pid, $eid, "startexp");
    TBExptSetLogFile($pid, $eid, $logname);
    TBExptOpenLogFile($pid, $eid);
    
    if (TBBackGround($logname)) {
	#
	# Parent exits normally
	#
	print STDOUT
	    "Experiment $pid/$eid is now configuring\n".
	    "You will be notified via email when the experiment is ".
	    "ready to use\n";
	exit(0);
    }
}

#
# Gather statistics; start the clock ticking.
#
if ($frontend) {
    GatherSwapStats($pid, $eid, $dbuid, TBDB_STATS_PRELOAD, 0,
		    TBDB_STATS_FLAGS_START);
}
else {
    GatherSwapStats($pid, $eid, $dbuid, TBDB_STATS_START, 0,
		    TBDB_STATS_FLAGS_START);
}

#
# Run the various scripts. We want to propogate the error from tbprerun
# and tbrun back out, hence the bogus looking errorstat variable.
#
if (system("$tbdir/tbprerun $pid $eid $nsfile") != 0) {
    $errorstat = $? >> 8;
    fatal("tbprerun failed!\n");
}
# So fatal errors run tbend.
$estate = EXPTSTATE_PRERUN;

if (! $frontend) {
    if (system("$tbdir/tbswap in $pid $eid") != 0) {
	$errorstat = $? >> 8;
	fatal("tbswap in failed!\n");
    }
    # So fatal errors run tbswap out,
    $estate = EXPTSTATE_ACTIVE;

    #
    # Look for the unsual case of more than 2 nodes and no vlans. Send a
    # warning message.
    #
    my @localnodes = ExpNodes($pid, $eid, 1);
    
    if (defined(@localnodes) && scalar(@localnodes) > 2) {
	my $vlans_result =
	    DBQueryFatal("select pid from virt_lans where ".
			 "pid='$pid' and eid='$eid'");
    
	if (!$vlans_result->numrows) {
	    SENDMAIL("$user_name <$user_email>",
		     "WARNING: Experiment Configuration: $pid/$eid",
		     "This experiment has zero network links defined.\n".
		     "Please check your NS file to verify this is what you ".
		     "want!\n",
		     "$user_name <$user_email>",
		     "Cc: $TBOPS", ($nsfile));
	}
    }
}

if (system("$tbdir/tbreport -b $pid $eid 2>&1 > $repfile") != 0) {
    fatal("tbreport failed!\n");
}

#
# Gather statistics.
#
if ($frontend) {
    GatherSwapStats($pid, $eid, $dbuid, TBDB_STATS_PRELOAD, 0);
}
else {
    GatherSwapStats($pid, $eid, $dbuid, TBDB_STATS_START, 0);
}

# Yippie!
print STDOUT "Setup Success\n";

#
# Try to copy off the files for testbed information gathering.
#
TBSaveExpLogFiles($pid, $eid);

#
# Make a copy of the work dir in the user visible space so the user
# can see the log files.
#
system("cp -Rfp $workdir/ $userdir/tbdata");

#
# Close up the log file so the webpage stops.
#
TBExptCloseLogFile($pid, $eid);

#
# Must unlock before exit.
#
if ($frontend) {
    TBUnLockExp($pid, $eid, BATCHSTATE_PAUSED());
}
else {
    TBUnLockExp($pid, $eid, BATCHSTATE_RUNNING());
}

#
# Clear the cancel flag now that the operation is complete. Must be
# done after we change the experiment state (above).
#
TBSetBatchCancelFlag($pid, $eid, BATCHMODE_CANCELCLEAR);

#
# In nodetach mode, just exit without sending email. 
#
if ($nodetach) {
    exit(0);
}

#
# Dump the report file and the log file to the user via email. 
#
my $message;

if ($frontend) {
    $message =
	"Your experiment `$eid' in project `$pid' has been created.\n" .
	"You can check the web interface to see if it looks the way\n" .
	"you expected it to. If so, you may swap the experiment in,\n" .
	"or terminate it, at any time.\n" .
        "\n";
}
else {
    $message =
	"Your experiment `$eid' in project `$pid' has been started.\n" .
	"Here is the experiment summary detailing the nodes that were\n" .
	"allocated to you. You may use the `Qualified Name' to log on\n" .
	"to your nodes. See /etc/hosts on your nodes (when running\n" .
	"FreeBSD, Linux, or NetBSD) for the IP mapping on each node.\n" .
        "\n";
}
$message .=
    "User:        $user_name\n" .
    "EID:         $eid\n" .
    "PID:         $pid\n" .
    "GID:         $gid\n" .
    "Name:        $expt_name\n" .
    $swapsettings .
    "Created:     $expt_created\n" .
    "Directory:   $expt_path\n".
    "\n".
    "Appended at the end is the output of the experiment setup. If you\n" .
    "have any questions or comments, please include the output below\n" .
    "in your message to $TBOPS";

SENDMAIL("$user_name <$user_email>",
	 "New Experiment " . (($frontend == 0) ? "Started" : "Created") .
	 ": $pid/$eid",
	 $message,
	 "$user_name <$user_email>",
	 "Bcc: $TBLOGS",
	 ($repfile, $logname, $nsfile));

# Done!
exit(0);

sub fatal()
{
    my($mesg)     = $_[0];

    print STDOUT "$mesg\n";
    print STDOUT "Cleaning up and exiting with status $errorstat ...\n";

    #
    # Gather statistics.
    #
    if ($frontend) {
	GatherSwapStats($pid, $eid, $dbuid, TBDB_STATS_PRELOAD, $errorstat);
    }
    else {
	GatherSwapStats($pid, $eid, $dbuid, TBDB_STATS_START, $errorstat);
    }

    #
    # Must clean state.
    #
    if ($estate ne EXPTSTATE_NEW) {
	tbendit();
    }

    #
    # Okay, we *are* going to terminate the experiment.
    # 
    GatherSwapStats($pid, $eid, $dbuid, TBDB_STATS_TERMINATE, 0);

    # Clear the logfile so the webpage stops. 
    TBExptClearLogFile($pid, $eid);

    #
    # In nodetach mode, just exit without sending email. No need to unlock
    # the experiment since its going to be killed. Better not to, just in
    # case the user tries to muck with it. 
    #
    if ($nodetach) {
	exit($errorstat);
    }

    #
    # Send a message to the testbed list. 
    #
    SENDMAIL("$user_name <$user_email>",
	     "Experiment Configure Failure: $pid/$eid",
	     $mesg,
	     "$user_name <$user_email>",
	     "Cc: $TBOPS",
	     ($logname, "assign.log", "wanassign.log", $nsfile));

    #
    # Back up the work dir for post-mortem debugging. 
    #
    system("/bin/rm -rf  ${workdir}-failed");
    system("/bin/mv -f   $workdir ${workdir}-failed");

    #
    # Clear the record and cleanup.
    # 
    TBExptDestroy($pid, $eid);    
    
    exit($errorstat);
}

#
# If tbprerun finishes, but tbrun fails, lets do a tbend to make sure
# the nodes and vlans are released.
# 
sub tbendit()
{
    if ($estate eq EXPTSTATE_ACTIVE) {
	print "Running 'tbswap out' with arguments: $pid $eid\n";
	if (system("$tbdir/tbswap out $pid $eid") != 0) {
	    print "tbswap out failed!\n";
	}
    }
    print "Running tbend with arguments: -force $pid $eid\n";
    if (system("$tbdir/tbend -force $pid $eid") != 0) {
	print "tbend failed!\n";
    }
}
