#!/usr/bin/perl -wT
use English;
use Getopt::Std;

#
# This gets invoked from the Web interface. CD into the proper directory
# and do the tb stuff.
#
# The -b (batch) argument is so that this script can be part of a batchmode
# that starts/ends experiments offline. In that case, we don't want to put
# it into the background and send email, but just want an exit status 
# returned to the batch system.
#
# XXX - The -b option takes a logfile name. This is so this script can
#       save off the file in the expinfo directory. The caller (batch daemon) 
#       opens the file and just passes the name in. I do not like this!
#
# usage: startexp [-b logfile] <pid> <eid> <nsfile>
#
sub usage()
{
    print STDOUT "Usage: startexp [-b logfile] <pid> <eid> <nsfile>\n";
    exit(-1);
}
my  $optlist = "b:";

#
# Configure variables
#
my $TB       = "@prefix@";
my $DBNAME   = "@TBDBNAME@";
my $TBOPS    = "@TBOPSEMAIL@";
my $TBINFO   = "$TB/expinfo";

my $tbdir    = "$TB/bin/";
my $projroot = "/proj";
my $tbdata   = "tbdata";
my $cleanme  = 0;
my $batch    = 0;
my $logname  = 0;
my $errorstat= -1;

#
# For debugging all this goo. Leaves the experiment directory intact,
# and placed in a subdir of the project directory.
# 
my $debug    = 1;

#
# Turn off line buffering on output
#
$| = 1;

#
# Untaint the path
# 
$ENV{'PATH'} = '/bin:/usr/bin';
delete @ENV{'IFS', 'CDPATH', 'ENV', 'BASH_ENV'};

#
# Parse command arguments. Once we return from getopts, all that should
# left are the required arguments.
#
%options = ();
if (! getopts($optlist, \%options)) {
    usage();
}
if (@ARGV != 3) {
    usage();
}
my $pid   = $ARGV[0];
my $eid   = $ARGV[1];
my $tempfile = $ARGV[2];
if (defined($options{"b"})) {
    $batch   = 1;
    $logname = $options{"b"};

    # Note different taint check (allow /).
    if ($logname =~ /^([-\@\w.\/]+)$/) {
	$logname = $1;
    } else {
	die "Bad data in logfile name: $logname";
    }
}

#
# Untaint the arguments.
#
if ($pid =~ /^([-\@\w.]+)$/) {
    $pid = $1;
}
if ($eid =~ /^([-\@\w.]+)$/) {
    $eid = $1;
}
# Note different taint check (allow /).
if ($tempfile =~ /^([-\w.\/]+)$/) {
    $tempfile = $1;
}
else {
    die("Tainted tempfile name: $tempfile");
}

my $piddir  = "$projroot/$pid";
my $expdir  = "$piddir/exp";
my $eiddir  = "$expdir/$eid";
my $nsfile  = "$eid.ns";
my $irfile  = "$eid.ir";
my $repfile = "$eid.report";
my $tempns  = "$tempfile.$$";
my $user_name  = "Startexp Script";
my $user_email = "$TBOPS";

#
# Set up for querying the database.
# 
use Mysql;
my $DB = Mysql->connect("localhost", $DBNAME, "script", "none");

#
# Check to make sure the experiment record exists. To prevent mishap,
# also check to make sure the experiment is in the "not ready" state
# to prevent this record from being used to configure two sets of nodes!
# This could happen if the user invokes this script directly, and that
# is eventually what I want anyway (instead of users using the tb scripts). 
#
$query_result =
    $DB->query("SELECT expt_ready FROM experiments ".
	       "WHERE eid='$eid' and pid='$pid'");

if (! $query_result) {
    fatal("DB Error getting experiment record $pid/$eid\n");
}
if ($query_result->numrows < 1) {
    print STDOUT "No experiment record for $pid/$eid exists!\n";
    exit(1);
}
@row = $query_result->fetchrow_array();
if ($row[0]) {
    fatal("Experiment $pid/$eid is already configured!\n".
	  "You are not allowed to reconfigure experiments unless you\n".
	  "first terminate the existing experiment via the web interface.\n");
}

#
# Get some user information. 
#
$query_result =
    $DB->query("SELECT uid,usr_name,usr_email from users ".
	       "WHERE unix_uid='$EUID'");

if (! $query_result) {
    fatal("DB Error getting user information for uid $EUID\n");
}
if ($query_result->numrows < 1) {
    print STDOUT "Go Away! You do not exist in the Emulab Database.\n";
    exit(1);
}

@row = $query_result->fetchrow_array();
$uid        = $row[0];
$user_name  = $row[1];
$user_email = $row[2];

#
# Verify that this person is allowed to start the experiment. Must be
# in the project membership table.
#
$query_result =
    $DB->query("SELECT pid FROM proj_memb ".
	       "WHERE uid=\"$uid\" and pid=\"$pid\"");

if (! $query_result) {
    fatal("DB Error getting project membership for uid $uid\n");
}
if ($query_result->numrows == 0) {
    print STDOUT "Go Away! You are not a member of project $pid\n";
    exit(1);
}

#
# Copy the nsfile from wherever the web server stuffed it into a temporary
# file. The web server is going to delete it once this script returns.
#
if (system("/bin/cp", "$tempfile", "$tempns") != 0) {
    fatal("Could not copy $tempfile to $tempns: $!\n");
}
chmod(0770, "$tempns");

#
# The rest of this goes into the background so that the user sees
# immediate response. We will send email later when the experiment
# is actually torn down.
#
if (! $batch) {
    if (background()) {
	#
	# Parent exits normally
	#
	print STDOUT
	    "Experiment $pid/$eid is now configuring\n".
	    "You will be notified via email when the experiment is ".
	    "ready to use\n";
	exit(0);
    }
}

#
# Create a directory structure for the experiment in the project directory.
#
if (system("$TB/libexec/mkexpdir $pid $eid") != 0) {
    fatal("$tbdir/mkexpdir failed\n");
}

#
# Copy the nsfile from wherever the web server stuffed it, into the
# experiment directory. We leave the tempns file around till later.
#
if (! chdir("$eiddir/$tbdata")) {
    fatal("Could not chdir to $tbdata in $eiddir: $!\n");
}

if (system("/bin/cp", "$tempns", "$nsfile") != 0) {
    fatal("Could not copy $tempns to $eiddir/$tbdata/$nsfile: $!\n");
}

#
# Run the various scripts. We want to propogate the error from tbprerun
# and tbrun back out, hence the bogus looking errorstat variable.
#
#if (system("$tbdir/tbprerun -nologfile $pid $eid $nsfile") != 0) {
if (system("$tbdir/tbprerun $pid $eid $nsfile") != 0) {
    $errorstat = $? >> 8;
    fatal("tbprerun failed!\n");
}
# So fatal errors run tbend.
$cleanme = 1;

#if (system("$tbdir/tbrun -nologfile $pid $eid $irfile") != 0) {
if (system("$tbdir/tbrun $pid $eid $irfile") != 0) {
    $errorstat = $? >> 8;
    fatal("tbrun failed!\n");
}

if (system("$tbdir/tbreport -v $pid $eid $irfile 2>&1 > $repfile") != 0) {
    fatal("tbreport failed!\n");
}

#
# In batchmode, send the report to stdout for the batch daemon.
#
if ($batch) {
    system("$tbdir/tbreport -v $pid $eid $irfile");
    print STDOUT "\n\n";
}

#
# Done! Set the ready bit in the experiment record.
# 
$query_result = $DB->query("UPDATE experiments SET expt_ready=1 ".
			   "WHERE eid='$eid' and pid='$pid'");

if (! $query_result) {
    fatal("DB Error setting ready bit in experiment record for $pid/$eid\n");
}

#
# Grab the entire experiment record for the mail message below.
#
$query_result =
    $DB->query("SELECT expt_name,expt_created,expt_expires from experiments ".
	       "WHERE eid='$eid' and pid='$pid'");

if (! $query_result) {
    fatal("DB Error getting experiment record for $pid/$eid\n");
}
@row = $query_result->fetchrow_array();
$expt_name     = $row[0];
$expt_created  = $row[1];
$expt_expires  = $row[2];

print STDOUT "Setup Success\n";

#
# Try to copy off the files for testbed information gathering.
#
my $infodir = "$pid-$eid-" . `date +20%y%m%d-%H.%M.%S`;

if ($infodir =~ /^([-\@\w.]+)$/) {
    $infodir = $1;

    if (mkdir("$TBINFO/$infodir", 0770)) {
	system("cp $nsfile $irfile $TBINFO/$infodir");
	system("cp *.ptop *.top $TBINFO/$infodir");
	system("cp assign.log $TBINFO/$infodir");
	system("cp $logname $TBINFO/$infodir/$eid.log");
    }
}

#
# In batch mode, just exit without sending email. Remove tempns file!
#
if ($batch) {
    unlink("$tempns");
    exit(0);
}

#
# Dump the report file and the log file to the user via email. 
#
open(MAIL, "| /usr/bin/mail ".
     "-s \"TESTBED: New Experiment Created: $pid/$eid\" ".
     "-c $TBOPS \"$user_name <$user_email>\" >/dev/null 2>&1")
    or die "Cannot start mail program: $!";

print MAIL "Your experiment `$eid' in project `$pid' is now configured.\n";
print MAIL "Here is the experiment summary detailing the nodes that were\n";
print MAIL "allocated to you. You may use the `Qualified Name' to log on\n";
print MAIL "to your nodes. See /etc/hosts on your nodes (when running\n";
print MAIL "FreeBSD, Linux, or NetBSD) for the IP name mapping on each node\n";

print MAIL "\n";
print MAIL "User:        $user_name\n";
print MAIL "EID:         $eid\n";
print MAIL "PID:         $pid\n";
print MAIL "Name:        $expt_name\n";
print MAIL "Created:     $expt_created\n";
print MAIL "Expires:     $expt_expires\n";
print MAIL "Directory:   $eiddir\n\n";

if (open(IN, "$repfile")) {
    while (<IN>) {
	print MAIL "$_";
    }
    close(IN);
}

print MAIL "\n\n---------\n\n";

print MAIL "Here is the log of the configuration process.\n";
print MAIL "If you have any questions or problems, please include the\n";
print MAIL "output below in your message to $TBOPS\n\n";

if (open(IN, "$logname")) {
    while (<IN>) {
	print MAIL "$_";
    }
    close(IN);
}

if (open(IN, "$nsfile")) {
    print MAIL "\n\n---------\n\n";
    print MAIL "Here is the NS file\n\n";

    while (<IN>) {
	print MAIL "$_";
    }
    close(IN);
}
close(MAIL);

unlink("$tempns");
unlink("$logname");
exit 0;

sub fatal()
{
    my($mesg)     = $_[0];

    print STDOUT "$mesg\n";
    print STDOUT "Cleaning up and exiting with status $errorstat ...\n";

    #
    # If we got far enough to allocate nodes, must run tbend.
    #
    if ($cleanme) {
	tbendit();
    }

    #
    # Now we can remove all trace from the DB since it failed.
    # 
    $query_result =
	$DB->query("DELETE from experiments WHERE eid='$eid' and pid='$pid'");

    if (! $query_result) {
	print STDOUT "DB Error deleting experiment record for $pid/$eid\n";
    }


    #
    # In batch mode, exit. Make sure to delete tempns file. 
    #
    if ($batch) {
	if (open(IN, "$eiddir/assign.log")) {
	    print STDOUT "\n\n--------- assign.log --------\n\n";
	    
	    while (<IN>) {
		print STDOUT "$_";
	    }
	    close(IN);
	}
	
	if (chdir($expdir)) {
	    system("/bin/rm", "-rf", "${eid}-TBfailed");
	    system("/bin/mv", "-f", "$eid", "${eid}-TBfailed");
	}
	unlink("$tempns");
	exit($errorstat);
    }

    #
    # Send a message to the testbed list. Append the logfile if it got
    # that far.
    # 
    open(MAIL, "| /usr/bin/mail ".
	 "-s \"TESTBED: Experiment Configure Failure $pid/$eid\" ".
	 "-c $TBOPS \"$user_name <$user_email>\" >/dev/null 2>&1")
	or die "Cannot start mail program: $!";

    print MAIL $mesg;

    if (open(IN, "$tempns")) {
	print MAIL "\n\n--------- $tempns ---------\n\n";

	while (<IN>) {
	    print MAIL "$_";
	}
	close(IN);
	unlink("$tempns");
    }

    if (open(IN, "$logname")) {
	print MAIL "\n\n--------- $logname ---------\n\n";
	
	while (<IN>) {
	    print MAIL "$_";
	}
	close(IN);
    }

    if (open(IN, "$eiddir/assign.log")) {
	print MAIL "\n\n--------- assign.log --------\n\n";
	
	while (<IN>) {
	    print MAIL "$_";
	}
	close(IN);
    }
    close(MAIL);

    unlink("$tempns");
    unlink("$logname");
    if (chdir($expdir)) {
	system("/bin/rm", "-rf", "${eid}-TBfailed");
	system("/bin/mv", "-f", "$eid", "${eid}-TBfailed");
    }
    exit($errorstat);
}

#
# If tbprerun finishes, but tbrun fails, lets do a tbend to make sure
# the nodes and vlans are released.
# 
sub tbendit()
{
	print STDOUT "Running tbend with arguments: -nologfile $pid $eid\n";
	if (system("$tbdir/tbend -nologfile $pid $eid") != 0) {
	    print STDOUT "tbend failed!\n";
	}
}

#
# Put ourselves into the background so that caller sees immediate response.
# Mail notification will happen later.
# 
sub background()
{
    $mypid = fork();
    if ($mypid) {
	return $mypid;
    }

    #
    # We have to disconnect from the caller by redirecting both STDIN and
    # STDOUT away from the pipe. Otherwise the caller (the web server) will
    # continue to wait even though the parent has exited. 
    #
    open(STDIN, "< /dev/null") or
	die("opening /dev/null for STDIN: $!");

    #
    # Create a temporary name for a log file and untaint it.
    #
    $logname = `mktemp /tmp/start-$pid-$eid.XXXXXX`;

    # Note different taint check (allow /).
    if ($logname =~ /^([-\@\w.\/]+)$/) {
	$logname = $1;
    } else {
	die "Bad data in logfile name: $logname";
    }

    open(STDERR, ">> $logname") or die("opening $logname for STDERR: $!");
    open(STDOUT, ">> $logname") or die("opening $logname for STDOUT: $!");

    return 0;
}
