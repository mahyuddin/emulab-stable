#!/usr/bin/perl -wT
use English;
use Getopt::Std;

#
# This gets invoked from the Web interface. CD into the proper directory
# and do the tb stuff.
#
# The -b (batch) argument is so that this script can be part of a batchmode
# that starts/ends experiments offline. In that case, we don't want to put
# it into the background and send email, but just want an exit status 
# returned to the batch system.
#
# XXX - The -b option takes a logfile name. This is so this script can
#       save off the file in the expinfo directory. The caller (batch daemon) 
#       opens the file and just passes the name in. I do not like this!
#
# usage: startexp [-l] [-b logfile] [-g gid] <pid> <eid> <nsfile>
#
sub usage()
{
    print STDOUT
	"Usage: startexp [-l] [-b logfile] [-g gid] <pid> <eid> <nsfile>\n";
    exit(-1);
}
my  $optlist = "b:g:";

#
# Configure variables
#
my $TB       = "@prefix@";
my $DBNAME   = "@TBDBNAME@";
my $TBOPS    = "@TBOPSEMAIL@";
my $TBLOGS   = "@TBLOGSEMAIL@";
my $TBINFO   = "$TB/expinfo";
my $PROJROOT = "/proj";

#
# Testbed Support libraries
#
use lib "@prefix@/lib";
use libdb;
use libtestbed;

my $tbdir    = "$TB/bin/";
my $tbdata   = "tbdata";
my $batch    = 0;
my $errorstat= -1;
my $logname;

#
# For debugging all this goo. Leaves the experiment directory intact,
# and placed in a subdir of the project directory.
# 
my $debug    = 1;

#
# Turn off line buffering on output
#
$| = 1;

#
# Set umask for start/swap. We want other members in the project to be
# able to swap/end experiments, so the log and intermediate files need
# to be 664 since some are opened for append.
#
umask(0002);

#
# Untaint the path
# 
$ENV{'PATH'} = '/bin:/usr/bin';
delete @ENV{'IFS', 'CDPATH', 'ENV', 'BASH_ENV'};

#
# Parse command arguments. Once we return from getopts, all that should
# left are the required arguments.
#
%options = ();
if (! getopts($optlist, \%options)) {
    usage();
}
if (@ARGV != 3) {
    usage();
}
my $pid   = $ARGV[0];
my $eid   = $ARGV[1];
my $nsfile= $ARGV[2];
if (defined($options{"b"})) {
    $batch   = 1;
    $logname = $options{"b"};
}

if (defined($options{"g"})) {
    $gid = $options{"g"};
}
else {
    $gid = $pid;
}

#
# Untaint the arguments.
#
if ($pid =~ /^([-\@\w]+)$/) {
    $pid = $1;
}
else {
    die("Tainted argument $pid!\n");
}
if ($eid =~ /^([-\@\w]+)$/) {
    $eid = $1;
}
else {
    die("Tainted argument $eid!\n");
}
if ($gid =~ /^([-\@\w]+)$/) {
    $gid = $1;
}
else {
    die("Tainted argument $gid!\n");
}
# Note different taint check (allow /).
if ($nsfile =~ /^([-\w.\/]+)$/) {
    $nsfile = $1;
}
else {
    die("Tainted nsfile name: $nsfile");
}

if (!defined($logname)) {
    $logname = `mktemp /tmp/start-$pid-$eid.XXXXXX`;
}
if ($logname =~ /^([-\@\w.\/]+)$/) {
    $logname = $1;
}
else {
    die("Bad data in logfile name: $logname");
}

my $repfile = "$eid.report";
my $user_name;
my $user_email;
my $dbuid;

#
# Verify user and get his DB uid.
#
if (! UNIX2DBUID($UID, \$dbuid)) {
    die("*** $0:\n".
	"    Go Away! You do not exist in the Emulab Database.\n");
}

#
# Verify that this person is allowed to start the experiment. 
#
if (! TBProjAccessCheck($dbuid, $pid, $gid, TB_PROJECT_CREATEEXPT)) {
    die("*** $0:\n".
	"    You do not have permission to start experiments in $pid/$gid\n");
}

#
# Get email info for user.
#
if (! UserDBInfo($dbuid, \$user_name, \$user_email)) {
    die("*** $0:\n".
        "    Cannot determine your name and email address.\n");
}

#
# Check to make sure the experiment record exists. The experiment must
# be in the "new" state when using this interface. 
#
$query_result =
    DBQueryFatal("SELECT * FROM experiments WHERE eid='$eid' and pid='$pid'");

if (! $query_result->numrows) {
    die("*** $0:\n".
        "    No experiment record for $pid/$eid exists!\n");
}

my %row		= $query_result->fetchhash();
my $estate	= $row{'state'};
my $expt_path   = $row{'path'};
my $expt_name   = $row{'expt_name'};
my $expt_created= $row{'expt_created'};
my $expt_expires= $row{'expt_expires'};
my $expt_started;

if ($estate ne EXPTSTATE_NEW) {
    die("*** $0:\n".
	"    Experiment $pid/$eid is already configured (or configuring)!\n");
}

if (! chdir("$expt_path/$tbdata")) {
    die("*** $0:\n".
	"    Could not chdir to $expt_path/$tbdata: $!\n");
}

#
# Lock the experiment record with the timestamp so that it cannot
# terminated or swapped. This is basically a wrapper state for the
# variety of actual states.
#
TBLockExp($pid, $eid);

#
# The rest of this goes into the background so that the user sees
# immediate response. We will send email later when the experiment
# is actually torn down.
#
if (! $batch) {
    TBExptSetLogFile($pid, $eid, $logname);
    
    if (TBBackGround($logname)) {
	#
	# Parent exits normally
	#
	print STDOUT
	    "Experiment $pid/$eid is now configuring\n".
	    "You will be notified via email when the experiment is ".
	    "ready to use\n";
	exit(0);
    }
}

#
# Run the various scripts. We want to propogate the error from tbprerun
# and tbrun back out, hence the bogus looking errorstat variable.
#
if (system("$tbdir/tbprerun $pid $eid $nsfile") != 0) {
    $errorstat = $? >> 8;
    fatal("tbprerun failed!\n");
}
# So fatal errors run tbend.
$estate = EXPTSTATE_PRERUN;

if (system("$tbdir/tbswapin  $pid $eid") != 0) {
    $errorstat = $? >> 8;
    fatal("tbswapin failed!\n");
}
# So fatal errors run tbswapout,
$estate = EXPTSTATE_ACTIVE;

if (system("$tbdir/tbreport -b $pid $eid 2>&1 > $repfile") != 0) {
    fatal("tbreport failed!\n");
}

#
# Look for the unsual case of more than 2 nodes and no vlans. Send a
# warning message.
#
if (ExpNodes($pid, $eid) > 2) {
    my $vlans_result =
	DBQueryFatal("select * from vlans where pid='$pid' and eid='$eid'");
    
    if (!$vlans_result->numrows) {
	SENDMAIL("$user_name <$user_email>",
		 "WARNING: Experiment Configuration: $pid/$eid",
		 "This experiment has zero network links defined.\n".
		 "Please check your NS file to verify this is what you ".
		 "want!\n",
		 "$user_name <$user_email>",
		 "Cc: $TBOPS", ($nsfile));
    }
}

#
# Increment the project experiment count/lastdate. This is informational. 
#
DBQueryWarn("update projects ".
	    "set expt_count=expt_count+1, expt_last=now() ".
	    "where pid='$pid'");

#
# Gen up a date for the started field of the record, and insert it.
# Unlock the experiment at the same time.
# 
$expt_started  = DBDateTime();
DBQueryWarn("update experiments set ".
	    "expt_start='$expt_started', expt_locked=NULL ".
	    "WHERE eid='$eid' and pid='$pid'");

#
# In batchmode, send the report to stdout for the batch daemon.
#
if ($batch) {
    system("$tbdir/tbreport -b $pid $eid");
    print STDOUT "\n\n";
}

#
# Try to copy off the files for testbed information gathering.
#
my $infodir = "$pid-$eid-" . TBDateTimeFSSafe();

if (mkdir("$TBINFO/$infodir", 0770)) {
    system("cp $nsfile $TBINFO/$infodir");
    system("cp *.ptop *.top $TBINFO/$infodir");
    system("cp  assign.log wanassign.log $TBINFO/$infodir");
    system("cp $logname $TBINFO/$infodir/$eid.log");
}

print STDOUT "Setup Success\n";

#
# In batch mode, just exit without sending email. 
#
if ($batch) {
    exit(0);
}

#
# Dump the report file and the log file to the user via email. 
#
my $message = 
    "Your experiment `$eid' in project `$pid' is now configured.\n" .
    "Here is the experiment summary detailing the nodes that were\n" .
    "allocated to you. You may use the `Qualified Name' to log on\n" .
    "to your nodes. See /etc/hosts on your nodes (when running\n" .
    "FreeBSD, Linux, or NetBSD) for the IP mapping on each node\n" .
    "\n" .
    "User:        $user_name\n" .
    "EID:         $eid\n" .
    "PID:         $pid\n" .
    "GID:         $gid\n" .
    "Name:        $expt_name\n" .
    "Created:     $expt_created\n" .
    "Expires:     $expt_expires\n" .
    "Started:     $expt_started\n" .
    "Directory:   $expt_path\n".
    "\n".
    "Appended at the end is the output of the experiment setup. If you\n" .
    "have any questions or comments, please include the output below\n" .
    "in your message to $TBOPS";
   

SENDMAIL("$user_name <$user_email>",
	 "New Experiment Created: $pid/$eid",
	 $message,
	 "$user_name <$user_email>",
	 "Bcc: $TBLOGS",
	 ($repfile, $logname, $nsfile));

TBExptClearLogFile($pid, $eid);
unlink($logname);
exit 0;

sub fatal()
{
    my($mesg)     = $_[0];

    print STDOUT "$mesg\n";
    print STDOUT "Cleaning up and exiting with status $errorstat ...\n";

    #
    # If we got far enough to allocate nodes, must run tbend.
    #
    if ($estate ne EXPTSTATE_NEW) {
	tbendit();
    }

    #
    # In batch mode, exit.
    #
    if ($batch) {
	TBUnLockExp($pid, $eid);
	exit($errorstat);
    }

    #
    # Send a message to the testbed list. 
    #
    SENDMAIL("$user_name <$user_email>",
	     "Experiment Configure Failure: $pid/$eid",
	     $mesg,
	     "$user_name <$user_email>",
	     "Cc: $TBOPS",
	     ($logname, "assign.log", "wanassign.log", $nsfile));

    #
    # We have to cleanup the DB since we are disconnected from the
    # wrapper script.
    #
    DBQueryWarn("DELETE from nsfiles ".
		"WHERE eid='$eid' and pid='$pid'");

    DBQueryWarn("DELETE from exppid_access ".
		"WHERE exp_eid='$eid' and exp_pid='$pid'");

    DBQueryWarn("DELETE from experiments ".
		"WHERE eid='$eid' and pid='$pid'");
    
    #
    # Save a copy of the failed experiment directory for debugging.
    # This must be done *after* sending email so that the nsfile and
    # log files are where the mail function expects them to be.
    #
    if (defined($expt_path)) {
	system("/bin/rm", "-rf", "${expt_path}-TBfailed");
	system("/bin/mv", "-f", "${expt_path}", "${expt_path}-TBfailed");
    }

    TBExptClearLogFile($pid, $eid);
    unlink($logname);
    exit($errorstat);
}

#
# If tbprerun finishes, but tbrun fails, lets do a tbend to make sure
# the nodes and vlans are released.
# 
sub tbendit()
{
    if ($estate eq EXPTSTATE_ACTIVE) {
	print "Running tbswapout with arguments: $pid $eid\n";
	if (system("$tbdir/tbswapout $pid $eid") != 0) {
	    print "tbswapout failed!\n";
	}
    }
    print "Running tbend with arguments: -force $pid $eid\n";
    if (system("$tbdir/tbend -force $pid $eid") != 0) {
	print "tbend failed!\n";
    }
}
