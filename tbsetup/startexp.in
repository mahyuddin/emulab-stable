#!/usr/bin/perl -wT

#
# EMULAB-COPYRIGHT
# Copyright (c) 2000-2002 University of Utah and the Flux Group.
# All rights reserved.
#

use English;
use Getopt::Std;

#
# This gets invoked from the Web interface. CD into the proper directory
# and do the tb stuff.
#
# The -b (batch) argument is so that this script can be part of a batchmode
# that starts/ends experiments offline. In that case, we don't want to put
# it into the background and send email, but just want an exit status 
# returned to the batch system.
#
sub usage()
{
    print STDOUT
	"Usage: startexp [-b | -f] [-g gid] <pid> <eid> <nsfile>\n";
    exit(-1);
}
my  $optlist = "bg:f";

#
# Configure variables
#
my $TB       = "@prefix@";
my $DBNAME   = "@TBDBNAME@";
my $TBOPS    = "@TBOPSEMAIL@";
my $TBLOGS   = "@TBLOGSEMAIL@";
my $TBINFO   = "$TB/expinfo";
my $PROJROOT = "/proj";

#
# Testbed Support libraries
#
use lib "@prefix@/lib";
use libdb;
use libtestbed;

my $tbdir    = "$TB/bin/";
my $tbdata   = "tbdata";
my $batch    = 0;
my $frontend = 0;
my $errorstat= -1;
my $logname;

#
# For debugging all this goo. Leaves the experiment directory intact,
# and placed in a subdir of the project directory.
# 
my $debug    = 1;

#
# Turn off line buffering on output
#
$| = 1;

#
# Set umask for start/swap. We want other members in the project to be
# able to swap/end experiments, so the log and intermediate files need
# to be 664 since some are opened for append.
#
umask(0002);

#
# Untaint the path
# 
$ENV{'PATH'} = '/bin:/usr/bin';
delete @ENV{'IFS', 'CDPATH', 'ENV', 'BASH_ENV'};

#
# Parse command arguments. Once we return from getopts, all that should
# left are the required arguments.
#
%options = ();
if (! getopts($optlist, \%options)) {
    usage();
}
if (@ARGV != 3) {
    usage();
}
my $pid   = $ARGV[0];
my $eid   = $ARGV[1];
my $nsfile= $ARGV[2];
if (defined($options{"b"})) {
    $batch   = 1;
}
if (defined($options{"f"})) {
    $frontend = 1;
}
if ($batch && $frontend) {
    usage();
}

if (defined($options{"g"})) {
    $gid = $options{"g"};
}
else {
    $gid = $pid;
}

#
# Untaint the arguments.
#
if ($pid =~ /^([-\@\w]+)$/) {
    $pid = $1;
}
else {
    die("Tainted argument $pid!\n");
}
if ($eid =~ /^([-\@\w]+)$/) {
    $eid = $1;
}
else {
    die("Tainted argument $eid!\n");
}
if ($gid =~ /^([-\@\w]+)$/) {
    $gid = $1;
}
else {
    die("Tainted argument $gid!\n");
}
# Note different taint check (allow /).
if ($nsfile =~ /^([-\w.\/]+)$/) {
    $nsfile = $1;
}
else {
    die("Tainted nsfile name: $nsfile");
}

my $workdir = TBExptWorkDir($pid, $eid);
my $userdir = TBExptUserDir($pid, $eid);
my $repfile = "$eid.report";
my $user_name;
my $user_email;
my $dbuid;

#
# Verify user and get his DB uid.
#
if (! UNIX2DBUID($UID, \$dbuid)) {
    die("*** $0:\n".
	"    Go Away! You do not exist in the Emulab Database.\n");
}

#
# Verify that this person is allowed to start the experiment. 
#
if (! TBProjAccessCheck($dbuid, $pid, $gid, TB_PROJECT_CREATEEXPT)) {
    die("*** $0:\n".
	"    You do not have permission to start experiments in $pid/$gid\n");
}

#
# Get email info for user.
#
if (! UserDBInfo($dbuid, \$user_name, \$user_email)) {
    die("*** $0:\n".
        "    Cannot determine your name and email address.\n");
}

#
# Check to make sure the experiment record exists. The experiment must
# be in the "new" state when using this interface. 
#
$query_result =
    DBQueryFatal("SELECT * FROM experiments WHERE eid='$eid' and pid='$pid'");

if (! $query_result->numrows) {
    die("*** $0:\n".
        "    No experiment record for $pid/$eid exists!\n");
}

my %row		= $query_result->fetchhash();
my $estate	= $row{'state'};
my $expt_path   = $row{'path'};
my $expt_name   = $row{'expt_name'};
my $expt_created= $row{'expt_created'};
my $expt_expires= $row{'expt_expires'};
my $expt_started;

if ($estate ne EXPTSTATE_NEW) {
    die("*** $0:\n".
	"    Experiment $pid/$eid is already configured (or configuring)!\n");
}

if (! chdir($workdir)) {
    die("*** $0:\n".
	"    Could not chdir to $workdir: $!\n");
}

#
# Lock the experiment record with the timestamp so that it cannot
# terminated or swapped. This is basically a wrapper state for the
# variety of actual states.
#
TBLockExp($pid, $eid);

#
# The rest of this goes into the background so that the user sees
# immediate response. We will send email later when the experiment
# is actually torn down.
#
if (! $batch) {
    $logname = TBExptCreateLogFile($pid, $eid, "startexp");
    TBExptSetLogFile($pid, $eid, $logname);
    TBExptOpenLogFile($pid, $eid);
    
    if (TBBackGround($logname)) {
	#
	# Parent exits normally
	#
	print STDOUT
	    "Experiment $pid/$eid is now configuring\n".
	    "You will be notified via email when the experiment is ".
	    "ready to use\n";
	exit(0);
    }
}

#
# Run the various scripts. We want to propogate the error from tbprerun
# and tbrun back out, hence the bogus looking errorstat variable.
#
if (system("$tbdir/tbprerun $pid $eid $nsfile") != 0) {
    $errorstat = $? >> 8;
    fatal("tbprerun failed!\n");
}
# So fatal errors run tbend.
$estate = EXPTSTATE_PRERUN;

if (! $frontend) {
    if (system("$tbdir/tbswapin  $pid $eid") != 0) {
	$errorstat = $? >> 8;
	fatal("tbswapin failed!\n");
    }
    # So fatal errors run tbswapout,
    $estate = EXPTSTATE_ACTIVE;

    #
    # Look for the unsual case of more than 2 nodes and no vlans. Send a
    # warning message.
    #
    if (ExpNodes($pid, $eid) > 2) {
	my $vlans_result =
	    DBQueryFatal("select * from vlans where ".
			 "pid='$pid' and eid='$eid'");
    
	if (!$vlans_result->numrows) {
	    SENDMAIL("$user_name <$user_email>",
		     "WARNING: Experiment Configuration: $pid/$eid",
		     "This experiment has zero network links defined.\n".
		     "Please check your NS file to verify this is what you ".
		     "want!\n",
		     "$user_name <$user_email>",
		     "Cc: $TBOPS", ($nsfile));
	}
    }
}

if (system("$tbdir/tbreport -b $pid $eid 2>&1 > $repfile") != 0) {
    fatal("tbreport failed!\n");
}

#
# Increment the project experiment count/lastdate. This is informational. 
#
DBQueryWarn("update projects ".
	    "set expt_count=expt_count+1, expt_last=now() ".
	    "where pid='$pid'");

#
# Gen up a date for the started field of the record, and insert it.
# Unlock the experiment at the same time.
# 
$expt_started  = DBDateTime();
DBQueryWarn("update experiments set ".
	    "expt_start='$expt_started', expt_locked=NULL ".
	    "WHERE eid='$eid' and pid='$pid'");

#
# In batchmode, send the report to stdout for the batch daemon.
#
if ($batch) {
    system("$tbdir/tbreport -b $pid $eid");
    print STDOUT "\n\n";
}

# Yippie!
print STDOUT "Setup Success\n";

#
# Try to copy off the files for testbed information gathering.
#
TBSaveExpLogFiles($pid, $eid);

#
# Make a copy of the work dir in the user visible space so the user
# can see the log files.
#
system("cp -Rfp $workdir/ $userdir/tbdata");

#
# In batch mode, just exit without sending email. 
#
if ($batch) {
    exit(0);
}

#
# Close up the log file so the webpage stops.
#
TBExptCloseLogFile($pid, $eid);

#
# Dump the report file and the log file to the user via email. 
#
my $message = 
    "Your experiment `$eid' in project `$pid' is now configured.\n" .
    "Here is the experiment summary detailing the nodes that were\n" .
    "allocated to you. You may use the `Qualified Name' to log on\n" .
    "to your nodes. See /etc/hosts on your nodes (when running\n" .
    "FreeBSD, Linux, or NetBSD) for the IP mapping on each node\n" .
    "\n" .
    "User:        $user_name\n" .
    "EID:         $eid\n" .
    "PID:         $pid\n" .
    "GID:         $gid\n" .
    "Name:        $expt_name\n" .
    "Created:     $expt_created\n" .
    "Expires:     $expt_expires\n" .
    "Started:     $expt_started\n" .
    "Directory:   $expt_path\n".
    "\n".
    "Appended at the end is the output of the experiment setup. If you\n" .
    "have any questions or comments, please include the output below\n" .
    "in your message to $TBOPS";
   

SENDMAIL("$user_name <$user_email>",
	 "New Experiment Created: $pid/$eid",
	 $message,
	 "$user_name <$user_email>",
	 "Bcc: $TBLOGS",
	 ($repfile, $logname, $nsfile));

# Done!
exit(0);

sub fatal()
{
    my($mesg)     = $_[0];

    print STDOUT "$mesg\n";
    print STDOUT "Cleaning up and exiting with status $errorstat ...\n";

    #
    # If we got far enough to allocate nodes, must run tbend.
    #
    if ($estate ne EXPTSTATE_NEW) {
	tbendit();
    }

    #
    # In batch mode, exit. Must unlock the experiment since the record
    # is kept by the batch system until it is finished or canceled.
    # The batch daemon might terminate the experiment based on the error.
    #
    if ($batch) {
	TBUnLockExp($pid, $eid);
	exit($errorstat);
    }

    # Clear the logfile so the webpage stops. 
    TBExptClearLogFile($pid, $eid);
    
    #
    # Send a message to the testbed list. 
    #
    SENDMAIL("$user_name <$user_email>",
	     "Experiment Configure Failure: $pid/$eid",
	     $mesg,
	     "$user_name <$user_email>",
	     "Cc: $TBOPS",
	     ($logname, "assign.log", "wanassign.log", $nsfile));

    #
    # Copy off the workdir to the user directory, Then back up both of
    # them for post-mortem debugging.
    #
    system("/bin/cp -Rfp $workdir/ $userdir/tbdata");
    system("/bin/rm -rf  ${workdir}-failed");
    system("/bin/mv -f   $workdir ${workdir}-failed");
    system("/bin/rm -rf  ${userdir}-failed");
    system("/bin/mv -f   $userdir ${userdir}-failed");

    #
    # Clear the record and cleanup.
    # 
    TBExptDestroy($pid, $eid);    
    
    exit($errorstat);
}

#
# If tbprerun finishes, but tbrun fails, lets do a tbend to make sure
# the nodes and vlans are released.
# 
sub tbendit()
{
    if ($estate eq EXPTSTATE_ACTIVE) {
	print "Running tbswapout with arguments: $pid $eid\n";
	if (system("$tbdir/tbswapout $pid $eid") != 0) {
	    print "tbswapout failed!\n";
	}
    }
    print "Running tbend with arguments: -force $pid $eid\n";
    if (system("$tbdir/tbend -force $pid $eid") != 0) {
	print "tbend failed!\n";
    }
}
