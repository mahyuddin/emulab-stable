#!/usr/bin/perl -wT
use English;
use Fcntl ':flock';

#
# Create an /etc/exports.tail file based on current reserved table and project
# members. Fire that tail over to the fileserver where it is concatenated with
# the head file to become the new /etc/exports
#
# This script always does the right thing, so it does not matter who calls it. 
#
# usage: exports_setup
#

#
# Configure variables
#
my $TB		= "@prefix@";
my $TBOPS       = "@TBOPSEMAIL@";
my $TESTMODE    = @TESTMODE@;
my $FSNODE      = "@FSNODE@";

# Note no -n option. We redirect stdin from the new exports file below.
my $SSH		= "$TB/bin/sshtb -l root $FSNODE";
my $PROG	= "/usr/testbed/sbin/exports_setup.proxy";
my $exportstail = "/var/tmp/exports.tail";
my $lockfile    = "/var/tmp/testbed_exports_lockfile";
my $projdir     = "/q/proj";
my $usersdir    = "/users";
my $groupdir    = "/q/groups";
my $dbg		= 1;
my @row; 

#
# We don't want to run this script unless its the real version.
#
if ($EUID != 0) {
    die("*** $0:\n".
	"    Must be root! Maybe its a development version?\n");
}
# XXX Hacky!
if ($TB ne "/usr/testbed") {
    print STDERR "*** $0:\n".
	         "    Wrong version. Maybe its a development version?\n";
    #
    # Let experiment continue setting up.
    # 
    exit(0);
}

# un-taint path
$ENV{'PATH'} = '/bin:/usr/bin:/usr/sbin:/usr/local/bin';
delete @ENV{'IFS', 'CDPATH', 'ENV', 'BASH_ENV'};

#
# Turn off line buffering on output
#
$| = 1;

#
# Testbed Support libraries
# 
use lib "@prefix@/lib";
use libdb;
use libtestbed;

#
# We need to serialize this script to avoid a trashed map file. Use
# a dummy file in /var/tmp, opened for writing and flock'ed. 
#
if (!$TESTMODE) {
  open(LOCK, ">>$lockfile") || fatal("Couldn't open $lockfile\n");
  $count = 0;
  while (flock(LOCK, LOCK_EX|LOCK_NB) == 0) {
    print "Another /etc/exports update in progress. Waiting a moment ...\n";
    if ($count++ > 20) {
      fatal("Could not get the lock after a long time!\n");
    }
    sleep(1);
  }
}

#
# We stick the new map entries into the tail file. First zero it out.
#
if (!$TESTMODE) {
  open(MAP, ">$exportstail") || fatal("Couldn't open $exportstail\n");
} else {
  open(MAP, ">/dev/null") || fatal("Couldn't open /dev/null\n");
}
print MAP "\n";
print MAP "#\n";
print MAP "# DO NOT EDIT below this point. Auto generated entries!\n";
print MAP "#\n";
print MAP "\n";

#
# We export to particular nodes, based on the experiment that is allocated
# to the node. Since we want the exports file to be based on IP numbers,
# we need this crazy join to find out the type of the node, so we can find
# the control network card number, so we can find the IP address for that
# card.
#
# XXX - Because of mountd sillyness, group experiments cannot be exported
#       here since the groups directory is in the same FS as the proj.
#       This bothers mountd, since the same IP would be listed more than once
#       on the right hand side. So, this first join eliminates nodes that
#       part of group experiments (pid!=gid).
#
$db_result =
    DBQueryFatal("select reserved.node_id,reserved.pid,interfaces.IP,a.pid ".
		 "from reserved ".
		 "left join exppid_access as a ".
		 " on a.exp_pid=reserved.pid and a.exp_eid=reserved.eid ".
		 "left join experiments as e on ".
		 " reserved.pid=e.pid and reserved.eid=e.eid ".
		 "left join nodes on reserved.node_id=nodes.node_id ".
		 "left join node_types on node_types.type=nodes.type ".
		 "left join interfaces on reserved.node_id=interfaces.node_id".
		 " and interfaces.card=node_types.control_net ".
		 "where interfaces.IP!='NULL' and e.gid=e.pid ".
		 "order by reserved.pid,interfaces.IP");

#
# Go through and build up a list of exported mounts for each IP. 
#
my %iphash = ();
my @iplist = ();

while (@row = $db_result->fetchrow_array) {
    my $node_id = $row[0];
    my $pid     = $row[1];
    my $ip      = $row[2];
    my $subpid  = $row[3];

    if (! defined($iphash{$ip})) {
	$iphash{$ip} = [ $pid ];
	push(@iplist, $ip);

	if (defined($subpid)) {
	    push(@{ $iphash{$ip} }, $subpid);
	}
    }
    else {
	if (defined($subpid)) {
	    push(@{ $iphash{$ip} }, $subpid);
	}
    }
}

print MAP "#\n";
print MAP "# Export Project directories\n";
print MAP "#\n";

#
# This takes the iphash array and spits out the mount lists using the
# function provided.
#
if (@iplist) {
    spitmounts(sub { my $pid = shift; print MAP "$projdir/$pid " });
}

#
# Next determine what group directories need to be exported. This is done
# only for experiments in which pid!=gid.
#
# XXX - See XXX above. The printer function below has to include the proj
#       directory.
#
$db_result =
    DBQueryFatal("select reserved.node_id,reserved.pid,interfaces.IP,e.gid ".
		 "from reserved ".
		 "left join experiments as e on ".
		 " reserved.pid=e.pid and reserved.eid=e.eid ".
		 "left join nodes on reserved.node_id=nodes.node_id ".
		 "left join node_types on node_types.type=nodes.type ".
		 "left join interfaces on reserved.node_id=interfaces.node_id".
		 " and interfaces.card=node_types.control_net ".
		 "where interfaces.IP!='NULL' and e.pid!=e.gid ".
		 "order by reserved.pid,e.gid,interfaces.IP");

#
# Go through and build up a list of exported mounts for each IP. 
#
%iphash = ();
@iplist = ();

while (@row = $db_result->fetchrow_array) {
    my $node_id = $row[0];
    my $pid     = $row[1];
    my $ip      = $row[2];
    my $gid     = $row[3];

    if (! defined($iphash{$ip})) {
	$iphash{$ip} = [ "$pid/$gid" ];
	push(@iplist, $ip);
    }
    else {
	push(@{ $iphash{$ip} }, "$pid/$gid");
    }
}

print MAP "#\n";
print MAP "# Export Group directories\n";
print MAP "#\n";

#
# This takes the iphash array and spits out the mount lists using function
# provided. Note that the function also prints include the proj dir. See
# the XXX comments above. 
#
if (@iplist) {
    my $printer = sub {
	my($pid, $gid) = split('/', $_[0]);

	print MAP "$projdir/$pid $groupdir/$pid/$gid ";
    };
    spitmounts($printer);
}

#
# Now we need the users list for exporting from /users. We need to export
# all of the project members to all of the machines in that projects
# experiments. Also, since we again want the IPs, we need all of that crazy
# join again. Even worse, we cannot list an IP address more than once, so
# we end up with mulitple exports for any particular user (cause they can be
# in multiple experiments within a project), but with non overlapping
# sets of IP addresses. For example:
#
#	/users/stoller /users/mike 101.101.101.100 101.101.101.101
#	/users/stoller             101.101.101.102
#       /users/mike                101.101.101.103
#
$db_result =
   DBQueryFatal("select distinct reserved.node_id,reserved.pid,".
		"g.uid,interfaces.IP from reserved ".
		"left join exppid_access as a ".
		" on a.exp_pid=reserved.pid and a.exp_eid=reserved.eid ".
		"left join group_membership as g on g.pid=a.pid or ".
		"          (g.pid=reserved.pid and g.gid=g.pid) ".
		"left join nodes on reserved.node_id=nodes.node_id ".
		"left join node_types on node_types.type=nodes.type ".
		"left join interfaces on reserved.node_id=interfaces.node_id ".
		"and interfaces.card=node_types.control_net ".
		"where interfaces.IP!='NULL' and g.trust!='none' ".
		"order by reserved.pid,reserved.node_id");

%iphash = ();
@iplist = ();

while (@row = $db_result->fetchrow_array) {
    my $node_id = $row[0];
    my $pid     = $row[1];
    my $uid     = $row[2];
    my $ip      = $row[3];

    if (! defined($iphash{$ip})) {
	$iphash{$ip} = [ $uid ];
	push(@iplist, $ip);
    }
    else {
	push(@{ $iphash{$ip} }, $uid);
    }
}

print MAP "#\n";
print MAP "# Export User directories\n";
print MAP "#\n";

#
# This takes the iphash array and spits out the mount lists using the
# function provided.
#
if (@iplist) {
    spitmounts(sub { my $uid = shift; print MAP "$usersdir/$uid " });
}

print MAP "\n";
close(MAP);

#
# Fire the new tail file over to the fileserver to finish. We cat the file
# right into it.
#
if (!$TESTMODE) {
  $UID = 0;
  #
  # Temp Hack! Save a copy of the exports file for debugging.
  #
  my $backup = "$TB/log/exports/" . TBDateTimeFSSafe();
  system("cp $exportstail $backup");
  
  system("$SSH $PROG < $exportstail") == 0 or
    fatal("Failed: $SSH $PROG < $exportstail: $?");
  unlink("$exportstail");

  #
  # Close the lock file. Exiting releases it, but might as well.
  #
  close(LOCK);
}

exit(0);

sub fatal {
    local($msg) = $_[0];

    SENDMAIL($TBOPS, "TESTBED: Exports Setup Failed", $msg);
    die($msg);
}

#
# Spit out a set of mounts. The argument is the printer function to
# format the mount line. 
# 
sub spitmounts($)
{
    my $printer = shift;
    
    #
    # Sort each of the lists (per IP). 
    # 
    foreach my $ip ( @iplist ) {
	my @lis = @{ $iphash{$ip} };

	$iphash{$ip} = [ sort( @lis ) ];
    }

    #
    # Next go through and combine sequential IPs that have exactly the
    # same set of exports. Not perfect, but should result in a big
    # enough reduction for now. At some point we should have our own
    # exportfs program do this stuff instead of going through mountd.
    #
    # Shift off the first IP to initialize the sequence.
    #
    my @ipseq   = ( shift(@iplist) );
    my @lastset = @{ $iphash{$ipseq[0]} };

    foreach my $ip ( @iplist ) {
	my @set = @{ $iphash{$ip} };

	#
	# Whenever the set changes, spit out what we have saved up, and then
	# start over. 
	# 
	if (! listequal(\@set, \@lastset)) {
	    foreach my $el ( @lastset ) {
		&$printer($el);
	    }
	    print MAP "-maproot=root @ipseq\n";
	    @ipseq = ();
	}
	push(@ipseq, $ip);
	@lastset = @set;
    }

    #
    # Last set of IPs.
    #
    if (@ipseq) {
	foreach my $el ( @lastset ) {
	    &$printer($el);
	}
	print MAP "-maproot=root @ipseq\n";
    }
}

#
# Compare two lists of tokens.
# 
sub listequal ($$)
{
    my($lista, $listb) = @_;

    if (@$lista != @$listb) {
	return 0;
    }
    for ($i = 0; $i < @$lista; $i++) {
	if ($$lista[$i] ne $$listb[$i]) {
	    return 0;
	}
    }
    return 1;
}



