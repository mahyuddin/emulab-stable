#!/usr/bin/perl -wT
use English;
use Fcntl ':flock';

#
# Create an /etc/exports.tail file based on current reserved table and project
# members. Fire that tail over to the fileserver where it is concatenated with
# the head file to become the new /etc/exports
#
# This script always does the right thing, so it does not matter who calls it. 
#
# usage: exports_setup
#

#
# Configure variables
#
my $TB		= "@prefix@";
my $TBOPS       = "@TBOPSEMAIL@";
my $TESTMODE    = @TESTMODE@;
my $FSNODE      = "@FSNODE@";

# Note no -n option. We redirect stdin from the new exports file below.
my $SSH		= "$TB/bin/sshtb -l root $FSNODE";
my $PROG	= "/usr/testbed/sbin/exports_setup.proxy";
my $exportstail = "/var/tmp/exports.tail";
my $lockfile    = "/var/tmp/testbed_exports_lockfile";
my $projdir     = "/q/proj";
my $usersdir    = "/users";
my $groupdir    = "/q/groups";
my $dbg		= 1;
my @row; 

#
# We don't want to run this script unless its the real version.
#
if ($EUID != 0) {
    die("*** $0:\n".
	"    Must be root! Maybe its a development version?\n");
}
# XXX Hacky!
if (0 && $TB ne "/usr/testbed") {
    print STDERR "*** $0:\n".
	         "    Wrong version. Maybe its a development version?\n";
    #
    # Let experiment continue setting up.
    # 
    exit(0);
}

# un-taint path
$ENV{'PATH'} = '/bin:/usr/bin:/usr/sbin:/usr/local/bin';
delete @ENV{'IFS', 'CDPATH', 'ENV', 'BASH_ENV'};

#
# Turn off line buffering on output
#
$| = 1;

#
# Testbed Support libraries
# 
use lib "@prefix@/lib";
use libdb;
use libtestbed;

#
# We need to serialize this script to avoid a trashed map file. Use
# a dummy file in /var/tmp, opened for writing and flock'ed. 
#
if (!$TESTMODE) {
  open(LOCK, ">>$lockfile") || fatal("Couldn't open $lockfile\n");
  $count = 0;
  while (flock(LOCK, LOCK_EX|LOCK_NB) == 0) {
    print "Another /etc/exports update in progress. Waiting a moment ...\n";
    if ($count++ > 20) {
      fatal("Could not get the lock after a long time!\n");
    }
    sleep(1);
  }
}

#
# We stick the new map entries into the tail file. First zero it out.
#
if (!$TESTMODE) {
  open(MAP, ">$exportstail") || fatal("Couldn't open $exportstail\n");
} else {
  open(MAP, ">/dev/null") || fatal("Couldn't open /dev/null\n");
}
print MAP "\n";
print MAP "#\n";
print MAP "# DO NOT EDIT below this point. Auto generated entries!\n";
print MAP "#\n";
print MAP "\n";

#
# First gather up all the nodes that are reserved and the required info.
#
$nodes_result =
    DBQueryFatal("select r.node_id,r.pid,r.eid,e.gid,i.IP from reserved as r ".
		 "left join experiments as e on r.pid=e.pid and r.eid=e.eid ".
		 "left join nodes on r.node_id=nodes.node_id ".
		 "left join node_types on node_types.type=nodes.type ".
		 "left join interfaces as i on r.node_id=i.node_id ".
		 " and i.card=node_types.control_net ".
		 " where i.IP!='NULL' and r.node_id not like 'sh%' ".
		 "order by i.IP");

my %ipgroups	= ();

while (@row = $nodes_result->fetchrow_array) {
    my $node_id = $row[0];
    my $pid     = $row[1];
    my $eid     = $row[2];
    my $gid     = $row[3];
    my $ip      = $row[4];
    my @dirlist = ();

    push(@dirlist, "$projdir/$pid");
    if ($gid ne $pid) {
	push(@dirlist, "$groupdir/$pid/$gid");
    }

    #
    # Need the user list. 
    #
    $users_result =
	DBQueryFatal("select distinct uid from group_membership ".
		     "where pid='$pid' and gid='$gid' and trust!='none'");

    while (@usersrow = $users_result->fetchrow_array) {
	my $uid = $usersrow[0];

	push(@dirlist, "$usersdir/$uid");
    }

    #
    # Convert dirlist to a string and use that as a hash index to group
    # IPs together with the same set of mounts.
    #
    my $str = join(" ", sort(@dirlist));

    if (! defined($ipgroups{$str})) {
	$ipgroups{$str} = [ $ip ];
    }
    else {
	push(@{ $ipgroups{$str} }, $ip);
    }
}

#
# Now spit out each group!
#
foreach my $str ( keys(%ipgroups) ) {
    my @iplist = @{ $ipgroups{$str} };    

    print MAP "$str -maproot=root @iplist\n";
}

print MAP "\n";
close(MAP);

#
# Fire the new tail file over to the fileserver to finish. We cat the file
# right into it.
#
if (!$TESTMODE) {
  $UID = 0;
  #
  # Temp Hack! Save a copy of the exports file for debugging.
  #
  my $backup = "$TB/log/exports/" . TBDateTimeFSSafe();
  system("cp $exportstail $backup");
  
  system("$SSH $PROG < $exportstail") == 0 or
    fatal("Failed: $SSH $PROG < $exportstail: $?");
  unlink("$exportstail");

  #
  # Close the lock file. Exiting releases it, but might as well.
  #
  close(LOCK);
}

exit(0);

sub fatal {
    local($msg) = $_[0];

    SENDMAIL($TBOPS, "TESTBED: Exports Setup Failed", $msg);
    die($msg);
}

