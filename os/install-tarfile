#!/usr/bin/perl -wT

#
# EMULAB-COPYRIGHT
# Copyright (c) 2000-2003 University of Utah and the Flux Group.
# All rights reserved.
#

use English;
use Getopt::Std;
use POSIX 'setsid';

#
# Install a tarfile. This script is run from the setup code on client nodes.
#
# Exit Value Matters!: 0 if installed okay
#                      1 if already installed
#                     -1 if something goes wrong.
#
# To ensure safety, the tar filename must start with /proj, except if
# running with jail option. Must be run as root.
#
sub usage()
{
    print STDOUT "Usage: install-tarfile [-j] <installdir> <filename>\n";
    exit(-1);
}
my $optlist  = "j";

#
# Turn off line buffering on output
#
$| = 1;

#
# Untaint the path
# 
$ENV{'PATH'} = "/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/etc/emulab";
delete @ENV{'IFS', 'CDPATH', 'ENV', 'BASH_ENV'};

#
# No configure vars.
#
my $IDENTFILE      = "/var/db/testbed.tarfiles";
my $tarfile        = "";
my $decompressflag = "";
my $installdir     = "/";
my $jailmode	   = 0;
my $jailfile       = "";

#
# Must be running as root to work. 
#
if ($EUID != 0) {
    die("Must be run as root! Try using sudo or su1!\n");
}

#
# Parse command arguments. Once we return from getopts, all that should be
# left are the required arguments.
#
%options = ();
if (! getopts($optlist, \%options)) {
    usage();
}
if (defined($options{"j"})) {
    $jailmode = 1;
}
if (@ARGV != 2) {
    usage();
}
$installdir = $ARGV[0];
$tarfile    = $ARGV[1];

#
# Untaint the arguments.
#
# Note different taint check (allow /).
if ($tarfile =~ /^([-\w.\/]+)$/) {
    $tarfile = $1;
}
else {
    fatal("Tainted filename: $tarfile");
}
if ($installdir =~ /^([-\w.\/]+)$/) {
    $installdir = $1;
}
else {
    fatal("Tainted directory name: $installdir");
}

#
# Make sure the installdir exists!
#
if (! -d $installdir) {
    fatal("$installdir does not exist or is not accessible!");
}

#
# Check to make sure this tarfile has not already been installed. Update
# the file now. If the tar fails, we got big problems.
#
if (-e $IDENTFILE) {
    if (! `egrep -q -s '^${tarfile}' $IDENTFILE`) {
	print STDOUT "Tarfile $tarfile has already been installed!\n";
	exit(1);
    }
}

#
# Must be able to see the tarfile if not in jail mode. The front end
# ensures that its in a reasonable place, but have to make sure here.
#
if (! $jailmode) {
    #
    # Make sure its really there.
    #
    if (! -r $tarfile) {
	fatal("$tarfile does not exist or is not accessible!");
    }
}
else {
    $jailfile = `mktemp /var/tmp/tarball.XXXXXX`;

    if ($jailfile =~ /^([-\@\w\.\/]+)$/) {
	$jailfile = $1;
    }
    else {
	die("Bad data in jailfile name: $jailfile");
    }
    GetTarFile($tarfile, $jailfile);
    #
    # Dies on any failure!
    #
}

#
# Add to index first; if fails too bad.
# 
system("echo \"$tarfile\" >> $IDENTFILE") == 0 or
    fatal("Could not update $IDENTFILE");

#
# Figure what decompression flag is required, based on file extension.
#
SWITCH: for ($tarfile) {
    /^.*\.tar\.Z$/   && do {$decompressflag = "-Z"; last SWITCH; } ;
    /^.*\.tar\.gz$/  && do {$decompressflag = "-z"; last SWITCH; } ;
    /^.*\.tar\.tgz$/ && do {$decompressflag = "-y"; last SWITCH; } ;
    /^.*\.tar$/      && do {last SWITCH; } ;
}

#
# Install tar file from root?
# 
if (! chdir($installdir)) {
    fatal("Could not chdir to $installdir: $!\n");
}

#
# Run the tarfile. 
#
if ($jailmode) {
    $tarfile = $jailfile;
}
system("tar $decompressflag -xf $tarfile");
$exit_status = $? >> 8;

exit($exit_status);

sub fatal {
    local($msg) = $_[0];

    print STDERR "$msg\n";
    exit(-1);
}

#
# Get a tarfile from the server via tmcc and stash.
#
sub GetTarFile($$)
{
    my ($tarfile, $jailfile) = @_;
    my $buf;

    #
    # Protocol is a little odd. First word is the number of bytes
    # (yes, limited to 31 bits of length!), then the data. If we do
    # not get that much data, we fail. What about timeout option?
    # Could take a while to get the entire file, but instead of a
    # timeout let Emulab decide when its too long.
    #
    open(TMCC, "tmcc -t 300 tarball $tarfile |")
	or fatal("Could not download tarfile from server!");

    # Hokey C struct stuff
    my $firstword = pack("i", 0);
    
    if (! sysread(TMCC, $firstword, length($firstword))) {
	fatal("Could not read length of tarfile from server!");
    }
    my $bytelen = unpack("i", $firstword);
    if ($bytelen == 0) {
	fatal("Zero length of tarfile from server!");
    }

    #
    # Open the target file and start dumping the data in.
    #
    open(JFILE, "> $jailfile")
	or fatal("Could not open local file $jailfile: $!");

    while ($bytelen) {
	my $rlen = sysread(TMCC, $buf, 8192);

	if (! defined($rlen)) {
	    fatal("Error reading tarball $tarfile: $!");
	}
        if ($rlen == 0) {
	    last;
	}
	if (! syswrite(JFILE, $buf)) {
	    fatal("Error writing tarfile $jailfile: $!");
	}
	$bytelen -= $rlen;
    }
    if ($bytelen) {
	fatal("Did not get the entire tarball! $bytelen bytes left.");
    }
    close(JFILE);
    close(TMCC);
    return 0;
}
