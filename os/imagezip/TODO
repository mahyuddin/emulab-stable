Things to do for image*:

1. Checksum chunks or the entire image file?
   Maybe just as a debug option to check for bugs in the zipper itself.
   In general use, we will be using TCP as the transport for image files
   or we will be using frisbee and the UDP checksum in conjunction with
   frisbee itself tracking blocks should be sufficient.  Anyway, doing
   an entire image checksum would be complicated by frisbee's out of order
   receipt of chunks.

2. Imagezip could be multithread so that we can be reading ahead on the
   input device and overlapping IO with compression.  Maybe a third thread
   for doing output.  Input is a little tricky since imagezip shortens up
   its reads as it gets near the end of a chunk, so the buffer mechanism
   will have to handle having blocks only partially consumed.

3. In imagezip, split out the FS-specific code into subdirectories.
   [DONE]

4. Write an imageconvert so that we can convert old version images into
   new ones and maybe change the compression level used in an image.

5. Imageunzip could be triple-threaded like frisbee, i.e., split the
   file reading and decompression that are currently one in imageunzip.

6. Create a "signature" file for an image using a collision-resistant hash
   like MD5 or SHA-1.  See TODO.hash for more.

7. Add an option to exclude (skip) disk blocks outside of any DOS partition.
   By default, we want to include these blocks in the image since some
   systems stash magic info this way IBM laptops for instance).  But in
   some cases we want to ignore it.  Since the MBR often falls in the
   outside-of-any-partition catagory (e.g., DOS partition 1 starting at
   sector 63, aka cylinder 1), we may need to further break this down into
   "before first part", "between parts", "after last part".  Also need an
   option to exclude space outside a filesystem but inside a DOS partition
   (e.g., when creating a small filesystem in a large partition).  This is
   highly dependent on the filesystem type, but presumably we can easily
   detect space beyond the end of the FS.  "Before the start" probably
   doesn't make sense for most filesystems.  Hmm...for FFS we can detect
   space outside a BSD partition in addition to space beyond the end of
   a filesystem but inside the BSD partition.  Yuk!  Maybe we keep it
   simple and have a single option and just treat things like the MBR
   special.

8. Encrypted images.
   This would give us confidentiality.  Images would be chunk-by-chunk
   encrypted/decrypted using a runtime specified session key.  I assume
   we want to use symmetric crypto here, since it is faster.  Note that
   we would need to combine this with some other mechanism if we also want
   to ensure integrity.

   Imagezip would take as an argument a key (or a file from which to read
   the key?) and in the code where it compresses, it can also encrypt
   (encrypt before compression? after?)  The resulting image is one in
   which the chunk meta-data (header info: disk ranges contained, any
   relocations) is not encrypted.  Is this a problem?  The block ranges
   and relocations could give some hint as to what the image contains
   (e.g., if block 16 is not in the list, it isn't a BSD filesystem since
   that is where the superblock is).  What the hell, we can independently
   encrypt the header as well.

   Imageunzip (and frisbee) will likewise take a new argument for the key
   to be used.  For frisbee this will be transferred "out-of-band" with
   TMCD.  While decryption could take place in a separate thread, I'm
   inclined not to worry about it right now given that we are mostly working
   with uniprocessor machines where there would be no advantage.  Anyway,
   imageunzip would collect a chunk, decompress and unencrypt it, and feed
   it to the disk writer.

   For integrity, we could use the signature-communicated-out-of-band
   approach (#6 above), or we could include a single, coarser-grained
   hash/checksum for each chunk.

