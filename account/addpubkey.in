#!/usr/bin/perl -wT
#
# EMULAB-COPYRIGHT
# Copyright (c) 2000-2003 University of Utah and the Flux Group.
# All rights reserved.
#
use English;
use Getopt::Std;

#
# Parse ssh public keys and enter into the DB. The default format is
# openssh, but if the key is not in that format, then use ssh-keygen
# to see if it can be converted from either SSH2 or SECSH format into
# openssh format. This gets called from the webpage to parse keys
# uploaded by users.
#
sub usage()
{
    print "Usage: addpubkeys [-n] [-k] <user> [<keyfile> | <key>]\n";
    print "       addpubkeys [-i | -w] <user>\n";
    print "Options:\n";
    print " -k      Indicates that key was passed in on the command line\n";
    print " -n      Verify key format only; do not enter into into DB\n";
    print " -w      Generate new authkeys (protocol 1 and 2) file for user\n";
    print " -i      Initialize mode; generate initial key for user\n";
    exit(-1);
}
my $optlist   = "kniw";
my $iskey     = 0;
my $verify    = 0;
my $initmode  = 0;
my $genmode   = 0;
my $nobody    = 0;
my $noemail   = 0;

#
# Configure variables
#
my $TB		= "@prefix@";
my $TBOPS       = "@TBOPSEMAIL@";
my $TBAUDIT     = "@TBAUDITEMAIL@";
my $HOMEDIR	= "/users";
my $KEYGEN	= "/usr/bin/ssh-keygen";
my $USERUID;

# Locals
my $user;
my $keyfile;
my $keyline;
my $key;
my $comment;
my $user_name;
my $user_email;

#
# Testbed Support libraries
#
use lib "@prefix@/lib";
use libaudit;
use libdb;
use libtestbed;

#
# Turn off line buffering on output
#
$| = 1;

#
# Untaint the path
# 
$ENV{'PATH'} = "/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin";
delete @ENV{'IFS', 'CDPATH', 'ENV', 'BASH_ENV'};

#
# We don't want to run this script unless its the real version.
#
if ($EUID != 0) {
    die("*** $0:\n".
	"    Must be setuid! Maybe its a development version?\n");
}

#
# Please do not run it as root. Hard to track what has happened.
# 
if ($UID == 0) {
    die("*** $0:\n".
	"    Please do not run this as root!\n");
}

#
# Parse command arguments. Once we return from getopts, all that should be
# left are the required arguments.
#
%options = ();
if (! getopts($optlist, \%options)) {
    usage();
}
if (defined($options{"k"})) {
    $iskey = 1;
}
if (defined($options{"n"})) {
    $verify = 1;
}
if (defined($options{"i"})) {
    $initmode = 1;
}
if (defined($options{"w"})) {
    $genmode = 1;
}
if ($verify && $genmode) {
    usage();
}
if ($initmode || $genmode) {
    if (@ARGV != 1) {
	usage();
    }
}
elsif (@ARGV == 2) {
    $keyfile = $ARGV[1];
}
else {
    usage();
}    
$user = $ARGV[0];

#
# Untaint the arguments.
#
if ($user =~ /^([a-z0-9]+)$/i) {
    $user = $1;
}
else {
    fatal("Tainted username: $user");
}

#
# If invoked as "nobody" its for a user with no actual account.
# 
if (getpwuid($UID) eq "nobody") {
    if ($initmode || $genmode) {
	fatal("Bad usage as 'nobody'");
    }
    $nobody = 1;
}
else {
    $USERUID = getpwnam($user);
}

#
# Initmode or genmode, do it and exit.
#
if ($initmode) {
    # Drop root privs, switch to target user.
    $EUID = $USERUID;
    exit InitUser();
}
if ($genmode) {
    # Drop root privs, switch to target user.
    $EUID = $USERUID;
    exit GenerateKeyFiles();
}

# Else, key parse mode ...
if ($iskey) {
    if ($keyfile =~ /^([-\w\s\.\@\+\/\=]*)$/) {
	$keyfile = $1;
    }
    else {
	fatal("Tainted key: $keyfile");
    }
    $keyline = $keyfile;
}
else {
    if ($keyfile =~ /^([-\w\.\/]+)$/) {
	$keyfile = $1;
     }
    else {
	fatal("Tainted filename: $keyfile");
    }
    if (! -e $keyfile) {
	fatal("No such file: $keyfile\n");
    }
    $keyline = `head -1 $keyfile`;
}

#
# Check user
#
if (!$verify) {
    # If its the user himself, then we can generate a new authkeys file. 
    if (!$nobody && getpwuid($UID) ne "$user" && !TBAdmin($UID)) {
	fatal("You are not allowed to set pubkeys for $user.\n");
    }
    if (-d "$HOMEDIR/$user/.ssh") {    
	$genmode = 1;
    }

    #
    # This script is audited when not in verify mode. Since all keys are first
    # checked with verify mode, this should not cause any extra email from bad
    # keys.
    #
    AuditStart(0);

    if (! UserDBInfo($user, \$user_name, \$user_email)) {
	if ($nobody) {
	    $noemail = 1;
	}
	else {
	    fatal("No DB info for $user!");
	}
    }
}

# Drop root privs, switching to user.
if (!$nobody) {
    $EUID = $USERUID;
}

#
# Grab the first line of the file. Parse it to see if its in the
# format we like (openssh), either protocol 1 or 2.
#
if (ParseKey($keyline)) {
    exit 0;
}
# If the key was entered on the command line, then nothing more to do.
if ($iskey) {
    exit 1;
}

#
# Run ssh-keygen over it and see if it can convert it. 
#
if (! open(KEYGEN, "ssh-keygen -i -f $keyfile 2>/dev/null |")) {
    fatal("*** $0:\n".
	  "    Could not start ssh-keygen\n");
}
$keyline = <KEYGEN>;
if (close(KEYGEN) && ParseKey($keyline)) {
    exit 0;
}
exit 1;

sub ParseKey($) {
    my ($keyline) = @_;
    
    if ($keyline =~ /^(\d*\s\d*\s[0-9a-zA-Z]*) ([-\w\@\.]*)$/) {
        # Protocol 1
	$type    = "ssh-rsa1";
	$key     = $1;
	$comment = $2;
    }
    elsif ($keyline =~ /^(\d*\s\d*\s[0-9a-zA-Z]*)\s*$/) {
        # Protocol 1 but no comment field.
	$type    = "ssh-rsa1";
	$key     = $1;
    }
    elsif ($keyline =~
	   /^(ssh-rsa|ssh-dss) ([-\w\.\@\+\/\=]*) ([-\w\@\.]*)$/) {
        # Protocol 2
	$type    = $1;
	$key     = "$1 $2";
	$comment = $3;
    }
    elsif ($keyline =~ /^(ssh-rsa|ssh-dss) ([-\w\.\@\+\/\=]*)$/) {
        # Protocol 2 but no comment field
	$type    = $1;
	$key     = "$1 $2";
    }

    if (!defined($key)) {
	return 0;
    }
    # Do not enter into DB if in verify mode.
    if ($verify) {
	print "Key was good: $type\n";
	return 1;
    }

    #
    # Make up a comment field for the DB. 
    #
    if (!defined($comment)) {
	$comment = "$type-${user_email}";
    }
    $key = "$key $comment";

    DBQueryFatal("replace into user_pubkeys ".
		 "values ('$user', 0, '$key', now(), '$comment')");

    #
    # Mark user record as modified so nodes are updated.
    #
    TBNodeUpdateAccountsByUID($user);

    my $chunked = "";

    while (length($key)) {
	$chunked .= substr($key, 0, 65, "");
	if (length($key)) {
	    $chunked .= "\n";
	}
    }
    print "SSH Public Key for '$user' added:\n";
    print "$chunked\n";
    
    # Generate new auth keys file. 
    if ($genmode) {
	GenerateKeyFiles();
    }

    if (! $noemail) {
	SENDMAIL("$user_name <$user_email>",
		 "SSH Public Key for '$user' Added",
		 "SSH Public Key for '$user' added:\n".
		 "\n".
		 "$chunked\n",
		 "$TBOPS");
    }
    return 1;
}

#
# Init function for new users. Generate the first key for the user (which
# is loaded into the DB), and then generate the keyfiles. Note that the
# user might have preloaded personal keys.
#
sub InitUser()
{
    my $sshdir  = "$HOMEDIR/$user/.ssh";

    #
    # Set up the ssh key, but only if not done so already.
    #
    if (! -e "$sshdir") {
	mkdir("$sshdir", 0700) or
	    fatal("Could not mkdir $sshdir: $!");
    }
    if (! -f "$sshdir/identity") {
	print "Setting up ssh configuration for $user.\n";
    
	if (system("$KEYGEN -t rsa1 -P '' -f $sshdir/identity")) {
	    fatal("Failure in ssh-keygen!");
	}

	#
	# Grab a copy for the DB.
	# 
	my $ident = `cat $sshdir/identity.pub`;

	if ($ident =~ /(\d*\s\d*\s[0-9a-zA-Z]*)\s([\w\@\.]*)/) {
	    DBQueryFatal("replace into user_pubkeys ".
			 "values ('$user', '$2', '$1 $2', now())");

	    #
	    # Backwards compat. Remove later.
	    #
	    DBQueryFatal("update users set emulab_pubkey='$1 $2' ".
			 "where uid='$user'");
	}
	else {
	    fatal("Bad emulab public key: $ident\n");
	}
    }
    return GenerateKeyFiles();
}

#
# Generate the ssh key files for the user. The keys come from the DB, and
# are split into protocol 1 and protocol 2 keys. Then use the aux function
# to generate each file. 
#
sub GenerateKeyFiles()
{
    my @p1keys = ();
    my @p2keys = ();
    
    my $query_result =
	DBQueryFatal("select * from user_pubkeys where uid='$user'");


    while (my %row = $query_result->fetchhash()) {
	my $key = $row{'pubkey'};

	if ($key =~ /^\d+\s+.*$/) {
	    push(@p1keys, $key);
	}
	else {
	    push(@p2keys, $key);
	}
    }
    GenerateKeyFile(1, @p1keys);
    GenerateKeyFile(2, @p2keys);
    return 0;
}

#
# Generate ssh authorized_keys files. Either protocol 1 or 2.
# Returns 0 on success, -1 on failure.
#
#
sub GenerateKeyFile($$)
{
    my ($protocol, @pkeys) = @_;
    my $sshdir  = "$HOMEDIR/$user/.ssh";
    my $keyfile = "$sshdir/authorized_keys";
	
    if (! -e $sshdir) {
	if (! mkdir($sshdir, 0700)) {
	    warn("*** WARNING: Could not mkdir $sshdir: $!\n");
	    return -1;
	}
    }
    if ($protocol == 2) {
	$keyfile .= "2";
    }
    print "Generating $keyfile ...\n";

    if (!open(AUTHKEYS, "> ${keyfile}.new")) {
	warn("*** WARNING: Could not open ${keyfile}.new: $!\n");
	return -1;
    }
    print AUTHKEYS "#\n";
    print AUTHKEYS "# DO NOT EDIT! This file auto generated by ".
	"Emulab.Net account software.\n";
    print AUTHKEYS "#\n";
    print AUTHKEYS "# Please use the web interface to edit your ".
	"public key list.\n";
    print AUTHKEYS "#\n";
    
    foreach my $key (@pkeys) {
	print AUTHKEYS "$key\n";
    }
    close(AUTHKEYS);

    if (!chmod(0600, "${keyfile}.new")) {
	warn("*** WARNING: Could not chmod ${keyfile}.new: $!\n");
	return -1;
    }
    if (-e "${keyfile}") {
	if (system("cp -p -f ${keyfile} ${keyfile}.old")) {
	    warn("*** Could not save off ${keyfile}: $!\n");
	    return -1;
	}
	if (!chmod(0600, "${keyfile}.old")) {
	    warn("*** Could not chmod ${keyfile}.old: $!\n");
	}
    }
    if (system("mv -f ${keyfile}.new ${keyfile}")) {
	warn("*** Could not mv ${keyfile} to ${keyfile}.new: $!\n");
    }
    return 0;
}

sub fatal($) {
    my($mesg) = $_[0];

    die("*** $0:\n".
	"    $mesg\n");
}
