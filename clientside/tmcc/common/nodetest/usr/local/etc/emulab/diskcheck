#! /bin/bash

echo -n ' Starting diskcheck..'

# find the number of disks
# find the size of each disk

# first arg is the log output file, if not set then /tmp/...

#Global
declare failed=""
declare error=""
declare err=""

source getfromtb.sh
source hbis.sh
source checkutils.sh

main() {
    inithostname
    initlogs $@

    SMARTCTL=$(findSmartctl)
    drivenames=$(getdrivenames)

    if [ -z "$drivenames" ] ; then
	echo "No drives found. exit"
	exit 1
    fi

    # array to put drive inventory
    unset -v driveinv ; declare -a driveinv=()
    # array of drives to hold each drive inventory
    unset -v drive ; declare -a drive=($drivenames)

    numberofdrives=${#drive[*]}

    # the index into dirveinv array
    # DISKUNIT SN=<serial> TYPE=<PATA|SATA|SCSI|RAID> SECSIZE=<#> SECTORS=<#> RSPE ED=<MBs> WSPEED=<MBs> 
    declare -i -r header=0
    declare -i -r header_val=1
    declare -i -r name=2
    declare -i -r name_val=3
    declare -i -r driver=4
    declare -i -r driver_val=5
    declare -i -r type=6
    declare -i -r type_val=7
    declare -i -r size=8
    declare -i -r size_val=9
    declare -i -r temp=10
    declare -i -r temp_val=11
    declare -i -r model=12
    declare -i -r model_val=13
    declare -i -r serial=14 
    declare -i -r serial_val=15
    declare -i -r bpers=16
    declare -i -r bpers_val=17
    declare -i -r sectors=18
    declare -i -r sectors_val=19
    declare -i -r wspeed=20    
    declare -i -r wspeed_val=21
    declare -i -r rspeed=22
    declare -i -r rspeed_val=23
    declare -i -r lastslot=23

    # init a default string
    unset -v d; declare -a d=()
    for ((i=0;i<=$lastslot;i++)) ; do
	case $i in
	    $header ) d[$header]="DISKUNIT" ;;
	    $header_val ) d[$header_val]="$header_val" ;;
	    $name ) d[$name]="Device=" ;;
	    $name_val ) d[$name_val]="unset " ;;
	    $driver ) d[$driver]="Driver=" ;;
	    $driver_val ) d[$driver_val]="\"UNKNOWN\" " ;;
	    $type ) d[$type]="TYPE=" ;;
	    $type_val ) d[$type_val]="\"UNKNOWN\"" ;;
	    $size ) d[$size]="Size=" ;;
	    $size_val ) d[$size_val]="unk" ;;
	    $temp ) d[$temp]="Temp=" ;;
	    $temp_val ) d[$temp_val]="unk" ;;
	    $model ) d[$model]="Model=" ;;
	    $model_val ) d[$model_val]="unk" ;;
	    $serial  ) d[$serial ]="SN=" ;;
	    $serial_val ) d[$serial_val]="\"UNKNOWN\"" ;;
	    $bpers ) d[$bpers]="SECSIZE=" ;;
	    $bpers_val ) d[$bpers_val]="unk" ;;
	    $sectors ) d[$sectors]="SECTORS=" ;;
	    $sectors_val ) d[$sectors_val]="\"UNKNOWN\"" ;;
	    $wspeed   ) d[$wspeed  ]="WSPEED=" ;;
	    $wspeed_val ) d[$wspeed_val]="\"UNKNOWN\"" ;;
	    $rspeed ) d[$rspeed]="RSPEED" ;;
	    $rspeed_val ) d[$rspeed_val]="\"UNKNOWN\"" ;;
	esac
    done

    #default string
    driveinvinit="${d[@]}"

    # initalize the driveinv array
    for ((idx=0; idx<$numberofdrives; idx++)) ; do
	driveinv[$idx]="$driveinvinit" 
    done

    #now fill in the array values
    for ((idx=0; idx<$numberofdrives; idx++)) ; do
	unset -v d ; declare -a d=(${driveinv[$idx]})
	for ((i=0;i<=$lastslot;i++)) ; do
	    case $i in
		$header_val ) d[$header_val]="$idx" ;;
		$name_val ) d[$name_val]="${drive[$idx]}" ;;
		$sectors_val ) d[$sectors_val]=$(getsectors ${drive[$idx]}) ;;
		$bpers_val ) d[$bpers_val]=$(getbpers ${drive[$idx]}) ;;
#		$driver_val ) d[$driver_val]=$(getdriver ${drive[$idx]}) ;;
#		$type_val ) d[$type_val]=$(gettype ${drive[$idx]}) ;;
#		$temp_val ) d[$temp_val]=$(gettemp ${drive[$idx]}) ;;
#		$model_val ) d[$model_val]=$(getmodel ${drive[$idx]}) ;;
#		$serial_val ) d[$serial_val]=$(getserial ${drive[$idx]}) ;;
#		$wspeed_val ) d[$wspeed_val]=$(getwspeed ${drive[$idx]}) ;;
#		$rspeed_val ) d[$rspeed_val]=$(getrspeed ${drive[$idx]}) ;;
	    esac
	done
	
	for ((i=0;i<=$lastslot;i++)) ; do
	    case $i in
		$size_val ) 
		x=$((${d[$sectors_val]}*${d[$bpers_val]}))
		d[$size_val]=$(($x / 1000000000))		
		;;
	    esac
	done
	driveinv[$idx]=${d[@]}
    done

# dbug
echo ""
for ((idx=0; idx<$numberofdrives; idx++)) ; do
echo "${driveinv[$idx]}"
done
exit


for ((idx=0; idx<${#drivescan[*]}; idx++)) ; do
    unset -v d ; declare -a d=(${drivescan[$idx]})
    lend=${#d[*]} ; x=$((lend - 2))
    
    #name
    cnt=${#driveinv[$idx]}
    lname="${d[0]}"
    sname="${lname:5}"
    [[  "$sname" == "pass2" ]] && break # /dev/pass2 on freebsd is tape device, skip
    driveinv[$idx]="$sname"
    #if we did not get any info then fillin value meaning unknown.
    [[ ${#driveinv[*]} -eq $cnt ]] && driveinv[$idx]="MissingDRIVE"
    driveinv[$idx]+=" "
    
    #driver
    cnt=${#driveinv[$idx]}
    driveinv[$idx]+="${d[2]}"
    [[ ${#driveinv[idx]} -eq $cnt ]] && driveinv[$idx]+="UNK"
    driveinv[$idx]+=" "
    
    #type
    cnt=${#driveinv[$idx]}
    driveinv[$idx]+="${d[$x]}"
    [[ ${#driveinv[idx]} -eq $cnt ]] && driveinv[$idx]+="UNK"
    driveinv[$idx]+=" "
    
    #size
    cnt=${#driveinv[$idx]}
    sz="$($SMARTCTL  -i ${d[0]} | grep -i "capacity" | awk '{print $5$6}' | sed s/[][]//g)"
    if [[ $sz ]] ; then
	driveinv[$idx]+="$sz"
    else
	x=$($SMARTCTL  -i ${d[0]} | grep -i "capacity" | awk '{print $3}' | sed s/,//g)
	[[ $x ]] && sz=$(hbis $x) || sz="UNK"
	driveinv[$idx]+="$sz"
    fi
    [[ ${#driveinv[idx]} -eq $cnt ]] && driveinv[$idx]+="UNK"
    driveinv[$idx]+=" "
    
    #temp
    cnt=${#driveinv[$idx]}
        #type 1
    driveinv[$idx]+="$($SMARTCTL  -l scttempsts ${d[0]} | grep -i "Current Temperature:" | awk '{print $3}')"
    if [ ${#driveinv[idx]} -eq $cnt ] ; then
        #type 2
	driveinv[$idx]+="$($SMARTCTL  -a ${d[0]} | grep -i "Current Drive Temperature:" | awk '{print $4}')"
    fi
    [[ ${#driveinv[idx]} -eq $cnt ]] && driveinv[$idx]+="UNK"
    driveinv[$idx]+=" "
    
    #vendor product
    cnt=${#driveinv[$idx]}
        #type 1
    driveinv[$idx]+="$($SMARTCTL  -i ${d[0]} | grep -i "Device Model:" | awk '{print $3$4}')"
    if [ ${#driveinv[idx]} -eq $cnt ] ; then
        #type 2
	driveinv[$idx]+="$($SMARTCTL  -i ${d[0]} | grep -i "Product:" | awk '{print $2}')"
    fi
    [[ ${#driveinv[idx]} -eq $cnt ]] && driveinv[$idx]+="UNK"
    driveinv[$idx]+=" "
    
    # serial number
    cnt=${#driveinv[$idx]}
    driveinv[$idx]+="$($SMARTCTL  -i ${d[0]} | grep -i "Serial Number:" | awk '{print $3}')"
    [[ ${#driveinv[idx]} -eq $cnt ]] && driveinv[$idx]+="UNK"
    driveinv[$idx]+=" "
done

## # does number of drives and size match ?
## # getfromtb operation node_id drivename drive size
## for ((idx=0; idx<${#driveinv[*]}; idx++)) ; do
##     unset -v d ; declare -a d=(${driveinv[$idx]})
##     tbdata=getfromtb $host driveinfo ${d[$name]} 
## done

#output to log file
{
echo -e "name\tdriver\ttype\tsize\ttemp\tmodel\t\tserial"
for ((idx=0; idx<${#driveinv[*]}; idx++)) ; do
    unset -v d ; declare -a d=(${driveinv[$idx]})
    echo -e "${d[$name]}\t${d[$driver]}\t${d[$type]}\t${d[$size]}\t${d[$temp]}\t${d[$model]}\t${d[$serial]}"
done
} > ${tmplog} 2>&1
cat ${tmplog} >> ${logfile} 


driveinfo=""

# echo name,size and serial to stdout, addr serialnumber
for ((idx=0; idx<${#driveinv[*]}; idx++)) ; do
    unset -v d ; declare -a d=(${driveinv[$idx]})
    echo -n "${d[$name]} ${d[$size]} ${d[$serial]}  "
    driveinfo+="${d[$serial]} "
done
driveinfo=${driveinfo% } # get rid of trailing space

# Now check against the testbed DB

tbinfo=$(getfromtb diskinfo $host)
error=$?
# echo drivesize:$drivesize: tbinfo:$tbinfo: error:$error


{ 
#save for both output to stdout and log file 
if [ -z "$tbinfo" ] ; then
    failed="TBmiss no info"
    echo "TBmiss empty info returned. Have ${tbinfo[@]} FAILED"
fi

#lower case
tbinfo=${tbinfo,,}
driveinfo=${driveinfo,,}
# turn space seperated string into array
unset -v tb; declare -a tb=(${tbinfo// / })
unset -v have; declare -a have=(${driveinfo// / })

havecnt=${#have[*]}
tbcnt=${#tb[*]}
numserial=${tbcnt}
maxcnt=${tbcnt}

if [[ ${tbcnt} -ne ${havecnt} ]] ; then
    failed="TBmiss"
    [[ ${tbcnt} -gt ${havecnt} ]] && maxcnt=${tbcnt} || maxcnt=${havecnt}
fi

for ((idx=0; idx<$maxcnt; idx++)) ; do
    for ((ifi=0; ifi<$havecnt; ifi++)) ; do
	for ((tbi=0; tbi<$tbcnt; tbi++)) ; do
	    if [ "${have[$ifi]}" = "${tb[$tbi]}" ] ; then
		have[$ifi]=''
		tb[$tbi]=''
	    fi
	done
    done
done
#turn array into string
haveresult=${have[@]}
tbresult=${tb[@]}

if [[ "$haveresult" || "$tbresult" ]] ; then
    if [[ $haveresult ]] ; then
	failed="${failed}: NotIn TB $haveresult"
    fi
    if [[ $tbresult ]] ; then
	failed="${failed}: TB Claims $tbresult"
    fi
fi

echo -n "Have $havecnt drive"
[[ ${havecnt} -gt 1 ]] && echo -n "s" 
[[ -z ${failed} ]] && echo " OK" || echo " $failed" FAILED


} > ${tmplog} 2>&1
cat ${tmplog} >> $logfile
cat ${tmplog}

}

getdriveinfo () {
#need to make sure smartcrl is installed
{
#    echo -n "${FUNCNAME[0]}:${LINENO} " ; echo "args::$@::"
    declare buildscan=""
    logout="$1"
    tmpout="$2"

    if [ "${SMARTCTL}" != "$NOSM" ] ; then
	rtn=$($SMARTCTL --scan)
	# unrecongnized
	if [ -n "$(echo $rtn | grep 'UNRECOGNIZED OPTION')" ] ; then
	    error="(smartctl option '--scan' not supported. Attempt alternet method) "
	    err=scan
	elif [ -n "$(echo $rtn | grep -v 'device')" ] ; then
            # output in unexpected format - missing deliminator "device"
	    error="(smartctl option '--scan' strange ouput. Attempt alternet method) "
	    err=scan
	# empty
	elif [ -z "$rtn" ] ; then
	    dt=$(df / | grep /dev)
	    dt=${dt:5}
	    dt=${dt%% *}
	    error="(smartctl device_type '$dt' not supported"
	    err=device
	fi
	[[ $error ]] && echo "$error"
    else
	error="smartmontools missing."
	err="missing"
	echo "$error. FAIL "
    fi
} > ${logout} 2>&1

# put smartctl --scan into driveinv array
# a better control flow control could be used 

placeholder=" . . . . . device"
case $err in
    scan | missing | device )
	case $os in
	    Linux )
		list="a b c d e f g h i j k l m n o p"
		for i in $list
		do
		    if [ -b /dev/sd${i} ] ; then
			buildscan+="/dev/sd${i} $placeholder"
		    fi
		done
		;;
	    FreeBSD )
		list="0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15"
		for i in $list
		do
		    [[ -b /dev/da${i} ]] && buildscan+="/dev/da${i} $placeholder " 
		    [[ -c /dev/ad${i} ]] && buildscan+="/dev/ad${i} $placeholder " 
		    [[ -c /dev/amrd${i} ]] && buildscan+="/dev/amrd${i} $placeholder " 
		done
		;;
	    * )
		echo "${FUNCNAME[0]}:${LINENO} Internal error"
		exit
		;;
	esac
	unset -v scan
	[[ $buildscan ]] && declare -a scan=($buildscan) || declare -a scan=("")
#	echo -n "${FUNCNAME[0]}:${LINENO} " ; echo "buildscan::${buildscan}::"
	;;
    root )
	echo -n "$error. FAIL " >> ${tmpout}
	echo "Last attempt return roots mount point" >> ${tmpout}
	x=$(df / | grep /dev)
	lastattempt="${x%% *} $placeholder "
	unset -v scan ; declare -a scan=($lastattempt)
	;;
    * )
        # get the output of --scan into array scan
	 unset -v scan ; declare -a scan=($rtn)
#	 echo -n "${FUNCNAME[0]}:${LINENO} " ; echo "rtn::${rtn}::"
	;;
esac

# the result
echo -n "${scan[@]}"

}

getdriver() { 
	echo '"UNKNOWN"'
	return 0
}
gettype() { 
    set -x
    smtcl=$(findSmartctl)
    if [ "${smtcl/smartcl}" == "$smtcl" ] ; then
	echo '"UNKNOWN"'
	return 0
    fi
    data=$($smtcl $1 | grep "")
    res=1
    set +x
    return 0
    echo $FUNCNAME
    return 0
}
gettemp() { 
    echo $FUNCNAME
    return 0
}
getmodel() { 
    echo $FUNCNAME
    return 0
}
getserial() { 
    echo $FUNCNAME
    return 0
}
getbpers() { 
    hdname=$1
    case $os in
	Linux )
	    hdname=${hdname##*/}
	    res=$(dmesg | grep "logical blocks" | grep $hdname)
	    if [ -z "$res" ] ; then
		echo 0
		return 0
	    fi
	    res=${res%%-byte *}
	    res=${res##*] }
	    res=${res#* }
	    [[ $res ]] || res=512
	    ;;
	FreeBSD )
	    hdname=${hdname##*/}
	    res=$(grep sectors /var/run/dmesg.boot | grep $hdname)
	    if [ -z "$res" ] ; then
		hdnamex=${hdname/ad/ada}
		res=$(grep sectors /var/run/dmesg.boot | grep $hdnamex)
		if [ -z "$res" ] ; then
		    echo 512
		    return 0
		fi
	    fi
	    res=${res%%byte sectors*}
	    res=${res##*(}
	    res=${res#* }
	    [[ $res ]] || res=512
	    ;;
	* ) echo "$FUNCNAME internal error"
	    exit 1
	    ;;
    esac
    echo $res
    return 0
}
getsectors() { 
    hdname=$1
    case $os in
	Linux )
	    hdname=${hdname##*/}
	    res=$(dmesg | grep "logical blocks" | grep $hdname)
	    if [ -z "$res" ] ; then
		echo 0
		return 0
	    fi
	    res=${res%%-byte *}
	    res=${res##*] }
	    res=${res%% *}
	    [[ $res ]] || res=0
	    ;;
	FreeBSD )
	    hdname=${hdname##*/}
	    res=$(grep sectors /var/run/dmesg.boot | grep $hdname)
	    if [ -z "$res" ] ; then
		hdnamex=${hdname/ad/ada}
		res=$(grep sectors /var/run/dmesg.boot | grep $hdnamex)
		if [ -z "$res" ] ; then
		    res=$(grep ${hdname} /var/run/dmesg.boot)
		    if [ -z "$res" ] ; then
			echo 0
			return 0
		    fi
		    res=${res%%MB*}
		    res=${res#* }
		    echo $(( $res * 2048 )) # assume 512 byte sectors
		    return 0
		fi
	    fi
	    res=${res%%byte sectors*}
	    res=${res##*(}
	    res=${res%% *}
	    [[ $res ]] || res=0
	    ;;
	* ) echo "$FUNCNAME internal error"
	    exit 1
	    ;;
    esac
    echo $res
    return 0
}
getwspeed() { 
    echo $FUNCNAME
    return 0
}
getrspeed() { 
    echo $FUNCNAME
    return 0
}


main $@

exit 0


