#! /bin/bash

echo -n ' Starting diskcheck..'

# find the number of disks
# find the size of each disk

# first arg is the log output file, if not set then /tmp/...

#Global
declare SMARTCTL=''
declare failed=""
declare error=""
declare err=""

source getfromtb.sh
source hbis.sh
source checkutils.sh




# setup logging
if [ $1 ] ; then
    logfile=$1
else
    logfile="/tmp/nodecheck.log"
fi

#exit on unbound var, set after sourcing files
set -u

os=`uname -s`
host=`hostname`
if [ -e "/var/emulab/boot/realname" ]; then
    host=`cat /var/emulab/boot/realname`
fi

tmplog=/tmp/.$$.log
cat /dev/null > ${tmplog}

tmpout=/tmp/.$$tmpout.log ; touch ${tmpout}
logout=/tmp/.$$logout.log ; touch ${logout}

disknames=$(getdriveinfo ${logout} ${tmpout})
cat ${tmpout} ; rm -f ${tmpout}
echo "diskcheck `date`" >> ${logfile}
cat ${logout} >> ${logfile} ; rm -f ${logout}

#echo "" ; echo -n "$0:${LINENO} " ; echo disknames:${disknames}:
if [ -z "$disknames" ] ; then
    echo "No drives found. exit"
    exit 1
fi

unset -v scan; declare -a scan=(${disknames// / })

echo -n "$0:${LINENO} " ; echo scan:"${scan[@]}":

# the index into dirveinv array
name=0; driver=1; type=2; size=3; temp=4; model=5; serial=6;
unset -v driveinv ; declare -a driveinv=()

#now split up each line using 'device' into the array drivescan
# This is an example of the string we are parsing:
# '/dev/sdb -d scsi # /dev/sdb, SCSI device'    
unset -v drive ; declare -a drivescan=()
y=0
for elm in ${scan[@]} ; do
    set +u
    drivescan[$y]="${drivescan[$y]} ${elm}"
    [[ "${elm}" == "device" ]] && ((++y))
    set -u
done
for ((idx=0; idx<${#drivescan[*]}; idx++)) ; do
    unset -v d ; declare -a d=(${drivescan[$idx]})
    lend=${#d[*]} ; x=$((lend - 2))
    
    #name
    cnt=${#driveinv[$idx]}
    lname="${d[0]}"
    sname="${lname:5}"
    [[  "$sname" == "pass2" ]] && break # /dev/pass2 on freebsd is tape device, skip
    driveinv[$idx]="$sname"
    #if we did not get any info then fillin value meaning unknown.
    [[ ${#driveinv[*]} -eq $cnt ]] && driveinv[$idx]="MissingDRIVE"
    driveinv[$idx]+=" "
    
    #driver
    cnt=${#driveinv[$idx]}
    driveinv[$idx]+="${d[2]}"
    [[ ${#driveinv[idx]} -eq $cnt ]] && driveinv[$idx]+="UNK"
    driveinv[$idx]+=" "
    
    #type
    cnt=${#driveinv[$idx]}
    driveinv[$idx]+="${d[$x]}"
    [[ ${#driveinv[idx]} -eq $cnt ]] && driveinv[$idx]+="UNK"
    driveinv[$idx]+=" "
    
    #size
    cnt=${#driveinv[$idx]}
    sz="$($SMARTCTL  -i ${d[0]} | grep -i "capacity" | awk '{print $5$6}' | sed s/[][]//g)"
    if [[ $sz ]] ; then
	driveinv[$idx]+="$sz"
    else
	x=$($SMARTCTL  -i ${d[0]} | grep -i "capacity" | awk '{print $3}' | sed s/,//g)
	[[ $x ]] && sz=$(hbis $x) || sz="UNK"
	driveinv[$idx]+="$sz"
    fi
    [[ ${#driveinv[idx]} -eq $cnt ]] && driveinv[$idx]+="UNK"
    driveinv[$idx]+=" "
    
    #temp
    cnt=${#driveinv[$idx]}
        #type 1
    driveinv[$idx]+="$($SMARTCTL  -l scttempsts ${d[0]} | grep -i "Current Temperature:" | awk '{print $3}')"
    if [ ${#driveinv[idx]} -eq $cnt ] ; then
        #type 2
	driveinv[$idx]+="$($SMARTCTL  -a ${d[0]} | grep -i "Current Drive Temperature:" | awk '{print $4}')"
    fi
    [[ ${#driveinv[idx]} -eq $cnt ]] && driveinv[$idx]+="UNK"
    driveinv[$idx]+=" "
    
    #vendor product
    cnt=${#driveinv[$idx]}
        #type 1
    driveinv[$idx]+="$($SMARTCTL  -i ${d[0]} | grep -i "Device Model:" | awk '{print $3$4}')"
    if [ ${#driveinv[idx]} -eq $cnt ] ; then
        #type 2
	driveinv[$idx]+="$($SMARTCTL  -i ${d[0]} | grep -i "Product:" | awk '{print $2}')"
    fi
    [[ ${#driveinv[idx]} -eq $cnt ]] && driveinv[$idx]+="UNK"
    driveinv[$idx]+=" "
    
    # serial number
    cnt=${#driveinv[$idx]}
    driveinv[$idx]+="$($SMARTCTL  -i ${d[0]} | grep -i "Serial Number:" | awk '{print $3}')"
    [[ ${#driveinv[idx]} -eq $cnt ]] && driveinv[$idx]+="UNK"
    driveinv[$idx]+=" "
done

## # does number of drives and size match ?
## # getfromtb operation node_id drivename drive size
## for ((idx=0; idx<${#driveinv[*]}; idx++)) ; do
##     unset -v d ; declare -a d=(${driveinv[$idx]})
##     tbdata=getfromtb $host driveinfo ${d[$name]} 
## done

#output to log file
{
echo -e "name\tdriver\ttype\tsize\ttemp\tmodel\t\tserial"
for ((idx=0; idx<${#driveinv[*]}; idx++)) ; do
    unset -v d ; declare -a d=(${driveinv[$idx]})
    echo -e "${d[$name]}\t${d[$driver]}\t${d[$type]}\t${d[$size]}\t${d[$temp]}\t${d[$model]}\t${d[$serial]}"
done
} > ${tmplog} 2>&1
cat ${tmplog} >> ${logfile} 


driveinfo=""

# echo name,size and serial to stdout, addr serialnumber
for ((idx=0; idx<${#driveinv[*]}; idx++)) ; do
    unset -v d ; declare -a d=(${driveinv[$idx]})
    echo -n "${d[$name]} ${d[$size]} ${d[$serial]}  "
    driveinfo+="${d[$serial]} "
done
driveinfo=${driveinfo% } # get rid of trailing space

# Now check against the testbed DB

tbinfo=$(getfromtb diskinfo $host)
error=$?
# echo drivesize:$drivesize: tbinfo:$tbinfo: error:$error


{ 
#save for both output to stdout and log file 
if [ -z "$tbinfo" ] ; then
    failed="TBmiss no info"
    echo "TBmiss empty info returned. Have ${tbinfo[@]} FAILED"
fi

#lower case
tbinfo=${tbinfo,,}
driveinfo=${driveinfo,,}
# turn space seperated string into array
unset -v tb; declare -a tb=(${tbinfo// / })
unset -v have; declare -a have=(${driveinfo// / })

havecnt=${#have[*]}
tbcnt=${#tb[*]}
numserial=${tbcnt}
maxcnt=${tbcnt}

if [[ ${tbcnt} -ne ${havecnt} ]] ; then
    failed="TBmiss"
    [[ ${tbcnt} -gt ${havecnt} ]] && maxcnt=${tbcnt} || maxcnt=${havecnt}
fi

for ((idx=0; idx<$maxcnt; idx++)) ; do
    for ((ifi=0; ifi<$havecnt; ifi++)) ; do
	for ((tbi=0; tbi<$tbcnt; tbi++)) ; do
	    if [ "${have[$ifi]}" = "${tb[$tbi]}" ] ; then
		have[$ifi]=''
		tb[$tbi]=''
	    fi
	done
    done
done
#turn array into string
haveresult=${have[@]}
tbresult=${tb[@]}

if [[ "$haveresult" || "$tbresult" ]] ; then
    if [[ $haveresult ]] ; then
	failed="${failed}: NotIn TB $haveresult"
    fi
    if [[ $tbresult ]] ; then
	failed="${failed}: TB Claims $tbresult"
    fi
fi

echo -n "Have $havecnt drive"
[[ ${havecnt} -gt 1 ]] && echo -n "s" 
[[ -z ${failed} ]] && echo " OK" || echo " $failed" FAILED


} > ${tmplog} 2>&1
cat ${tmplog} >> $logfile
cat ${tmplog}

exit 0


