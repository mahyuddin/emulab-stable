#!/bin/bash
#
# Copyright (c) 2013 University of Utah and the Flux Group.
# 
# {{{EMULAB-LICENSE
# 
# This file is part of the Emulab network testbed software.
# 
# This file is free software: you can redistribute it and/or modify it
# under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or (at
# your option) any later version.
# 
# This file is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public
# License for more details.
# 
# You should have received a copy of the GNU Affero General Public License
# along with this file.  If not, see <http://www.gnu.org/licenses/>.
# 
# }}}
#

_1KiB=1
_1KMiB=1024
_256KMiB=262144
_1KGiB=1048576
_32KGiB=33554432

echo -n ' Starting memcheck..'

source checkutils.sh
source hbis.sh

declare failed="" s=""

inithostname
initlogs $@

#set +x
#exit on unbound var
set -u
#exit on any error
set -e

# only called on error, should just get rig of
finish() {
    echo "memcheck `date`" >> ${logfile}
    cat ${tmplog} >> ${logfile} 
    
    echo "$failed"
    echo "$failed" >> ${logfile} 
    exit 1
}

s=""

# check that external need program are installed
case $os in
    Linux )
	if [ -f ${logfile4tb} ] ; then
	    progs="cat grep"
	else
	    progs="cat grep bc"
	fi
	;;
    FreeBSD )
	progs="grep cat"
	;;
    * )
	failed="Unknown OS :$os:"
	finish
	exit 1
	;;
esac
for i in $progs ; do
    type $i &>/dev/null && continue  || s="$s $i "
done
if [ -n "$s" ] ; then
    failed=" Unable to run need missing command(s) $s"
    echo "$failed" >> ${tmplog}
    finish
fi


{
case $os in
    Linux )
	    unset -v d ; declare -a d=($(cat /proc/meminfo | grep MemTotal))
	    # we don't have the use of bc in mfs/load boot
	    if [ -f ${logfile4tb} ] ; then
		# punt punt punt
		number=${d[1]}
		if (( number > $_32KGiB )) ; then
#		    ((number+=5033126))
		    ((number+=2048000))
		elif (( number > $_1KGiB )) ; then
		    ((number+=31457))
		elif (( number > $_256KMiB )) ; then
		    ((number+=47972))
		elif (( number > $_1KMiB )) ; then
		    ((number+=48))
		fi
	    else
	    # Linux under reports, add ??MiB (in KiB units) for reserved mem
		if (( ${d[1]} > $_32KGiB )) ; then
		    number=$(echo "scale=0; (${d[1]} * 1.015) / 1;" | bc) # divide by 1 for the truncate
		elif (( ${d[1]} > $_1KGiB )) ; then
		    number=$(echo "scale=0; (${d[1]} * 1.03) / 1;" | bc)
		elif (( ${d[1]} > $_256KMiB )) ; then
		    number=$(echo "scale=0; (${d[1]} * 1.183) / 1;" | bc)
		elif (( ${d[1]} > $_1KMiB )) ; then
		    number=$(echo "scale=0; (${d[1]} * 1.047) / 1;" | bc)
		else 
		    number=$(echo "scale=0; (${d[1]} * 1.0) / 1;" | bc)
		fi
	    fi
		
	    mi=${number}${d[2]}
	    meminfo=$(hbis $mi)
	    ;;
    FreeBSD )
	    unset -v d ; declare -a d=($(grep memory /var/run/dmesg.boot | grep real))
	    # ???? use the bytes and not the stuff in the (), seem to round up using int rounding.
	    # example: "real memory  = 268419072 (255 MB)" is not true, 268419072 = 255.984375 MB
#	    w=${d[4]} ; x=${w#(}
#		z=${d[5]} ; y=${z%)}
#	    meminfo=$x$y
	    meminfo=${d[3]}
	    meminfo=$(hbis $meminfo)
	    ;;
    * )
	    echo "os $os unknown"
	    meminfo="0"
	    failed=FAIL
	    ;;
esac

echo -n "Found phys memory $meminfo"
} >> ${tmplog} 2>&1

# if saving data for testbed database
num=${meminfo//[a-z]*/}
num=${meminfo//[A-Z]*/}
base=${meminfo//[0-9]/}
#it is MiB or GiB
if [ "$base" == "GiB" ] ; then
    num=$(($num * 1024))
fi
if [ -f ${logfile4tb} ] ; then
    printf "MEMINFO SIZE=%s\n" ${num} >> ${logfile4tb}
    exit 0
fi

# done at this point in MFS
# we are done if in MFS mode
(( $mfsmode )) && exit 0


tbinfo=$(getfromtb meminfo $host)

{
if [ "$meminfo" == "$tbinfo" ] ; then
    echo " Equals node inventory $tbinfo"
else
    echo " Does not equals node inventory $tbinfo"    
    failed=FAIL
fi
} >> ${tmplog} 2>&1

echo "memcheck `date`" >> ${logfile}
cat ${tmplog} >> ${logfile} 

[[ -z ${failed} ]] && echo "$tbinfo OK" || echo "TBmiss Have |$meminfo| Want |$tbinfo| FAILED"

exit 0
