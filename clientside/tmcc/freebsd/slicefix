#!/bin/sh
#
# EMULAB-COPYRIGHT
# Copyright (c) 2000-2012 University of Utah and the Flux Group.
# All rights reserved.
#

if [ -r /etc/emulab/paths.sh ]; then
	. /etc/emulab/paths.sh
else
	BINDIR=/etc/testbed
	BOOTDIR=/var/emulab/boot
	ETCDIR=/etc/emulab
fi

# XXX should fix paths.sh but I am afraid of the consequences
if [ -d "/etc/emulab" -a "$ETCDIR" = "/etc/testbed" ]; then
	ETCDIR=/etc/emulab
	for f in isvgaonly isflash bossnode emulab.pem client.pem; do
		if [ -e "/etc/testbed/$f" -a ! -e "/etc/emulab/$f" ]; then
			mv /etc/testbed/$f /etc/emulab/$f
		fi
	done
fi    

disk="ad0"

case $# in
1)
	part=$1
	;;
2)
	part=$1
	disk=$2
	;;
*)
	echo "Usage: $0 partition [disk]"
	exit 1
esac

#
# Handle pseudo arguments in the environment.
#
ACPI=${SLICEFIX_ACPI:-'unknown'}
case $ACPI in
0|no|NO)
    ACPI=no
    ;;
1|yes|YES)
    ACPI=yes
    ;;
*)
    ACPI=unknown
    ;;
esac

ASF=${SLICEFIX_ASF:-'unknown'}
case $ASF in
0|no|NO)
    ASF=no
    ;;
1|yes|YES)
    ASF=yes
    ;;
*)
    ASF=unknown
    ;;
esac

NOCLFLUSH=${SLICEFIX_NOCLFLUSH:-'unknown'}
case $NOCLFLUSH in
0|no|NO)
    NOCLFLUSH=0
    ;;
1|yes|YES)
    NOCLFLUSH=1
    ;;
*)
    NOCLFLUSH=unknown
    ;;
esac

VGAONLY=${SLICEFIX_VGAONLY:-'unknown'}
case $VGAONLY in
0|no|NO)
    VGAONLY=no
    ;;
1|yes|YES)
    VGAONLY=yes
    ;;
*)
    # XXX check the MFS filesystem
    if [ -r $ETCDIR/isvgaonly ]; then
	VGAONLY=yes
    else
	VGAONLY=unknown
    fi
    ;;
esac

#
# ...or the filesystem
#
if [ -r $ETCDIR/isflash ]; then
    FLASHBOOT=1
else
    FLASHBOOT=0
fi

if [ -r $ETCDIR/bossnode ]; then
    bossnode=`cat $ETCDIR/bossnode`;
    setboss=1
else
    setboss=0
fi

# Indicates the MFS has been properly localized and we can copy stuff
# into the image.
LOCALIZED="/.localized"

islocalized() {
    if [ -e $LOCALIZED ]; then
	return 0;
    fi
    return 1;
}

dofreebsd() {
	#
	# ARGH!  FreeBSD 5, which primarily uses UFS2, internally converts
	# UFS1 filesystems to an updated, UFS2 compatible form.  However,
	# some of the converted fields leak back to disk when the filesystem
	# is unmounted, creating the potential for corruption in the following
	# scenerio:
	#
	# 1. mount, update, and unmount a UFS1 FS under FBSD5
	# 2. mount, update, and unmount the FS under FBSD4
	# 3. go back and access the FS under FBSD5
	#
	# #2 will update the old version of the csum structure.  At step
	# #3, the mount will see some of the leaked info from the unmount
	# in #1 and determine that it has already "upgraded" this FS and
	# thus doesn't need to copy the old csum into the new one.  The
	# result is that it will use stale csum info.
	#
	# In theory we could encounter this problem when we slicefix
	# a newly loaded FBSD image (#1), boot up and update stuff on
	# the image (#2), and then create a new image with imagezip
	# (#3, as imagezip uses the FBSD5 filesystem logic).
	#
	# How do we deal with this?  What we will have to do is either
	# fix the FBSD5 filesystem code or we will have to run a little
	# hack after the slicefix unmount to undo the damage that FBSD5
	# does.  Currently I have not done either.  Instead we avoid the
	# problem as follows.  Before making any change to the FS with
	# slicefix, we first RO-mount the FS to see if anything needs to
	# be done.  If not, we just leave it alone.  Since I currently
	# create all new images on machines with "ad" disks and that is
	# what the default fstab contains for its root device, we avoid
	# making any mods with slicefix and thus avoid #1 above.
	#
	# This is clearly not a solution.
	#
	vers=`uname -v | sed -e 's/FreeBSD \([0-9]\).*/\1/'`

	# see if there is a root ('a') partition on this BSD slice
	`disklabel ${disk}s${part} 2>&1 | grep -s -E '^[ ]+a:' >/dev/null` || {
		return 1
	}

	rootdev=/dev/${disk}s${part}a
	echo "fixing FreeBSD root partition ${disk}s${part}a"
	fsck -p $rootdev || {
		# 8.x fsck fails to determine the FS type, try again with ufs
		echo "retrying fsck with '-t ufs'"
		fsck -t ufs -p $rootdev || {
		    echo "Fsck of $rootdev failed"
		    return 1
		}
	}
	mount -o ro $rootdev /mnt || {
		echo "RO-mount of $rootdev failed"
		return 1
	}

	#
	# See if we need to modify anything in the image
	#
	changedisk=0
	changeentropy=0
	changeacpi=0
	changeasf=0
	changeclflush=0
	changecons=0
	changecerts=0
	changehostkeys=0
	changerootkeys=0
	changezone=0

	fixit=0

	# Hardwire the boss?
	if [ $setboss -eq 1 ]; then
	    fixit=1
        fi

	# If our disk/part does not appear anywhere in fstab, we need to fix it
	grep "^/dev/${disk}s${part}" /mnt/etc/fstab >/dev/null 2>&1
	case $? in
	0)
	    ;;
	*)
	    changedisk=1
	    fixit=1
	    ;;
	esac

	# If there is a /entropy file, we need to update it
	if [ -f /mnt/entropy -a -c /dev/random ]; then
		changeentropy=1
		fixit=1
	fi

	#
	# See if we need to change the ACPI setting.
	#
	# If ACPI was not specified via TMCD, leave it along.
	#
	# If "acpi_load" does not appear at all in the loader.conf file,
	# assume the OS cannot handle it (or that we do not know how to
	# change it) and leave it alone.
	#
	if [ $ACPI != "unknown" ]; then
	    grep "acpi_load=" /mnt/boot/loader.conf >/dev/null 2>&1
	    case $? in
	    0)
		grep "^acpi_load=\"YES\"" /mnt/boot/loader.conf >/dev/null 2>&1
		case $? in
		0)
		    if [ $ACPI = "no" ]; then
			changeacpi=1
			fixit=1
		    fi
		    ;;
		*)
		    if [ $ACPI = "yes" ]; then
			changeacpi=1
			fixit=1
		    fi
		    ;;
		esac
		;;
	    *)
		;;
	    esac
	fi

	#
	# See if we need to change the ASF setting.
	#
	# Note that, unlike ACPI, we change it even if there was no
	# previous setting in /boot/loader.conf.
	#
	if [ $ASF != "unknown" ]; then
	    grep "hw.bge.allow_asf=" /mnt/boot/loader.conf >/dev/null 2>&1
	    case $? in
	    0)
		grep "^hw.bge.allow_asf=1" /mnt/boot/loader.conf >/dev/null 2>&1
		case $? in
		0)
		    if [ $ASF = "no" ]; then
			changeasf=1
			fixit=1
		    fi
		    ;;
		*)
		    if [ $ASF = "yes" ]; then
			changeasf=1
			fixit=1
		    fi
		    ;;
		esac
		;;
	    *)
	        changeasf=1
		fixit=1
		;;
	    esac
	fi

	if [ $NOCLFLUSH != "unknown" ]; then
	    fixit=1
	fi

	#
	# If node doesn't have a serial port, make sure comconsole is not set!
	#
	if [ $VGAONLY = "yes" ]; then
	    grep "^console=\"comconsole\"" /mnt/boot/loader.conf >/dev/null 2>&1
	    case $? in
	    0)
		changecons=1
		fixit=1
		;;
	    *)
	        ;;
	    esac
	fi

        # check to see if we need to download any postconfig scripts:
	doosconfig=0
	if [ -x $BINDIR/osconfig ]; then
	    $BINDIR/osconfig -c -m /mnt -D $rootdev -s FreeBSD postload
	    if [ $? -eq 0 ]; then
		doosconfig=1
		fixit=1
	    fi
	fi

	#
	# Localize the image. We only do this if the MFS we are running in
	# has the necessary files.
	#
	if islocalized; then
	    # Check the certs.
	    if [ -e $ETCDIR/emulab.pem ]; then
		cmp -s $ETCDIR/emulab.pem /mnt/etc/emulab/emulab.pem
		if [ $? -ne 0 ]; then
		    changecerts=1
		    fixit=1
		fi
	    fi
	    if [ -e $ETCDIR/client.pem ]; then
		cmp -s $ETCDIR/client.pem /mnt/etc/emulab/client.pem
		if [ $? -ne 0 ]; then
		    changecerts=1
		    fixit=1
		fi
	    fi

	    # Check the root keys.
	    if [ -e /root/.ssh/authorized_keys2 ]; then
		cmp -s /root/.ssh/authorized_keys2 /mnt/root/.ssh/authorized_keys
		if [ $? -ne 0 ]; then
		    changerootkeys=1
		    fixit=1
		fi
	    fi
	
	    # Check the host keys.
	    if [ -e /etc/ssh/ssh_host_key ]; then
		cmp -s /etc/ssh/ssh_host_key /mnt/etc/ssh/ssh_host_key
		if [ $? -ne 0 ]; then
		    changehostkeys=1
		    fixit=1
		fi
	    fi
	    if [ -e /etc/ssh/ssh_host_rsa_key ]; then
		cmp -s /etc/ssh/ssh_host_rsa_key /mnt/etc/ssh/ssh_host_rsa_key
		if [ $? -ne 0 ]; then
		    changehostkeys=1
		    fixit=1
		fi
	    fi
	    if [ -e /etc/ssh/ssh_host_dsa_key ]; then
		cmp -s /etc/ssh/ssh_host_dsa_key /mnt/etc/ssh/ssh_host_dsa_key
		if [ $? -ne 0 ]; then
		    changehostkeys=1
		    fixit=1
		fi
	    fi

	    # Check the time zone.
	    if [ -e /etc/localtime ]; then
		cmp -s /etc/localtime /mnt/etc/localtime
		if [ $? -ne 0 ]; then
		    changezone=1
		    fixit=1
		fi
	    fi
	fi

	if [ $fixit -eq 0 ]; then
		echo "  no changes necessary"
		umount $rootdev
		return 0
	fi

	# We need to change something, remount RW and change it
	umount $rootdev
	mount $rootdev /mnt || {
		echo "Mount of $rootdev failed"
		return 1
	}

	# hardwire the boss node
	if [ $setboss -eq 1 -a -d /mnt/etc/emulab ]; then
	    echo "  hardwiring boss to $bossnode"
	    cp $ETCDIR/bossnode /mnt/etc/emulab/bossnode || {
	        echo "Failed to create /etc/emulab/bossnode"
		umount $rootdev
		return 1
	    }
	fi

	if [ $changedisk -eq 1 ]; then
	    echo "  updating /etc/fstab"
	    sed -E -i .preemulab -e "s;^/dev/[a-zA-Z]+[0-9]+s[0-9]+;/dev/${disk}s${part};" /mnt/etc/fstab || {
		echo "Failed to update /etc/fstab"
		umount $rootdev
		return 1
	    }
	    echo "  updating /etc/dumpdates"
	    sed -E -i .preemulab -e "s;^/dev/[a-zA-Z]+[0-9]+s[0-9]+;/dev/${disk}s${part};" /mnt/etc/dumpdates || {
		echo "Failed to update /etc/dumpdates"
		umount $rootdev
		return 1
	    }
	fi

	if [ $changeentropy -eq 1 ]; then
	    echo "  updating /entropy"
	    dd if=/dev/random of=/mnt/entropy bs=4096 count=1 >/dev/null 2>&1
	fi

	lcbak=".preemulab"
	if [ $changeacpi -eq 1 ]; then
	    if [ $ACPI = "no" ]; then
		on="dis"
	    else
		on="en"
	    fi
	    echo "  ${on}abling ACPI"
	    sed -E -i $lcbak -e "/[Aa][Cc][Pp][Ii]/d" /mnt/boot/loader.conf || {
		echo "Failed to update /boot/loader.conf"
		umount $rootdev
		return 1
	    }
	    lcbak=""
	    if [ $ACPI = "no" ]; then
		cat <<EOF1 >>/mnt/boot/loader.conf
# disable ACPI
acpi_load="NO"
hint.acpi.0.disabled=1
loader.acpi_disabled_by_user=1
EOF1
	    else
		cat <<EOF2 >>/mnt/boot/loader.conf
# enable ACPI
acpi_load="YES"
hint.acpi.0.disabled=0
EOF2
	    fi
	fi

	if [ $changeasf -eq 1 ]; then
	    if [ $ASF = "no" ]; then
		on="dis"
	    else
		on="en"
	    fi
	    echo "  ${on}abling ASF"
	    sed -E -i $lcbak -e "/[Aa][Ss][Ff]/d" /mnt/boot/loader.conf || {
		echo "Failed to update /boot/loader.conf"
		umount $rootdev
		return 1
	    }
	    lcbak=""
	    if [ $ASF = "no" ]; then
		cat <<EOF1 >>/mnt/boot/loader.conf
# disable ASF
hw.bge.allow_asf=0
EOF1
	    else
		cat <<EOF2 >>/mnt/boot/loader.conf
# enable ASF
hw.bge.allow_asf=1
EOF2
	    fi
	fi

	#
	# Remove console="comconsole"
	#
	if [ $changecons -eq 1 ]; then
	    echo "  disabling comconsole"
	    sed -E -i $lcbak -e "/^console=\"comconsole\"/d" /mnt/boot/loader.conf || {
		echo "Failed to update /boot/loader.conf"
		umount $rootdev
		return 1
	    }
	    lcbak=""
	fi

	#
	# See if we need to change the use of NOCLFLUSH.
	# If explicitly specified, we override any previous setting.
	#
	if [ $NOCLFLUSH != "unknown" ]; then
	    if [ $NOCLFLUSH = "1" ]; then
		on="dis"
	    else
		on="en"
	    fi
	    echo "  ${on}abling use of CLFLUSH"
	    sed -E -i $lcbak -e "/clflush_disable/d" /mnt/boot/loader.conf || {
		echo "Failed to update /boot/loader.conf"
		umount $rootdev
		return 1
	    }
	    lcbak=""
	    cat <<EOF1 >>/mnt/boot/loader.conf
# ${on}able CLFLUSH (hw.clflush_disable)
hw.clflush_disable=$NOCLFLUSH
EOF1
	fi

	# Copy in new certs
	if [ $changecerts -eq 1 ]; then
	    echo "  updating /etc/emulab/{emulab.pem,client.pem}"

	    if [ ! -d /mnt/etc/emulab ]; then
		mkdir -m 755 /mnt/etc/emulab || {
	            echo "Failed to mkdir /mnt/etc/emulab"
		    umount $rootdev
		    return 1
		}
	    fi
	    cp -p $ETCDIR/emulab.pem $ETCDIR/client.pem /mnt/etc/emulab/ || {
	        echo "Failed to create $ETCDIR/emulab.pem or $ETCDIR/client.pem"
		umount $rootdev
		return 1
	    }
	fi

	# Copy in new root keys
	if [ $changerootkeys -eq 1 ]; then
	    echo "  updating /root/.ssh/authorized_keys"

	    if [ ! -d /mnt/root/.ssh ]; then
		mkdir -m 700 /mnt/root/.ssh || {
	            echo "Failed to mkdir /root/.ssh"
		    umount $rootdev
		    return 1
		}
	    fi
	    # copy to both authorized_keys and _keys2
	    cp -p /root/.ssh/authorized_keys2 /mnt/root/.ssh/authorized_keys || {
	        echo "Failed to create /root/.ssh/authorized_keys"
		umount $rootdev
		return 1
	    }
	    cp -p /root/.ssh/authorized_keys2 /mnt/root/.ssh/ || {
	        echo "Failed to create /root/.ssh/authorized_keys2"
		umount $rootdev
		return 1
	    }
	fi

	# Copy in new host keys
	if [ $changehostkeys -eq 1 ]; then
	    echo "  updating /etc/ssh/hostkeys"

	    if [ ! -d /mnt/etc/ssh ]; then
		mkdir -m 755 /mnt/etc/ssh || {
	            echo "Failed to mkdir /mnt/etc/ssh"
		    umount $rootdev
		    return 1
		}
	    fi
	    cp -p /etc/ssh/ssh_host_* /mnt/etc/ssh/ || {
	        echo "Failed to create /etc/ssh/hostkeys"
		umount $rootdev
		return 1
	    }
	fi

	# Copy in new localtime
	if [ $changezone -eq 1 ]; then
	    echo "  updating /etc/localtime"

	    cp -p /etc/localtime /mnt/etc/localtime || {
	        echo "Failed to create /etc/localtime"
		umount $rootdev
		return 1
	    }
	fi

	# actually run any postconfig scripts if we're supposed to:
	if [ $doosconfig -eq 1 -a -x $BINDIR/osconfig ]; then
	    $BINDIR/osconfig -m /mnt -D $rootdev -s FreeBSD postload
	fi

	umount $rootdev

	# XXX need to fixup FS, see big comment above
	if [ "x$vers" != "x4" ]; then
		echo "WARNING: FBSD${vers} may have modified the UFS1 root FS"
	fi

	return 0
}

#
# echo the name of the kernel that lilo will boot by default
#
lilogetkernel() {
    _lconf=$1
    _re='[a-zA-Z0-9][-_\.a-zA-Z0-9]*'

    # see if there is a default= line and prefer that
    linux=`grep -E "default=$_re" $_lconf | sed -e "s/default=\($_re\).*/\1/"`

    # no explicit default, use first kernel listed
    if [ "x${linux}" = x ]; then
	linux=`grep -E "label=$_re" $_lconf | head -1 | \
		sed -e "s/label=\($_re\).*/\1/"`
    fi

    # still no hit, just use 'linux'
    linux=${linux:-'linux'}

    echo $linux
}

dolinux() {
	# figure out the linux device name
	dunit=`echo $disk | sed -e 's/..\([0-7]\)/\1/'`
	case $disk in
	# IDE
	ad[0-3])
		dtype="hd"
		d=`echo $dunit | sed -e 'y/0123/048c/'`
		lrootdev="3${d}${part}"
		;;
	# SATA
	ad[4-7])
		dtype="sd"
		dunit=`expr $dunit - 4`
		lrootdev="8${dunit}${part}"
		;;
	# SCSI
	da[0-7])
		dtype="sd"
		lrootdev="8${dunit}${part}"
		;;
	# PERC
	mfid[0-9]|mfisyspd[0-9])
		dtype="sd"
		dunit=`echo $disk | sed -e 's/.*\([0-9]\)$/\1/'`
		lrootdev="8${dunit}${part}"
		;;
	# Adaptec
	aacd[0-7])
		dunit=`echo $disk | sed -e 's/aacd\([0-7]\)/\1/'`
		dtype="sd"
		lrootdev="8${dunit}${part}"
		;;
	# Megaraid
	amrd[0-7])
		dunit=`echo $disk | sed -e 's/amrd\([0-7]\)/\1/'`
		dtype="sd"
		lrootdev="8${dunit}${part}"
		;;
	*)
		echo "slicefix: linux: unknown disk $disk"
		return 1
		;;
	esac
	dunit=`echo $dunit | sed -e 'y/01234567/abcdefgh/'`;
	ldisk=$dtype$dunit
	rootdev=/dev/${disk}s${part}

	#
	# See if there is a valid filesystem UUID to use in fstab and grub.
	#
	RUUID=""
	if [ -x /usr/local/sbin/dumpe2fs ]; then
	    RUUID=`dumpe2fs $rootdev 2>/dev/null | grep UUID: | sed -e 's/.*UUID:  *\([^ ]*\).*/\1/'`
	    #
	    # To be pedantic, we should do the following (generate a new
	    # UUID, but this seems to be causing strange problems with the
	    # UUID not always being updated. It will also cause the root FS
	    # to be fsck'ed everytime (see needfsck below).
	    #
	    if false && [ -n "$RUUID" -a -x /usr/local/sbin/tune2fs ]; then
		# generate/install a new random UUID with tune2fs
		echo "  setting new root FS UUID"
		tune2fs -U random $rootdev 2>/dev/null
		RUUID=`dumpe2fs $rootdev 2>/dev/null | grep UUID: | sed -e 's/.*UUID:  *\([^ ]*\).*/\1/'`
	    fi
	fi

	# attempt to mount filesystem   
	echo "  fixing Linux root partition ${disk}s${part}"
	mount -t ext2fs $rootdev /mnt || {
	    # might need a journal recovery, try fsck
	    echo "EXT2FS mount failed, trying recovery..."
	    e2fsck -yf $rootdev
	    mount -t ext2fs $rootdev /mnt || {
		echo "EXT2FS mount failed"
		return 1
	    }
	}

	# hardwire the boss node
	if [ $setboss -eq 1 -a -d /mnt/etc/emulab ]; then
	    echo "  hardwiring boss to $bossnode"
	    cp $ETCDIR/bossnode /mnt/etc/emulab/bossnode || {
	        echo "Failed to create /etc/emulab/bossnode"
		umount $rootdev
		return 1
	    }
	fi

	# change the devices in fstab
	echo "  updating /etc/fstab"
	sed -i .preemulab -e "s;^/dev/[hs]d.\([0-7]\);/dev/${ldisk}\1;" /mnt/etc/fstab || {
	    echo "Failed to update /etc/fstab"
	    umount $rootdev
	    return 1
	}

	#
	# If filesystem has a UUID, make sure that is used in fstab.
	#
	# Note that we will only use the UUID if it is already being used
	# in the image we just downloaded. This is just because I don't want
	# to chance breaking some really old image.
	#
	if [ -n "$RUUID" ]; then
	    sed -E -i '' -e "s;^UUID=[^ ]+ +/ ;UUID=$RUUID / ;" /mnt/etc/fstab || {
		echo "Failed to update /etc/fstab"
		umount $rootdev
		return 1
	    }
	fi
	
	#
	# If there's a GRUB config file, update all root=X kernel params.
	#
	needfsck=0
	fgconf=""
	for f in grub.conf grub.cfg menu.lst; do
	    if [ -z "$fgconf" -a -r /mnt/boot/grub/$f ]; then
		fgconf=/boot/grub/$f
		gconf=/mnt$fgconf
	    fi
	done
	if [ -n "$fgconf" -a -r "$gconf" ]; then
	    echo "  updating $fgconf"

	    #
	    # We go out of our way to avoid changing grub.conf if we don't
	    # have to, since it might require us to fsck the filesystem
	    # afterward (see "XXX woeful hack" below).
	    #
	    tgconf="$gconf.tmp"
	    rm -f $tgconf
	    cp $gconf $tgconf || {
		echo "Cannot copy $fgconf, will change in place"
		cp -p $gconf $gconf.preemulab
		# XXX only do this if it appears that selinux is installed
		if [ -e /mnt/etc/selinux/config ]; then
		    needfsck=1
		fi
		tgconf=gconf
	    }

	    sed -i '' -e "s;\([br]oot=/dev\)/[hs]d.[0-7];\1/${ldisk}${part};" $tgconf || {
		echo "Failed to update $fgconf"
	    }

	    #
	    # Again, replace UUID if we have one and grub conf uses it already.
	    #
	    if [ -n "$RUUID" ]; then
		sed -i '' -e "s;\([br]oot=\)UUID=[^ ]* ;\1UUID=$RUUID ;" $tgconf || {
		    echo "Failed to update UUIDs in $fgconf"
		}
		
	    fi

	    #
	    # Tweak grub's notion of root.
	    # Note that grub's partition numbering is zero-based.
	    #
	    gdisk=`echo $dunit | sed -e 'y/abcdefgh/01234567/'`
	    gpart=`expr $part - 1`
	    #
	    # If we booted from a flash device we also have to further tweak
	    # grub's notion of root disk since the flash device will be "hd0".
	    # It appears that we do NOT have to update Linux's drive mapping.
	    #
	    if [ $FLASHBOOT -eq 1 ]; then
	        gdisk=`expr $gdisk + 1`
	    fi

	    # grub1
	    sed -i '' -e "s;root (hd[0-9],[0-9]);root (hd${gdisk},${gpart});" $tgconf || {
		echo "Failed to update root in $fgconf"
	    }

	    # grub2 (note 'part' and not 'gpart'; no -1 in grub2)
	    sed -i '' -e "s;set root='(hd[0-9],[^)]*)';set root='(hd${gdisk},${part})';" $tgconf || {
		echo "Failed to update root in $fgconf"
	    }

	    #
	    # Console. If there is no serial console, need to modify the
	    # grub config to use the vga only. 
	    #
	    if [ $VGAONLY = "yes" ]; then
		grep -E '^terminal.*serial' $tgconf >/dev/null 2>&1
		case $? in
		0)
		    echo "  changing grub terminal to console"
		    sed -i '' -e "s;^terminal;#terminal;" $tgconf || {
			echo "Failed to update terminal line in $fgconf"
		    }
		    echo "terminal --timeout=5 console" >> $tgconf
		    ;;
		*)
		    ;;
		esac
		
		# Added by Hussam to disable the serial line defination
		grep -E '^serial.*--speed' $tgconf >/dev/null 2>&1
		case $? in
		0)
		    echo "  disabling serial line config in grub"
	            sed -i '' -e "s;^serial;#serial;" $tgconf || {
			echo "Failed to update serial line in $fgconf"
		    }
		    ;;
		*)
	            ;;
		esac

		grep -E "console=ttyS" $tgconf >/dev/null 2>&1
		case $? in
		0)
		    echo "  changing grub kernel command to console"
		    sed -i '' -e 's;ttyS[^ ]*;tty0;' $tgconf || {
			echo "Failed to update console in $fgconf"
		    }
	            ;;
		*)
	            ;;
		esac
	    fi

	    #
	    # If we had to change something, then move the new version into
	    # place and mark that we did so.
	    #
	    if [ "$tgconf" != "$gconf" ]; then
		cmp -s $tgconf $gconf 2>/dev/null
		if [ $? -ne 0 ]; then
		    cp -p $gconf $gconf.preemulab
		    mv $tgconf $gconf || {
			echo "Failed to update $fgconf"
			mv $gconf.preemulab $gconf
		    }
		    # XXX only do this if it appears that selinux is installed
		    if [ -e /mnt/etc/selinux/config ]; then
			needfsck=1
		    fi
		fi
		rm -f $tgconf
	    fi
	fi

	#
	# If using lilo, update lilo.conf and set indicator to tell Emulab
	# to rerun lilo.
	#
	linux=
	lconf=/mnt/etc/lilo.conf
	if [ -r $lconf ]; then
	    echo "  updating /etc/lilo.conf"
	    sed -i .preemulab -e "s;\([br]oot=/dev\)/[hs]d.[0-7];\1/${ldisk}${part};" $lconf || {
		    echo "Failed to update /etc/lilo.conf"
		    umount $rootdev
		    return 1
	    }

	    # XXX note the hardwired path, cannot use BOOTDIR as it is
	    # different in frisbee MFS.  This also assumes Linux partition
	    # is one big filesystem.
	    cp /dev/null /mnt/var/emulab/boot/runlilo

	    # grab the default linux kernel to boot
	    linux=`lilogetkernel $lconf`
	fi

	#
	# Blacklist the hp ilo stuff.
	#
	if [ -d "/mnt/etc/modprobe.d" ]; then
	    modules="hpilo hpwdt"
	    for mod in ${modules}; do
		grep $mod /mnt/etc/modprobe.d/blacklist.conf >/dev/null 2>&1
		case $? in
		0)
		    ;;
		*)
		    echo "  blacklisting $mod"
                    echo "blacklist $mod" >> /mnt/etc/modprobe.d/blacklist.conf
	            ;;
		esac
            done
	fi

	if [ -f /mnt/var/lib/random-seed -a -c /dev/urandom ]; then
	    echo "  updating /var/lib/random-seed"
	    dd if=/dev/urandom of=/mnt/var/lib/random-seed bs=512 count=1 >/dev/null 2>&1
	fi

	#
	# Localize the image. We only do this if the MFS we are running in
	# has the necessary files.
	#
	if islocalized; then
	    # Check the certs.
	    if [ ! -d /mnt/etc/emulab ]; then
		mkdir -m 755 /mnt/etc/emulab || {
	            echo "Failed to mkdir /mnt/etc/emulab"
		    umount $rootdev
		    return 1
		}
	    fi
	    if [ -e $ETCDIR/emulab.pem ]; then
		cmp -s $ETCDIR/emulab.pem /mnt/etc/emulab/emulab.pem
		if [ $? -ne 0 ]; then
		    echo "  updating /mnt/etc/emulab/emulab.pem"
		    cp -p $ETCDIR/emulab.pem /mnt/etc/emulab/ || {
			echo "Failed to create $ETCDIR/emulab.pem"
			umount $rootdev
			return 1
		    }
		fi
	    fi
	    if [ -e $ETCDIR/client.pem ]; then
		cmp -s $ETCDIR/client.pem /mnt/etc/emulab/client.pem
		if [ $? -ne 0 ]; then
		    echo "  updating /mnt/etc/emulab/client.pem"
		    cp -p $ETCDIR/client.pem /mnt/etc/emulab/ || {
			echo "Failed to create $ETCDIR/client.pem"
			umount $rootdev
			return 1
		    }
		fi
	    fi

	    # Check the root keys.
	    if [ -e /root/.ssh/authorized_keys2 ]; then
		cmp -s /root/.ssh/authorized_keys2 /mnt/root/.ssh/authorized_keys
		if [ $? -ne 0 ]; then
		    echo "  updating /root/.ssh/authorized_keys"
		    
		    if [ ! -d /mnt/root/.ssh ]; then
			mkdir -m 700 /mnt/root/.ssh || {
			    echo "Failed to mkdir /root/.ssh"
			    umount $rootdev
			    return 1
			}
		    fi
		    # copy to both authorized_keys and _keys2
		    cp -p /root/.ssh/authorized_keys2 /mnt/root/.ssh/authorized_keys || {
			echo "Failed to create /root/.ssh/authorized_keys"
			umount $rootdev
			return 1
		    }
		    cp -p /root/.ssh/authorized_keys2 /mnt/root/.ssh/ || {
			echo "Failed to create /root/.ssh/authorized_keys2"
			umount $rootdev
			return 1
		    }
		fi
	    fi

  	    # Check the host keys.
	    changehostkeys=0
	    if [ -e /etc/ssh/ssh_host_key ]; then
		cmp -s /etc/ssh/ssh_host_key /mnt/etc/ssh/ssh_host_key
		if [ $? -ne 0 ]; then
		    changehostkeys=1
		fi
	    fi
	    if [ -e /etc/ssh/ssh_host_rsa_key ]; then
		cmp -s /etc/ssh/ssh_host_rsa_key /mnt/etc/ssh/ssh_host_rsa_key
		if [ $? -ne 0 ]; then
		    changehostkeys=1
		fi
	    fi
	    if [ -e /etc/ssh/ssh_host_dsa_key ]; then
		cmp -s /etc/ssh/ssh_host_dsa_key /mnt/etc/ssh/ssh_host_dsa_key
		if [ $? -ne 0 ]; then
		    changehostkeys=1
		fi
	    fi
	    if [ $changehostkeys -eq 1 ]; then
		echo "  updating /etc/ssh/hostkeys"

		if [ ! -d /mnt/etc/ssh ]; then
		    mkdir -m 755 /mnt/etc/ssh || {
			echo "Failed to mkdir /mnt/etc/ssh"
			umount $rootdev
			return 1
		    }
		fi
		cp -p /etc/ssh/ssh_host_* /mnt/etc/ssh/ || {
	            echo "Failed to create /etc/ssh/hostkeys"
		    umount $rootdev
		    return 1
		}
	    fi

	    # Check the time zone.
	    if [ -e /etc/localtime ]; then
		cmp -s /etc/localtime /mnt/etc/localtime
		if [ $? -ne 0 ]; then
		    echo "  updating /etc/localtime"

		    cp -p /etc/localtime /mnt/etc/localtime || {
			echo "Failed to create /etc/localtime"
			umount $rootdev
			return 1
		    }
		fi
	    fi
	fi

	# run any postconfig scripts:
	if [ -x $BINDIR/osconfig ]; then
	    echo "  checking for dynamic client-side updates to slice";
	    $BINDIR/osconfig -m /mnt -M '-t ext2fs' -f ext2fs \
		-D $rootdev -s Linux postload
	fi

	umount $rootdev

	#
	# XXX woeful hack. On an SELinux-enabled filesystem, grub.conf
	# might have an SELinux context and the BSD extfs implmentation
	# doesn't know how to deal with extended attributes and leaves
	# the FS in an inconsistent state. So if we changed grub.conf,
	# we must fsck the filesystem to clean up.
	#
	if [ $needfsck -ne 0 ]; then
	    echo -n "  ensuring FS is consistent..."
	    e2fsck -yf $rootdev >/dev/null 2>&1
	    if [ $? -ne 0 ]; then
		echo "FIXED"
	    else
		echo "OK"
	    fi
	fi

	if [ "x${linux}" != x ]; then
	    echo -n "  "
	    # setup one time lilo command line, must be done after unmount
	    $BINDIR/groklilo -c "$linux root=$lrootdev" $part /dev/$disk || {
		echo "Failed to set LILO command line"
		return 1
	    }
	fi

	return 0
}

fixone() {
    echo "*** ${disk}s${part}:"
    ptype=`fdisk -${part} ${disk} | grep sysid | sed 's/^sysid \([0-9][0-9]*\).*/\1/'`
    ptype=${ptype:-0}

    case $ptype in
    165)
	dofreebsd
	return $?
	;;
    131)
	dolinux
	return $?
	;;
    130)
	echo "ignoring Linux swap partition"
	;;
    7)
	echo "ignoring NTFS partition"
	;;
    0)
	echo "ignoring unused partition"
	;;
    *)
	echo "ignoring partition type $ptype"
	;;
    esac
    return 0
}

case $part in
0)
    part=1; fixone
    part=2; fixone
    part=3; fixone
    part=4; fixone

    # when fixing all partitions, do not fail on an error
    if [ $? -ne 0 ]; then
    	echo "WARNING: failed to fix one or more partitions, BEWARE!"
    fi

    # for the CD boot, we need to intialize the magic boot block
    if [ -e /cdrom.inf -a -x $BINDIR/tbbootconfig ]; then
	$BINDIR/tbbootconfig -f -c 1 -k 0 -m 1 /dev/${disk}
    fi
    ;;
1|2|3|4)
    fixone
    ;;
*)
    echo "bad partition: $part"
    false
    ;;
esac

exit $?
