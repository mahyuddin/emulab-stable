#!/usr/bin/perl -wT
#
# EMULAB-COPYRIGHT
# Copyright (c) 2009, 2010 University of Utah and the Flux Group.
# All rights reserved.
#
package libGeni;

use strict;
use Exporter;
use vars qw(@ISA @EXPORT);

@ISA    = "Exporter";
@EXPORT = qw();

# Configure variables
my $TB		= "@prefix@";
my $BOSSNODE    = "@BOSSNODE@";
my $TBDOCBASE   = "@TBDOCBASE@";

my $ASSIGN	= "$TB/libexec/assign";

use libdb;
use libtestbed;
use emutil;
use NodeType;
use Interface;
use Experiment;
use OSinfo;
use GeniEmulab;
use GeniResource;
use English;
use Socket;
use XML::Simple;
use Data::Dumper;
use File::Temp;
use IO::File;

sub Register($$)
{
    my ($experiment, $user) = @_;

    return GeniEmulab::RegisterExperiment($experiment, $user);
}

sub UnRegister($)
{
    my ($experiment) = @_;

    return GeniEmulab::UnRegisterExperiment($experiment);
}

sub RenewSlivers($;$)
{
    my ($experiment, $force) = @_;

    return GeniResource::RenewExperimentResources($experiment, $force);
}

#
# Map rspec to resources using assign. 
#
sub MapResources($$$$)
{
    my ($experiment, $user, $rspec, $verbose) = @_;
    my %cm_urns   = ();
    my %fragments = ();
    my %nodemap   = ();
    my %node_cms  = ();

    Register($experiment, $user) == 0
	or return -1;

    foreach my $ref (@{ $rspec->{'node'} }) {
	my %copy = %{ $ref };
	my $copy = \%copy;
	
	my $node_urn = $copy->{'component_urn'};
	my ($auth,$type,$node_id) = GeniHRN::Parse($node_urn);
	my $cm = GeniHRN::Generate($auth, "authority", "cm");

	$copy->{'component_manager_uuid'} = $cm;
	if ($node_id eq "*") {
	    # assign will use this, but its format is bogus. Kill it.
	    delete($copy->{'component_urn'});
	}
	else {
	    $copy->{'component_uuid'} = $node_urn;
	}
	$cm_urns{$cm} = $cm;

	#
	# The point of this is to split the rspec apart, since at present
	# assign cannot handle multiple advertisements, and it will not work
	# to pass in an rspec that references CMs other then the one
	# advertisement being passed in.
	#
	# This should go away when assign is fixed.
	#
	if (!exists($fragments{$cm})) {
	    $fragments{$cm} = {
		'generated_by' => 'libvtop',
		'type'  => 'request',
		'xmlns' => 'http://www.protogeni.net/resources/rspec/0.1',
		'node'  => [] };
	}
	push(@{ $fragments{$cm}->{'node'} }, $copy);
	$node_cms{$ref->{'virtual_id'}} = $cm;
	$nodemap{$ref->{'virtual_id'}}  = $ref;
    }

    #
    # As above, need to split the interfaces into the correct fragments.
    #
    if (exists($rspec->{'link'})) {
	foreach my $ref (@{ $rspec->{'link'} }) {
	    my $linkname   = $ref->{'virtual_id'};

	    # Skip tunnels until rspec stitching in place.
	    next
		if (exists($ref->{'link_type'}) &&
		    $ref->{'link_type'} eq "tunnel");
	    next
		if (0 && exists($ref->{'link_type'}) &&
		    exists($ref->{'link_type'}->{'type_name'}) &&
		    $ref->{'link_type'}->{'type_name'} eq "tunnel");

	    foreach my $ifaceref (@{ $ref->{'interface_ref'} }) {
		my $virtual_node_id = $ifaceref->{'virtual_node_id'};

		if (!exists($node_cms{$virtual_node_id}) ||
		    !exists($fragments{$node_cms{$virtual_node_id}})) {
		    print STDERR "Inconsistency in rspec link $linkname\n";
		    print Dumper($rspec);
		    return -1;
		}
		my $fragment = $fragments{$node_cms{$virtual_node_id}};
		if (!exists($fragment->{'link'})) {
		    $fragment->{'link'} = [];
		}
		push(@{ $fragment->{'link'} }, $ref);
		#
		# There should be a sanity check here ... too lazy. 
		#
		last;
	    }
	}
    }

    #
    # Get the resource objects.
    #
    foreach my $cm (keys(%cm_urns)) {
	my $resource = GeniResource->Lookup($experiment->idx(), $cm);
	if (!defined($resource)) {
	    $resource = GeniResource->Create($experiment, $cm);
	    if (!defined($resource)) {
		print STDERR "Could not create GeniResource for $cm\n";
		return -1;
	    }
	}
	$cm_urns{$cm} = $resource;
    }

    #
    # Discover resources at the component and run assign.
    #
    foreach my $cm (keys(%cm_urns)) {
	my $resource = $cm_urns{$cm};
	my $fragment = $fragments{$cm};
	my $advertisement;

	print STDERR "Asking for resource list from $resource\n";
	if ($resource->Discover($user, \$advertisement)) {
		print STDERR "Could not get resource list for $resource\n";
		return -1;
	}
	my $tmp  = File::Temp::mktemp("XXXXX");
	my $soln = $tmp . ".soln";
	my $log  = $tmp . ".log";
	my $ptop = $tmp . ".ptop";
	my $vtop = $tmp . ".vtop";

	my $reqstring =
	    eval { XMLout($fragment, "NoAttr" => 0, RootName => "rspec") };
	if ($@) {
	    print STDERR "XMLout error: $@\n";
	    print STDERR Dumper($fragment);
	    return -1;
	}

	my $vtopfh = new IO::File "> $vtop";
	my $ptopfh = new IO::File "> $ptop";
	if (! (defined($vtopfh) && defined($ptopfh))) {
	    print STDERR "Could not create temporary files for ptop/vtop\n";
	    return -1;
	}
	print $vtopfh "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n";
	print $vtopfh $reqstring;
	print $ptopfh $advertisement;
	$vtopfh->close();
	$ptopfh->close();

	system("nice $ASSIGN -uod -c .75 ".
	       "-q $ptop -w $vtop -W $soln > $log 2>&1");
	
	if ($?) {
	    print STDERR "Could not map to physical resources on $resource\n";
	    print STDERR Dumper($fragment);
	    return -1;
	}
	my $solution =
	    eval { XMLin($soln, KeyAttr => [],
			 ForceArray => ["node", "link", "interface",
					"interface_ref", "linkendpoints",
					"component_manager"]) };
	if ($@) {
	    print STDERR "XMLin error reading $soln: $@\n";
	    return -1;
	}
	if ($verbose) {
	    print STDERR "Solution for $resource\n";
	    print STDERR Dumper($solution);
	}

	foreach my $ref (@{ $solution->{'node'} }) {
	    my $virtual_id = $ref->{'virtual_id'};
	    my $node_uuid  = $ref->{'component_uuid'};
	    my $cm_urn     = $ref->{'component_manager_uuid'};
	    my $noderef    = $nodemap{$virtual_id};

	    #
	    # This writes the solution back into the original rspec. 
	    #
	    $noderef->{'component_uuid'} = $node_uuid;
	    $noderef->{'component_urn'}  = $node_uuid;
	    $noderef->{'component_manager_uuid'} = $cm_urn;

	    if (exists($ref->{'interface'})) {
		my $interfaces = $ref->{'interface'};

		foreach my $ifaceref (@{ $interfaces }) {
		    my $iface_id = $ifaceref->{'virtual_id'};
		    my $compid   = $ifaceref->{'component_id'};

		    # Not supposed to happen, but does cause of issues
		    # with tunnels and rspec stitching. 
		    next
			if (!defined($compid));

		    foreach my $oref (@{ $noderef->{'interface'} }) {
			if ($oref->{'virtual_id'} eq $iface_id) {
			    # write the solution back into the original rspec. 
			    $oref->{'component_id'} = $compid;
			    last;
			}
		    }
		}
	    }
	}
    }
    if (exists($rspec->{'link'})) {
	foreach my $ref (@{ $rspec->{'link'} }) {
	    my %cms = ();
	    my @cms = ();

	    foreach my $ifaceref (@{ $ref->{'interface_ref'} }) {
		my $virtual_node_id = $ifaceref->{'virtual_node_id'};
		my $node_cm = $node_cms{$virtual_node_id};

		if (!exists($cms{$node_cm})) {
		    push(@cms, {'id' => $node_cm});
		    $cms{$node_cm} = $node_cm;
		}
	    }
	    $ref->{'component_manager'} = [@cms];
	}
    }

    if ($verbose) {
	print STDERR "Final rspec:\n";
	print STDERR Dumper($rspec);
    }
    return 0;
}

sub GetTickets($$$$)
{
    my ($experiment, $impotent, $user, $rspec) = @_;
    my %cm_urns  = ();
    my %node_cms = ();

    Register($experiment, $user) == 0
	or return -1;

    foreach my $ref (@{ $rspec->{'node'} }) {
	#
	# Delete the fake lan nodes before sending off the request.
	# They were needed for the mapping above, but the remote CM
	# will barf on them.
	#
	if (0 && exists($ref->{'node_type'}) &&
	    exists($ref->{'node_type'}->{'type_name'}) &&
	    $ref->{'node_type'}->{'type_name'} eq "lan") {
	    next;
	}
	my $node_urn = $ref->{'component_urn'};
	my ($auth,$type,$node_id) = GeniHRN::Parse($node_urn);
	my $cm = GeniHRN::Generate($auth, "authority", "cm");

	$cm_urns{$cm} = $cm;
	$node_cms{$ref->{'virtual_id'}} = $cm;

	#
	# This is how we get the client side to do cooked mode properly.
	#
	$ref->{'tarfiles'} = "/usr/local/etc/emulab ".
	    "$TBDOCBASE/downloads/geniclient.tar";
    }

    #
    # Get the resource objects.
    #
    foreach my $cm (keys(%cm_urns)) {
	my $resource = GeniResource->Lookup($experiment->idx(), $cm);
	if (!defined($resource)) {
	    $resource = GeniResource->Create($experiment, $cm);
	    if (!defined($resource)) {
		print STDERR "Could not create GeniResource for $cm\n";
		return -1;
	    }
	}
	$cm_urns{$cm} = $resource;
    }

    #
    # Ask for tickets.
    #
    foreach my $cm (keys(%cm_urns)) {
	my $resource = $cm_urns{$cm};

	print STDERR "Asking for ticket from $resource\n";
	if ($resource->GetTicket($user, $rspec, $impotent)) {
	    print STDERR "Could not GetTicket for $resource\n";
	    print STDERR Dumper($rspec);
	    return -1;
	}
    }
    return 0;
}

#
# Redeem the tickets for an experiment. 
#
sub RedeemTickets($$$)
{
    my ($experiment, $user, $rspec) = @_;

    #
    # Get the resource objects.
    #
    my @resources = GeniResource->LookupAll($experiment);
    if (! @resources) {
	print STDERR "RedeemTickets: No resource objects\n";
	return 0;
    }

    foreach my $resource (@resources) {
	print STDERR "Redeeming ticket for $resource\n";
	if ($resource->RedeemTicket($user)) {
	    print STDERR
		"RedeemTicket: Could not redeem ticket for $resource\n";
	    return -1;
	}
    }

    return 0;
}

#
# Map the local nodes to the external nodes. This just sets some DB
# state for now.
#
sub MapNodes($$)
{
    my ($experiment, $verbose) = @_;
    my $eventkey = $experiment->eventkey();
    my $keyhash  = $experiment->keyhash();
    my %ifacemap = ();

    #
    # Get the resource objects.
    #
    my @resources = GeniResource->LookupAll($experiment);
    if (! @resources) {
	return 0;
    }

    foreach my $resource (@resources) {
	my $manifest = $resource->Manifest();
	return -1
	    if (!defined($manifest));

	print STDERR Dumper($manifest);
	
	foreach my $ref (@{ $manifest->{'node'} }) {
	    my $sliver_urn = $ref->{'sliver_urn'};
	    my $vname      = $ref->{'virtual_id'};

	    #
	    # The manifest can include nodes from other CMs. There will not
	    # be a sliver urn in that case.
	    #
	    my $component_manager_urn = $ref->{'component_manager_urn'};
	    next
		if (!defined($sliver_urn) && !defined($component_manager_urn));
	    
	    my $node = $experiment->VnameToNode($vname);
	    if (!defined($node)) {
		print STDERR
		    "MapNodes: Could not locate node $vname in $experiment\n";
		return -1;
	    }
	    $node->ModifyReservation({"external_resource_index" =>
					  $resource->idx(),
				      "external_resource_id"    =>
				          $sliver_urn})
		== 0 or return -1;

	    if (exists($ref->{'sshdport'})) {
		my $sshdport = $ref->{'sshdport'};

		$node->Update({'sshdport' => $sshdport});
	    }
	    #
	    # This is how we get the client side to do cooked mode properly.
	    #
	    my $cmd = "sudo /usr/local/etc/emulab/rc/rc.pgeni ".
		"-s $BOSSNODE -k $eventkey,$keyhash -u '$sliver_urn'";
	    $cmd .= " -j " . $node->node_id()
		if ($node->isvirtnode());
	    
	    $ref->{'startup_command'} = "$cmd boot";

	    # Interface map for loop below.
	    if (exists($ref->{'interface'})) {
		foreach my $ifaceref (@{ $ref->{'interface'} }) {
		    my $virtid = $ifaceref->{'virtual_id'};
		    my $compid = $ifaceref->{'component_id'};

		    $ifacemap{$virtid} = [$node, $compid];
		}
	    }
	}
	foreach my $ref (@{ $manifest->{'link'} }) {
	    my $linkname   = $ref->{"virtual_id"};
	    my $interfaces = $ref->{'interface_ref'};
	    my %managers   = map { $_->{'id'} => $_->{'id'} }
	                        @{ $ref->{'component_manager'} };

	    # Skip tunnels in this loop for now.
	    next
		if (exists($ref->{'link_type'}) &&
		    $ref->{'link_type'} eq "tunnel");

	    #
	    # The manifest can include links for other CMs. Skip those
	    # for now.
	    #
	    next 
		if (!exists($managers{$resource->manager_urn()}));

	    foreach my $ifaceref (@{ $interfaces }) {
		my $vname    = $ifaceref->{'virtual_node_id'};
		my $iface_id = $ifaceref->{'virtual_interface_id'};
		my $MAC      = $ifaceref->{'MAC'};
		my ($node, $compid) = @{ $ifacemap{$iface_id} };
		my $iface;

		if (GeniHRN::IsValid($compid)) {
		    (undef,undef,$iface) = GeniHRN::ParseInterface($compid);
		}
		else {
		    $iface = $compid;
		}
		if (!defined($iface)) {
		    print STDERR "Could not determine iface for" .
			"$vname,$iface_id\n";
		    print STDERR Dumper($manifest);
		    return -1;
		}
		my $interface = Interface->LookupByIface($node,$iface);
		if (!defined($interface)) {
		    print STDERR "Could not map iface for $node,$iface\n";
		    print STDERR Dumper($manifest);
		    return -1;
		}
		if (! ($MAC =~ /^[\w]*$/)) {
		    print STDERR "Bad mac '$MAC' for $node,$iface\n";
		    print STDERR Dumper($manifest);
		    return -1;
		}
		if ($interface->Update({"mac" => "$MAC"})) {
		    print STDERR "Could not update mac for $node,$iface\n";
		    print Dumper($manifest);
		    return -1;
		}
	    }
	}
	# The manifest was changed above.
	if ($resource->UpdateManifest($manifest)) {
	    print STDERR "Could not store manifest for $resource\n";
	    return -1;
	}
    }
    return 0;
}

#
# Boot (Start) all of the slivers. This does the entire set, and blocks
# till done.
#
sub StartSlivers($$)
{
    my ($experiment, $user) = @_;

    #
    # Get the resource objects.
    #
    my @resources = GeniResource->LookupAll($experiment);
    if (! @resources) {
	return 0;
    }

    #
    # Start slivers in parallel.
    # 
    my @results = ();
    my $coderef = sub {
	my ($resource) = @_;

	print STDERR "Starting ($$) sliver $resource\n";
	
	return $resource->StartSliver($user);
    };
    if (ParRun(undef, \@results, $coderef, @resources)) {
	print STDERR "*** StartSlivers: Internal error starting slivers.\n";
	return -1;
    }
    #
    # Check the exit codes. Eventually return specific error info.
    #
    my $errors = 0;
    my $count  = 0;
    my @tmp    = ();
    foreach my $result (@results) {
	my $resource = $resources[$count];
	
	if ($result != 0) {
	    print STDERR "*** Error starting slivers for $resource\n";
	    $errors++;
	}
	else {
	    push(@tmp, $resource);
	}
	$count++;
    }
    return WaitForSlivers($experiment, $user, @tmp);
}

sub WaitForSlivers($$@)
{
    my ($experiment, $user, @resources) = @_;
    my %nodemap = ();

    #
    # Get the resource objects.
    #
    @resources = GeniResource->LookupAll($experiment)
	if (!@resources);
    
    if (! @resources) {
	return 0;
    }

    #
    # Build a map of the nodes. I made a real mess of this in Version 1.
    #
    foreach my $resource (@resources) {
	my $manifest = $resource->Manifest();
	return -1
	    if (!defined($manifest));

	foreach my $ref (@{ $manifest->{'node'} }) {
	    my $vname      = $ref->{'virtual_id'};
	    my $urn        = $ref->{'component_urn'};
	    my $node       = $experiment->VnameToNode($vname);

	    #
	    # The manifest can include nodes from other CMs. There will not
	    # be a sliver urn in that case.
	    #
	    my $sliver_urn = $ref->{'sliver_urn'};
	    next
		if (!defined($sliver_urn));
	    
	    if (!defined($node)) {
		print STDERR "WaitForSlivers: ".
		    "Could not locate node $vname in $experiment\n";
		return -1;
	    }
	    if ($resource->ManagerVersion() == 1.0) {
		my ($domain,undef,$node_id) = GeniHRN::Parse($urn);
		$urn = GeniHRN::Generate($domain, "sliver", $node_id);
		$nodemap{$urn} = $node;
	    }
	    else {
		next
		    if (!defined($node->external_resource_id()) ||
			$node->external_resource_id() eq "");

		$nodemap{$node->external_resource_id()} = $node;
	    }
	    $node->Refresh();
	}
    }

    #
    # Now we use parrun again to get the sliver status. We are waiting
    # for them to become ready so we can send them into ISUP. 
    #
    my $coderef = sub {
	my ($resource) = @_;
	my $ref;
	my $notready = 0;

	print STDERR "Waiting ($$) for sliver $resource\n";

	if ($resource->SliverStatus($user, \$ref) != 0) {
	    print STDERR "Error getting sliver status for $resource\n";
	    # Tell the parent error.
	    return -1;
	}
	print STDERR Dumper($ref);

	foreach my $key (keys(%{ $ref->{'details'} })) {
	    my $val  = $ref->{'details'}->{$key};
	    my ($status, $node);

	    if ($resource->ManagerVersion() == 1.0) {
		$node   = $nodemap{$key};
		$status = $val;
	    }
	    elsif ($resource->ManagerVersion() == 2.0) {
		$node   = $nodemap{$key};
		$status = $val->{'status'};
	    }
	    else {
		print STDERR
		    "*** WaitForSlivers: Unknown version on $resource\n";
		next;
	    }

	    if (!defined($node)) {
		print STDERR "No node in map for $key ($resource)\n";
		next;
	    }
	    # State was changed in a another process.
	    $node->Refresh();

	    #
	    # Only send on state change to avoid multiple events.
	    #
	    if ($status eq "ready" && !$node->IsUp()) {
#		print STDERR "    Sending ISUP event.\n";
#		$node->SetEventState(TBDB_NODESTATE_ISUP());
	    }
	    elsif ($status eq "failed" &&
		   $node->eventstate() ne TBDB_NODESTATE_TBFAILED) {
#		print STDERR "    Sending TBFAILED event.\n";
#		$node->SetEventState(TBDB_NODESTATE_TBFAILED());
	    }
	    else {
		$notready++;
	    }
	}
	# Tell the parent to stop if ready or all failed.
	if ($ref->{'status'} eq "ready" || $notready == 0) {
	    return 0;
	}
	# Tell the parent not ready.
	return 1;
    };
    while (@resources) {
	my @results = ();
	
	if (ParRun(undef, \@results, $coderef, @resources)) {
	    print STDERR
		"*** WaitForSlivers: Internal error waiting on slivers.\n";
	    return -1;
	}

	my @tmp = ();
	while (@results) {
	    my $result   = pop(@results);
	    my $resource = pop(@resources);
	    if ($result > 0) {
		push(@tmp, $resource);
	    }
	}
	@resources = @tmp;

	#
	# Check for cancelation. When canceled, go through and mark
	# any nodes that have not been marked, as failed. This will
	# stop the waiting up in os_setup.
	#
	if ($experiment->canceled()) {
	    foreach my $resource (@resources) {	
		my $manifest = $resource->Manifest();
		next
		    if (!defined($manifest));

		foreach my $ref (@{ $manifest->{'node'} }) {
		    my $vname      = $ref->{'virtual_id'};
		    my $node       = $experiment->VnameToNode($vname);
		    next
			if (!defined($node));
		    # State was changed in child process.
		    $node->Refresh();

		    if ($node->eventstate() ne TBDB_NODESTATE_ISUP &&
			$node->eventstate() ne TBDB_NODESTATE_TBFAILED) {
			$node->SetEventState(TBDB_NODESTATE_TBFAILED());
		    }
		}
	    }
	    return 0;
	}

	sleep(10)
	    if (@resources);
    }
    return 0;
}

#
# Delete all slivers for an Experiment.
#
sub DeleteAllSlivers($$)
{
    my ($experiment, $user) = @_;

    #
    # Get the resource objects.
    #
    my @resources = GeniResource->LookupAll($experiment);
    if (! @resources) {
	return 0;
    }

    foreach my $resource (@resources) {
	print STDERR "Deleting sliver for $resource\n";
	if ($resource->Clear($user)) {
	    print STDERR "DeleteSlivers: Could not clear $resource\n";
	    return -1;
	}
	if ($resource->Delete()) {
	    print STDERR "DeleteSlivers: Could not delete $resource\n";
	    return -1;
	}
    }

    return 0;
}

#
# Find the proxy (widearea) node given a urn.
#
sub LookupProxyNode($)
{
    my ($node_urn) = @_;

    my $query_result =
	DBQueryWarn("select node_id,hostname from widearea_nodeinfo ".
		    "where external_node_id='$node_urn'");
    return undef
	if (!$query_result);

    if ($query_result->numrows) {
	my ($node_id,$hostname) = $query_result->fetchrow_array();
	my $node = Node->Lookup($node_id);
	if (!defined($node)) {
	    print STDERR "Could not get object for $node_id ($node_urn)\n";
	    return undef;
	}
	return $node;
    }

    #
    # We have to create the local node proxy. 
    #
    return GeniEmulab::CreatePhysNode($node_urn);
}

1;
