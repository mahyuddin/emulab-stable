#!/usr/bin/perl -wT
#
# EMULAB-COPYRIGHT
# Copyright (c) 2009 University of Utah and the Flux Group.
# All rights reserved.
#
package libGeni;

use strict;
use Exporter;
use vars qw(@ISA @EXPORT);

@ISA    = "Exporter";
@EXPORT = qw();

# Configure variables
my $TB		= "@prefix@";
my $BOSSNODE    = "@BOSSNODE@";
my $TBDOCBASE   = "@TBDOCBASE@";

my $ASSIGN	= "$TB/libexec/assign";

use libdb;
use libtestbed;
use emutil;
use NodeType;
use Interface;
use Experiment;
use OSinfo;
use GeniEmulab;
use GeniResource;
use English;
use Socket;
use XML::Simple;
use Data::Dumper;
use File::Temp;

sub Register($$)
{
    my ($experiment, $user) = @_;

    return GeniEmulab::RegisterExperiment($experiment, $user);
}

sub UnRegister($)
{
    my ($experiment) = @_;

    return GeniEmulab::UnRegisterExperiment($experiment);
}

#
# Map rspec to resources using assign. 
#
sub MapResources($$$)
{
    my ($experiment, $user, $rspec) = @_;
    my %cm_urns   = ();
    my %fragments = ();
    my %nodemap   = ();
    my %node_cms  = ();

    Register($experiment, $user) == 0
	or return -1;

    foreach my $ref (@{ $rspec->{'node'} }) {
	my $node_urn = $ref->{'component_urn'};
	my ($auth,$type,$node_id) = GeniHRN::Parse($node_urn);
	my $cm = GeniHRN::Generate($auth, "authority", "cm");

	$ref->{'component_manager_uuid'} = $cm;
	if ($node_id ne "*") {
	    $ref->{'component_uuid'} = $node_urn;
	}
	$cm_urns{$cm} = $cm;

	#
	# The point of this is to split the rspec apart, since at present
	# assign cannot handle multiple advertisements, and it will not work
	# to pass in an rspec that references CMs other then the one
	# advertisement being passed in.
	#
	# This should go away when assign is fixed.
	#
	if (!exists($fragments{$cm})) {
	    $fragments{$cm} = {
		'type'  => 'request',
		'xmlns' => 'http://www.protogeni.net/resources/rspec/0.1',
		'node'  => [] };
	}
	push(@{ $fragments{$cm}->{'node'} }, $ref);
	$node_cms{$ref->{'virtual_id'}} = $cm;
	$nodemap{$ref->{'virtual_id'}}  = $ref;
    }
    #
    # As above, need to split the interfaces into the correct fragments.
    #
    if (exists($rspec->{'link'})) {
	foreach my $ref (@{ $rspec->{'link'} }) {
	    my $linkname   = $ref->{'virtual_id'};

	    foreach my $ifaceref (@{ $ref->{'interface_ref'} }) {
		my $virtual_node_id = $ifaceref->{'virtual_node_id'};

		if (!exists($node_cms{$virtual_node_id}) ||
		    !exists($fragments{$node_cms{$virtual_node_id}})) {
		    print STDERR "Inconsistency in rspec link $linkname\n";
		    print Dumper($rspec);
		    return -1;
		}
		my $fragment = $fragments{$node_cms{$virtual_node_id}};
		if (!exists($fragment->{'link'})) {
		    $fragment->{'link'} = [];
		}
		push(@{ $fragment->{'link'} }, $ref);
		#
		# There should be a sanity check here ... too lazy. 
		#
		last;
	    }
	}
    }
	
    #
    # Get the resource objects.
    #
    foreach my $cm (keys(%cm_urns)) {
	my $resource = GeniResource->Lookup($experiment->idx(), $cm);
	if (!defined($resource)) {
	    $resource = GeniResource->Create($experiment, $cm);
	    if (!defined($resource)) {
		print STDERR "Could not create GeniResource for $cm\n";
		return -1;
	    }
	}
	$cm_urns{$cm} = $resource;
    }

    #
    # Discover resources at the component and run assign.
    #
    foreach my $cm (keys(%cm_urns)) {
	my $resource = $cm_urns{$cm};
	my $fragment = $fragments{$cm};
	my $advertisement;

	print STDERR "Asking for resource list from $resource\n";
	if ($resource->Discover($user, \$advertisement)) {
		print STDERR "Could not get resource list for $resource\n";
		return -1;
	}
	my $vtop = new File::Temp(TEMPLATE => 'XXXXX',
				  UNLINK => 0,
				  SUFFIX => '.vtop');
	my $ptop = new File::Temp(TEMPLATE => 'XXXXX',
				  UNLINK => 0,
				  SUFFIX => '.ptop');
	my $tmp  = File::Temp::mktemp("/tmp/XXXXX") . ".soln";

	my $reqstring =
	    eval { XMLout($fragment, "NoAttr" => 0, RootName => "rspec") };
	if ($@) {
	    print STDERR "XMLout error: $@\n";
	    return -1;
	}

	print $vtop "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n";
	print $vtop $reqstring;
	print $ptop $advertisement;

	system("$ASSIGN -uod -c .75 -q $ptop -w $vtop -W $tmp");
	if ($?) {
	    print STDERR "Could not map to physical resources on $resource\n";
	    return -1;
	}
	my $solution =
	    eval { XMLin($tmp, KeyAttr => [],
			 ForceArray => ["node", "link", "interface",
					"interface_ref", "linkendpoints"]) };
	if ($@) {
	    print STDERR "XMLin error: $@\n";
	    return -1;
	}
	print STDERR Dumper($solution);

	foreach my $ref (@{ $solution->{'node'} }) {
	    my $virtual_id = $ref->{'virtual_id'};
	    my $node_urn   = $ref->{'component_uuid'};
	    my $cm_urn     = $ref->{'component_manager_uuid'};
	    my $noderef    = $nodemap{$virtual_id};

	    $noderef->{'component_uuid'} = $node_urn;

	    if (exists($ref->{'interface'})) {
		my $interfaces = $ref->{'interface'};

		foreach my $ifaceref (@{ $interfaces }) {
		    my $iface_id = $ifaceref->{'virtual_id'};
		    my $compid   = $ifaceref->{'component_name'};

		    foreach my $oref (@{ $noderef->{'interface'} }) {
			if ($oref->{'virtual_id'} eq $iface_id) {
			    $oref->{'component_id'} = $compid;
			    last;
			}
		    }
		}
	    }
	}
    }
    print STDERR Dumper($rspec);
    return 0;
}

sub GetTickets($$$$)
{
    my ($experiment, $impotent, $user, $rspec) = @_;
    my %cm_urns = ();

    Register($experiment, $user) == 0
	or return -1;

    foreach my $ref (@{ $rspec->{'node'} }) {
	my $node_urn = $ref->{'component_urn'};
	my ($auth,$type,$node_id) = GeniHRN::Parse($node_urn);
	my $cm = GeniHRN::Generate($auth, "authority", "cm");

	$cm_urns{$cm} = $cm;

	#
	# This is how we get the client side to do cooked mode properly.
	#
	$ref->{'tarfiles'} = "/usr/local/etc/emulab ".
	    "$TBDOCBASE/downloads/geniclient.tar";
    }
    print STDERR Dumper($rspec);

    #
    # Get the resource objects.
    #
    foreach my $cm (keys(%cm_urns)) {
	my $resource = GeniResource->Lookup($experiment->idx(), $cm);
	if (!defined($resource)) {
	    $resource = GeniResource->Create($experiment, $cm);
	    if (!defined($resource)) {
		print STDERR "Could not create GeniResource for $cm\n";
		return -1;
	    }
	}
	$cm_urns{$cm} = $resource;
    }
    #
    # Ask for tickets.
    #
    foreach my $cm (keys(%cm_urns)) {
	my $resource = $cm_urns{$cm};

	print STDERR "Asking for ticket from $resource\n";
	if ($resource->GetTicket($user, $rspec, $impotent)) {
		print STDERR "Could not GetTicket for $resource\n";
		return -1;
	}
    }

    #
    # If we can get all of the tickets, lets create the physical nodes
    # we need.
    #
    foreach my $cm (keys(%cm_urns)) {
	my $resource = $cm_urns{$cm};
	my $ticket   = $resource->Ticket();

	if (!defined($ticket)) {
	    print STDERR "No ticket defined for $resource\n";
	    return -1;
	}
	my $rspec = $ticket->rspec();
	if (!defined($rspec)) {
	    print STDERR "No rspec defined for $ticket on $resource\n";
	    return -1;
	}
	foreach my $ref (@{ $rspec->{'node'} }) {
	    my $node_urn = $ref->{'component_uuid'};
	    my $cm_urn   = $ref->{'component_manager_uuid'};

	    $ref->{'component_urn'} = $node_urn;

	    print STDERR "Creating $node_urn for $resource\n";
	    my $node = GeniEmulab::CreatePhysNode($node_urn);
	    if (!defined($node)) {
		print STDERR "  Could not create $node_urn!\n";
		return -1;
	    }
	}
    }
    return 0;
}

#
# Redeem the tickets for an experiment. 
#
sub RedeemTickets($$$)
{
    my ($experiment, $user, $rspec) = @_;

    #
    # Get the resource objects.
    #
    my @resources = GeniResource->LookupAll($experiment);
    if (! @resources) {
	print STDERR "RedeemTickets: No resource objects\n";
	return 0;
    }

    foreach my $resource (@resources) {
	print STDERR "Redeeming ticket for $resource\n";
	if ($resource->RedeemTicket($user)) {
	    print STDERR
		"RedeemTicket: Could not redeem ticket for $resource\n";
	    return -1;
	}
    }

    return 0;
}

#
# Map the local nodes to the external nodes. This just sets some DB
# state for now.
#
sub MapNodes($)
{
    my ($experiment) = @_;
    my %ifacemap = ();

    #
    # Get the resource objects.
    #
    my @resources = GeniResource->LookupAll($experiment);
    if (! @resources) {
	return 0;
    }

    foreach my $resource (@resources) {
	my $manifest = $resource->Manifest();
	return -1
	    if (!defined($manifest));

	foreach my $ref (@{ $manifest->{'node'} }) {
	    my $sliver_urn = $ref->{'sliver_urn'};
	    my $vname      = $ref->{'virtual_id'};
	    my $node       = $experiment->VnameToNode($vname);

	    if (!defined($node)) {
		print STDERR
		    "MapNodes: Could not locate node $vname in $experiment\n";
		return -1;
	    }
	    $node->ModifyReservation({"external_resource_index" =>
					  $resource->idx(),
				      "external_resource_id"    =>
				          $sliver_urn})
		== 0 or return -1;

	    if (exists($ref->{'sshdport'})) {
		my $sshdport = $ref->{'sshdport'};

		$node->Update({'sshdport' => $sshdport});
	    }
	    if (exists($ref->{'interface'})) {
		foreach my $ifaceref (@{ $ref->{'interface'} }) {
		    my $virtid = $ifaceref->{'virtual_id'};
		    my $compid = $ifaceref->{'component_id'};

		    $ifacemap{$virtid} = [$node, $compid];
		}
	    }
	}
	foreach my $ref (@{ $manifest->{'link'} }) {
	    my $linkname   = $ref->{"virtual_id"};
	    my $interfaces = $ref->{'interface_ref'};

	    foreach my $ifaceref (@{ $interfaces }) {
		my $vname    = $ifaceref->{'virtual_node_id'};
		my $iface_id = $ifaceref->{'virtual_interface_id'};
		my $MAC      = $ifaceref->{'MAC'};
		my ($node, $compid) = @{ $ifacemap{$iface_id} };
		my $iface;

		if (GeniHRN::IsValid($compid)) {
		    (undef,undef,$iface) = GeniHRN::ParseInterface($compid);
		}
		else {
		    $iface = $compid;
		}
		if (!defined($iface)) {
		    print STDERR "Could not determine iface for" .
			"$vname,$iface_id\n";
		    print Dumper($manifest);
		    return -1;
		}
		my $interface = Interface->LookupByIface($node,$iface);
		if (!defined($interface)) {
		    print STDERR "Could not map iface for $node,$iface\n";
		    print Dumper($manifest);
		    return -1;
		}
		if (! ($MAC =~ /^[\w]*$/)) {
		    print STDERR "Bad mac '$MAC' for $node,$iface\n";
		    print Dumper($manifest);
		    return -1;
		}
		if ($interface->Update({"mac" => "$MAC"})) {
		    print STDERR "Could not update mac for $node,$iface\n";
		    print Dumper($manifest);
		    return -1;
		}
	    }
	}
    }
    return 0;
}

#
# Boot (Start) all of the slivers. This does the entire set, and blocks
# till done.
#
sub StartSlivers($$)
{
    my ($experiment, $user) = @_;

    #
    # Get the resource objects.
    #
    my @resources = GeniResource->LookupAll($experiment);
    if (! @resources) {
	return 0;
    }

    #
    # Start slivers in parallel.
    # 
    my @results = ();
    my $coderef = sub {
	my ($resource) = @_;

	print STDERR "Starting ($$) sliver $resource\n";
	
	return $resource->StartSliver($user);
    };
    if (ParRun(undef, \@results, $coderef, @resources)) {
	print STDERR "*** StartSlivers: Internal error starting slivers.\n";
	return -1;
    }
    #
    # Check the exit codes. Eventually return specific error info.
    #
    my $errors = 0;
    my $count  = 0;
    my @tmp    = ();
    foreach my $result (@results) {
	my $resource = $resources[$count];
	
	if ($result != 0) {
	    print STDERR "*** Error starting slivers for $resource\n";
	    $errors++;
	}
	else {
	    push(@tmp, $resource);
	}
	$count++;
    }
    return WaitForSlivers($experiment, $user, @tmp);
}

sub WaitForSlivers($$@)
{
    my ($experiment, $user, @resources) = @_;
    my %nodemap = ();

    #
    # Get the resource objects.
    #
    @resources = GeniResource->LookupAll($experiment)
	if (!@resources);
    
    if (! @resources) {
	return 0;
    }

    #
    # Build a map of the nodes.
    #
    my @nodelist = $experiment->NodeList(0, 1);
    foreach my $node (@nodelist) {
	next
	    if (!defined($node->external_resource_id()) ||
		$node->external_resource_id() eq "");
	
	$nodemap{$node->external_resource_id()} = $node;
	$node->Refresh();
    }

    #
    # Now we use parrun again to get the sliver status. We are waiting
    # for them to become ready so we can send them into ISUP. 
    #
    my $coderef = sub {
	my ($resource) = @_;
	my $ref;
	my $notready = 0;

	print STDERR "Waiting ($$) for sliver $resource\n";

	if ($resource->SliverStatus($user, \$ref) != 0) {
	    print STDERR "Error getting sliver status for $resource\n";
	    # Tell the parent error.
	    return -1;
	}
	print STDERR Dumper($ref);

	foreach my $key (keys(%{ $ref->{'detailsNew'} })) {
	    my $val  = $ref->{'detailsNew'}->{$key};
	    my $node = $nodemap{$key};

	    if (!defined($node)) {
		print STDERR "No node in map for $key ($resource)\n";
		next;
	    }
	    # State was changed in a another process.
	    $node->Refresh();

	    #
	    # Only send on state change to avoid multiple events.
	    #
	    if ($val eq "ready" && !$node->IsUp()) {
		print STDERR "    Sending ISUP event.\n";
		$node->SetEventState(TBDB_NODESTATE_ISUP());
	    }
	    elsif ($val eq "failed" &&
		   $node->eventstate() ne TBDB_NODESTATE_TBFAILED) {
		print STDERR "    Sending TBFAILED event.\n";
		$node->SetEventState(TBDB_NODESTATE_TBFAILED());
	    }
	    else {
		$notready++;
	    }
	}
	# Tell the parent to stop if ready or all failed.
	if ($ref->{'status'} eq "ready" || $notready == 0) {
	    return 0;
	}
	# Tell the parent not ready.
	return 1;
    };
    while (@resources) {
	my @results = ();
	
	if (ParRun(undef, \@results, $coderef, @resources)) {
	    print STDERR
		"*** WaitForSlivers: Internal error waiting on slivers.\n";
	    return -1;
	}

	my @tmp = ();
	while (@results) {
	    my $result   = pop(@results);
	    my $resource = pop(@resources);
	    if ($result > 0) {
		push(@tmp, $resource);
	    }
	}
	@resources = @tmp;

	#
	# Check for cancelation. When canceled, go through and mark
	# any nodes that have not been marked, as failed. This will
	# stop the waiting up in os_setup.
	#
	if ($experiment->canceled()) {
	    foreach my $resource (@resources) {	
		my $manifest = $resource->Manifest();
		next
		    if (!defined($manifest));

		foreach my $ref (@{ $manifest->{'node'} }) {
		    my $vname      = $ref->{'virtual_id'};
		    my $node       = $experiment->VnameToNode($vname);
		    next
			if (!defined($node));
		    # State was changed in child process.
		    $node->Refresh();

		    if ($node->eventstate() ne TBDB_NODESTATE_ISUP &&
			$node->eventstate() ne TBDB_NODESTATE_TBFAILED) {
			$node->SetEventState(TBDB_NODESTATE_TBFAILED());
		    }
		}
	    }
	    return 0;
	}

	sleep(10)
	    if (@resources);
    }
    return 0;
}

#
# Delete all slivers for an Experiment.
#
sub DeleteAllSlivers($$)
{
    my ($experiment, $user) = @_;

    #
    # Get the resource objects.
    #
    my @resources = GeniResource->LookupAll($experiment);
    if (! @resources) {
	return 0;
    }

    foreach my $resource (@resources) {
	print STDERR "Deleting sliver for $resource\n";
	if ($resource->Clear($user)) {
	    print STDERR
		"DeleteSlivers: Could not delete sliver for $resource\n";
	    return -1;
	}
    }

    return 0;
}

#
# Find the proxy (widearea) node given a urn.
#
sub LookupProxyNode($)
{
    my ($node_urn) = @_;

    my $query_result =
	DBQueryWarn("select node_id,hostname from widearea_nodeinfo ".
		    "where external_node_id='$node_urn'");
    return undef
	if (!$query_result);

    if ($query_result->numrows) {
	my ($node_id,$hostname) = $query_result->fetchrow_array();
	my $node = Node->Lookup($node_id);
	if (!defined($node)) {
	    print STDERR "Could not get object for $node_id ($node_urn)\n";
	    return undef;
	}
	return $node;
    }

    #
    # We have to create the local node proxy. 
    #
    return GeniEmulab::CreatePhysNode($node_urn);
}

1;
