#!/usr/bin/perl -w

#
# node_status - Updates the 'status' column in the nodes table to indicate
# whether nodes are pingable, etc.
# Intended to be run as a cronjob
# Requires 'fping' to be installed
#

############################## Defines and includes
my $fping = "/usr/local/sbin/fping"; # Path to fping

use strict;
use English;
use IPC::Open2;

# Configure variables
use lib '@prefix@/lib';
use libdb;

#
# Only root and admins are allowed to use this script
#
if (($UID != 0) && (!TBAdmin())) {
	die "Only root and admins are allowed to use this script\n";
}

############################## Get node list
my $query = "SELECT nodes.node_id, nodes.status, os_info.osfeatures " .
            "FROM nodes LEFT JOIN os_info ON nodes.def_boot_osid = os_info.osid ";
my $result = DBQueryFatal($query);

############################## Determine pingable/unpingable nodes
my (@newlyUp, @newlyDown, @newlyPD, @newlyUnpingable) = ();

my $fpingPID = &open2("FOUT","FIN","$fping"); # Throws an exception on failure

my %oldStatus = (); # Status of node from the DB, so we can tell if it changed

while (my %row = $result->fetchhash) {
	my $node = $row{node_id};
	if ($row{osfeatures} && ($row{osfeatures} =~ /ping/)) {
		# We have a node that should be capable of returning pings
		$oldStatus{$node} = $row{status};
		print FIN $node,"\n"; # Give fping another node to ping
	} else {
		# This node can't return pings
		if ((!$row{status}) || ($row{status} ne 'unpingable')) {
			push @newlyUnpingable, $node;
		}
	}
}
close(FIN); # Tell fping we're done giving it nodes

############################## Determine status changes
while (<FOUT>) { # Read fping results
	chomp;
	my ($node,$status) = split /\s+/,$_,2;
	
	if ($status eq "is alive") {
		if ($oldStatus{$node} ne "up") {
			push @newlyUp,$node;
		}
	} else { # Node must not have returned a ping
		if ($oldStatus{$node} eq "possibly down") {
			push @newlyDown, $node;
		} elsif ($oldStatus{$node} ne "down") {
			push @newlyPD, $node;
		}
	}
}
close(FOUT);

############################## Write back changes
# When I started this section, it seemed a clever way to avoid code
# duplication. Now, I'm not so sure :)
foreach (['down', @newlyDown], ['up', @newlyUp],
		['possibly down', @newlyPD], ['unpingable', @newlyUnpingable]) {
	my $status = shift @$_;
	my @nodes = @$_;
	if (@nodes) {
		my $query = "UPDATE nodes SET status='$status' WHERE " .
			join " OR ", map("node_id='$_'",@nodes);
		DBQueryFatal($query);
	}
}
