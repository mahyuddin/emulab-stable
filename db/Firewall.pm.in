#!/usr/bin/perl -w
#
# EMULAB-COPYRIGHT
# Copyright (c) 2009 University of Utah and the Flux Group.
# All rights reserved.
#

#
# Some firewall stuff.
#
package Firewall;
use strict;
use Exporter;
use vars qw(@ISA @EXPORT);
@ISA = "Exporter";
@EXPORT = qw ( doFWlans undoFWNodes
	       FWSETUP FWADDNODES FWDELNODES FWTEARDOWN
	       );

# Configure variables
my $TB	      = "@prefix@";
my $TBOPS     = "@TBOPSEMAIL@";
my $POWER     = "$TB/bin/power";
my $SNMPIT    = "$TB/bin/snmpit";

# Flags.
sub FWSETUP()		{ return 1; }
sub FWADDNODES()	{ return 2; }
sub FWDELNODES()	{ return 3; }
sub FWTEARDOWN()	{ return 4; }

# XXX fixme: should not be hardwired!
my $cnetstack    = "-S Control";
my $cnetvlanname = "Control";

use lib '@prefix@/lib';
use emdbi;
use libdb;
use libtestbed;
use libadminmfs;
use libtblog_simple;
use Node;
use Interface;
use Experiment;
use Lan;

#
# Setup and teardown experiment firewall.
#
# XXX note that right now, we just setup the switch infrastructure
# first, and then just let everything else go.  Firewalled nodes will
# not boot until the firewall is up since the VLAN is isolated til then.
# The firewall will boot ok since it still talks to the real control net.
#
# XXX for tearing down firewalls, we assume that nodes have been "cleansed"
# and it is safe to put ports back into the default control net VLAN.
#
sub doFWlans($$$) {
    my ($experiment, $action, $nodelist) = @_;
    my ($fwnode, $fwvlanname, $fwvlan, $fwport, $fwvid);
    my %nodenames;

    my $pid = $experiment->pid();
    my $eid = $experiment->eid();

    #
    # See if there is a firewall, fetching node/VLAN info if so.
    # If not, we are all done.
    #
    if (!$experiment->IsFirewalled(\$fwnode, \$fwvid, \$fwvlan)) {
	return 0;
    }

    if ($action == FWSETUP) {
	$fwvid = TBGetUniqueIndex("cnet_vlanid");

	print "Setting up control net firewall.\n";
    }
    else {
	if ($action == FWADDNODES) {
	    print "Adding nodes to control net firewall.\n";
	}
	elsif ($action == FWDELNODES) {
	    print "Removing nodes from control net firewall.\n";
	}
	else {
	    print "Tearing down control net firewall.\n";
	}

	# Prior setup didn't succeed, nothing to do
	if (!defined($fwvid)) {
	    return 0;
	}
    }

    # See below.
    if (defined($nodelist)) {
	foreach my $nodeid (@$nodelist) {
	    my $node = Node->Lookup($nodeid);
	    if (!defined($node)) {
		tberror("Could not map $nodeid to its object");
		return 1;
	    }
	    $nodenames{$nodeid} = $node;
	}
    }

    # Get current list of reserved nodes. 
    my @allnodes;
    if (Node->BulkLookup($experiment, \@allnodes) < 0) {
	tberror("Failed to load reserved nodes");
	return 1;
    }

    # XXX vlanid in the DB is currently an int, we need a more unique name
    $fwvlanname = "fw$fwvid";

    #
    # Find all the experiment nodes and their control interface switch ports
    #
    my $portlist  = "";
    foreach my $node (@allnodes) {
	next
	    if ($node->isremotenode() || $node->isvirtnode());

	my $control_iface = Interface->LookupControl($node);
	if (!defined($control_iface)) {
	    tberror("Could not find control iface object for $node");
	    return 1;
	}
	my $node_id = $node->node_id();
	my $cif = $control_iface->iface();
	    
	if ($node_id eq $fwnode) {
	    $fwport = "$node_id:$cif";
	}
	elsif (defined($nodelist)) {
	    # Only nodes we are moving in/out of the experiment.
	    $portlist .= " $node_id:$cif"
		if (exists($nodenames{$node_id}));
	}
	else {
	    $portlist .= " $node_id:$cif";
	}
    }
    if (!defined($fwport)) {
	tberror "Firewall node '$fwnode' not found in $pid/${eid}!";
	return 0;
    }
    if ($portlist eq "") {
	#
	# We catch this up in swapexp; admin users can specify just a firewall,
	# but mere users must have at least one firewalled node. Just print
	# the warning though. 
	# 
	tbwarn "No firewalled nodes in $pid/${eid}!";
    }

    #
    # XXX hack commands til we nail down the API
    #
    my $fwsetupstr1 = "$SNMPIT $cnetstack -m $fwvlanname $pid $eid $portlist";
    my $fwsetupstr3 = "$SNMPIT $cnetstack -T $fwport $cnetvlanname ";
    my $fwtakedownstr0 = "$SNMPIT $cnetstack -e $fwport";
    my $fwtakedownstr1 = ($portlist eq "" ? "true" :
		  "$SNMPIT $cnetstack -m $cnetvlanname $pid $eid $portlist");
    my $fwtakedownstr2 = "$SNMPIT $cnetstack -o $fwvlanname $pid $eid";
    my $fwtakedownstr3 = "$SNMPIT $cnetstack -U $fwport";
    my $fwtakedownstr4 = "$SNMPIT $cnetstack -f -m $cnetvlanname $fwport";

    if ($action == FWSETUP) {
	TBDebugTimeStamp("snmpit firewall setup: VLAN");
	print "doFW: '$fwsetupstr1'\n";
	if (system($fwsetupstr1)) {
	    tberror({type => 'secondary', severity => SEV_SECONDARY,
		     error => ['fwcnvlan_setup_failed']},
		    "Failed to setup Firewall control net VLAN.");
	    return 1;
	}
	my $vlan = VLan->Lookup($experiment, $fwvlanname);
	if (!defined($vlan)) {
	    tberror({type => 'secondary', severity => SEV_SECONDARY,
		     error => ['fwcnvlan_setup_failed']},
		    "Failed to locate vlan object for $fwvlanname");
	    return 1;
	}
	if ($vlan->GetTag(\$fwvlan) != 0) {
	    tberror("No vlan tag associated with $vlan");
	    goto badsetup;
	}

	#
	# No point to trunking if thre are no ports; fails.
	#
	if ($portlist ne "") {
	    $fwsetupstr3 = "$fwsetupstr3 " . $vlan->id();
	    TBDebugTimeStamp("snmpit firewall setup: trunk");
	    print "doFW: '$fwsetupstr3'\n";
	    if (system($fwsetupstr3)) {
		tberror "Failed to setup Firewall trunk on port $fwport.";
	      badsetup:
		print "doFW: '$fwtakedownstr1'\n";
		if (system($fwtakedownstr1)) {
		    tberror "Could not return $portlist to Control VLAN!";
		    return 1;
		}
		print "doFW: '$fwtakedownstr2'\n";
		if (system($fwtakedownstr2)) {
		    tberror "Could not destroy VLAN $fwvlanname ($fwvlan)!";
		    return 1;
		}
		print "doFW: '$fwtakedownstr3'\n";
		if (system($fwtakedownstr3)) {
		    tberror "Could not untrunk $fwport!";
		    return 1;
		}
		print "doFW: '$fwtakedownstr4'\n";
		if (system($fwtakedownstr4)) {
		    tberror "Could not move $fwport back to Control lan!";
		}
		return 1;
	    }
	}
	TBDebugTimeStamp("snmpit firewall setup done");

	# Record VLAN info now that everything is done
	$experiment->SetFirewallVlan($fwvid, $fwvlan);
	return 0;
    }
    elsif ($action == FWADDNODES) {
	my $vlan = VLan->Lookup($experiment, $fwvlanname);
	if (!defined($vlan)) {
	    tberror "Cannot find vlan object for $fwvlanname";
	    return 1;
	}
	TBDebugTimeStamp("snmpit firewall port addition");
	print "doFW: '$fwsetupstr1'\n";
	if (system($fwsetupstr1)) {
	    tberror "Failed to add nodes to Firewall control net VLAN.";
	    return 1;
	}
	#
	# Redo the trunk operation since there might not have been
	# any ports last time, and the vlan would not have existed,
	# so the trunk would not be setup.
	#
	$fwsetupstr3 = "$fwsetupstr3 " . $vlan->id();
	print "doFW: '$fwsetupstr3'\n";
	if (system($fwsetupstr3)) {
	    tberror "Failed to setup Firewall trunk on port $fwport.";
	    return 1;
	}
	TBDebugTimeStamp("snmpit firewall setup done");
    }
    elsif ($action == FWDELNODES) {
	TBDebugTimeStamp("snmpit firewall port deletion");
	print "doFW: '$fwtakedownstr1'\n";
	if (system($fwtakedownstr1)) {
	    tberror "Failed to remove nodes from Firewall control net VLAN.\n";
	    return 1;
	}
	TBDebugTimeStamp("snmpit firewall setup done");
    }
    else {
	TBDebugTimeStamp("snmpit re-enable fw control port: $fwport");
	print "doFW: '$fwtakedownstr0'\n";
	my $failed = 0;
	if (system($fwtakedownstr0)) {
	    tberror "Could not re-enable firewall control port $fwport!";
	    $failed = 1;
	}
	#
	# Do not try to do this if the vlan is already gone.
	#
	my $vlan = VLan->Lookup($experiment, $fwvlanname);
	if (defined($vlan)) {
	    TBDebugTimeStamp("snmpit firewall teardown: VLAN");
	    print "doFW: '$fwtakedownstr1'\n";
	    if (system($fwtakedownstr1)) {
		tberror "Could not return $portlist to Control VLAN!";
		return 1;
	    }
	    print "doFW: '$fwtakedownstr2'\n";
	    if (system($fwtakedownstr2)) {
		tberror "Could not destroy VLAN $fwvlanname ($fwvlan)!";
		return 1;
	    }
	}
	TBDebugTimeStamp("snmpit firewall teardown: trunk");
	print "doFW: '$fwtakedownstr3'\n";
	if (system($fwtakedownstr3)) {
	    tberror "Could not tear down trunk on $fwport!";
	    $failed = 1;
	}
	print "doFW: '$fwtakedownstr4'\n";
	if (system($fwtakedownstr4)) {
	    tberror "Could not return $fwport to Control VLAN!";
	    $failed = 1;
	}
	if ($failed) {
	    return 1;
	}
	TBDebugTimeStamp("snmpit firewall teardown done");

	# Clean VLAN info from DB
	$experiment->ClearFirewallVlan();
    }
    return 0;
}

#
# Undo the firewall state for a set of nodes in the indicated experiment.
# If no nodes are specified, we remove all nodes and tear down the firewall.
#
# This function takes care of ensuring that all such nodes have been
# neutered prior to being released:
#
# Change the OSID of all nodes (firewall included) to reboot into
# the admin MFS and then power cycle them.  We must power cycle to
# ensure nodes don't spoof a simple reboot request and pretend to
# come up in the MFS.  The power "cycle" is actually an "off"
# followed by an "on", since true power cycling of large numbers
# of nodes may be done in batches to avoid network (or power)
# overload on restart.  Skewed reboots like this open a window of
# vulnerability where nodes rebooted later might be able, before
# they are rebooted, to spoof the reload server for nodes that have
# just rebooted.  So we first turn everyone off, then batched power
# ons are safe.
#
# Note that we take down the firewall while the nodes are turned
# off.  This is a convenient time while we know no nodes are in
# transition.  Plus, since we take down the firewall too, other
# nodes would not be able to reboot if we left the firewall up.
#
# BIG SECURITY ASSUMPTION: we are assuming that upon power on,
# no node can somehow reboot from the hard disk instead of
# from the network.  If it does, it is out from behind the
# firewall and can wreak havoc.
#
sub undoFWNodes($;$@) {
    my ($experiment, $leavefw, @nodes) = @_;
    my $doall   = 0;
    my $fwerr   = 0;
    my @fwstate = ();
    my $zap = 1;
    my $pid = $experiment->pid();
    my $eid = $experiment->eid();
    $leavefw = 0
	if (!defined($leavefw));

    my $fwnode;
    return
	if ($experiment->IsFirewalled(\$fwnode) == 0);

    if (!@nodes || scalar(@nodes) == 0) {
	$experiment->LocalNodeListNames(\@nodes, 1);
	if ($leavefw) {
	    @nodes = map {$_ ne $fwnode} @nodes;
	}
	else {
	    $doall = 1;
	}
    }

    #
    # There has to at least be a firewall node to be interesting
    #
    if (@nodes == 0) {
	return 0;
    }

    if ($doall) {
	print "Taking down experiment firewall.\n";
    } else {
	if (grep {$_ eq $fwnode} @nodes) {
	    tberror "Cannot remove firewall node from an experiment!";
	    return 1;
	}
	print "Removing firewalled nodes from experiment.\n";
    }

    #
    # At the lowest level of security, we don't do the diskzap dance
    # unless we have paniced.
    #
    # This level ("blue") is used for experiments where we are trying to
    # protect the inside from outside; i.e., there is no bad stuff inside
    # to clean up.
    #
    my $paniced = $experiment->paniced();
    my $security_level = $experiment->security_level();
    if ($paniced == 0 && $security_level < TBDB_SECLEVEL_ZAPDISK()) {
	$zap = 0;
    }

    #
    # First turn off all the machines.
    # If we fail, the firewall in left in place, and some nodes may
    # be powered off.
    #
    if ($zap) {
	print STDERR "Powering down firewalled nodes.\n";
	TBDebugTimeStamp("Powering down nodes");
	system("$POWER off @nodes");
	if ($?) {
	    tbreport(SEV_SECONDARY, 'power_off_failed');
	    $fwerr = "Failed to power off all nodes!";
	    @fwstate = ("Firewall is still in place",
			"Some nodes may NOT be powered off",
			"Nodes NOT switched to admin MFS");
	    goto done;
	}

	#
	# Force all nodes into admin mode.
	# If we fail, the firewall is left in place.
	#
	my %myargs;
	$myargs{'name'} = "tbswap";
	$myargs{'on'} = 1;
	$myargs{'clearall'} = 1;
	if (TBAdminMfsSelect(\%myargs, undef, @nodes)) {
	    $fwerr = "Failed to force all nodes into admin mode!";
	    @fwstate = ("Firewall is still in place",
			"All nodes are powered off",
			"Not all nodes have been switched to admin MFS");
	    goto done;
	}
    }

    #
    # Once all nodes have been turned off and their DB state changed
    # to force MFS booting, we can modify the switch firewall state,
    # either tearing down the firewall ($doall) entirely or just moving
    # the indicated nodes out from behind it (!$doall).
    #
    # If this fails, we warn and punt.  The switch or DB state could
    # be screwed up at this point.
    #
    if ($doall) {
	if (doFWlans($experiment, FWTEARDOWN, undef)) {
	    $fwerr = "Failed to tear down firewall!";
	    @fwstate = ("Firewall may NOT be in place",
			$zap ? ("All nodes are powered off",
				"All nodes set to admin mode") : (),
			"Switch/DB firewall state could be inconsistent!");
	    goto done;
	}
    } else {
	my @deleted = @nodes;
	if (doFWlans($experiment, FWDELNODES, \@deleted)) {
	    $fwerr = "Failed to remove nodes from firewall VLAN!";
	    @fwstate = ("Nodes may still be in firewall VLAN",
			$zap ? ("All nodes are powered off",
				"All nodes set to admin mode") : ());
	    goto done;
	}
    }

    #
    # Now we power on the nodes and let them boot into the MFS,
    # where they will run the disk bootblock zapper.
    #
    # If this fails, we power off all the nodes again and get a
    # little edgy in our error messages to emphasize the gravity
    # of the situation.  Someday we could just move the failed
    # nodes into a special firewalled holding experiment, and
    # let the experiment swapout finish, freeing up the nodes that
    # did succeed.
    #
    if ($zap) {
	print STDERR "Booting nodes into admin MFS and zapping bootblocks.\n";
	TBDebugTimeStamp("Booting admin MFS/zapping bootblocks");
	my @failed = ();
	my %myargs = ();
	$myargs{'name'} = "tbswap";
	$myargs{'command'} = "sudo /usr/local/bin/diskzap";
	$myargs{'poweron'} = 1;
	$myargs{'retry'} = 1;
	if (TBAdminMfsRunCmd(\%myargs, \@failed, @nodes)) {
	    foreach my $failed (@failed) {
		tbreport(SEV_ERROR, 'invalidate_bootblock_failed', $failed);
	    }
	    $fwerr = "Failed to invalidate bootblocks on @failed!";
	    @fwstate = ("Firewall is NOT in place",
			"All nodes set to admin mode");
	    system("$POWER off @nodes");
	    if ($?) {
		push(@fwstate, "Some nodes may NOT be powered off");
	    } else {
		push(@fwstate, "All nodes are powered off");
	    }
	    push(@fwstate, "MAKE SURE THESE NODES DO NOT BOOT FROM DISK!");
	}
    }

done:
    #
    # If we had a failure when tearing down the firewall completely,
    # we act as though the panic button had been pressed (set panic
    # bit in DB, disable cnet port, and inform tbops).  This hopefully
    # ensures that everything will get cleaned up correctly.  This may
    # eventually prove to be overkill.
    #
    # If we failed while removing some nodes from behind the firewall
    # we don't get quite so cranky.
    #
    if ($fwerr) {
	my $op;

	if ($doall) {
	    my $fwport;
	    if ($experiment->FirewallAndPort(\$fwnode, \$fwport) != 0 ||
		system("$SNMPIT -d ${fwnode}:${fwport}") != 0) {
		push(@fwstate,
		     "Firewall cnet interface ${fwnode}:${fwport} NOT disabled");
	    } else {
		push(@fwstate,
		     "Firewall cnet interface ${fwnode}:${fwport} disabled");
	    }
	    $experiment->SetPanicBit(2);
	    $op = "Swapout";
	} else {
	    $op = "Modify";
	}

	my $this_user = User->ThisUser();
	my $user_uid;
	my $user_name;
	my $user_email;
	if (defined($this_user)) {
	    $user_uid   = $this_user->uid();
	    $user_name  = $this_user->name();
	    $user_email = $this_user->email();
	}
	tberror "$fwerr" . "\nINFORMING $TBOPS!";
	if (defined($user_email)) {
	    SENDMAIL("$user_name <$user_email>",
		     "Firewalled experiment $op failed".
		     " for $pid/$eid",
		     "$op of firewalled experiment $pid/$eid".
		     " by $user_uid failed!\n".
		     "Admin intervention required:\n\n$fwerr\n\n".
		     "Current state of @nodes:\n\n".
		     join("\n", @fwstate) . "\n",
		     "$user_name <$user_email>",
		     "Cc: $TBOPS");
	}
	return 1;
    }

    return 0;
}

