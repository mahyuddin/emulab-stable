# -*- python -*-
#
# EMULAB-COPYRIGHT
# Copyright (c) 2000-2004, 2007 University of Utah and the Flux Group.
# All rights reserved.
#

#
# Database functions
#

import sys
import os, os.path
import pwd

TBPATH = os.path.join("@prefix@", "lib")
if TBPATH not in sys.path:
    sys.path.append(TBPATH)
    pass

import MySQLdb

from libtestbed import *

#
# Debug vars.
#
verbose = 0
debug = 0

# Constants
TBOPSPID               = "emulab-ops"
NODEDEAD_PID           = TBOPSPID
NODEDEAD_EID           = "hwdown"
TB_NODEHISTORY_OP_MOVE = "move"

# Node Log Types
TB_NODELOGTYPE_MISC    = "misc"
TB_NODELOGTYPES        = (TB_NODELOGTYPE_MISC, )
TB_DEFAULT_NODELOGTYPE = TB_NODELOGTYPE_MISC

# Node History Stuff.
TB_NODEHISTORY_OP_FREE  = "free"
TB_NODEHISTORY_OP_ALLOC	= "alloc"
TB_NODEHISTORY_OP_MOVE  = "move"

#
# DB variables.
#
__dbName = "@TBDBNAME@"
__dbQueryMaxtries = 1
__dbConnMaxtries = 5

__dbConnection = None

def TBDBConnect():
    global __dbConnection
    
    if __dbConnection:
        return

    # Create a DB username for accounting purposes
    uid = os.getuid()
    try:
        name = pwd.getpwuid(uid)[0]
    except KeyError:
        name = "uid%d" % uid
    dbuser = "%s:%s:%d" % (sys.argv[0], name, os.getpid())

    if debug:
        print "Connecting to db %s as %s" % (__dbName, dbuser)

    # Connect, with retries
    for tries in range(__dbConnMaxtries):
        try:
            __dbConnection = MySQLdb.connect(db = __dbName, user = dbuser)
        except:
            time.sleep(1)
        else:
            break
    else:
        raise RuntimeError, "Cannot connect to DB after several attempts!"

def DBQuery(queryPat, querySub = (), asDict = False):
    TBDBConnect()
    
    if asDict:
        cursor = __dbConnection.cursor(MySQLdb.cursors.DictCursor)
    else:
        cursor = __dbConnection.cursor()

    if debug:
        print "Executing DB query %s" % queryPat

    tries = __dbQueryMaxtries
    while tries:
        try:
            cursor.execute(queryPat, querySub)
            ret = cursor.fetchall()
            if debug:
                rs = `ret`
                if len(rs) > 60:
                    rs = rs[:60] + "..."
                print "Result: %s" % rs
                pass
            if ret == None:
                return ()
            return ret
        except MySQLdb.MySQLError, e:
            tries -= 1
            if tries == 0:
                break
            else:
                time.sleep(1)
                try:
                    __dbConnection.ping()
                except MySQLdb.MySQLError:
                    pass
                
    tbmsg  = queryPat % cursor.connection.literal(querySub)
    tbmsg += "\n\n"
    tbmsg += "".join(traceback.format_exception(*sys.exc_info()))
    SENDMAIL(TBOPS, "DB query failed", "DB query failed:\n\n%s" % tbmsg, TBOPS)
    return None

def DBQueryFatal(*args):
    ret = DBQuery(*args)
    if ret == None:
        raise RuntimeError, "DBQueryFatal failed"
    return ret

def DBQueryWarn(*args):
    return DBQuery(*args)

def DBQuoteSpecial(str):
    TBDBConnect()
    return __dbConnection.escape_string(str)


#
# Map UID to DB UID (login). Does a DB check to make sure user is known to
# the DB (user obviously has a regular account), and that account will
# always match what the DB says. Redundant, I know. But consider it a
# sanity (or consistency) check.
#
# usage: UNIX2DBUID(int uid)
#        returns username if the UID is okay.
#        raises a UserError exception if the UID is bogus.
#
class UserError(StandardError): pass # XXX: need better suite of exceptions
def UNIX2DBUID (unix_uid):
    qres = \
         DBQueryFatal("select uid from users where unix_uid=%s",
                      (unix_uid))
    if not len(qres):
	raise UserError, "*** %s not a valid Emulab user!" % uid
    pwname = pwd.getpwuid(unix_uid)[0]
    dbuser = qres[0][0]
    if dbuser != pwname:
	raise UserError, "*** %s (passwd file) does not match %s (db)" % \
              (pwname, dbuser)
    return dbuser

#
# Helper. Test if numeric. Convert to dbuid if numeric.
#
def MapNumericUID(uid):
    name = ""
    try:
        uid = int(uid)
	name = UNIX2DBUID(uid)
    except ValueError:
	name = uid
        pass
    return name


#
# Return the IDX for a current experiment. 
#
# usage: TBExptIDX(char $pid, char *gid, int \$idx)
#        returns 1 if okay.
#	 returns 0 if error.
#
class UnknownExptID(StandardError): pass # XXX: need better suite of exceptions
def TBExptIDX(pid,eid):
    qres = \
         DBQueryWarn("select idx from experiments "
                     "where pid=%s and eid=%s",
                     (pid, eid))

    if not len(qres):
	raise UnknownExptID, "Experiment %s/%s unknown!" % (pid,eid)
    
    idx = qres[0][0]
    return int(idx)

#
# Insert a Log entry for a node.
#
# usage: TBSetNodeLogEntry(char *node, char *uid, char *type, char *message)
#        Returns 1 if okay.
#        Returns 0 if failed.
#
def TBSetNodeLogEntry(node, dbuid, type, message):
    if not TBValidNodeName(node) or not TBValidNodeLogType(type):
	return 0
    idx = TBMapUIDtoIDX(dbuid)
    return DBQueryWarn("insert into nodelog "
		       "values "
                       "(%s, NULL, %s, %s, %s, %s, now())",
                       (node, type, dbuid, idx, message))

#
# Validate a node name.
#
# usage: TBValidNodeName(char *name)
#        Returns 1 if the node is valid.
#        Returns 0 if not.
#
def TBValidNodeName(node):
    qres = \
         DBQueryWarn("select node_id from nodes where node_id=%s",
                     (node))
    if len(qres) == 0:
	return 0
    return 1

#
# Validate a node log type.
#
# usage: TBValidNodeLogType(char *type)
#        Returns 1 if the type string is valid.
#        Returns 0 if not.
#
def TBValidNodeLogType(type):
    if type in TB_NODELOGTYPES:
        return 1
    return 0

#
# Mark a Phys node as down. Cannot use next reserve since the pnode is not
# going to go through the free path.
#
# usage: MarkPhysNodeDown(char *nodeid)
#
def MarkPhysNodeDown(pnode):
    pid = NODEDEAD_PID;
    eid = NODEDEAD_EID;
    
    DBQueryFatal("lock tables reserved write")
    DBQueryFatal("update reserved set "
		 "  pid=%s,eid=%s,rsrv_time=now() "
		 "where node_id=%s",
                 (pid, eid, pnode))
    DBQueryFatal("unlock tables")
    TBSetNodeHistory(pnode, TB_NODEHISTORY_OP_MOVE, os.getuid(), pid, eid)
    return


def TBSetNodeHistory(nodeid, op, uid, pid, eid):
    exptidx = 0

    try:
        exptidx = TBExptIDX(pid, eid)
    except:
        print "*** WARNING: No such experiment %s/%s!" % (pid,eid)
	return 0

    try:
        uid = int(uid)
        # val = <expr> ? TrueRet : FalseRet
        uid = uid == 0 and "root" or UNIX2DBUID(uid)
        pass
    except ValueError:
        pass

    idx = TBMapUIDtoIDX(uid)
    
    return DBQueryWarn("insert into node_history set "
		       "  history_id=0, node_id=%s, op=%s, "
		       "  uid=%s, uid_idx=%s stamp=UNIX_TIMESTAMP(now()), "
		       "  exptidx=%s",
                       (nodeid,op,uid,idx,exptidx))


def TBSiteVarExists(name):
    name = DBQuoteSpecial(name)

    qres = DBQueryFatal("select name from sitevariables "
                        "where name=%s", (name,))

    if len(qres) > 0:
        return 1
    else:
        return 0
    pass


def TBGetSiteVar(name):
    name = DBQuoteSpecial(name)

    qres = DBQueryFatal("select value, defaultvalue from sitevariables "
                        "where name=%s", (name,))

    if len(qres) > 0:
        value, defaultvalue = qres[0]

        if value: return value
        elif defaultvalue: return defaultvalue

        pass
    
    raise RuntimeException, \
          "*** attempted to fetch unknown site variable name!"

def TBMapUIDtoIDX(uid):
    uid = DBQuoteSpecial(uid)
    
    qres = DBQueryFatal("select uid_idx from users "
                        "where uid=%s", (uid,))

    if len(qres) == 0:
        return 0

    return qres[0]

