#!/usr/bin/perl -wT
#
# EMULAB-COPYRIGHT
# Copyright (c) 2007 University of Utah and the Flux Group.
# All rights reserved.
#
package Image;

use strict;
use Exporter;
use vars qw(@ISA @EXPORT);

@ISA    = "Exporter";
@EXPORT = qw ( );

# Must come after package declaration!
use lib '@prefix@/lib';
use libdb;
use libtestbed;
use User;
use English;
use Data::Dumper;
use overload ('""' => 'Stringify');

# Configure variables
my $TB		  = "@prefix@";
my $BOSSNODE      = "@BOSSNODE@";
my $CONTROL	  = "@USERNODE@";
my $TBOPS         = "@TBOPSEMAIL@";
my $TBAPPROVAL    = "@TBAPPROVALEMAIL@";
my $TBAUDIT       = "@TBAUDITEMAIL@";
my $TBBASE        = "@TBBASE@";
my $TBWWW         = "@TBWWW@";

# Cache of instances to avoid regenerating them.
my %images    = ();
my $debug      = 0;

# Little helper and debug function.
sub mysystem($)
{
    my ($command) = @_;

    print STDERR "Running '$command'\n"
	if ($debug);
    return system($command);
}

#
# Lookup by idx or pid,osname, depending on the args.
#
sub Lookup($$;$)
{
    my ($class, $arg1, $arg2) = @_;
    my $imageid;

    #
    # A single arg is either an index or a "pid,osname" or "pid/osname" string.
    #
    if (!defined($arg2)) {
	if ($arg1 =~ /^(\d*)$/) {
	    $imageid = $1;
	}
	elsif ($arg1 =~ /^([-\w]*),([-\w\.\+]*)$/ ||
	       $arg1 =~ /^([-\w]*)\/([-\w\.\+]*)$/) {
	    $arg1 = $1;
	    $arg2 = $2;
	}
	else {
	    return undef;
	}
    }
    elsif (! (($arg1 =~ /^[-\w\.\+]*$/) && ($arg2 =~ /^[-\w\.\+]*$/))) {
	return undef;
    }

    #
    # Two args means pid/imagename lookup instead of gid_idx.
    #
    if (defined($arg2)) {
	my $images_result =
	    DBQueryWarn("select imageid from images ".
			"where pid='$arg1' and imagename='$arg2'");

	return undef
	    if (! $images_result || !$images_result->numrows);

	($imageid) = $images_result->fetchrow_array();
    }

    # Look in cache first
    return $images{"$imageid"}
        if (exists($images{"$imageid"}));
    
    my $query_result =
	DBQueryWarn("select * from images where imageid='$imageid'");

    return undef
	if (!$query_result || !$query_result->numrows);

    my $self           = {};
    $self->{'IMAGE'}   = $query_result->fetchrow_hashref();

    bless($self, $class);
    
    # Add to cache. 
    $images{"$imageid"} = $self;
    
    return $self;
}
# accessors
sub field($$) { return ((! ref($_[0])) ? -1 : $_[0]->{'IMAGE'}->{$_[1]}); }
sub imagename($)        { return field($_[0], "imagename"); }
sub imageid($)          { return field($_[0], "imageid"); }
sub old_imageid($)      { return field($_[0], "old_imageid"); }
sub pid($)	        { return field($_[0], "pid"); }
sub gid($)	        { return field($_[0], "gid"); }
sub pid_idx($)          { return field($_[0], "pid_idx"); }
sub gid_idx($)          { return field($_[0], "gid_idx"); }
sub creator($)          { return field($_[0], "creator"); }
sub creator_idx($)      { return field($_[0], "creator_idx"); }
sub created($)          { return field($_[0], "created"); }
sub description($)      { return field($_[0], "description"); }
sub loadpart($)         { return field($_[0], "loadpart"); }
sub loadlength($)       { return field($_[0], "loadlength"); }
sub part1_osid($)       { return field($_[0], "part1_osid"); }
sub part2_osid($)       { return field($_[0], "part2_osid"); }
sub part3_osid($)       { return field($_[0], "part3_osid"); }
sub part4_osid($)       { return field($_[0], "part4_osid"); }
sub default_osid($)     { return field($_[0], "default_osid"); }
sub path($)             { return field($_[0], "path"); }
sub magic($)            { return field($_[0], "magic"); }
sub load_address($)     { return field($_[0], "load_address"); }
sub frisbee_pid($)      { return field($_[0], "frisbee_pid"); }
sub load_busy($)        { return field($_[0], "load_busy"); }
sub ezid($)             { return field($_[0], "ezid"); }
sub shared($)           { return field($_[0], "shared"); }
sub global($)           { return field($_[0], "global"); }
sub updated($)          { return field($_[0], "updated"); }

#
# Refresh a class instance by reloading from the DB.
#
sub Refresh($)
{
    my ($self) = @_;

    return -1
	if (! ref($self));

    my $imageid = $self->imageid();
    
    my $query_result =
	DBQueryWarn("select * from images where imageid=$imageid");

    return -1
	if (!$query_result || !$query_result->numrows);

    $self->{'IMAGE'} = $query_result->fetchrow_hashref();

    return 0;
}

#
# Stringify for output.
#
sub Stringify($)
{
    my ($self) = @_;
    
    my $pid       = $self->pid();
    my $imageid   = $self->imageid();
    my $imagename = $self->imagename();

    return "[Image $imageid: $pid,$imagename]";
}

#
# Return the internal DB rowref. Used for code that has not been converted.
#
sub DBData($)
{
    my ($self) = @_;

    return undef
	if (! ref($self));

    return $self->{'IMAGE'}
}

#
# Perform some updates ...
#
sub Update($$)
{
    my ($self, $argref) = @_;

    # Must be a real reference. 
    return -1
	if (! ref($self));

    my $imageid = $self->imageid();

    my $query = "update images set ".
	join(",", map("$_='" . $argref->{$_} . "'", keys(%{$argref})));

    $query .= " where imageid='$imageid'";

    return -1
	if (! DBQueryWarn($query));

    return Refresh($self);
}

#
# Check permissions.
#
sub AccessCheck($$$)
{
    my ($self, $user, $access_type) = @_;

    # Must be a real reference. 
    return -1
	if (! ref($self));

    my $uid = (ref($user) ? $user->uid() : $user);

    return TBImageIDAccessCheck($uid, $self->imageid(), $access_type);
}

#
# LockTables simply locks the given tables, and then refreshes the
# instance (thereby getting the data from the DB after the tables are locked).
#
sub LockTables($;$)
{
    my ($self, $spec) = @_;

    # Must be a real reference. 
    return -1
	if (! ref($self));

    $spec = "images write"
	if (!defined($spec));
    
    DBQueryWarn("lock tables $spec")
	or return -1;
	
    return $self->Refresh();
}
sub UnLockTables($)
{
    my ($self) = @_;

    # Must be a real reference. 
    return -1
	if (! ref($self));

    DBQueryWarn("unlock tables")
	or return -1;
    return 0;
}

#
# Bump the busy indicator to keep the frisbeed going.
#
sub KeepBusy($)
{
    my ($self) = @_;

    # Must be a real reference. 
    return -1
	if (! ref($self));

    my $imageid = $self->imageid();

    DBQueryFatal("update images set load_busy=GREATEST(load_busy,1) " .
		 "where imageid='$imageid'");

    return 0;
}


# _Always_ make sure that this 1 is at the end of the file...
1;
