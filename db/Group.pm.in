#!/usr/bin/perl -wT
#
# EMULAB-COPYRIGHT
# Copyright (c) 2005, 2006, 2007 University of Utah and the Flux Group.
# All rights reserved.
#
package Group;

use strict;
use Exporter;
use vars qw(@ISA @EXPORT);

@ISA    = "Exporter";
@EXPORT = qw ( );

# Must come after package declaration!
use lib '@prefix@/lib';
use libdb;
use libtestbed;
use User;
use English;
use Data::Dumper;
use File::Basename;
use overload ('""' => 'Stringify');

# Configure variables
my $TB		  = "@prefix@";
my $BOSSNODE      = "@BOSSNODE@";
my $CONTROL	  = "@USERNODE@";
my $TBOPS         = "@TBOPSEMAIL@";
my $TBAPPROVAL    = "@TBAPPROVALEMAIL@";
my $TBAUDIT       = "@TBAUDITEMAIL@";
my $TBBASE        = "@TBBASE@";
my $TBWWW         = "@TBWWW@";
my $MIN_UNIX_GID  = @MIN_UNIX_GID@;

# Cache of instances to avoid regenerating them.
my %groups    = ();
my $debug      = 0;

# Little helper and debug function.
sub mysystem($)
{
    my ($command) = @_;

    print STDERR "Running '$command'\n"
	if ($debug);
    return system($command);
}

#
# Lookup by idx.
#
sub Lookup($$)
{
    my ($class, $gid_idx) = @_;

    # Look in cache first
    return $groups{"$gid_idx"}
        if (exists($groups{"$gid_idx"}));
    
    my $query_result =
	DBQueryWarn("select * from groups where gid_idx='$gid_idx'");

    return undef
	if (!$query_result || !$query_result->numrows);

    my $self           = {};
    $self->{'GROUP'}   = $query_result->fetchrow_hashref();
    $self->{'PROJECT'} = undef;

    bless($self, $class);
    
    # Add to cache. 
    $groups{"$gid_idx"} = $self;
    
    return $self;
}
# accessors
sub field($$) { return ((! ref($_[0])) ? -1 : $_[0]->{'GROUP'}->{$_[1]}); }
sub pid($)	        { return field($_[0], "pid"); }
sub gid($)	        { return field($_[0], "gid"); }
sub pid_idx($)          { return field($_[0], "pid_idx"); }
sub gid_idx($)          { return field($_[0], "gid_idx"); }
sub leader($)           { return field($_[0], "leader"); }
sub leader_idx($)       { return field($_[0], "leader_idx"); }
sub created($)          { return field($_[0], "created"); }
sub description($)      { return field($_[0], "description"); }
sub unix_gid($)         { return field($_[0], "unix_gid"); }
sub unix_name($)        { return field($_[0], "unix_name"); }
sub expt_count($)       { return field($_[0], "expt_count"); }
sub expt_last($)        { return field($_[0], "expt_last"); }
sub wikiname($)         { return field($_[0], "wikiname"); }
sub mailman_password($) { return field($_[0], "mailman_password"); }

#
# Lookup given pid/gid. For backwards compat.
#
sub LookupByPidGid($$$)
{
    my ($class, $pid, $gid) = @_;

    my $query_result =
	DBQueryWarn("select gid_idx from groups ".
		    "where pid='$pid' and gid='$gid'");

    return undef
	if (! $query_result || !$query_result->numrows);

    my ($gid_idx) = $query_result->fetchrow_array();

    return Group->Lookup($gid_idx);
}

#
# Refresh a class instance by reloading from the DB.
#
sub Refresh($)
{
    my ($self) = @_;

    return -1
	if (! ref($self));

    my $gid_idx = $self->gid_idx();
    
    my $query_result =
	DBQueryWarn("select * from groups where gid_idx=$gid_idx");

    return -1
	if (!$query_result || !$query_result->numrows);

    $self->{'GROUP'} = $query_result->fetchrow_hashref();

    return 0;
}

#
# Stringify for output.
#
sub Stringify($)
{
    my ($self) = @_;
    
    my $pid     = $self->pid();
    my $gid     = $self->gid();
    my $gid_idx = $self->gid_idx();
    my $pid_idx = $self->pid_idx();

    return "[Group: $pid/$gid, IDX: $pid_idx/$gid_idx]";
}

#
# Perform some updates ...
#
sub Update($$)
{
    my ($self, $argref) = @_;

    # Must be a real reference. 
    return -1
	if (! ref($self));

    my $gid_idx = $self->gid_idx();

    my $query = "update groups set ".
	join(",", map("$_='" . $argref->{$_} . "'", keys(%{$argref})));

    $query .= " where gid_idx='$gid_idx'";

    return -1
	if (! DBQueryWarn($query));

    return Refresh($self);
}

#
# Class function to create new group and return object.
#
sub Create($$$$$$)
{
    my ($class, $project, $gid, $leader, $description, $unix_name) = @_;
    my $pid;
    my $pid_idx;
    
    #
    # Check that we can guarantee uniqueness of the unix group name.
    # 
    my $query_result =
	DBQueryFatal("select gid from groups ".
		     "where unix_name='$unix_name'");

    if ($query_result->numrows) {
	print "*** Could not form a unique Unix group name: $unix_name!\n";
	return undef;
    }

    # Every group gets a new unique index.
    my $gid_idx = TBGetUniqueIndex('next_gid');

    # If project is not defined, then creating initial project group.
    if (! $project) {
	$pid = $gid;
	$pid_idx = $gid_idx;
    }
    else {
	$pid = $project->pid();
	$pid_idx = $project->pid_idx();
    }

    #
    # Get me an unused unix gid. 
    #
    my $unix_gid;

    #
    # Start here, and keep going if the one picked from the DB just
    # happens to be in use (in the group file). Actually happens!
    #
    my $min_gid = $MIN_UNIX_GID;
    
    while (! defined($unix_gid)) {
	#
	# Get me an unused unix id. Nice query, eh? Basically, find
	# unused numbers by looking at existing numbers plus one, and
	# check to see if that number is taken.
	#
	$query_result =
	    DBQueryWarn("select g.unix_gid + 1 as start from groups as g ".
			"left outer join groups as r on ".
			"  g.unix_gid + 1 = r.unix_gid ".
			"where g.unix_gid>=$min_gid and ".
			"      g.unix_gid<50000 and ".
			"      r.unix_gid is null limit 1");

	return undef
	    if (! $query_result);

	if (! $query_result->numrows) {
	    print "*** WARNING: Could not find an unused unix_gid!\n";
	    return undef;
	}

	my ($unused) = $query_result->fetchrow_array();

	if (getgrgid($unused)) {
	    # Keep going.
	    $min_gid++;
	}
	else {
	    # Break out of loop.
	    $unix_gid = $unused;
	}
    }

    if (!DBQueryWarn("insert into groups set ".
		     " pid='$pid', gid='$gid', ".
		     " leader='" . $leader->uid() . "'," .
		     " leader_idx='" . $leader->uid_idx() . "'," .
		     " created=now(), ".
		     " description='$description', ".
		     " unix_name='$unix_name', ".
		     " gid_idx=$gid_idx, ".
		     " pid_idx=$pid_idx, ".
		     " unix_gid=$unix_gid")) {
	return undef;
    }

    if (! DBQueryWarn("insert into group_stats (pid, gid, gid_idx) ".
		      "values ('$pid', '$gid', $gid_idx)")) {
	DBQueryFatal("delete from groups where gid_idx='$gid_idx'");
	return undef;
    }
    my $newgroup = Group->Lookup($gid_idx);
    return undef
	if (! $newgroup);

    return $newgroup;
}

#
# Delete a group.
#
sub Delete($)
{
    my ($self) = @_;

    # Must be a real reference. 
    return -1
	if (! ref($self));

    my $gid_idx = $self->gid_idx();

    DBQueryWarn("delete from group_stats where gid_idx='$gid_idx'");
    DBQueryWarn("delete from groups where gid_idx='$gid_idx'");
    return 0;
}

#
# Change the leader for a group.
#
sub ChangeLeader($$)
{
    my ($self, $leader) = @_;

    # Must be a real reference. 
    return -1
	if (! (ref($self) && ref($leader)));

    my %args = ();
    $args{'leader'}     = $leader->uid();
    $args{'leader_idx'} = $leader->uid_idx();
    return $self->Update(\%args);
}

#
# Add a user to the group
#
sub AddMemberShip($$;$)
{
    my ($self, $user, $trust) = @_;

    # Must be a real reference. 
    return -1
	if (! (ref($self) && ref($user)));

    my $membership = $self->LookupUser($user);

    if (defined($membership)) {
	print "*** AddMemberShip: $user is already a member of $self!\n";
	return -1;
    }
    return Group::MemberShip->NewMemberShip($self, $user, $trust);
}

#
# Remove a user from a group
#
sub DeleteMemberShip($$)
{
    my ($self, $user) = @_;

    # Must be a real reference. 
    return -1
	if (! (ref($self) && ref($user)));

    return Group::MemberShip->DeleteMemberShip($self, $user);
}

#
# Send email notification of user joining a group.
#
sub SendJoinEmail($$)
{
    my ($self, $user) = @_;

    # Must be a real reference. 
    return -1
	if (! (ref($self) && ref($user)));

    #
    # Grab user info.
    #
    my $usr_email   = $user->email();
    my $usr_URL     = $user->URL();
    my $usr_addr    = $user->addr();
    my $usr_addr2   = $user->addr2();
    my $usr_city    = $user->city();
    my $usr_state   = $user->state();
    my $usr_zip	    = $user->zip();
    my $usr_country = $user->country();
    my $usr_name    = $user->name();
    my $usr_phone   = $user->phone();
    my $usr_title   = $user->title();
    my $usr_affil   = $user->affil();
    my $uid_idx     = $user->uid_idx();
    my $uid         = $user->uid();

    # And leader info
    my $leader      = $self->GetLeader();
    my $leader_name = $leader->name();
    my $leader_email= $leader->email();
    my $leader_uid  = $leader->uid();
    my $allleaders  = $self->LeaderMailList();
    my $pid         = $self->pid();
    my $gid         = $self->gid();

    $usr_addr2 = ""
	if (!defined($usr_addr2));
    $usr_URL = ""
	if (!defined($usr_URL));

    SENDMAIL("$leader_name '$leader_uid' <$leader_email>",
	     "$uid $pid Project Join Request",
	     "$usr_name is trying to join your group $gid in project $pid.".
	     "\n".
	     "\n".
	     "Contact Info:\n".
	     "Name:            $usr_name\n".
	     "Emulab ID:       $uid\n".
	     "Email:           $usr_email\n".
	     "User URL:        $usr_URL\n".
	     "Job Title:       $usr_title\n".
	     "Affiliation:     $usr_affil\n".
	     "Address 1:       $usr_addr\n".
	     "Address 2:       $usr_addr2\n".
	     "City:            $usr_city\n".
	     "State:           $usr_state\n".
	     "ZIP/Postal Code: $usr_zip\n".
	     "Country:         $usr_country\n".
	     "Phone:           $usr_phone\n".
	     "\n".
	     "Please return to $TBWWW,\n".
	     "log in, select the 'New User Approval' page, and enter your\n".
	     "decision regarding $usr_name's membership in your project.\n".
	     "\n".
	     "Thanks,\n".
	     "Testbed Operations\n",
	     "$TBAPPROVAL",
	     "CC: $allleaders\n".
	     "Bcc: $TBAUDIT");

    return 0;
}

#
# Send email notifying of initial approval testbed approval in a group.
#
sub SendApprovalEmail($$$)
{
    my ($self, $this_user, $target_user) = @_;

    # Must be a real reference. 
    return -1
	if (! (ref($self) && ref($this_user) && ref($target_user)));

    my $usr_email   = $target_user->email();
    my $usr_name    = $target_user->name();
    my $usr_uid     = $target_user->uid();
    my $this_name   = $this_user->name();
    my $this_email  = $this_user->email();
    my $pid         = $self->pid();
    my $gid         = $self->gid();
    my $allleaders  = $self->LeaderMailList();
    my $membership  = $self->LookupUser($target_user);

    return -1
	if (!defined($membership));

    my $trust = $membership->trust();

    SENDMAIL("$usr_name '$usr_uid' <$usr_email>",
             "Membership Approved in '$pid/$gid' ",
	     "\n".
	     "This message is to notify you that you have been approved as\n".
	     "a member of $pid/$gid with '$trust' permission.\n".
             "\n\n".
             "Thanks,\n".
             "Testbed Operations\n",
             "$this_name <$this_email>",
	     "CC: $allleaders\n".
	     "Bcc: $TBAUDIT");

    return 0;
}

sub SendTrustChangeEmail($$$)
{
    my ($self, $this_user, $target_user) = @_;

    # Must be a real reference. 
    return -1
	if (! (ref($self) && ref($this_user) && ref($target_user)));

    my $usr_email   = $target_user->email();
    my $usr_name    = $target_user->name();
    my $usr_uid     = $target_user->uid();
    my $this_name   = $this_user->name();
    my $this_email  = $this_user->email();
    my $pid         = $self->pid();
    my $gid         = $self->gid();
    my $allleaders  = $self->LeaderMailList();
    my $membership  = $self->LookupUser($target_user);

    return -1
	if (!defined($membership));

    my $trust = $membership->trust();

    SENDMAIL("$usr_name '$usr_uid' <$usr_email>",
             "Membership Change in '$pid/$gid' ",
	     "\n".
	     "This message is to notify you that your permission in $pid/$gid".
	     "\n".
	     "has been changed to '$trust'\n".
             "\n\n".
             "Thanks,\n".
             "Testbed Operations\n",
             "$this_name <$this_email>",
	     "CC: $allleaders\n".
	     "Bcc: $TBAUDIT");

    return 0;
}

#
# Lookup user membership in this group
#
sub LookupUser($$)
{
    my ($self, $user) = @_;

    # Must be a real reference. 
    return undef
	if (! (ref($self) && ref($user)));

    return Group::MemberShip->LookupUser($self, $user);
}

#
# Is this group the default project group. Returns boolean.
#
sub IsProjectGroup($)
{
    my ($self) = @_;

    # Must be a real reference. 
    return 0
	if (! ref($self));

    return $self->pid_idx() == $self->gid_idx();
}

#
# Return (and cache) the project for a group.
#
sub GetProject($)
{
    my ($self) = @_;

    # Must be a real reference. 
    return undef
	if (! ref($self));

    return $self->{'PROJECT'}
        if (defined($self->{'PROJECT'}));

    $self->{'PROJECT'} = Project->Lookup($self->pid_idx());
    return $self->{'PROJECT'};
}

#
# Is the user the group leader.
#
sub IsLeader($$)
{
    my ($self, $user) = @_;

    # Must be a real reference. 
    return 0
	if (! (ref($self) && ref($user)));

    return $self->leader_idx() == $user->uid_idx();
}

#
# Return user object for leader.
#
sub GetLeader($)
{
    my ($self) = @_;

    # Must be a real reference. 
    return undef
	if (! ref($self));

    return User->Lookup($self->leader_idx());
}

#
# Return a list of leaders (proj/group roots) in the format of an
# email address list.
#
sub LeaderMailList($)
{
    my ($self) = @_;

    # Must be a real reference. 
    return undef
	if (! ref($self));

    my $gid_idx   = $self->gid_idx();
    my $projroot  = $Group::MemberShip::TRUSTSTRING_PROJROOT;
    my $grouproot = $Group::MemberShip::TRUSTSTRING_GROUPROOT;
    my $mailstr   = "";
    
    my $query_result =
	DBQueryFatal("select distinct usr_name,u.uid,usr_email ".
		     "  from users as u ".
		     "left join group_membership as gm on ".
		     "     gm.uid_idx=u.uid_idx ".
		     "where gid_idx='$gid_idx' and ".
		     "      (trust='$projroot' or trust='$grouproot') ".
		     "order by trust DESC, usr_name");

    while (my ($name,$uid,$email) = $query_result->fetchrow_array()) {
	$mailstr .= ", "
	    if ($mailstr ne "");

	$mailstr .= '"' . $name . " (". $uid . ")\" <". $email . ">";
    }
    return $mailstr;
}



############################################################################

package Group::MemberShip;
use libdb;
use libtestbed;
use English;
use overload ('""' => 'Stringify');
use vars qw($TRUSTSTRING_NONE $TRUSTSTRING_USER
	    $TRUSTSTRING_LOCALROOT $TRUSTSTRING_GROUPROOT
	    $TRUSTSTRING_PROJROOT
	    @EXPORT_OK);

# Constants for membership.
$TRUSTSTRING_NONE		= "none";
$TRUSTSTRING_USER		= "user";
$TRUSTSTRING_LOCALROOT		= "local_root";
$TRUSTSTRING_GROUPROOT		= "group_root";
$TRUSTSTRING_PROJROOT		= "project_root";

# Why, why, why?
@EXPORT_OK = qw($TRUSTSTRING_NONE $TRUSTSTRING_USER
		$TRUSTSTRING_LOCALROOT $TRUSTSTRING_GROUPROOT
		$TRUSTSTRING_PROJROOT);

my @alltrustvals = ($TRUSTSTRING_NONE, $TRUSTSTRING_USER,
		    $TRUSTSTRING_LOCALROOT, $TRUSTSTRING_GROUPROOT,
		    $TRUSTSTRING_PROJROOT);

# Cache of instances to avoid regenerating them.
my %membership = ();

#
# Lookup user membership in a group. Group and User are references. Hmm ...
#
sub LookupUser($$$)
{
    my ($class, $group, $user) = @_;

    # Must be a real reference. 
    return -1
	if (! (ref($group) && ref($user)));

    my $pid_idx = $group->pid_idx();
    my $gid_idx = $group->gid_idx();
    my $uid_idx = $user->uid_idx();

    # Look in cache first
    return $membership{"$uid_idx:$gid_idx"}
        if (exists($membership{"$uid_idx:$gid_idx"}));
    
    my $query_result =
	DBQueryWarn("select * from group_membership ".
		    "where uid_idx=$uid_idx and gid_idx=$gid_idx");

    return undef
	if (!$query_result || !$query_result->numrows);

    my $self              = {};
    $self->{'MEMBERSHIP'} = $query_result->fetchrow_hashref();
    $self->{'GROUP'}      = $group;
    $self->{'USER'}       = $user;

    bless($self, $class);
    
    # Add to cache. 
    $membership{"$uid_idx:$gid_idx"} = $self;
    
    return $self;
}
# accessors
sub field($$) { return ((! ref($_[0])) ? -1 : $_[0]->{'MEMBERSHIP'}->{$_[1]});}
sub uid($)	        { return field($_[0], "uid"); }
sub pid($)	        { return field($_[0], "pid"); }
sub gid($)	        { return field($_[0], "gid"); }
sub uid_idx($)          { return field($_[0], "uid_idx"); }
sub pid_idx($)          { return field($_[0], "pid_idx"); }
sub gid_idx($)          { return field($_[0], "gid_idx"); }
sub trust($)            { return field($_[0], "trust"); }
sub date_applied($)     { return field($_[0], "date_applied"); }
sub date_approved($)    { return field($_[0], "date_approved"); }
sub group($)            { return $_[0]->{'group'}; }
sub user($ )            { return $_[0]->{'user'}; }

#
# Refresh a class instance by reloading from the DB.
#
sub Refresh($)
{
    my ($self) = @_;

    return -1
	if (! ref($self));

    my $uid_idx = $self->uid_idx();
    my $gid_idx = $self->gid_idx();

    my $query_result =
	DBQueryWarn("select * from group_membership ".
		    "where uid_idx=$uid_idx and gid_idx=$gid_idx");

    return -1
	if (!$query_result || !$query_result->numrows);

    $self->{'MEMBERSHIP'} = $query_result->fetchrow_hashref();

    return 0;
}

#
# Stringify for output.
#
sub Stringify($)
{
    my ($self) = @_;
    
    my $uid     = $self->uid();
    my $pid     = $self->pid();
    my $gid     = $self->gid();
    my $uid_idx = $self->uid_idx();
    my $pid_idx = $self->pid_idx();
    my $gid_idx = $self->gid_idx();
    my $trust   = $self->trust();

    return "[MemberShip: $uid/$trust/$pid/$gid]";
}

#
# Perform some updates ...
#
sub Update($$)
{
    my ($self, $argref) = @_;

    # Must be a real reference. 
    return -1
	if (! ref($self));

    my $uid_idx = $self->uid_idx();
    my $gid_idx = $self->gid_idx();

    my $query = "update group_membership set ".
	join(",", map("$_='" . $argref->{$_} . "'", keys(%{$argref})));

    $query .= " where gid_idx='$gid_idx' and uid_idx='$uid_idx'";

    return -1
	if (! DBQueryWarn($query));

    return Refresh($self);
}

#
# Create new membership in a group. This is a "class" method.
#
sub NewMemberShip($$$;$)
{
    my ($class, $group, $user, $trust) = @_;
    my $clause = "";
    
    # Must be a real reference. 
    return -1
	if (! (ref($group) && ref($user)));

    my $uid     = $user->uid();
    my $pid     = $group->pid();
    my $gid     = $group->gid();
    my $uid_idx = $user->uid_idx();
    my $pid_idx = $group->pid_idx();
    my $gid_idx = $group->gid_idx();

    $trust = $TRUSTSTRING_NONE
	if (!defined($trust));
    
    # Sanity check.
    if (! grep {$_ eq $trust} @alltrustvals) {
	print STDERR "*** NewMemberShip: Not a valid trust: $trust\n";
	return -1;
    }

    # If current trust is none, then requesting membership.
    $clause = ", date_approved=now() "
	if ($trust ne $TRUSTSTRING_NONE);

    DBQueryWarn("insert into group_membership set ".
		"     uid='$uid', uid_idx=$uid_idx, ".
		"     pid='$pid', pid_idx=$pid_idx, ".
		"     gid='$gid', gid_idx=$gid_idx, ".
		"     trust='$trust', ".
		"     date_applied=now() $clause ")
	or return -1;

    return 0;
}

#
# Delete membership from a group. This is a "class" method.
#
sub DeleteMemberShip($$$)
{
    my ($class, $group, $user) = @_;
    my $clause = "";
    
    # Must be a real reference. 
    return -1
	if (! (ref($group) && ref($user)));

    my $uid     = $user->uid();
    my $pid     = $group->pid();
    my $gid     = $group->gid();
    my $uid_idx = $user->uid_idx();
    my $pid_idx = $group->pid_idx();
    my $gid_idx = $group->gid_idx();

    # Remove from cache.
    delete($membership{"$uid_idx:$gid_idx"})
	if (exists($membership{"$uid_idx:$gid_idx"}));

    DBQueryWarn("delete from group_membership ".
		"where gid_idx='$gid_idx' and uid_idx='$uid_idx'")
	or return -1;

    return 0;
}

#
# Modify a membership trust value.
#
sub ModifyTrust($$)
{
    my ($self, $trust) = @_;
    my $clause = "";

    # Must be a real reference. 
    return -1
	if (! ref($self));

    # Sanity check.
    if (! grep {$_ eq $trust} @alltrustvals) {
	print STDERR "*** ModifyTrust: Not a valid trust: $trust\n";
	return -1;
    }

    my $uid_idx = $self->uid_idx();
    my $gid_idx = $self->gid_idx();

    # If current trust is none, then also update date_approved.
    $clause  = ", date_approved=now() "
	if ($self->trust() eq $TRUSTSTRING_NONE);

    DBQueryWarn("update group_membership set trust='$trust' $clause ".
		"where gid_idx='$gid_idx' and uid_idx='$uid_idx'")
	or return -1;

    return Refresh($self);
}

# _Always_ make sure that this 1 is at the end of the file...
1;
