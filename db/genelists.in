#!/usr/bin/perl -wT

#
# EMULAB-COPYRIGHT
# Copyright (c) 2000-2004 University of Utah and the Flux Group.
# All rights reserved.
#
use Fcntl ':flock';
use English;
use Getopt::Std;

sub usage() {
    print("Usage: genelists [-d] [-n] -a\n".
	  "Usage: genelists [-d] [-n] [-m] -u user\n".
	  "Usage: genelists [-d] [-n] -p project\n".
	  "Usage: genelists [-d] [-n] -t\n".
	  "where:\n".
	  "  -d    - Turn on debugging\n".
	  "  -n    - Impotent mode\n".
	  "  -u    - Generate lists for a user; add -m for new email address\n".
	  "  -p    - Generate lists for a project (includes subgroups)\n".
	  "  -t    - Generate activity lists\n".
	  "  -a    - Generate all email lists; careful ...\n");
    exit(-1);
}

sub ActiveUsers();
sub RecentUsers();
sub RecentProjects();
sub Users();
sub WideAreaPeople();
sub ProjectLeaders();
sub ProjectLists($$);
sub genelist($$$);

my $optlist = "anu:p:tdm";
my $debug   = 0;
my $all     = 0;
my $update  = 0;
my $activity= 0;
my $impotent= 0;
my $pid;
my $user;

# Configure variables
my $TB		= "@prefix@";
my $TBOPS       = "@TBOPSEMAIL@";
my $USERS       = "@USERNODE@";
my $TBACTIVE    = "@TBACTIVEARCHIVE@";
my $TBALL       = "@TBUSERSARCHIVE@";
my $PROJROOT	= "/proj";
my $GRPROOT	= "/groups";
my $ELISTS      = "$TB/lists";

# Note no -n option. We redirect stdin from the new exports file below.
my $SSH		= "$TB/bin/sshtb -l root -host $USERS";
my $PROG	= "/usr/testbed/sbin/genelists.proxy";
my $lockfile    = "/var/tmp/testbed_genelists_lockfile";
my $tempfile    = "/var/tmp/testbed_genelists_tempfile";

#
# Turn off line buffering on output
#
$| = 1;

# Load the Testbed support stuff.
use lib "@prefix@/lib";
use libdb;
use libtestbed;

#
# We don't want to run this script unless its the real version.
#
if ($EUID != 0) {
    die("*** $0:\n".
	"    Must be root! Maybe its a development version?\n");
}
# XXX Hacky!
if (0 && $TB ne "/usr/testbed") {
    die("*** $0:\n".
	"    Wrong version. Maybe its a development version?\n");
}

#
# un-taint path
#
$ENV{'PATH'} = '/bin:/usr/bin:/usr/sbin:/usr/local/bin';
delete @ENV{'IFS', 'CDPATH', 'ENV', 'BASH_ENV'};

#
# Parse command arguments. Once we return from getopts, all that should
# left are the required arguments.
#
%options = ();
if (! getopts($optlist, \%options)) {
    usage();
}
if (@ARGV) {
    usage();
}
if (defined($options{"d"})) {
    $debug++;
}
if (defined($options{"a"})) {
    $all = 1;
}
if (defined($options{"m"})) {
    $update = 1;
}
if (defined($options{"t"})) {
    $activity = 1;
}
if (defined($options{"n"})) {
    $impotent = 1;
}
if (defined($options{"u"})) {
    $user = $options{"u"};
    
    #
    # Untaint.
    #
    if ($user =~ /^([-\w]+)$/) {
	$user = $1;
    }
    else {
	die("Tainted argument $user!\n");
    }
}

if (defined($options{"p"})) {
    $pid = $options{"p"};
    
    #
    # Untaint.
    #
    if ($pid =~ /^([-\w]+)$/) {
	$pid = $1;
    }
    else {
	die("Tainted argument $pid!\n");
    }
}

if (defined($user) && defined($pid)) {
    usage();
}
if ($update && !defined($user)) {
    usage();
}

#
# We need to serialize this script to avoid a trashed map file. Use
# a dummy file in /var/tmp, opened for writing and flock'ed.
#
open(LOCK, ">>$lockfile") || fatal("Couldn't open $lockfile\n");
$count = 0;
if (flock(LOCK, LOCK_EX|LOCK_NB) == 0) {
    #
    # If we don't get it the first time, we wait for:
    # 1) The lock to become free, in which case we do our thing
    # 2) The time on the lock to change, in which case we wait for that process
    #    to finish
    #
    my $oldlocktime = (stat(LOCK))[9];
    my $gotlock = 0;
    while (1) {
	print "Another genelists in progress, waiting for it to finish\n";
	if (flock(LOCK, LOCK_EX|LOCK_NB) != 0) {
	    # OK, got the lock, we can do what we're supposed to
	    $gotlock = 1;
	    last;
	}
	$locktime = (stat(LOCK))[9];
	if ($locktime != $oldlocktime) {
	    $oldlocktime = $locktime;
	    last;
	}
	if ($count++ > 20)  {
	    fatal("Could not get the lock after a long time!\n");
	}
	sleep(1);
    }

    $count = 0;
    #
    # If we didn't get the lock, wait for the processes that did to finish
    #
    if (!$gotlock) {
	while (1) {
	    if ((stat(LOCK))[9] != $oldlocktime) {
		exit(0);
	    }
	    if (flock(LOCK, LOCK_EX|LOCK_NB) != 0) {
		close(LOCK);
		exit(0);
	    }
	    if ($count++ > 30)  {
		fatal("Process with the lock didn't finish after a long time!\n");
	    }
	    sleep(1);
	}
    }
}

#
# Perl-style touch(1)
#
my $now = time;
utime $now, $now, $lockfile;

ActiveUsers()
    if ($all || $activity || $update);

RecentUsers()
    if ($all || $activity || $update);

RecentProjects()
    if ($all || $activity || $update);

Users()
    if ($all || defined($user));

WideAreaPeople()
    if ($all || defined($user));

ProjectLeaders()
    if ($all || defined($user) || defined($pid));

if ($all || defined($user) || defined($pid)) {
    my $query;
    my $phash = {};
    my $query_result;
    
    if ($all) {
	$query = "select pid,gid from groups";
    }
    elsif ($user) {
	$query = "select pid,gid from group_membership where uid='$user'";
    }
    else {
	$query = "select pid,gid from groups where pid='$pid'";
    }
    $query .= " order by pid,gid";

    if (! ($query_result = DBQuery($query))) {
	DBFatal("Getting Project List!");
    }
    while (my ($pid,$gid) = $query_result->fetchrow_array()) {
	ProjectLists($pid, $gid);
    }
}

#
# Close the lock file. Exiting releases it, but might as well.
#
close(LOCK);
exit 0;

#
# All active users on the testbed
#
sub ActiveUsers()
{
    my $userlist;
    my $query_result;

    print "Getting Active Users\n" if $debug;
    
    if (! ($query_result =
	   DBQuery("SELECT DISTINCT u.usr_email from experiments as e ".
		   "left join group_membership as p ".
		   "     on e.pid=p.pid and p.pid=p.gid ".
		   "left join users as u on u.uid=p.uid ".
		   "where u.status='active' and ".
		   "      e.state='active' ".
		   "order by u.usr_email"))) {
	DBFatal("Getting Active Users!");
    }
    $userlist = "$TBOPS\n".
	        "$TBACTIVE";

    genelist($query_result, $userlist, "emulab-active-users");
}

#
# Recently active users.
# 
sub RecentUsers()
{
    my $userlist;
    my $query_result;

    my $limit = (60 * 60 * 24) * TBGetSiteVar("general/recently_active");
    print "Getting Recently Active Users\n" if $debug;

    if (! DBQuery("create temporary table tstat1 ".
		  "select distinct exptidx,uid from testbed_stats as t ".
		  "where ((UNIX_TIMESTAMP(now()) - ".
		  "UNIX_TIMESTAMP(t.end_time)) <= $limit)")) {
	DBFatal("Making Recently Active Temp Table!");
    }
    if (! ($query_result =
	   DBQuery("select distinct u.usr_email from tstat1 as t ".
		   "left join users as u on u.uid=t.uid ".
		   "order by u.usr_email"))) {
	DBFatal("Getting Recently Active Users!");
    }
    $userlist = "$TBOPS\n".
	        "$TBACTIVE";

    genelist($query_result, $userlist, "emulab-recently-active-users");
}

#
# Recently active projects (members).
#
sub RecentProjects()
{
    my $userlist;
    my $query_result;

    my $limit = (60 * 60 * 24) * TBGetSiteVar("general/recently_active");
    print "Getting Recently Active Projects (members)\n" if $debug;

    if (! ($query_result =
	   DBQuery("select distinct u.usr_email from tstat1 as t ".
		   "left join experiment_stats as s on ".
		   "     s.exptidx=t.exptidx ".
		   "left join group_membership as p ".
		   "     on s.pid=p.pid and p.pid=p.gid ".
		   "left join users as u on u.uid=p.uid ".
		   "where u.status='active' ".
		   "order by u.usr_email"))) {
	DBFatal("Getting Recently Active Projects!");
    }
    $userlist = "$TBOPS\n".
	        "$TBACTIVE";

    genelist($query_result, $userlist, "emulab-recently-active-projects");
}

#
# All active users of the testbed.
# 
sub Users()
{
    my $userlist;
    my $query_result;

    print "Getting All Users\n" if $debug;

    if (! ($query_result =
	   DBQuery("SELECT DISTINCT usr_email FROM users ".
		   "where status='active' order by usr_email"))) {
	DBFatal("Getting Users!");
    }
    $userlist = "$TBOPS\n".
	        "$TBALL";
    
    genelist($query_result, $userlist, "emulab-users");
}

#
# Special list for people approved to use the widearea-nodes.
#
sub WideAreaPeople()
{
    my $query_result =
	DBQueryFatal("SELECT DISTINCT u.usr_email from projects as p ".
		     "left join group_membership as m on m.pid=p.pid ".
		     "left join users as u on u.uid=m.uid ".
		     "where p.approved!=0 and p.pcremote_ok is not null ".
		     "      and m.trust!='none' and u.status='active' ".
		     "order by usr_email");

    genelist($query_result, "$TBOPS", "emulab-widearea-users");
}

#
# Another list of project leaders.
#
sub ProjectLeaders()
{
    my $query_result =
	DBQueryFatal("SELECT DISTINCT u.usr_email from projects as p ".
		     "left join users as u on u.uid=p.head_uid ".
		     "where p.approved!=0 ".
		     "order by usr_email");

    genelist($query_result, "$TBOPS", "emulab-project-leaders");
}

#
# Regen project lists. 
#
sub ProjectLists($$)
{
    my ($pid, $gid) = @_;
    my $proj_result;

    print "Getting project members for $pid/$gid\n" if $debug;

    my $query_result =
	DBQueryFatal("SELECT distinct u.usr_email from ".
		     " group_membership as p ".
		     "left join users as u on u.uid=p.uid ".
		     "where p.pid='$pid' and p.gid='$gid' and ".
		     " p.trust!='none' ".
		     "order by u.usr_email");

    if ($query_result->numrows) {
	my $archive;

	if ($pid eq $gid) {
	    $archive = "$PROJROOT/$pid/$pid-users.mail";
	}
	else {
	    $archive = "$GRPROOT/$pid/$gid/$pid-$gid.mail";
	}

	#
	# This would be nice, but will not work since the mailer daemon
	# cannot access files in /proj/$pid or /groups/$pid
	#
	if (0 && ! -e $archive) {
	    open(ARCHIVE, ">>$archive") or
		fatal("Could not create $archive: $!");
	    close(ARCHIVE);
	    
	    chmod(0666, "$archive") or
		fatal("Could not chmod(666) $archive: $!");
	}
	if ($pid eq $gid) {
	    genelist($query_result, undef, "$pid-users");
	}
	else {
	    genelist($query_result, undef, "$pid-$gid-users");
	}
    }
}

#
# Generate and fire over a list.
#
sub genelist($$$)
{
    my($query_result, $inituserlist, $listname) = @_;

    print "Processing $listname at: \t".time()." \t(".
      $query_result->numrows()." entries)\n" if $debug;

    open(LIST,"> $tempfile") ||
	fatal("Couldn't open $tempfile: $!\n");

    print LIST "#\n";
    print LIST "# WARNING! THIS FILE IS AUTOGENERATED. DO NOT EDIT!\n";
    print LIST "#\n";
    if (defined($inituserlist)) {
	print LIST "$inituserlist\n";
    }

    for ($i = 0; $i < $query_result->numrows; $i++) {
	my $user_email = ($query_result->fetchrow_array())[0];
	if (! defined($user_email)) {
	    next;
	}
	print LIST "$user_email\n";
	print "$user_email\n" if $debug>1;
    }
    close(LIST);
    chmod(0664, $tempfile);

    if (! -d $ELISTS) {
	if (! mkdir($ELISTS, 0770)) {
	    fatal("Could not make directory $ELISTS: $!");
	}

	if (! chmod(0775, $ELISTS)) {
	    fatal("Could not chmod directory $ELISTS: $!");
	}
    }

    if (-e "$ELISTS/$listname" &&
	system("cmp -s $tempfile $ELISTS/$listname") == 0) {
	print "$listname has not changed. Skipping.\n"
	    if ($debug);
	unlink("$tempfile");
	return;
    }

    system("/bin/cp -pf $tempfile $ELISTS/$listname") == 0 ||
	fatal("Could not move $tempfile to $ELISTS/$listname: $!");
    
    #
    # Fire the new file over to the fileserver to finish up.
    #
    if (!$impotent) {
	$UID = 0;
	system("$SSH $PROG $listname < $tempfile") == 0 or
	    fatal("Failed: $SSH $PROG $listname < $tempfile: $?");
    }
    unlink("$tempfile");
}

sub fatal {
  local($msg) = $_[0];
  SENDMAIL($TBOPS, "Failure Generating Email Lists", $msg);
  die($msg);
}
