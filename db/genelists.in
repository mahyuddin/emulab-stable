#!/usr/bin/perl -wT

#
# EMULAB-COPYRIGHT
# Copyright (c) 2000-2003 University of Utah and the Flux Group.
# All rights reserved.
#
use Fcntl ':flock';
use English;
use Getopt::Std;

sub usage() {
    print STDOUT "Usage: genelists [-a] [-n uid]\n".
	"Generate the email list files after things change.\n".
	"Use the -a option to generate lists for all projects.\n".
	"Use the -n option to generate lists for a new user.\n";
    exit(-1);
}
my  $optlist = "an:";

# Configure variables
my $TB		= "@prefix@";
my $TBOPS       = "@TBOPSEMAIL@";
my $USERS       = "@USERNODE@";
my $TBACTIVE    = "@TBACTIVEARCHIVE@";
my $TBALL       = "@TBUSERSARCHIVE@";
my $PROJROOT	= "/proj";
my $GRPROOT	= "/groups";

# Note no -n option. We redirect stdin from the new exports file below.
my $SSH		= "$TB/bin/sshtb -l root -host $USERS";
my $PROG	= "/usr/testbed/sbin/genelists.proxy";
my $lockfile    = "/var/tmp/testbed_genelists_lockfile";
my $tempfile    = "/var/tmp/testbed_genelists_tempfile";
my $newuser;
my $allprojects;
my $d = 0;

#
# Turn off line buffering on output
#
$| = 1; 

# Load the Testbed support stuff.
use lib "@prefix@/lib";
use libdb;
use libtestbed;

#
# We don't want to run this script unless its the real version.
#
if ($EUID != 0) {
    die("*** $0:\n".
	"    Must be root! Maybe its a development version?\n");
}
# XXX Hacky!
if (0 && $TB ne "/usr/testbed") {
    die("*** $0:\n".
	"    Wrong version. Maybe its a development version?\n");
}

#
# un-taint path
#
$ENV{'PATH'} = '/bin:/usr/bin:/usr/sbin:/usr/local/bin';
delete @ENV{'IFS', 'CDPATH', 'ENV', 'BASH_ENV'};

#
# Parse command arguments. Once we return from getopts, all that should
# left are the required arguments.
#
%options = ();
if (! getopts($optlist, \%options)) {
    usage();
}
if (@ARGV) {
    usage();
}
if (defined($options{"a"})) {
    $allprojects = 1;
}
if (defined($options{"n"})) {
    $newuser = $options{"n"};
    #
    # Untaint.
    #
    if ($newuser =~ /^([-\w]+)$/) {
	$newuser = $1;
    }
    else {
	die("Tainted argument $newuser!\n");
    }
}
if (defined($newuser) && defined($allprojects)) {
    usage();
}

#
# We need to serialize this script to avoid a trashed map file. Use
# a dummy file in /var/tmp, opened for writing and flock'ed. 
#
open(LOCK, ">>$lockfile") || fatal("Couldn't open $lockfile\n");
$count = 0;
if (flock(LOCK, LOCK_EX|LOCK_NB) == 0) {
    #
    # If we don't get it the first time, we wait for:
    # 1) The lock to become free, in which case we do our thing
    # 2) The time on the lock to change, in which case we wait for that process
    #    to finish
    #
    my $oldlocktime = (stat(LOCK))[9];
    my $gotlock = 0;
    while (1) {
	print "Another genelists in progress, waiting for it to finish\n";
	if (flock(LOCK, LOCK_EX|LOCK_NB) != 0) {
	    # OK, got the lock, we can do what we're supposed to
	    $gotlock = 1;
	    last;
	}
	$locktime = (stat(LOCK))[9];
	if ($locktime != $oldlocktime) {
	    $oldlocktime = $locktime;
	    last;
	}
	if ($count++ > 20)  {
	    fatal("Could not get the lock after a long time!\n");
	}
	sleep(1);
    }

    $count = 0;
    #
    # If we didn't get the lock, wait for the processes that did to finish
    #
    if (!$gotlock) {
	while (1) {
	    if ((stat(LOCK))[9] != $oldlocktime) {
		exit(0);
	    }
	    if (flock(LOCK, LOCK_EX|LOCK_NB) != 0) {
		close(LOCK);
		exit(0);
	    }
	    if ($count++ > 20)  {
		fatal("Process with the lock didn't finish after a long time!\n");
	    }
	    sleep(1); 
	}
    }
}

#
# Perl-style touch(1)
#
my $now = time;
utime $now, $now, $lockfile;

foreach my $active ( "active", "recent", "all" ) {
    my $progarg;
    my $userlist;
    
    if ($active eq "active") {
	print "Getting Active Users\n" if $d;
	# All active users on the testbed
	if (! ($query_result =
	       DBQuery("SELECT DISTINCT u.usr_email from experiments as e ".
		       "left join group_membership as p ".
		       "     on e.pid=p.pid and p.pid=p.gid ".
		       "left join users as u on u.uid=p.uid ".
		       "where u.status='active' and ".
		       "      e.state='active' ".
		       "order by u.usr_email"))) {
	    DBFatal("Getting Active Users!");
	}
	$userlist = "$TBOPS\n".
	            "$TBACTIVE";
	$progarg  = "emulab-active-users";
    }
    elsif ($active eq "recent") {
	my $limit = (60 * 60 * 24) * TBGetSiteVar("general/recently_active");
	print "Getting Recently Active Users\n" if $d;
	# Recently active users on the testbed
	if (! ($query_result =
	       DBQuery("select distinct u.usr_email from testbed_stats as t ".
		       "left join users as u on u.uid=t.uid ".
		       "where ((UNIX_TIMESTAMP(now()) - ".
		       "        UNIX_TIMESTAMP(t.end_time)) <= $limit) ".
		       "order by u.usr_email"))) {
	    DBFatal("Getting Recently Active Users!");
	}
	$userlist = "$TBOPS\n".
	            "$TBACTIVE";
	$progarg  = "emulab-recently-active-users";
    }
    elsif ($active eq "all") {
	print "Getting All Users\n" if $d;
	# All approved users on the testbed
	if (! ($query_result =
	       DBQuery("SELECT DISTINCT usr_email FROM users ".
		       "where status='active' order by usr_email"))) {
	    DBFatal("Getting Users!");
	}
	$userlist = "$TBOPS\n".
	            "$TBALL";
	$progarg  = "emulab-users";
    }
    genelist($query_result, $userlist, $progarg);
}

#
# Special list for people approved to use the widearea-nodes.
#
$query_result =
    DBQueryFatal("SELECT DISTINCT u.usr_email from projects as p ".
		 "left join group_membership as m on m.pid=p.pid ".
		 "left join users as u on u.uid=m.uid ".
		 "where p.approved!=0 and p.pcremote_ok is not null ".
		 "      and m.trust!='none' and u.status='active'");
    
genelist($query_result, "$TBOPS", "emulab-widearea-users");

#
# Another list of project leaders. 
#
$query_result =
    DBQueryFatal("SELECT DISTINCT u.usr_email from projects as p ".
		 "left join users as u on u.uid=p.head_uid ".
		 "where p.approved!=0");

genelist($query_result, "$TBOPS", "emulab-project-leaders");

#
# Regen project lists. Either all the lists, or just the projects
# that "newuser" is a member of.
# 
if (defined($newuser) || defined($allprojects)) {
    my $proj_result;

    if (defined($newuser)) {
	$proj_result =
	    DBQueryFatal("select pid,gid from group_membership ".
			 "where uid='$newuser'");
    }
    else {
	$proj_result =
	    DBQueryFatal("select pid,gid from groups");
    }

    while (my ($pid,$gid) = $proj_result->fetchrow_array) {
	print "Getting project members for $pid/$gid\n" if $d;

	my $query_result =
	    DBQueryFatal("SELECT distinct u.usr_email from ".
			 " group_membership as p ".
			 "left join users as u on u.uid=p.uid ".
			 "where p.pid='$pid' and p.gid='$gid' and ".
			 " p.trust!='none' ".
			 "order by u.usr_email");

	if ($query_result->numrows) {
	    my $archive;

	    if ($pid eq $gid) {
		$archive = "$PROJROOT/$pid/$pid-users.mail";
	    }
	    else {
		$archive = "$GRPROOT/$pid/$gid/$pid-$gid.mail";
	    }

	    #
	    # This would be nice, but will not work since the mailer daemon
	    # cannot access files in /proj/$pid or /groups/$pid
	    #
	    if (0 && ! -e $archive) {
		open(ARCHIVE, ">>$archive") or
		    fatal("Could not create $archive: $!");
		close(ARCHIVE);
		
		chmod(0666, "$archive") or
		    fatal("Could not chmod(666) $archive: $!");
	    }
	    if ($pid eq $gid) {
		genelist($query_result, undef, "$pid-users");
	    }
	    else {
		genelist($query_result, undef, "$pid-$gid-users");
	    }	    
	}
    }
}

#
# Generate and fire over a list.
#
sub genelist($$$)
{
    my($query_result, $inituserlist, $progarg) = @_;

    open(LIST,"> $tempfile") ||
	fatal("Couldn't open $tempfile: $!\n");
  
    print LIST "#\n";
    print LIST "# WARNING! THIS FILE IS AUTOGENERATED. DO NOT EDIT!\n";
    print LIST "#\n";
    if (defined($inituserlist)) {
	print LIST "$inituserlist\n";
    }

    for ($i = 0; $i < $query_result->numrows; $i++) {
	my $user_email = ($query_result->fetchrow_array())[0];
	if (! defined($user_email)) {
	    next;
	}
	print LIST "$user_email\n";
	print "$user_email\n" if $d;
    }
    close(LIST);

    #
    # Fire the new file over to the fileserver to finish up.
    #
    $UID = 0;
    system("$SSH $PROG $progarg < $tempfile") == 0 or
    	fatal("Failed: $SSH $PROG $progarg < $tempfile: $?");
    unlink("$tempfile");
}

#
# Close the lock file. Exiting releases it, but might as well.
#
close(LOCK);
exit 0;

sub fatal {
  local($msg) = $_[0];
  SENDMAIL($TBOPS, "Failure Generating Email Lists", $msg);
  die($msg);
}
