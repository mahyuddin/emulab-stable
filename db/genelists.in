#!/usr/bin/perl -wT
use Fcntl ':flock';
use English;
use Getopt::Std;

sub usage() {
    print STDOUT "Usage: genelists [-a] [-n uid]\n".
	"Generate the email list files after things change.\n".
	"Use the -a option to generate lists for all projects.\n".
	"Use the -n option to generate lists for a new user.\n";
    exit(-1);
}
my  $optlist = "an:";

# Configure variables
my $TB		= "@prefix@";
my $TBOPS       = "@TBOPSEMAIL@";
my $USERS       = "@USERNODE@";
my $TBACTIVE    = "@TBACTIVEARCHIVE@";
my $TBALL       = "@TBUSERSARCHIVE@";
my $PROJROOT	= "/proj";

# Note no -n option. We redirect stdin from the new exports file below.
my $SSH		= "$TB/bin/sshtb -l root -host $USERS";
my $PROG	= "/usr/testbed/sbin/genelists.proxy";
my $lockfile    = "/var/tmp/testbed_genelists_lockfile";
my $tempfile    = "/var/tmp/testbed_genelists_tempfile";
my $newuser;
my $allprojects;
my $d = 0;

#
# Turn off line buffering on output
#
$| = 1; 

# Load the Testbed support stuff.
use lib "@prefix@/lib";
use libdb;
use libtestbed;

#
# We don't want to run this script unless its the real version.
#
if ($EUID != 0) {
    die("*** $0:\n".
	"    Must be root! Maybe its a development version?\n");
}
# XXX Hacky!
if (1 && $TB ne "/usr/testbed") {
    die("*** $0:\n".
	"    Wrong version. Maybe its a development version?\n");
}

#
# un-taint path
#
$ENV{'PATH'} = '/bin:/usr/bin:/usr/sbin:/usr/local/bin';
delete @ENV{'IFS', 'CDPATH', 'ENV', 'BASH_ENV'};

#
# Parse command arguments. Once we return from getopts, all that should
# left are the required arguments.
#
%options = ();
if (! getopts($optlist, \%options)) {
    usage();
}
if (@ARGV) {
    usage();
}
if (defined($options{"a"})) {
    $allprojects = 1;
}
if (defined($options{"n"})) {
    $newuser = $options{"n"};
    #
    # Untaint.
    #
    if ($newuser =~ /^([-\w]+)$/) {
	$newuser = $1;
    }
    else {
	die("Tainted argument $newuser!\n");
    }
}
if (defined($newuser) && defined($allprojects)) {
    usage();
}

# Set up a mutex so this doesn't get run twice at the same time

open(LOCK, ">>$lockfile") || fatal("Couldn't open $lockfile\n");
$count = 0;
while (flock(LOCK, LOCK_EX|LOCK_NB) == 0) {
    print "Another genelists in progress. Waiting a moment ...\n";
    if ($count++ > 20) {
	fatal("Could not get the lock after a long time!\n");
    }
    sleep(1);
}

foreach my $active ( 0, 1 ) {
    my $progarg;
    my $userlist;
    
    if ($active) {
	print "Getting Active Users\n" if $d;
	# All active users on the testbed
	if (! ($query_result =
	       DBQuery("SELECT DISTINCT u.usr_email from experiments as e ".
		       "left join group_membership as p ".
		       "     on e.pid=p.pid and p.pid=p.gid ".
		       "left join users as u on u.uid=p.uid ".
		       "where u.status='active' order by u.usr_email"))) {
	    DBFatal("Getting Active Users!");
	}
	$userlist = "$TBOPS\n".
	            "$TBACTIVE";
	$progarg  = "emulab-active-users";
    }
    else {
	print "Getting All Users\n" if $d;
	# All approved users on the testbed
	if (! ($query_result =
	       DBQuery("SELECT DISTINCT usr_email FROM users ".
		       "where status='active' order by usr_email"))) {
	    DBFatal("Getting Users!");
	}
	$userlist = "$TBOPS\n".
	            "$TBALL";
	$progarg  = "emulab-users";
    }
    genelist($query_result, $userlist, $progarg);
}

#
# Regen project lists. Either all the lists, or just the projects
# that "newuser" is a member of.
# 
if (defined($newuser) || defined($allprojects)) {
    my $proj_result;

    if (defined($newuser)) {
	$proj_result =
	    DBQueryFatal("select pid from group_membership ".
			 "where uid='$newuser' and pid=gid");
    }
    else {
	$proj_result =
	    DBQueryFatal("select pid from projects");
    }

    while (($pid) = $proj_result->fetchrow_array) {
	print "Getting project members for $pid\n" if $d;

	my $query_result =
	    DBQueryFatal("SELECT distinct u.usr_email from ".
			 " group_membership as p ".
			 "left join users as u on u.uid=p.uid ".
			 "where p.pid='$pid' and p.pid=p.gid and ".
			 " p.trust!='none' ".
			 "order by u.usr_email");

	if ($query_result->numrows) {
	    my $archive = "$PROJROOT/$pid/$pid-users.mail";

	    #
	    # This would be nice, but will not work since the mailer daemon
	    # cannot access files in /proj/$pid. 
	    #
	    if (0 && ! -e $archive) {
		open(ARCHIVE, ">>$archive") or
		    fatal("Could not create $archive: $!");
		close(ARCHIVE);
		
		chmod(0666, "$archive") or
		    fatal("Could not chmod(666) $archive: $!");
	    }
	    genelist($query_result, undef, "$pid-users");
	}
    }
}

#
# Generate and fire over a list.
#
sub genelist($$$)
{
    my($query_result, $inituserlist, $progarg) = @_;

    open(LIST,"> $tempfile") ||
	fatal("Couldn't open $tempfile: $!\n");
  
    print LIST "#\n";
    print LIST "# WARNING! THIS FILE IS AUTOGENERATED. DO NOT EDIT!\n";
    print LIST "#\n";
    if (defined($inituserlist)) {
	print LIST "$inituserlist\n";
    }

    for ($i = 0; $i < $query_result->numrows; $i++) {
	my $user_email = ($query_result->fetchrow_array())[0];
	if (! defined($user_email)) {
	    next;
	}
	print LIST "$user_email\n";
	print "$user_email\n" if $d;
    }
    close(LIST);

    #
    # Fire the new file over to the fileserver to finish up.
    #
    $UID = 0;
    system("$SSH $PROG $progarg < $tempfile") == 0 or
    	fatal("Failed: $SSH $PROG $progarg < $tempfile: $?");
    unlink("$tempfile");
}

#
# Close the lock file. Exiting releases it, but might as well.
#
close(LOCK);
exit 0;

sub fatal {
  local($msg) = $_[0];
  SENDMAIL($TBOPS, "Failure Generating Email Lists", $msg);
  die($msg);
}
