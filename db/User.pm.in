#!/usr/bin/perl -wT
#
# EMULAB-COPYRIGHT
# Copyright (c) 2005, 2006, 2007 University of Utah and the Flux Group.
# All rights reserved.
#
package User;

use strict;
use Exporter;
use vars qw(@ISA @EXPORT);

@ISA    = "Exporter";
@EXPORT = qw ( );

# Must come after package declaration!
use lib '@prefix@/lib';
use libdb;
use libtestbed;
use English;
use Data::Dumper;
use File::Basename;
use overload ('""' => 'Stringify');
use Project;
use vars qw($NEWUSER_FLAGS_PROJLEADER $NEWUSER_FLAGS_WIKIONLY
	    $NEWUSER_FLAGS_WEBONLY $NEWUSER_FLAGS_ARCHIVED
	    $USERSTATUS_ACTIVE $USERSTATUS_FROZEN
	    $USERSTATUS_UNAPPROVED $USERSTATUS_UNVERIFIED
	    $USERSTATUS_NEWUSER $USERSTATUS_ARCHIVED
	    @EXPORT_OK);

# Configure variables
my $TB		   = "@prefix@";
my $TBOPS          = "@TBOPSEMAIL@";
my $TBAPPROVAL     = "@TBAPPROVALEMAIL@";
my $TBAUDIT   	   = "@TBAUDITEMAIL@";
my $TBBASE         = "@TBBASE@";
my $TBWWW          = "@TBWWW@";
my $WIKISUPPORT    = @WIKISUPPORT@;
my $BOSSNODE       = "@BOSSNODE@";
my $CONTROL	   = "@USERNODE@";
my $OURDOMAIN      = "@OURDOMAIN@";
my $MIN_UNIX_UID   = @MIN_UNIX_UID@;
my $MIN_UNIX_GID   = @MIN_UNIX_GID@;

# Create() flags.
$NEWUSER_FLAGS_PROJLEADER	= 0x01;
$NEWUSER_FLAGS_WIKIONLY		= 0x02;
$NEWUSER_FLAGS_WEBONLY		= 0x04;
$NEWUSER_FLAGS_ARCHIVED		= 0x08;

# Status values.
$USERSTATUS_ACTIVE		= "active";
$USERSTATUS_FROZEN		= "frozen";
$USERSTATUS_UNAPPROVED		= "unapproved";
$USERSTATUS_UNVERIFIED		= "unverified";
$USERSTATUS_NEWUSER	        = "newuser";
$USERSTATUS_ARCHIVED	        = "archived";

# Why, why, why?
@EXPORT_OK = qw($NEWUSER_FLAGS_PROJLEADER $NEWUSER_FLAGS_WIKIONLY
		$NEWUSER_FLAGS_WEBONLY $NEWUSER_FLAGS_ARCHIVED
		$USERSTATUS_ACTIVE $USERSTATUS_FROZEN
		$USERSTATUS_UNAPPROVED $USERSTATUS_UNVERIFIED
		$USERSTATUS_NEWUSER $USERSTATUS_ARCHIVED);

# Cache of instances to avoid regenerating them.
my %users      = ();
my $debug      = 0;

# Little helper and debug function.
sub mysystem($)
{
    my ($command) = @_;

    print STDERR "Running '$command'\n"
	if ($debug);
    return system($command);
}

#
# Lookup by idx.
#
sub Lookup($$)
{
    my ($class, $token) = @_;
    my $status_archived = $USERSTATUS_ARCHIVED;
    my $query_result;

    # Look in cache first
    return $users{"$token"}
        if (exists($users{"$token"}));

    #
    # For backwards compatability, look to see if the token is numeric
    # or alphanumeric. If numeric, assumes its an idx, otherwise a name.
    #
    if ($token =~ /^\d+$/) {
	$query_result =
	    DBQueryWarn("select * from users where uid_idx='$token'");
    }
    elsif ($token =~ /^\w+$/) {
	# When looking up by uid, only look for non-archived users;
	# Must use an idx if you really want an archived user. This
	# will prevent problems with code that has not yet been
	# changed to use the idx field.
	$query_result =
	    DBQueryWarn("select * from users ".
			"where uid='$token' and status!='$status_archived'");
    }
    else {
	return undef;
    }
    
    return undef
	if (!$query_result || !$query_result->numrows);

    my $self         = {};
    $self->{'USER'}  = $query_result->fetchrow_hashref();

    bless($self, $class);
    
    # Add to cache. 
    $users{$self->{'USER'}->{'uid_idx'}} = $self;
    
    return $self;
}
# accessors
sub field($$) { return ((! ref($_[0])) ? -1 : $_[0]->{'USER'}->{$_[1]}); }
sub uid_idx($)		{ return field($_[0], "uid_idx"); }
sub dbid($)		{ return field($_[0], "uid_idx"); }
sub uid($)		{ return field($_[0], "uid"); }
sub created($)		{ return field($_[0], "usr_created"); }
sub expires($)		{ return field($_[0], "usr_expires"); }
sub modified($)		{ return field($_[0], "usr_modified"); }
sub name($)		{ return field($_[0], "usr_name"); }
sub title($)		{ return field($_[0], "usr_title"); }
sub affil($)		{ return field($_[0], "usr_affil"); }
sub email($)		{ return field($_[0], "usr_email"); }
sub URL($)		{ return field($_[0], "usr_URL"); }
sub addr($)		{ return field($_[0], "usr_addr"); }
sub addr2($)		{ return field($_[0], "usr_addr2"); }
sub city($)		{ return field($_[0], "usr_city"); }
sub state($)		{ return field($_[0], "usr_state"); }
sub zip($)		{ return field($_[0], "usr_zip"); }
sub country($)		{ return field($_[0], "usr_country"); }
sub phone($)		{ return field($_[0], "usr_phone"); }
sub shell($)		{ return field($_[0], "usr_shell"); }
sub pswd($)		{ return field($_[0], "usr_pswd"); }
sub w_pswd($)		{ return field($_[0], "usr_w_pswd"); }
sub unix_uid($)		{ return field($_[0], "unix_uid"); }
sub status($)		{ return field($_[0], "status"); }
sub admin($)		{ return field($_[0], "admin"); }
sub foreign_admin($)	{ return field($_[0], "foreign_admin"); }
sub dbedit($)		{ return field($_[0], "dbedit"); }
sub stud($)		{ return field($_[0], "stud"); }
sub webonly($)		{ return field($_[0], "webonly"); }
sub pswd_expires($)	{ return field($_[0], "pswd_expires"); }
sub cvsweb($)		{ return field($_[0], "cvsweb"); }
sub emulab_pubkey($)	{ return field($_[0], "emulab_pubkey"); }
sub home_pubkey($)	{ return field($_[0], "home_pubkey"); }
sub adminoff($)		{ return field($_[0], "adminoff"); }
sub verify_key($)	{ return field($_[0], "verify_key"); }
sub widearearoot($)	{ return field($_[0], "widearearoot"); }
sub wideareajailroot($) { return field($_[0], "wideareajailroot"); }
sub notes($)		{ return field($_[0], "notes"); }
sub weblogin_frozen($)  { return field($_[0], "weblogin_frozen"); }
sub weblogin_failcount($){return field($_[0], "weblogin_failcount");}
sub weblogin_failstamp($){return field($_[0], "weblogin_failstamp");}
sub plab_user($)	{ return field($_[0], "plab_user"); }
sub user_interface($)	{ return field($_[0], "user_interface"); }
sub chpasswd_key($)	{ return field($_[0], "chpasswd_key"); }
sub chpasswd_expires($) { return field($_[0], "chpasswd_expires"); }
sub wikiname($)		{ return field($_[0], "wikiname"); }
sub wikionly($)		{ return field($_[0], "wikionly"); }
sub mailman_password($) { return field($_[0], "mailman_password"); }

#
# Lookup user given a plain uid. For backwards compat.
#
sub LookupByUid($$)
{
    my ($class, $uid) = @_;

    return User->Lookup($uid);
}

#
# Lookup user given the unix uid ($UID typically).
#
sub LookupByUnixId($$)
{
    my ($class, $unix_uid) = @_;

    my $query_result =
	DBQueryFatal("select uid,uid_idx from users ".
		     "where unix_uid='$unix_uid'");

    return undef
	if (! $query_result || !$query_result->numrows);

    my ($uid, $uid_idx) = $query_result->fetchrow_array();

    # Sanity check against password file before returning.
    my ($pwname) = getpwuid($unix_uid) or
	die("*** $unix_uid is not in the password file!");

    if ($uid ne $pwname) {
	warn("*** WARNING: LookupByUnixId: $pwname does not match $uid\n");
	return undef
    }

    return User->Lookup($uid_idx);
}

#
# Lookup user given a wikiname. This is just to make sure the wikiname
# the user picked is unique.
#
sub LookupByWikiName($$)
{
    my ($class, $wikiname) = @_;
    my $status_archived = $USERSTATUS_ARCHIVED;
    
    my $query_result =
	DBQueryFatal("select uid_idx from users ".
		     "where wikiname='$wikiname' and ".
		     "      status!='$status_archived'");

    return undef
	if (! $query_result || !$query_result->numrows);

    my ($uid_idx) = $query_result->fetchrow_array();

    return User->Lookup($uid_idx);
}

#
# Lookup user given a wikiname. This is just to make sure the wikiname
# the user picked is unique.
#
sub LookupByEmail($$)
{
    my ($class, $email) = @_;
    my $status_archived = $USERSTATUS_ARCHIVED;

    my $query_result =
	DBQueryFatal("select uid_idx from users ".
		     "where LCASE(usr_email)=LCASE('$email') and ".
		     "      status!='$status_archived'");

    return undef
	if (! $query_result || !$query_result->numrows);

    my ($uid_idx) = $query_result->fetchrow_array();

    return User->Lookup($uid_idx);
}

#
# Class function to create new user and return object.
#
sub Create($$$$)
{
    my ($class, $uid, $flags, $argref) = @_;

    my $isleader = ($flags & $NEWUSER_FLAGS_PROJLEADER ? 1 : 0);
    my $wikionly = ($flags & $NEWUSER_FLAGS_WIKIONLY   ? 1 : 0);
    my $webonly  = ($flags & $NEWUSER_FLAGS_WEBONLY    ? 1 : 0);
    my $archived = ($flags & $NEWUSER_FLAGS_ARCHIVED   ? 1 : 0);

    #
    # If no uid, we need to generate a unique one for the user.
    #
    if (! $uid) {
	#
	# Take the first 5 letters of the email to form a root. That gives
	# us 3 digits to make it unique, since unix uids are limited to 8
	# chars, sheesh!
	#
	my $email = $argref->{'usr_email'};
	my $token;

	if ($email =~ /^([-\w\+\.]+)\@([-\w\.]+)$/) {
	    $token = $1;
	}
	else {
	    return undef;
	}
	# Squeeze out any dots or dashes.
	$token =~ s/\.//g;
	$token =~ s/\-//g;

	# Trim off any trailing numbers or +foo tokens.
	if ($token =~ /^([a-zA-Z]+)/) {
	    $token = $1;
	}
	else {
	    return undef;
	}

	# First 5 chars, at most.
	$token = substr($token, 0, 5);

	# Grab all root matches from the DB.
	my $query_result =
	    DBQueryWarn("select uid from users where uid like '${token}%'");

	return undef
	    if (!$query_result);

	# Easy; no matches at all!
	if (!$query_result->numrows) {
	    $uid = "$token" . "001";
	}
	else {
	    my $max = 0;
		
	    #
	    # Find unused slot. Must be a better way to do this!
	    #
	    while (my ($foo) = $query_result->fetchrow_array()) {
		my $name;
		my $number;
		
		# Split name from number
		if ($foo =~ /^([a-zA-Z]+)(\d*)$/) {
		    $name   = $1;
		    $number = $2;
		}
		else {
		    return undef;
		}
		# Must be exact root
		next
		    if ($name != $token);

		# Backwards compatability; might not have appended number.
		if (isset($number) && intval($number) > $max) {
		    $max = intval($number);
		}
	    }
	    $max++;
	    $uid = $token . sprintf("%03d", $max);
	}
    }
	
    #
    # The array of inserts is assumed to be safe already. Generate
    # a list of actual insert clauses to be joined below.
    #
    my @insert_data = (!defined($argref) ? () :
		       map("$_=" . DBQuoteSpecial($argref->{$_}),
			   keys(%{$argref})));

    # Every user gets a new unique index.
    my $uid_idx = TBGetUniqueIndex('next_uid', 1);

    #
    # Get me an unused unix id. 
    #
    my $unix_uid;

    #
    # Start here, and keep going if the one picked from the DB just
    # happens to be in use (in the passwd file). Actually happens!
    #
    my $min_uid = $MIN_UNIX_UID;
    
    while (! defined($unix_uid)) {
	#
	# Nice query, eh? Basically, find unused numbers by looking at
	# existing numbers plus one, and check to see if that number
	# is taken.
	#
	my $query_result =
	    DBQueryWarn("select u.unix_uid + 1 as start from users as u ".
			"left outer join users as r on ".
			"  u.unix_uid + 1 = r.unix_uid ".
			"where u.unix_uid>$min_uid and ".
			"      u.unix_uid<60000 and ".
			"      r.unix_uid is null limit 1");
	return undef
	    if (! $query_result);

	if (! $query_result->numrows) {
	    print "*** WARNING: Could not find an unused unix_uid!\n";
	    return undef;
	}

	my ($unused) = $query_result->fetchrow_array();

	if (getpwuid($unused)) {
	    # Keep going.
	    $min_uid++;
	}
	else {
	    # Break out of loop.
	    $unix_uid = $unused;
	}
    }

    # Initial mailman_password.
    my $mailman_password = substr(TBGenSecretKey(), 0, 10);

    # And a verification key.
    my $verify_key = TBGenSecretKey();

    # Now tack on other stuff we need.
    push(@insert_data, "wikionly='1'")
	if ($wikionly);
    push(@insert_data, "webonly='1'")
	if ($webonly);

    push(@insert_data, "usr_created=now()");
    push(@insert_data, "usr_modified=now()");
    push(@insert_data, "unix_uid=$unix_uid");
    push(@insert_data, "mailman_password='$mailman_password'");
    push(@insert_data, "verify_key='$verify_key'");
    push(@insert_data, "uid_idx='$uid_idx'");
    push(@insert_data, "uid='$uid'");

    if ($archived) {
	#
	# Creating an archived user; this only happens when restoring a
        # deleted user (which is to say, not often).
	#
	push(@insert_data, "status='$USERSTATUS_ARCHIVED'");
	push(@insert_data, "usr_name='$uid'");
	push(@insert_data, "pswd_expires=now()");
	push(@insert_data, "usr_pswd='*'");
	push(@insert_data, "usr_email='bouncer\@${OURDOMAIN}'");
    }
    else {
	push(@insert_data, "status='$USERSTATUS_NEWUSER'");
	push(@insert_data, "pswd_expires=date_add(now(), interval 1 year)");
    }

    # Insert into DB.
    DBQueryWarn("insert into users set " . join(",", @insert_data))
	or return undef;

    if (! DBQueryWarn("insert into user_stats (uid, uid_idx) ".
		      "VALUES ('$uid', $uid_idx)")) {
	DBQueryFatal("delete from users where uid_idx='$uid_idx'");
	return undef;
    }
    return User->Lookup($uid_idx);
}

#
# Wrap above function so I do not forget to use it for the current user.
#
sub ThisUser($)
{
    return User->LookupByUnixId($UID);
}

#
# The "implied" user is the user the web interface says we are running as.
#
sub ImpliedUser($)
{
    return undef
	if (! exists($ENV{'HTTP_INVOKING_USER'}));
    
    # The lookup routine checks it argument, so no need to taint check.
    return User->Lookup($ENV{'HTTP_INVOKING_USER'});
}

#
# Refresh a class instance by reloading from the DB.
#
sub Refresh($)
{
    my ($self) = @_;

    return -1
	if (! ref($self));

    my $uid_idx = $self->uid_idx();
    
    my $query_result =
	DBQueryWarn("select * from users where uid_idx=$uid_idx");

    return -1
	if (!$query_result || !$query_result->numrows);

    $self->{'USER'} = $query_result->fetchrow_hashref();

    return 0;
}

#
# Stringify for output.
#
sub Stringify($)
{
    my ($self) = @_;
    
    my $uid     = $self->uid();
    my $uid_idx = $self->uid_idx();

    return "[User: $uid, IDX: $uid_idx]";
}

#
# Perform some updates ...
#
sub Update($$)
{
    my ($self, $argref) = @_;

    # Must be a real reference. 
    return -1
	if (! ref($self));

    my $uid_idx = $self->uid_idx();

    my $query = "update users set ".
	join(",", map("$_='" . $argref->{$_} . "'", keys(%{$argref})));

    $query .= " where uid_idx='$uid_idx'";

    return -1
	if (! DBQueryWarn($query));

    return Refresh($self);
}

#
# Equality test for two users. Not strictly necessary in perl, but good form.
#
sub SameUser($$)
{
    my ($self, $other) = @_;

    # Must be a real reference. 
    return -1
	if (! (ref($self) && ref($other)));

    return $self->uid_idx() == $other->uid_idx();
}

#
# First approved project.
#
sub FirstApprovedProject($$)
{
    my ($self, $pptr) = @_;

    # Must be a real reference. 
    return -1
	if (! ref($self));

    my $uid_idx = $self->uid_idx();

    my $query_result =
	DBQueryWarn("select pid_idx from group_membership ".
		    "where uid_idx='$uid_idx' and pid_idx=gid_idx and ".
		    "      trust!='none' ".
		    "order by date_approved asc limit 1");

    if (! $query_result || !$query_result->numrows) {
	$$pptr = undef;
	return 0;
    }

    my ($pid_idx) = $query_result->fetchrow_array();
    my $project   = Project->Lookup($pid_idx);
    
    if (! defined($project)) {
	warn("*** User::FirstApprovedProject: ".
	     "Could not load project $pid_idx!");
	return -1;
    }
    $$pptr = $project;
    return 0;
}

#
# Change the status of a user in the DB.
#
sub SetStatus($$)
{
    my ($self, $status) = @_;

    # Must be a real reference. 
    return -1
	if (! ref($self));

    my %args = ("status" => $status);

    return $self->Update(\%args);
}

#
# Set password for user.
#
sub SetPassword($$$)
{
    my ($self, $encoding, $expires) = @_;

    # Must be a real reference. 
    return -1
	if (! ref($self));

    my $uid_idx = $self->uid_idx();

    # Clear the chpasswd stuff anytime passwd is set.
    return -1
	if (! DBQueryWarn("update users set ".
			  "  usr_pswd='$encoding', pswd_expires=$expires, ".
			  "  chpasswd_key=NULL,chpasswd_expires=0 ".
			  "where uid_idx='$uid_idx'"));

    return Refresh($self);
}

#
# User verified; find users groups and send email.
#
sub SendVerifiedEmail($)
{
    my ($self) = @_;

    # Must be a real reference. 
    return -1
	if (! ref($self));

    my $uid     = $self->uid();
    my $uid_idx = $self->uid_idx();

    my $newuser     = $USERSTATUS_NEWUSER;
    my $unapproved  = $USERSTATUS_UNAPPROVED;
    my $none        = $Group::MemberShip::TRUSTSTRING_NONE;

    # Audit email.
    SENDMAIL($TBAUDIT,
	     "User '$uid' has been verified",
	     "\n".
	     "User '$uid' has been verified.\n".	
	     "Status has been changed from '$newuser' to '$unapproved'\n",
	     "$TBAPPROVAL");

    #
    # Get the list of all project/groups this users has tried to join
    # but whose membership messages where delayed until the user verified
    # himself.
    #
    my $query_result =
	DBQueryFatal("select gid_idx from group_membership ".
		     "where uid_idx='$uid_idx' and trust='$none'");

    while (my ($gid_idx) = $query_result->fetchrow_array()) {
	my $group = Group->Lookup($gid_idx);

	if (!defined($group)) {
	    print("*** User::SendApprovalEmail: ".
		  "Could not load group $gid_idx!");
	    return -1;
	}
	#
	# If a project leader is verifying himself, then we do the project
	# version of the email (sends to tbapproval).
	#
	if ($group->IsProjectGroup() && $group->IsLeader($self)) {
	    my $project = $group->GetProject();

	    $project->SendNewProjectEmail() == 0 or
		return -1;
	}
	else {
	    $group->SendJoinEmail($self) == 0 or
		return -1;
	}
    }
    return 0;
}

#
# Return group membership for a user.  
#
sub GroupMembershipList($$;$)
{
    my ($self, $prval, $desired_trust) = @_;

    # Must be a real reference. 
    return -1
	if (! ref($self));

    my $uid_idx     = $self->uid_idx();
    my $none        = $Group::MemberShip::TRUSTSTRING_NONE;
    my @result      = ();
    my $trust_clause;

    if (!defined($desired_trust)) {
	$trust_clause = "trust!='$none'"
    }
    else {
	$trust_clause = "trust='$desired_trust'"
    }

    my $query_result =
	DBQueryWarn("select distinct gid_idx from group_membership ".
		    "where uid_idx='$uid_idx' and $trust_clause");

    return -1
	if (!$query_result);

    while (my ($gid_idx) = $query_result->fetchrow_array()) {
	my $group = Group->Lookup($gid_idx);

	if (!defined($group)) {
	    print("*** User::GroupMembershipList: ".
		  "Could not load group $gid_idx!");
	    return -1;
	}
	push(@result, $group);
    }
    @$prval = @result;
    return 0;
}    

# _Always_ make sure that this 1 is at the end of the file...
1;
