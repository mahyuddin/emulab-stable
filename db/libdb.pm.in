#!/usr/bin/perl -w

#
# EMULAB-COPYRIGHT
# Copyright (c) 2000-2008 University of Utah and the Flux Group.
# All rights reserved.
#

#
# A library of useful DB stuff. Mostly things that get done a lot.
# Saves typing.
#
# NOTE: Overrides perl's builtin fork()
#
# XXX: The notion of "uid" is a tad confused. A unix uid is a number,
#      while in the DB a user uid is a string (equiv to unix login).
#      Needs to be cleaned up.
#

package libdb;
use strict;
use Exporter;
use vars qw(@ISA @EXPORT);
@ISA = "Exporter";
@EXPORT =
    qw ( NODERELOADING_PID NODERELOADING_EID NODEDEAD_PID NODEDEAD_EID
	 OLDRESERVED_PID OLDRESERVED_EID NFREELOCKED_PID NFREELOCKED_EID 
	 NODEBOOTSTATUS_OKAY NODEBOOTSTATUS_FAILED NODEBOOTSTATUS_UNKNOWN
	 NODESTARTSTATUS_NOSTATUS PROJMEMBERTRUST_NONE PROJMEMBERTRUST_USER
	 PROJMEMBERTRUST_ROOT PROJMEMBERTRUST_GROUPROOT
	 PROJMEMBERTRUST_PROJROOT PROJMEMBERTRUST_LOCALROOT

	 TBOPSPID EXPTLOGNAME
	 PLABMOND_PID PLABMOND_EID PLABHOLDING_PID PLABHOLDING_EID
         PLABTESTING_PID PLABTESTING_EID PLABDOWN_PID PLABDOWN_EID

	 TBTrustConvert TBMinTrust TBGrpTrust TBProjTrust MapNumericUID

	 TB_NODEACCESS_READINFO TB_NODEACCESS_MODIFYINFO
	 TB_NODEACCESS_LOADIMAGE TB_NODEACCESS_REBOOT
	 TB_NODEACCESS_POWERCYCLE TB_NODEACCESS_MODIFYVLANS
	 TB_NODEACCESS_MIN TB_NODEACCESS_MAX

	 NODEFAILMODE_FATAL NODEFAILMODE_NONFATAL NODEFAILMODE_IGNORE

	 TB_USERINFO_READINFO TB_USERINFO_MODIFYINFO
	 TB_USERINFO_MIN TB_USERINFO_MAX

	 USERSTATUS_ACTIVE USERSTATUS_FROZEN
	 USERSTATUS_UNAPPROVED USERSTATUS_UNVERIFIED USERSTATUS_NEWUSER

	 TB_EXPT_READINFO TB_EXPT_MODIFY TB_EXPT_DESTROY TB_EXPT_UPDATE
	 TB_EXPT_MIN TB_EXPT_MAX

	 TB_PROJECT_READINFO TB_PROJECT_MAKEGROUP
	 TB_PROJECT_EDITGROUP TB_PROJECT_DELGROUP
	 TB_PROJECT_GROUPGRABUSERS TB_PROJECT_BESTOWGROUPROOT
	 TB_PROJECT_LEADGROUP TB_PROJECT_ADDUSER
	 TB_PROJECT_DELUSER TB_PROJECT_MAKEOSID
	 TB_PROJECT_DELOSID TB_PROJECT_MAKEIMAGEID TB_PROJECT_DELIMAGEID
	 TB_PROJECT_CREATEEXPT TB_PROJECT_MIN TB_PROJECT_MAX

	 TB_OSID_READINFO TB_OSID_CREATE
	 TB_OSID_DESTROY TB_OSID_MIN TB_OSID_MAX
	 TB_OSID_OSIDLEN TB_OSID_OSNAMELEN TB_OSID_VERSLEN

	 TB_IMAGEID_READINFO TB_IMAGEID_MODIFYINFO
	 TB_IMAGEID_CREATE TB_IMAGEID_DESTROY
	 TB_IMAGEID_ACCESS TB_IMAGEID_MIN TB_IMAGEID_MAX
	 TB_IMAGEID_IMAGEIDLEN TB_IMAGEID_IMAGENAMELEN

	 DBLIMIT_NSFILESIZE NODERELOADPENDING_EID

	 NODEREPOSITIONING_PID NODEREPOSITIONING_EID NODEREPOSPENDING_EID

	 EXPTSTATE_NEW EXPTSTATE_PRERUN EXPTSTATE_SWAPPED EXPTSTATE_SWAPPING
	 EXPTSTATE_ACTIVATING EXPTSTATE_ACTIVE EXPTSTATE_PANICED
	 EXPTSTATE_TERMINATING EXPTSTATE_TERMINATED EXPTSTATE_QUEUED
	 EXPTSTATE_MODIFY_PARSE EXPTSTATE_MODIFY_REPARSE EXPTSTATE_MODIFY_RESWAP
	 EXPTSTATE_RESTARTING
	 BATCHSTATE_LOCKED BATCHSTATE_UNLOCKED
	 EXPTCANCEL_CLEAR EXPTCANCEL_TERM EXPTCANCEL_SWAP EXPTCANCEL_DEQUEUE

	 TBSetCancelFlag TBGetCancelFlag

	 TB_NODELOGTYPE_MISC TB_NODELOGTYPES TB_DEFAULT_NODELOGTYPE

	 TB_DEFAULT_RELOADTYPE TB_RELOADTYPE_FRISBEE TB_RELOADTYPE_NETDISK

	 TB_EXPTPRIORITY_LOW TB_EXPTPRIORITY_HIGH

	 TB_ASSIGN_TOOFEWNODES TB_OPSPID

	 TBDB_TBEVENT_NODESTATE TBDB_TBEVENT_NODEOPMODE TBDB_TBEVENT_CONTROL
	 TBDB_TBEVENT_COMMAND

	 TBDB_NODESTATE_ISUP TBDB_NODESTATE_REBOOTING TBDB_NODESTATE_REBOOTED
	 TBDB_NODESTATE_SHUTDOWN TBDB_NODESTATE_BOOTING TBDB_NODESTATE_TBSETUP
	 TBDB_NODESTATE_RELOADSETUP TBDB_NODESTATE_RELOADING
	 TBDB_NODESTATE_RELOADDONE TBDB_NODESTATE_RELOADDONE_V2
	 TBDB_NODESTATE_UNKNOWN
	 TBDB_NODESTATE_PXEWAIT TBDB_NODESTATE_PXEWAKEUP
	 TBDB_NODESTATE_PXEBOOTING TBDB_NODESTATE_ALWAYSUP
	 TBDB_NODESTATE_MFSSETUP TBDB_NODESTATE_TBFAILED
	 TBDB_NODESTATE_POWEROFF

	 TBDB_NODEOPMODE_NORMAL TBDB_NODEOPMODE_DELAYING
	 TBDB_NODEOPMODE_UNKNOWNOS TBDB_NODEOPMODE_RELOADING
	 TBDB_NODEOPMODE_NORMALv1 TBDB_NODEOPMODE_MINIMAL
	 TBDB_NODEOPMODE_RELOAD TBDB_NODEOPMODE_RELOADMOTE
	 TBDB_NODEOPMODE_DELAY
	 TBDB_NODEOPMODE_BOOTWHAT
	 TBDB_NODEOPMODE_ANY
	 TBDB_NODEOPMODE_UNKNOWN

	 TBDB_COMMAND_REBOOT
	 TBDB_COMMAND_POWEROFF TBDB_COMMAND_POWERON TBDB_COMMAND_POWERCYCLE

	 TBDB_STATED_TIMEOUT_REBOOT TBDB_STATED_TIMEOUT_NOTIFY
	 TBDB_STATED_TIMEOUT_CMDRETRY

	 TBDB_ALLOCSTATE_FREE_CLEAN TBDB_ALLOCSTATE_FREE_DIRTY
	 TBDB_ALLOCSTATE_DOWN TBDB_ALLOCSTATE_RELOAD_TO_FREE
	 TBDB_ALLOCSTATE_RELOAD_PENDING TBDB_ALLOCSTATE_RES_RELOAD
	 TBDB_ALLOCSTATE_RES_INIT_DIRTY TBDB_ALLOCSTATE_RES_INIT_CLEAN
	 TBDB_ALLOCSTATE_RES_REBOOT_DIRTY TBDB_ALLOCSTATE_RES_REBOOT_CLEAN
	 TBDB_ALLOCSTATE_RES_READY TBDB_ALLOCSTATE_UNKNOWN
	 TBDB_ALLOCSTATE_RES_TEARDOWN TBDB_ALLOCSTATE_DEAD
	 TBDB_ALLOCSTATE_RES_RECONFIG

	 TBDB_STATS_PRELOAD TBDB_STATS_START TBDB_STATS_TERMINATE
	 TBDB_STATS_SWAPIN TBDB_STATS_SWAPOUT TBDB_STATS_SWAPMODIFY
	 TBDB_STATS_FLAGS_IDLESWAP TBDB_STATS_FLAGS_PREMODIFY
	 TBDB_STATS_FLAGS_START TBDB_STATS_FLAGS_PRESWAPIN

	 TBDB_JAILIPBASE TBDB_JAILIPMASK

	 TBDB_RSRVROLE_NODE TBDB_RSRVROLE_VIRTHOST TBDB_RSRVROLE_DELAYNODE
	 TBDB_RSRVROLE_SIMHOST

	 TBDB_EXPT_WORKDIR
	 TBSetNodeEventState TBGetNodeEventState
	 TBNodeEventStateUpdated
	 TBSetNodeAllocState TBGetNodeAllocState
	 TBSetNodeOpMode TBGetNodeOpMode TBSetNodeNextOpMode
	 TB_OSID_MBKERNEL 
	 TB_OSID_FREEBSD_MFS TB_OSID_FRISBEE_MFS
	 TBBootWhat TBNodeStateTimeout
	 TBDB_TBCONTROL_RESET TBDB_TBCONTROL_RELOADDONE
	 TBDB_TBCONTROL_RELOADDONE_V2
	 TBDB_TBCONTROL_TIMEOUT TBDB_NO_STATE_TIMEOUT
	 TBDB_TBCONTROL_PXEBOOT TBDB_TBCONTROL_BOOTING
	 TBDB_TBCONTROL_CHECKGENISUP

	 TBDB_LOWVPORT TBDB_MAXVPORT TBDB_PORTRANGE

	 TBDB_PHYSICAL_NODE_TABLES

	 TBAdmin TBOpsGuy TBProjAccessCheck TBNodeAccessCheck 
	 TBExptAccessCheck MarkNodeDown
	 SetNodeBootStatus OSFeatureSupported NodeidToExp 
	 DBQuery DBQueryFatal DBQueryWarn DBWarn DBFatal DBErr
	 NewTBDBHandle DBQueryN DBQueryFatalN DBQueryWarnN DBErrN
	 DBQuoteSpecial ExpState
	 ExpNodes ExpNodeVnames ExpNodesOldReserved
	 DBDateTime DefaultImageID 
	 TBSetNodeLogEntry
	 MapNodeOSID 
	 TBOSID TBOSMaxConcurrent TBOSCountInstances
	 TBResolveNextOSID TBOsidToPid TBOSIDRebootWaittime
	 TBOSLoadMaxOkay TBImageLoadMaxOkay TBImageID 
	 TBdbfork TBDBDisconnect VnameToNodeid 
	 TBIsNodeRemote 
	 TBIsNodeImageable TBIsNodeVirtual TBControlNetIP TBPhysNodeID
	 TBNodeUpdateAccountsByPid TBNodeUpdateAccountsByType
	 TBNodeUpdateAccountsByUID
	 TBSaveExpLogFiles TBExptWorkDir TBExptUserDir TBExptLogDir
	 TBIPtoNodeID TBNodeBootReset TBNodeStateWait
	 TBExptSetSwapUID TBExptSetThumbNail
	 TBPlabNodeUsername MarkPhysNodeDown
	 TBExptIsElabInElab TBExptIsPlabInElab
	 TBExptPlabInElabPLC TBExptPlabInElabNodes
	 TBBatchUnLockExp TBExptIsBatchExp
	 
	 TBExptFirewall TBNodeFirewall TBExptFirewallAndPort
	 TBSetExptFirewallVlan TBClearExptFirewallVlan
	 TBNodeConsoleTail TBExptGetSwapoutAction TBExptGetSwapState

	 TBNodeSubNodes
	 TBNodeAdminOSID TBNodeDiskloadOSID
	 TBNodeType TBNodeTypeProcInfo TBNodeTypeBiosWaittime

	 TBExptRemoveVirtualState TBExptBackupVirtualState
	 TBExptRestoreVirtualState

	 TBExptRemovePhysicalState TBExptBackupPhysicalState
	 TBExptRestorePhysicalState TBExptClearBackupState

	 TBExptPortRange

	 TBDB_WIDEAREA_LOCALNODE
	 TBWideareaNodeID TBTipServers

	 TBSiteVarExists TBGetSiteVar TBSetSiteVar

	 TBActivityReport GatherAssignStats
	 TBAvailablePCs

	 TBDB_IFACEROLE_CONTROL TBDB_IFACEROLE_EXPERIMENT
	 TBDB_IFACEROLE_JAIL TBDB_IFACEROLE_FAKE TBDB_IFACEROLE_OTHER
	 TBDB_IFACEROLE_GW TBDB_IFACEROLE_OUTER_CONTROL

	 TBDB_ROUTERTYPE_NONE	TBDB_ROUTERTYPE_OSPF
	 TBDB_ROUTERTYPE_STATIC TBDB_ROUTERTYPE_MANUAL
	 TBDB_USER_INTERFACE_EMULAB TBDB_USER_INTERFACE_PLAB
	 TBDB_EVENTKEY TBDB_WEBKEY
	 TBDB_CHECKDBSLOT_NOFLAGS TBDB_CHECKDBSLOT_WARN TBDB_CHECKDBSLOT_ERROR
         max min TBcheck_dbslot TBFieldErrorString
	 hash_recurse array_recurse hash_recurse2 array_recurse2
	 TBGetUniqueIndex

	 TBExptMinMaxNodes TBExptSecurityLevel TBExptIDX
	 TBDB_SECLEVEL_GREEN TBDB_SECLEVEL_BLUE TBDB_SECLEVEL_YELLOW
	 TBDB_SECLEVEL_ORANGE TBDB_SECLEVEL_RED TBDB_SECLEVEL_ZAPDISK

	 TBExptSetPanicBit TBExptGetPanicBit TBExptClearPanicBit

	 TB_NODEHISTORY_OP_FREE TB_NODEHISTORY_OP_ALLOC TB_NODEHISTORY_OP_MOVE
	 TBSetNodeHistory

	 TBGetOSBootCmd

	 TBRobotLabExpt

	 TBExptContainsNodeCT
	 );

# Must come after package declaration!
use lib '@prefix@/lib';
use libtblog_simple;
use English;
use File::Basename;
use POSIX qw(strftime);
require User;
require Project;
require Group;
require Node;
require NodeType;
require Mysql;
require Lan;
use vars qw($DBQUERY_MAXTRIES $DBCONN_MAXTRIES
	    $DBCONN_EXITONERR $DBQUERY_RECONNECT $DBQUERY_DEBUG
	    @EXPORT_OK @virtualTables @physicalTables);

# Configure variables
my $TB		= "@prefix@";
my $DBNAME	= "@TBDBNAME@";
my $TBOPS       = "@TBOPSEMAIL@";
my $EVENTSYS    = "@EVENTSYS@";
my $BOSSNODE    = "@BOSSNODE@";
my $TESTMODE    = @TESTMODE@;
my $TBOPSPID	= "emulab-ops";
my $SCRIPTNAME  = "Unknown";
my $EXPTLOGNAME = "activity.log";
my $PROJROOT    = "@PROJROOT_DIR@";

if ($EVENTSYS) {
    require event;
    import event;
}

# Untainted scriptname for email below.
if ($PROGRAM_NAME =~ /^([-\w\.\/]+)$/) {
    $SCRIPTNAME = basename($1);
}
else {
    $SCRIPTNAME = "Tainted";
}

{
    #
    # Create a special class for keeping track of the process the
    # database handle was created.  This is needed so that the child
    # process after a fork() 1) set's InactiveDestroy to avoid sending
    # a disconnect message since it will also close the parent's
    # database handle 2) reconnects since two separate processes
    # shouldn't share the same handle.  (1) is handled via overridding
    # the database handle DESTROY method, (2) is handled in the
    # DBQueryN function.
    #
    package TestbedDBHandle;
    use vars '@ISA';
    @ISA = ('Mysql');
    @TestbedDBHandle::Statement::ISA = ('Mysql::Statement');
    my %DB_PID; # hash based on db handle
    sub obj_hash( $ ) {
	# Return a hex string of the location of the object in memory.
	# This is slightly better than just converting it to a scalar
	# as two objects as the scalar also included the class name
	# the object is "blessed" into which might change over time
	sprintf("0x%x", $_[0]); 
    }
    sub MakeA ( $ ) {
	my ($obj) = @_;
	return unless defined $obj;
	bless ($obj);
	$DB_PID{obj_hash($obj)} = $$;
    }
    sub db_pid () {
	my ($self) = @_;
	return $DB_PID{obj_hash($self)};
    }
    sub DESTROY {
	my ($self) = @_;
	if ($self->db_pid() != $$) {
	    $self->setInactiveDestroy(1);
	}
	delete $DB_PID{obj_hash($self)};
	$self->SUPER::DESTROY() if $self->can("SUPER::DESTROY");
    }
}

#
# Set up for querying the database. Note that fork causes a reconnect
# to the DB in the child.
#
my @DB;
$DBQUERY_MAXTRIES  = 1;
$DBQUERY_RECONNECT = 1;
$DBCONN_MAXTRIES   = 5;
$DBCONN_EXITONERR  = 1;
$DBQUERY_DEBUG     = 0;
@EXPORT_OK         = qw($DBQUERY_MAXTRIES $DBQUERY_RECONNECT
			$DBCONN_EXITONERR $DBCONN_MAXTRIES $DBQUERY_DEBUG);

sub TBDBConnect($)
{
    my ($dbnum) = @_;
    my $maxtries = $DBCONN_MAXTRIES;

    #
    # Construct a 'username' from the name of this script and the user who
    # ran it. This is for accounting purposes.
    #
    my $name = getpwuid($UID);
    if (!$name) {
	$name = "uid$UID";
    }
    my $dbuser = "$SCRIPTNAME:$name:$PID";

    while ($maxtries) {
	$DB[$dbnum] = Mysql->connect("localhost", $DBNAME, $dbuser, "none");
        TestbedDBHandle::MakeA($DB[$dbnum]);
	if (defined($DB[$dbnum])) {
	    last;
	}
	$maxtries--;
	if ($maxtries) {
	    print STDERR "Cannot connect to DB; trying again in 5 seconds!\n";
	    sleep(5);
	}
    }
    if (!defined($DB[$dbnum])) {
	print STDERR
	    "Cannot connect to DB after $DBQUERY_MAXTRIES attempts!\n";
	return -1
	    if (! $DBCONN_EXITONERR);
	exit(-1);
    }
    $DB[$dbnum]->{'dbh'}->{'PrintError'} = 0;
    $Mysql::QUIET = 1;
    return 0;
}
TBDBConnect(0);

# Old version. Should be renamed or just eventfork.
sub TBdbfork()
{
    if ($EVENTSYS) {
	EventFork();
    }
}

# New version.
sub TBDBReconnect($)
{
    my ($retry) = @_;
    my ($exitonerr,$maxtries);
    
    if ($retry) {
	$exitonerr = $DBCONN_EXITONERR;
	$DBCONN_EXITONERR = 0;
	
	# And we want to keep trying for a long time!
	$maxtries = $DBCONN_MAXTRIES;
	$DBCONN_MAXTRIES  = 10000;
    }

    for (my $i = 0; $i < @DB; $i++) {
	undef($DB[$i]);
	return -1
	    if (TBDBConnect($i) != 0);
    }

    if ($retry) {
	$DBCONN_EXITONERR = $exitonerr;
	$DBCONN_MAXTRIES  = $maxtries;
    }
    #print "Reconnected to DB in process $PID\n";
   
    return 0;
}

# To avoid keeping a mysql connection around.
sub TBDBDisconnect()
{
    for (my $i = 0; $i < @DB; $i++) {
	undef($DB[$i]);
    }
    select(undef, undef, undef, 0.2);
}

# Create a new DB handle and return the handle number
sub NewTBDBHandle() {
    my $dbnum = @DB;
    TBDBConnect($dbnum);
    return $dbnum;
}

#
# Record last DB error string.
#
my $DBErrorString = "";

#
# Needs to be config'ed.
#
sub TBDB_EXPT_WORKDIR()		{ "/usr/testbed/expwork"; }

#
# Define exported "constants". Basically, these are just perl subroutines
# that look like constants cause you do not need to call a perl subroutine
# with parens. That is, FOO and FOO() are the same thing.
#
sub NODERELOADING_PID()		{ $TBOPSPID; }
sub NODERELOADING_EID()		{ "reloading"; }
sub NODERELOADPENDING_EID()	{ "reloadpending"; }
sub NODEREPOSITIONING_PID()	{ $TBOPSPID; }
sub NODEREPOSITIONING_EID()	{ "repositioning"; }
sub NODEREPOSPENDING_EID()	{ "repositionpending"; }
sub NODEDEAD_PID()		{ $TBOPSPID; }
sub NODEDEAD_EID()		{ "hwdown"; }
sub PLABMOND_PID()		{ $TBOPSPID; }
sub PLABMOND_EID()		{ "plab-monitor"; }
sub PLABTESTING_PID()		{ $TBOPSPID; }
sub PLABTESTING_EID()		{ "plab-testing"; }
sub PLABHOLDING_PID()		{ $TBOPSPID; }
sub PLABHOLDING_EID()		{ "plabnodes"; }
sub PLABDOWN_PID()		{ $TBOPSPID; }
sub PLABDOWN_EID()		{ "hwdown"; }
sub OLDRESERVED_PID()		{ $TBOPSPID; }
sub OLDRESERVED_EID()		{ "oldreserved"; }
sub NFREELOCKED_PID()		{ $TBOPSPID; }
sub NFREELOCKED_EID()		{ "nfree-locked"; }
sub TBOPSPID()			{ $TBOPSPID; }
sub EXPTLOGNAME()		{ $EXPTLOGNAME; }

sub NODEBOOTSTATUS_OKAY()	{ "okay" ; }
sub NODEBOOTSTATUS_FAILED()	{ "failed"; }
sub NODEBOOTSTATUS_UNKNOWN()	{ "unknown"; }
sub NODESTARTSTATUS_NOSTATUS()	{ "none"; }

sub NODEFAILMODE_FATAL()	{ "fatal"; }
sub NODEFAILMODE_NONFATAL()	{ "nonfatal"; }
sub NODEFAILMODE_IGNORE()	{ "ignore"; }

# Experiment states
sub EXPTSTATE_NEW()		{ "new"; }
sub EXPTSTATE_PRERUN()		{ "prerunning"; }
sub EXPTSTATE_SWAPPED()		{ "swapped"; }
sub EXPTSTATE_QUEUED()		{ "queued"; }
sub EXPTSTATE_SWAPPING()	{ "swapping"; }
sub EXPTSTATE_ACTIVATING()	{ "activating"; }
sub EXPTSTATE_ACTIVE()		{ "active"; }
sub EXPTSTATE_PANICED()		{ "paniced"; }
sub EXPTSTATE_TERMINATING()	{ "terminating"; }
sub EXPTSTATE_TERMINATED()	{ "ended"; }
sub EXPTSTATE_MODIFY_PARSE()	{ "modify_parse"; }
sub EXPTSTATE_MODIFY_REPARSE()	{ "modify_reparse"; }
sub EXPTSTATE_MODIFY_RESWAP()	{ "modify_reswap"; }
sub EXPTSTATE_RESTARTING()	{ "restarting"; }
# For the batch_daemon.
sub BATCHSTATE_LOCKED()		{ "locked";}
sub BATCHSTATE_UNLOCKED()	{ "unlocked";}

# Cancel flags
sub EXPTCANCEL_CLEAR()		{ 0 ;}
sub EXPTCANCEL_TERM()		{ 1 ;}
sub EXPTCANCEL_SWAP()		{ 2 ;}
sub EXPTCANCEL_DEQUEUE()	{ 3 ;}

sub USERSTATUS_ACTIVE()		{ "active"; }
sub USERSTATUS_FROZEN()		{ "frozen"; }
sub USERSTATUS_UNAPPROVED()	{ "unapproved"; }
sub USERSTATUS_UNVERIFIED()	{ "unverified"; }
sub USERSTATUS_NEWUSER()	{ "newuser"; }
sub USERSTATUS_ARCHIVED()	{ "archived"; }

#
# We want valid project membership to be non-zero for easy membership
# testing. Specific trust levels are encoded thusly.
#
sub PROJMEMBERTRUST_NONE()	{ 0; }
sub PROJMEMBERTRUST_USER()	{ 1; }
sub PROJMEMBERTRUST_ROOT()	{ 2; }
sub PROJMEMBERTRUST_LOCALROOT()	{ 2; }
sub PROJMEMBERTRUST_GROUPROOT()	{ 3; }
sub PROJMEMBERTRUST_PROJROOT()	{ 4; }
sub PROJMEMBERTRUST_ADMIN()	{ 5; }

#
# Access types. Duplicated in the web interface. Make changes there too!
#
# Things you can do to a node.
sub TB_NODEACCESS_READINFO()	{ 1; }
sub TB_NODEACCESS_MODIFYINFO()	{ 2; }
sub TB_NODEACCESS_LOADIMAGE()	{ 3; }
sub TB_NODEACCESS_REBOOT()	{ 4; }
sub TB_NODEACCESS_POWERCYCLE()	{ 5; }
sub TB_NODEACCESS_MODIFYVLANS()	{ 6; }
sub TB_NODEACCESS_MIN()		{ TB_NODEACCESS_READINFO; }
sub TB_NODEACCESS_MAX()		{ TB_NODEACCESS_MODIFYVLANS; }

# User Info (modinfo web page, etc).
sub TB_USERINFO_READINFO()	{ 1; }
sub TB_USERINFO_MODIFYINFO()	{ 2; }
sub TB_USERINFO_MIN()		{ TB_USERINFO_READINFO; }
sub TB_USERINFO_MAX()		{ TB_USERINFO_MODIFYINFO; }

# Experiments.
sub TB_EXPT_READINFO()		{ 1; }
sub TB_EXPT_MODIFY()		{ 2; }
sub TB_EXPT_DESTROY()		{ 3; }
sub TB_EXPT_UPDATE()		{ 4; }
sub TB_EXPT_MIN()		{ TB_EXPT_READINFO; }
sub TB_EXPT_MAX()		{ TB_EXPT_UPDATE; }

# Projects.
sub TB_PROJECT_READINFO()	{ 1; }
sub TB_PROJECT_MAKEGROUP()	{ 2; }
sub TB_PROJECT_EDITGROUP()	{ 3; }
sub TB_PROJECT_GROUPGRABUSERS() { 4; }
sub TB_PROJECT_BESTOWGROUPROOT(){ 5; }
sub TB_PROJECT_DELGROUP()	{ 6; }
sub TB_PROJECT_LEADGROUP()	{ 7; }
sub TB_PROJECT_ADDUSER()	{ 8; }
sub TB_PROJECT_DELUSER()	{ 9; }
sub TB_PROJECT_MAKEOSID()	{ 10; }
sub TB_PROJECT_DELOSID()	{ 11; }
sub TB_PROJECT_MAKEIMAGEID()	{ 12; }
sub TB_PROJECT_DELIMAGEID()	{ 13; }
sub TB_PROJECT_CREATEEXPT()	{ 14; }
sub TB_PROJECT_MIN()		{ TB_PROJECT_READINFO; }
sub TB_PROJECT_MAX()		{ TB_PROJECT_CREATEEXPT; }

# OSIDs
sub TB_OSID_READINFO()		{ 1; }
sub TB_OSID_CREATE()		{ 2; }
sub TB_OSID_DESTROY()		{ 3; }
sub TB_OSID_MIN()		{ TB_OSID_READINFO; }
sub TB_OSID_MAX()		{ TB_OSID_DESTROY; }
sub TB_OSID_OSIDLEN()		{ 35; }
sub TB_OSID_OSNAMELEN()		{ 20; }
sub TB_OSID_VERSLEN()		{ 12; }

# Magic OSID constants
sub TB_OSID_MBKERNEL()          { "_KERNEL_"; } # multiboot kernel OSID

# Magic MFS constants
sub TB_OSID_FREEBSD_MFS()	{ "FREEBSD-MFS" };
sub TB_OSID_FRISBEE_MFS()	{ "FRISBEE-MFS" };

# ImageIDs
#
# Clarification:
# READINFO is read-only access to the image and its contents
# (This is what people get for shared images)
# ACCESS means complete power over the image and its [meta]data
sub TB_IMAGEID_READINFO()	{ 1; }
sub TB_IMAGEID_MODIFYINFO()	{ 2; }
sub TB_IMAGEID_CREATE()		{ 3; }
sub TB_IMAGEID_DESTROY()	{ 4; }
sub TB_IMAGEID_ACCESS()		{ 5; }
sub TB_IMAGEID_MIN()		{ TB_IMAGEID_READINFO; }
sub TB_IMAGEID_MAX()		{ TB_IMAGEID_ACCESS; }
sub TB_IMAGEID_IMAGEIDLEN()	{ 45; }
sub TB_IMAGEID_IMAGENAMELEN()	{ 30; }

# Node Log Types
sub TB_NODELOGTYPE_MISC		{ "misc"; }
sub TB_NODELOGTYPES()		{ ( TB_NODELOGTYPE_MISC ) ; }
sub TB_DEFAULT_NODELOGTYPE()	{ TB_NODELOGTYPE_MISC; }

# Node History Stuff.
sub TB_NODEHISTORY_OP_FREE	{ "free"; }
sub TB_NODEHISTORY_OP_ALLOC	{ "alloc"; }
sub TB_NODEHISTORY_OP_MOVE	{ "move"; }

# Reload Types.
sub TB_RELOADTYPE_NETDISK()	{ "netdisk"; }
sub TB_RELOADTYPE_FRISBEE()	{ "frisbee"; }
sub TB_DEFAULT_RELOADTYPE()	{ TB_RELOADTYPE_FRISBEE; }

# Experiment priorities.
sub TB_EXPTPRIORITY_LOW()	{ 0; }
sub TB_EXPTPRIORITY_HIGH()	{ 20; }

# Assign exit status for too few nodes.
sub TB_ASSIGN_TOOFEWNODES()	{ 2; }

# System PID.
sub TB_OPSPID()			{ $TBOPSPID; }

#
# Events we may want to send
#
sub TBDB_TBEVENT_NODESTATE	{ "TBNODESTATE"; }
sub TBDB_TBEVENT_NODEOPMODE	{ "TBNODEOPMODE"; }
sub TBDB_TBEVENT_CONTROL	{ "TBCONTROL"; }
sub TBDB_TBEVENT_COMMAND	{ "TBCOMMAND"; }
sub TBDB_TBEVENT_EXPTSTATE	{ "TBEXPTSTATE"; }

#
# For nodes, we use this set of events.
#
sub TBDB_NODESTATE_ISUP()	{ "ISUP"; }
sub TBDB_NODESTATE_ALWAYSUP()	{ "ALWAYSUP"; }
sub TBDB_NODESTATE_REBOOTED()	{ "REBOOTED"; }
sub TBDB_NODESTATE_REBOOTING()	{ "REBOOTING"; }
sub TBDB_NODESTATE_SHUTDOWN()	{ "SHUTDOWN"; }
sub TBDB_NODESTATE_BOOTING()	{ "BOOTING"; }
sub TBDB_NODESTATE_TBSETUP()	{ "TBSETUP"; }
sub TBDB_NODESTATE_RELOADSETUP(){ "RELOADSETUP"; }
sub TBDB_NODESTATE_MFSSETUP()   { "MFSSETUP"; }
sub TBDB_NODESTATE_TBFAILED()	{ "TBFAILED"; }
sub TBDB_NODESTATE_RELOADING()	{ "RELOADING"; }
sub TBDB_NODESTATE_RELOADDONE()	{ "RELOADDONE"; }
sub TBDB_NODESTATE_RELOADDONE_V2(){ "RELOADDONEV2"; }
sub TBDB_NODESTATE_UNKNOWN()	{ "UNKNOWN"; };
sub TBDB_NODESTATE_PXEWAIT()	{ "PXEWAIT"; }
sub TBDB_NODESTATE_PXEWAKEUP()	{ "PXEWAKEUP"; }
sub TBDB_NODESTATE_PXEBOOTING()	{ "PXEBOOTING"; }
sub TBDB_NODESTATE_POWEROFF()	{ "POWEROFF"; }

sub TBDB_NODEOPMODE_ANY		{ "*"; } # A wildcard opmode
sub TBDB_NODEOPMODE_NORMAL	{ "NORMAL"; }
sub TBDB_NODEOPMODE_DELAYING	{ "DELAYING"; }
sub TBDB_NODEOPMODE_UNKNOWNOS	{ "UNKNOWNOS"; }
sub TBDB_NODEOPMODE_RELOADING	{ "RELOADING"; }
sub TBDB_NODEOPMODE_NORMALv1	{ "NORMALv1"; }
sub TBDB_NODEOPMODE_MINIMAL	{ "MINIMAL"; }
sub TBDB_NODEOPMODE_RELOAD	{ "RELOAD"; }
sub TBDB_NODEOPMODE_RELOADMOTE	{ "RELOAD-MOTE"; }
sub TBDB_NODEOPMODE_DELAY	{ "DELAY"; }
sub TBDB_NODEOPMODE_BOOTWHAT	{ "_BOOTWHAT_"; } # A redirection opmode
sub TBDB_NODEOPMODE_UNKNOWN	{ "UNKNOWN"; }

sub TBDB_COMMAND_REBOOT         { "REBOOT"; }
sub TBDB_COMMAND_POWEROFF       { "POWEROFF"; }
sub TBDB_COMMAND_POWERON        { "POWERON"; }
sub TBDB_COMMAND_POWERCYCLE     { "POWERCYCLE"; }

sub TBDB_STATED_TIMEOUT_REBOOT  { "REBOOT"; }
sub TBDB_STATED_TIMEOUT_NOTIFY  { "NOTIFY"; }
sub TBDB_STATED_TIMEOUT_CMDRETRY{ "CMDRETRY"; }

sub TBDB_ALLOCSTATE_FREE_CLEAN()       { "FREE_CLEAN"; }
sub TBDB_ALLOCSTATE_FREE_DIRTY()       { "FREE_DIRTY"; }
sub TBDB_ALLOCSTATE_DOWN()             { "DOWN"; }
sub TBDB_ALLOCSTATE_DEAD()             { "DEAD"; }
sub TBDB_ALLOCSTATE_RELOAD_TO_FREE()   { "RELOAD_TO_FREE"; }
sub TBDB_ALLOCSTATE_RELOAD_PENDING()   { "RELOAD_PENDING"; }
sub TBDB_ALLOCSTATE_RES_RELOAD()       { "RES_RELOAD"; }
sub TBDB_ALLOCSTATE_RES_REBOOT_DIRTY() { "RES_REBOOT_DIRTY"; }
sub TBDB_ALLOCSTATE_RES_REBOOT_CLEAN() { "RES_REBOOT_CLEAN"; }
sub TBDB_ALLOCSTATE_RES_INIT_DIRTY()   { "RES_INIT_DIRTY"; }
sub TBDB_ALLOCSTATE_RES_INIT_CLEAN()   { "RES_INIT_CLEAN"; }
sub TBDB_ALLOCSTATE_RES_READY()        { "RES_READY"; }
sub TBDB_ALLOCSTATE_RES_RECONFIG()     { "RES_RECONFIG"; }
sub TBDB_ALLOCSTATE_RES_TEARDOWN()     { "RES_TEARDOWN"; }
sub TBDB_ALLOCSTATE_UNKNOWN()          { "UNKNOWN"; };

sub TBDB_TBCONTROL_RESET	{ "RESET"; }
sub TBDB_TBCONTROL_RELOADDONE	{ "RELOADDONE"; }
sub TBDB_TBCONTROL_RELOADDONE_V2{ "RELOADDONEV2"; }
sub TBDB_TBCONTROL_TIMEOUT	{ "TIMEOUT"; }
sub TBDB_TBCONTROL_PXEBOOT	{ "PXEBOOT"; }
sub TBDB_TBCONTROL_BOOTING	{ "BOOTING"; }
sub TBDB_TBCONTROL_CHECKGENISUP	{ "CHECKGENISUP"; }

# Constant we use for the timeout field when there is no timeout for a state
sub TBDB_NO_STATE_TIMEOUT	{ 0; }

#
# Node name we use in the widearea_* tables to represent a generic local node.
# All local nodes are considered to have the same network characteristcs.
#
sub TBDB_WIDEAREA_LOCALNODE     { "boss"; }

#
# We should list all of the DB limits.
#
sub DBLIMIT_NSFILESIZE()	{ (2**24 - 1); }

#
# Virtual nodes must operate within a restricted port range. The range
# is effective across all virtual nodes in the experiment. When an
# experiment is swapped in, allocate a subrange from this and setup
# all the vnodes to allocate from that range. We tell the user this
# range so this they can set up their programs to operate in that range.
#
sub TBDB_LOWVPORT()		{ 30000; }
sub TBDB_MAXVPORT()		{ 60000; }
sub TBDB_PORTRANGE()		{ 256;   }

#
# STATS constants.
#
sub TBDB_STATS_PRELOAD()	{ "preload"; }
sub TBDB_STATS_START()		{ "start"; }
sub TBDB_STATS_TERMINATE()	{ "destroy"; }
sub TBDB_STATS_SWAPIN()		{ "swapin"; }
sub TBDB_STATS_SWAPOUT()	{ "swapout"; }
sub TBDB_STATS_SWAPMODIFY()	{ "swapmod"; }
sub TBDB_STATS_FLAGS_IDLESWAP()	{ 0x01; }
sub TBDB_STATS_FLAGS_PREMODIFY(){ 0x02; }
sub TBDB_STATS_FLAGS_START()    { 0x04; }
sub TBDB_STATS_FLAGS_PRESWAPIN(){ 0x08; }
sub TBDB_STATS_FLAGS_BATCHCTRL(){ 0x10; }
# Do not export these variables!
my $TBDB_STATS_STARTCLOCK;
my $TBDB_STATS_SAVEDSWAPUID;

# Jail.
sub TBDB_JAILIPBASE()		{ "@JAILIPBASE@"; }
sub TBDB_JAILIPMASK()		{ "@JAILIPMASK@"; }

# Reserved node "roles"
sub TBDB_RSRVROLE_NODE()	{ "node"; }
sub TBDB_RSRVROLE_VIRTHOST()	{ "virthost"; }
sub TBDB_RSRVROLE_DELAYNODE()	{ "delaynode"; }
sub TBDB_RSRVROLE_SIMHOST()	{ "simhost"; }

# Interfaces roles.
sub TBDB_IFACEROLE_CONTROL()	{ "ctrl"; }
sub TBDB_IFACEROLE_EXPERIMENT()	{ "expt"; }
sub TBDB_IFACEROLE_JAIL()	{ "jail"; }
sub TBDB_IFACEROLE_FAKE()	{ "fake"; }
sub TBDB_IFACEROLE_GW()		{ "gw"; }
sub TBDB_IFACEROLE_OTHER()	{ "other"; }
sub TBDB_IFACEROLE_OUTER_CONTROL(){ "outer_ctrl"; }

# Routertypes.
sub TBDB_ROUTERTYPE_NONE()	{ "none"; }
sub TBDB_ROUTERTYPE_OSPF()	{ "ospf"; }
sub TBDB_ROUTERTYPE_STATIC()	{ "static"; }
sub TBDB_ROUTERTYPE_MANUAL()	{ "manual"; }

# User Interface types.
sub TBDB_USER_INTERFACE_EMULAB(){ "emulab"; }
sub TBDB_USER_INTERFACE_PLAB()	{ "plab"; }

# Key Stuff
sub TBDB_EVENTKEY($$)	{ TBExptUserDir($_[0],$_[1]) . "/tbdata/eventkey"; }
sub TBDB_WEBKEY($$)	{ TBExptUserDir($_[0],$_[1]) . "/tbdata/webkey"; }

# Regex stuff
sub TBDB_CHECKDBSLOT_NOFLAGS()	{ 0x0; }
sub TBDB_CHECKDBSLOT_WARN()	{ 0x1; }
sub TBDB_CHECKDBSLOT_ERROR()	{ 0x2; }

# Security Levels.
sub TBDB_SECLEVEL_GREEN()	{ 0; }
sub TBDB_SECLEVEL_BLUE()	{ 1; }
sub TBDB_SECLEVEL_YELLOW()	{ 2; }
sub TBDB_SECLEVEL_ORANGE()	{ 3; }
sub TBDB_SECLEVEL_RED()		{ 4; }

# This is the level at which we get extremely cautious when swapping out
sub TBDB_SECLEVEL_ZAPDISK()	{ TBDB_SECLEVEL_YELLOW; }

#
# A hash of all tables that contain information about physical nodes - the
# value for each key is the list of columns that could contain the node's ID.
#
sub TBDB_PHYSICAL_NODE_TABLES() {
    return (
	'current_reloads'	=> [ 'node_id' ],
	'delays'		=> [ 'node_id' ],
	'iface_counters'	=> [ 'node_id' ],
	'interfaces'		=> [ 'node_id' ],
	'interface_settings'	=> [ 'node_id' ],
	'last_reservation'	=> [ 'node_id' ],
	'linkdelays'		=> [ 'node_id' ],
	'location_info'		=> [ 'node_id' ],
	'next_reserve'		=> [ 'node_id' ],
	'node_activity'		=> [ 'node_id' ],
	'node_auxtypes'		=> [ 'node_id' ],
	'node_features'		=> [ 'node_id' ],
	'node_hostkeys'		=> [ 'node_id' ],
	'node_idlestats'	=> [ 'node_id' ],
	'node_status'   	=> [ 'node_id' ],
	'node_rusage'		=> [ 'node_id' ],
	'nodeipportnum'		=> [ 'node_id' ],
	'nodelog'		=> [ 'node_id' ],
	'nodes'			=> [ 'node_id', 'phys_nodeid' ],
	'nodeuidlastlogin'	=> [ 'node_id' ],
	'ntpinfo'		=> [ 'node_id' ],
	'outlets'		=> [ 'node_id' ],
	'partitions'		=> [ 'node_id' ],
	'plab_slice_nodes'	=> [ 'node_id' ],
	'port_counters'		=> [ 'node_id' ],
	'reserved'		=> [ 'node_id' ],
	'scheduled_reloads'	=> [ 'node_id' ],
	'state_triggers'	=> [ 'node_id' ],
	'switch_stacks'		=> [ 'node_id' ],
	'tiplines'		=> [ 'node_id' ],
	'tmcd_redirect'		=> [ 'node_id' ],
	'tunnels'		=> [ 'node_id' ],
	'uidnodelastlogin'	=> [ 'node_id' ],
	'v2pmap'		=> [ 'node_id' ],
	'vinterfaces'		=> [ 'node_id' ],
	'widearea_accounts'	=> [ 'node_id' ],
	'widearea_delays'	=> [ 'node_id1', 'node_id2' ],
	'widearea_recent'	=> [ 'node_id1', 'node_id2' ],
	'wires'			=> [ 'node_id1', 'node_id2' ],
	'node_startloc'		=> [ 'node_id' ],
	'node_history'		=> [ 'node_id' ],
	'node_bootlogs'		=> [ 'node_id' ],
        'plab_mapping'          => [ 'node_id' ],
        'node_utilization'      => [ 'node_id' ],
    );
}

#
# Auth stuff.
#

#
# Convert a trust string to the above numeric values.
#
sub TBTrustConvert($)
{
    my($trust_string) = @_;
    my $trust_value = 0;

    #
    # Convert string to value. Perhaps the DB should have done it this way?
    #
    if ($trust_string eq "none") {
	$trust_value = PROJMEMBERTRUST_NONE;
    }
    elsif ($trust_string eq "user") {
	$trust_value = PROJMEMBERTRUST_USER;
    }
    elsif ($trust_string eq "local_root") {
	$trust_value = PROJMEMBERTRUST_LOCALROOT;
    }
    elsif ($trust_string eq "group_root") {
	$trust_value = PROJMEMBERTRUST_GROUPROOT;
    }
    elsif ($trust_string eq "project_root") {
	$trust_value = PROJMEMBERTRUST_PROJROOT;
    }
    elsif ($trust_string eq "admin") {
	$trust_value = PROJMEMBERTRUST_ADMIN;
    }
    else {
	    die("*** Invalid trust value $trust_string!");
    }

    return $trust_value;
}

#
# Return true if the given trust string is >= to the minimum required.
# The trust value can be either numeric or a string; if a string its
# first converted to the numeric equiv.
#
sub TBMinTrust($$)
{
    my ($trust_value, $minimum) = @_;

    if ($minimum < PROJMEMBERTRUST_NONE ||
	$minimum > PROJMEMBERTRUST_ADMIN) {
	    die("*** Invalid minimum trust $minimum!");
    }

    #
    # Sleazy? How do you do a typeof in perl?
    #
    if (length($trust_value) != 1) {
	$trust_value = TBTrustConvert($trust_value);
    }

    return $trust_value >= $minimum;
}

#
# Determine the trust level for a uid/pid/gid. That is, each uid will have
# a different trust level depending on the project/group in question.
# Return that trust level as one of the numeric values above.
#
# usage: TBGrpTrust($dbuid, $pid, $gid)
#        returns numeric trust value if a group member.
#        returns PROJMEMBERTRUST_NONE if not a group member.
#
sub TBGrpTrust($$$)
{
    my ($uid, $pid, $gid) = @_;

    #
    # No group, then use the default group.
    #
    $gid = $pid
	if (! $gid);

    #
    # Must map to an existing user to be trusted, obviously.
    #
    my $target_user = User->Lookup($uid);
    return PROJMEMBERTRUST_NONE
	if (! defined($target_user));

    # Ditto the group.
    my $target_group = Group->Lookup($pid, $gid);
    return PROJMEMBERTRUST_NONE
	if (! defined($target_group));

    return $target_group->Trust($target_user)
}

#
# Determine the project trust level for a uid/pid. This is the trust level
# for the default group in the project.
#
# usage: TBProjTrust($dbuid, $pid)
#        returns numeric trust value if a project member.
#        returns PROJMEMBERTRUST_NONE if not a project member.
#
sub TBProjTrust($$)
{
    my ($uid, $pid) = @_;

    return TBGrpTrust($uid, $pid, $pid);
}

#
# Test admin status. Ignore argument; we only care if the current user
# has admin privs turned on.
#
# usage: TBAdmin();
#        returns 1 if an admin type.
#        returns 0 if a mere user.
#
sub TBAdmin(;$)
{
    my $this_user = User->ThisUser();
    return 0
	if (! defined($this_user));

    return $this_user->IsAdmin();
}

#
# Project permission checks. The group id (gid) can be undef, in which case
# the pid is used (ie: a default group check is made).
#
# Usage: TBProjAccessCheck($uid, $pid, $gid, $access_type)
#	 returns 0 if not allowed.
#        returns 1 if allowed.
#
sub TBProjAccessCheck($$$$)
{
    my ($uid, $pid, $gid, $access_type) = @_;

    #
    # Must map to an existing user to be trusted, obviously.
    #
    my $target_user = User->LookupByUnixId($uid);
    return 0
	if (! defined($target_user));

    # Ditto the group
    my $target_group = Group->Lookup($pid, $gid);
    return 0
	if (! defined($target_group));

    return $target_group->AccessCheck($target_user, $access_type);
}

#
# Experiment permission checks.
#
# Usage: TBExptAccessCheck($uid, $pid, $eid, $access_type)
#	 returns 0 if not allowed.
#        returns 1 if allowed.
#
sub TBExptAccessCheck($$$$)
{
    my ($uid, $pid, $eid, $access_type) = @_;

    #
    # Must map to an existing user to be trusted, obviously.
    #
    my $target_user = User->LookupByUnixId($uid);
    return 0
	if (! defined($target_user));

    # Ditto the group
    my $experiment = Experiment->Lookup($pid, $eid);
    return 0
	if (! defined($experiment));

    return $experiment->AccessCheck($target_user, $access_type);
}

#
# Determine if uid can access a node or list of nodes.
#
# Usage: TBNodeAccessCheck($uid, $access_type, $node_id, ...)
#	 returns 0 if not allowed.
#        returns 1 if allowed.
#
sub TBNodeAccessCheck($$@)
{
    my ($uid, $access_type) = (shift, shift);
    my @nodelist = @_;

    #
    # Must map to an existing user to be trusted, obviously.
    #
    my $target_user = User->LookupByUnixId($uid);
    return 0
	if (! defined($target_user));
    return 1
	if ($target_user->IsAdmin());

    foreach my $nodeid (@nodelist) {
	my $node = Node->Lookup($nodeid);
	return 0
	    if (!defined($node));

	return 0
	    if (!$node->AccessCheck($target_user, $access_type));
    }
    return 1;
}

#
# Return Experiment state.
#
# usage: ExpState(char *pid, char *eid)
#        returns state if a valid pid/eid.
#        returns 0 if an invalid pid/eid or if an error.
#
sub ExpState($$)
{
    my ($pid, $eid) = @_;

    my $experiment = Experiment->Lookup($pid, $eid);
    return 0
	if (!defined($experiment));
    return $experiment->state();
}

#
# Helper function for batch system.
#
sub TBBatchUnLockExp($$;$)
{
    my($pid, $eid, $newstate) = @_;
    my $BSTATE_UNLOCKED       = BATCHSTATE_UNLOCKED;
    
    my $query_result =
	DBQueryWarn("update experiments set expt_locked=NULL, ".
		    "       batchstate='$BSTATE_UNLOCKED' ".
		    (defined($newstate) ? ",state='$newstate' " : "") .
		    "where eid='$eid' and pid='$pid'");
    
    if (! $query_result ||
	$query_result->numrows == 0) {
	return 0;
    }
    
    if ($EVENTSYS && defined($newstate)) {
	EventSendWarn(objtype   => TBDB_TBEVENT_EXPTSTATE,
		      objname   => "$pid/$eid",
		      eventtype => $newstate,
		      expt      => "$pid/$eid",
		      host      => $BOSSNODE);
    }
    return 1;
}

#
# Set cancel flag,
#
# usage: SetCancelFlag(char *pid, char *eid, char *flag)
#        returns 1 if okay.
#        returns 0 if an invalid pid/eid or if an error.
#
sub TBSetCancelFlag($$$)
{
    my($pid, $eid, $flag) = @_;

    my $query_result =
	DBQueryWarn("update experiments set canceled='$flag' ".
		    "where eid='$eid' and pid='$pid'");

    if (! $query_result ||
	$query_result->numrows == 0) {
	return 0;
    }
    return 1;
}

#
# Get cancel flag,
#
# usage: TBGetCancelFlag(char *pid, char *eid, char **flag)
#        returns 1 if okay.
#        returns 0 if an invalid pid/eid or if an error.
#
sub TBGetCancelFlag($$$)
{
    my($pid, $eid, $flag) = @_;

    my $query_result =
	DBQueryWarn("select canceled from experiments ".
		    "where eid='$eid' and pid='$pid'");

    if (! $query_result ||
	$query_result->numrows == 0) {
	return 0;
    }
    ($$flag) = $query_result->fetchrow_array();
    return 1;
}

#
# Return a list of all the nodes in an experiment.
#
# usage: ExpNodes(char *pid, char *eid, [bool islocal])
#        returns the list if a valid pid/eid.
#	 If the optional flag is set, returns only local nodes.
#        Returns 0 if an invalid pid/eid or if an error.
#
sub ExpNodes($$;$$)
{
    my($pid, $eid, $localonly, $physonly) = @_;
    my(@row);
    my(@nodes);
    my $clause = "";

    if (defined($localonly)) {
	$clause .= " and nt.isremotenode=0";
    }
    if (defined($physonly)) {
	$clause .= " and nt.isvirtnode=0";
    }

    my $query_result =
	DBQueryWarn("select r.node_id from reserved as r ".
		    "left join nodes as n on n.node_id=r.node_id ".
		    "left join node_types as nt on nt.type=n.type ".
		    "where r.pid='$pid' and r.eid='$eid' $clause");

    if (! $query_result or
	$query_result->numrows == 0) {
	return ();
    }
    while (@row = $query_result->fetchrow_array()) {
	my $node = $row[0];

	#
	# Taint check. I do not understand this sillyness, but if I
	# taint check these node names, I avoid warnings throughout.
	#
	if ($node =~ /^([-\w]+)$/) {
	    $node = $1;

	    push(@nodes, $node);
	}
	else {
	    print "*** $0: WARNING: Bad node name: $node.\n";
	}
    }
    return @nodes;
}

#
# Return a hash of all the nodes in an experiment.  The hash maps pnames
# to vnames.
#
# usage: ExpNodeVnames(char *pid, char *eid, [bool islocal], [bool isphys])
#        returns the hash if a valid pid/eid.
#	 If the optional islocal is set, returns only local nodes.
#	 If the optional isphys is set, returns only physical nodes.
#        Returns 0 if an invalid pid/eid or if an error.
#
sub ExpNodeVnames($$;$$)
{
    my($pid, $eid, $localonly, $physonly) = @_;
    my(@row);
    my(%nodes);
    my $clause = "";

    if (defined($localonly)) {
	$clause = "and nt.isremotenode=0";
    }
    if (defined($physonly)) {
	$clause = "and nt.isvirtnode=0";
    }
    my $query_result =
	DBQueryWarn("select r.node_id,r.vname from reserved as r ".
		    "left join nodes as n on n.node_id=r.node_id ".
		    "left join node_types as nt on nt.type=n.type ".
		    "where r.pid='$pid' and r.eid='$eid' $clause");

    if (!$query_result || $query_result->numrows == 0) {
	return ();
    }
    while (@row = $query_result->fetchrow_array()) {
	my $node = $row[0];
	my $vname = $row[1];

	#
	# Taint check. I do not understand this sillyness, but if I
	# taint check these node names, I avoid warnings throughout.
	#
	if ($node =~ /^([-\w]+)$/) {
	    $node = $1;
	    if ($vname =~ /^([-\w]+)$/) {
		$vname = $1;
	    } else {
		$vname = $node;
	    }
	    $nodes{$node} = $vname;
	} else {
	    print "*** $0: WARNING: Bad node name: $node.\n";
	}
    }
    return %nodes;
}

#
# Mark a node as down. We schedule a next reservation for it so that it
# remains in the users experiment through the termination so that there
# are no permission errors (say, from snmpit).
#
# usage: MarkNodeDown(char *nodeid)
#
sub MarkNodeDown($)
{
    my($node) = $_[0];
    my($pid, $eid);

    $pid = NODEDEAD_PID;
    $eid = NODEDEAD_EID;

    my $exptidx;
    if (!TBExptIDX($pid, $eid, \$exptidx)) {
	print "*** WARNING: No such experiment $pid/$eid!\n";
	return -1;
    }

    my $query_result =
	DBQueryFatal("replace into next_reserve " .
		     "(node_id, exptidx, pid, eid) " .
		     "values ('$node', '$exptidx', '$pid', '$eid')");

    if ($query_result->num_rows < 1) {
	DBWarn("WARNING: Could not mark $node down");
    }
}

#
# Set the boot status for a node.
#
# usage: SetNodeBootStatus(char *status)
#
sub SetNodeBootStatus($$)
{
    my($node, $bstat) = @_;

    DBQueryFatal("update nodes set bootstatus='$bstat' ".
		 "where node_id='$node'");
}

#
# Check if a particular feature is supported by an OSID.
#
# usage: OSFeatureSupported(char *osid, char *feature)
#        returns 1 if supported, 0 if not.
#
sub OSFeatureSupported($$) {
    my($osid, $feature) = @_;

    my $query_result =
	DBQueryFatal("select osfeatures from os_info where osid='$osid'");

    # Invalid OSID?
    if ($query_result->numrows < 1) {
	return 0;
    }

    my $osfeatures = $query_result->fetchrow_array();
    if (defined($osfeatures)) {
	foreach my $osfeature (split(',', $osfeatures)) {
	    if ($feature eq $osfeature) {
		return 1; 
	    }
	} 
    }
    return 0;
}

#
# Find out what osid a node will boot next time it comes up,
# Usually (but not always) the currently running OS as well.
#
sub TBBootWhat($;$)
{
    my ($node, $debug) = @_;
    $debug = 0
	if (!defined($debug));

    #
    # WARNING!!!
    #
    # DO NOT change this function without making corresponding changes to
    # pxe/bootinfo_mysql.c.
    #
    # ALWAYS find exactly the same resulting OSID given the same inputs.
    #
    my $query_result =
	DBQueryWarn("select def_boot_osid, odef.op_mode, ".
		    "       temp_boot_osid, otemp.op_mode, ".
		    "       next_boot_osid, onext.op_mode ".
		    "from nodes as n ".
		    "left join os_info as odef  on odef.osid=def_boot_osid ".
		    "left join os_info as otemp on otemp.osid=temp_boot_osid ".
		    "left join os_info as onext on onext.osid=next_boot_osid ".
		    "where node_id='$node'");

    if (!$query_result || !$query_result->numrows) {
	print("*** Warning: No bootwhat info for $node\n");
	return 0;
    }
    my ($def_boot_osid, $def_boot_opmode,
	$temp_boot_osid, $temp_boot_opmode,
	$next_boot_osid, $next_boot_opmode) = $query_result->fetchrow_array();

    #
    # The priority would seem pretty clear.
    #
    return ($next_boot_osid, $next_boot_opmode)
	if (defined($next_boot_osid) && $next_boot_osid ne 0);
    return ($temp_boot_osid, $temp_boot_opmode)
	if (defined($temp_boot_osid) && $temp_boot_osid ne 0);
    return ($def_boot_osid, $def_boot_opmode)
	if (defined($def_boot_osid) && $def_boot_osid ne 0);

    print("*** Warning: node '$node': All boot info was null!\n");
    return undef;
}

#
# Map nodeid to its pid/eid/vname. vname is optional.
#
# usage: NodeidToExp(char *nodeid, \$pid, \$eid, \$vname)
#        returns 1 if the node is reserved.
#        returns 0 if the node is not reserved.
#
sub NodeidToExp ($$$;$) {
    my($nodeid, $pid, $eid, $vname) = @_;

    my $query_result =
	DBQueryWarn("select pid,eid,vname from reserved ".
		    "where node_id='$nodeid'");

    if (! $query_result ||
	! $query_result->num_rows) {
	return 0;
    }

    my @row = $query_result->fetchrow_array();
    $$pid = $row[0];
    $$eid = $row[1];
    if (defined($vname)) {
	if (defined($row[2])) {
	    $$vname = $row[2];
	}
	else {
	    $$vname = undef;
	}
    }
    return 1;
}

#
# Map a pid/eid/vname to its real nodename
#
# usage: VnameToNodeid(char *pid, char * eid, char *vname, \$nodeid)
#        returns 1 if the specified pid/eid/vname exists
#        returns 0 if it does not
#
sub VnameToNodeid ($$$$) {
    my($pid, $eid, $vname, $nodeid) = @_;

    my $query_result =
	DBQueryWarn("select node_id from reserved ".
		    "where pid='$pid' and eid='$eid' and vname='$vname'");

    if (! $query_result ||
	! $query_result->num_rows) {
	return 0;
    }

    my @row = $query_result->fetchrow_array();
    $$nodeid = $row[0];
    return 1;
}


#
# Get the default ImageID for a particular node.
#
# usage: DefaultImageID(char *nodeid, \*imageid)
#        returns 1 if the node is valid and has a default imageid.
#                  Imageid is returned in reference param
#        returns 0 if there are problems.
#
sub DefaultImageID ($$) {
    my ($nodeid, $imageid) = @_;

    my $node = Node->Lookup($nodeid);

    if (! $node) {
	$$imageid = undef;
	return 0;
    }

    if ($node->NodeTypeAttribute("default_imageid", $imageid) ||
	$$imageid eq "") {
	$$imageid = undef;
	return 0;
    }
    return 1;
}

#
# Convert user pid/name to internal imageid.
#
# usage: TBImageID(char *pid, char *imagename)
#        returns imageid if its valid.
#        returns 0 if not valid.
#
sub TBImageID ($$) {
    my($pid, $imagename) = @_;

    my $query_result =
	DBQueryFatal("select imageid from images ".
		     "where pid='$pid' and imagename='$imagename'");

    if (! $query_result->num_rows) {
	return 0;
    }

    my @row = $query_result->fetchrow_array();
    return $row[0];
}

#
# Convert user pid/name to internal osid.
#
# usage: TBOSID(char *pid, char *isname)
#        returns osid if its valid.
#        returns 0 if not valid.
#
sub TBOSID ($$) {
    my($pid, $osname) = @_;

    my $query_result =
	DBQueryFatal("select osid from os_info ".
		     "where pid='$pid' and osname='$osname'");

    if (! $query_result->num_rows) {
	return 0;
    }

    my @row = $query_result->fetchrow_array();
    return $row[0];
}

#
# Return pid of an osid (internal name).
#
# usage: TBOsidToPid(char *osid, \$pid)
#        returns 1 if osid is valid; store pid into return arg.
#        returns 0 if osid is not valid.
#
sub TBOsidToPid ($$) {
    my($osid, $ppid) = @_;

    my $query_result =
	DBQueryFatal("select pid from os_info where osid='$osid'");

    if (! $query_result->num_rows) {
	return 0;
    }
    my ($pid) = $query_result->fetchrow_array();
    $$ppid = $pid;
    return 1;
}

#
# Returns the maximum number of concurrent instantiations of an image.
#
# usage: TBOSMaxConcurrent(char *osid)
#        returns >= 1 if there is a maximum number of concurrent instantiations
#        returns undef if there is no limi
#        returns 0 if not valid.
#
sub TBOSMaxConcurrent ($)
{
    my($osid) = @_;

    my $query_result =
	DBQueryFatal("select max_concurrent from os_info where osid='$osid'");

    if (! $query_result->num_rows) {
	return 0;
    }

    my @row = $query_result->fetchrow_array();
    return $row[0];
}

#
# Returns the reboot waittime.
#
# usage: TBOSIDRebootWaittime(char *osid)
#        returns >= 1 if there is a waittime
#        returns undef if there is no waittime
#        returns 0 if not valid.
#
sub TBOSIDRebootWaittime ($)
{
    my($osid) = @_;

    my $query_result =
	DBQueryFatal("select reboot_waittime from os_info where osid='$osid'");

    if (! $query_result->num_rows) {
	return 0;
    }

    my @row = $query_result->fetchrow_array();
    return $row[0];
}

#
# Returns the number of nodes that are supposedly booting an OS. A list of
# nodes that should be excluded from this count can be given.
#
# usage: TBOSCountInstances(char *osid; char *nodeid ...)
#        returns the number of nodes booting the OSID
#
sub TBOSCountInstances ($;@)
{
    my($osid,@exclude) = @_;

    my $nodelist = join(" or ",map("p.node_id='$_'",@exclude));
    if (!@exclude) {
	$nodelist = "0";
    }

    my $query_result = DBQueryFatal("select distinct p.node_id from partitions " .
	"as p left join reserved as r on p.node_id = r.node_id " .
	"where osid='$osid' and !($nodelist) and r.pid != '$TBOPSPID'");
    my $current_count = $query_result->num_rows();

    return $current_count;
}

#
# Resolve a 'generic' OSID (ie. FBSD-STD) to a real OSID
#
# Note: It's okay to call this function with a 'real' OSID, but it would be
# waseful to do so.
#
# usage: TBResolveNextOSID(char *osid, char *pid, char *eid)
# returns: The 'real' OSID that the OSID resolves to, or undef if there is a
#          problem (ie. unknown OSID)
#
sub TBResolveNextOSID($;$$)
{
    my ($osid,$pid,$eid) = @_;
    my $next_osid = $osid;
    my $input_osid = $osid;

    my $count = 0;
    do {
	#
	# Just a guard to make sure we don't end up in a loop
	#
	if ($count++ > 10) {
	    warn "Resolving $input_osid: Circular reference\n";
	}

	$osid = $next_osid;
	my $result = DBQueryWarn("select nextosid from os_info where
	    osid='$osid';");

	if ($result->num_rows() != 1) {
	    warn "Resolving $input_osid: Unable to fetch os_info for $osid!\n";
	    return undef;
	}
	($next_osid) = $result->fetchrow();

	#
	# See if we need to resolve using a map.
	# Maps currently are only indexed by modification time;
	# i.e., we look at the last modification time of the experiment to
	# determine what OSID should be used.
	#
	# NOTE: mapping used to be done based on experiment *creation* time
	# but that left no ability to "update" an experiment to use current
	# images, at least short of creating a new experiment with the same
	# ns file.
	#
	# next_osid used to be MAP:osid_map, but now its an integer field
	# so just look for a 0 index, which is not a "valid" osid.
	#
	if (defined($next_osid) && $next_osid == 0) {
	    my $map = "osid_map";

	    my $timestr;
	    if (defined($pid) && defined($eid)) {
		my $m_result =
		    DBQueryWarn("select e.expt_created, s.swapmod_last ".
				"from experiments as e, experiment_stats as s ".
				"where e.idx=s.exptidx and ".
				"e.pid='$pid' and e.eid='$eid'");
		if (!$m_result || $m_result->num_rows() == 0) {
		    warn "Resolving $input_osid: no experiment $pid/$eid!\n";
		    return undef;
		}
		my ($ctime,$mtime) = $m_result->fetchrow();
		if (defined($mtime) && $mtime ne "") {
		    $timestr = "'$mtime'";
		} else {
		    $timestr = "'$ctime'";
		}
	    } else {
		$timestr = "now()";
	    }

	    $result = DBQueryWarn("select nextosid from $map ".
				  "where osid='$osid' and ".
				  "$timestr between btime and etime");
	    if (!$result) {
		warn "No such osid map $map!\n";
		return undef;
	    }

	    if ($result->num_rows() == 0) {
		warn "Resolving $input_osid: Unable to map $osid!\n";
		return undef;
	    }
	    ($next_osid) = $result->fetchrow();
	}
    } while ($next_osid);
    
    return $osid;
}

#
# Check whether or not it's permissible, given max_concurrent restrictions, to
# load an OSID onto a number of nodes - the nodes themselves can be passed, so
# that they do no count twice (once in the count of current loads, and once in
# the count of potential loads.)
#
# usage: TBOSLoadMaxOkay(char *osid, int node_count; char *nodeid ... )
#        returns 1 if loading the given OS on the given number of nodes would
#            not go over the max_concurrent limit for the OS
#        returns 0 otherwise
#
sub TBOSLoadMaxOkay($$;@)
{
    my($osid,$node_count,@nodes) = @_;

    if (TBAdmin()) {
	return 1;
    }

    my $max_instances = TBOSMaxConcurrent($osid);
    if (!$max_instances) {
	return 1;
    }

    my $current_instances = TBOSCountInstances($osid,@nodes);

    if (($current_instances + $node_count) > $max_instances) {
	return 0;
    } else {
	return 1;
    }
}

#
#
# Check whether or not it's permissible, given max_concurrent restrictions, to
# load an image onto a number of nodes - simply checks all OSIDs on the image.
#
# usage: TBImageLoadMaxOkay(char *imageid, int node_count; char *nodeid ... )
#        returns 1 if loading the given image on the given number of nodes
#        	would not go over the max_concurrent limit for any OS im the
#        	image
#        returns 0 otherwise
#
sub TBImageLoadMaxOkay($$;@)
{
    my($imageid,$node_count,@nodes) = @_;


    my $query_result = DBQueryFatal("select part1_osid, part2_osid, " .
	"part3_osid, part4_osid from images where imageid='$imageid'");

    if ($query_result->num_rows() != 1) {
	#
	# XXX - Just pretend everything is OK, something else will presumably
	# have to check the imageid anyway
	#
	return 1;
    }

    foreach my $OS ($query_result->fetchrow()) {
	if ($OS && (!TBOSLoadMaxOkay($OS,$node_count,@nodes))) {
	    return 0;
	}
    }

    return 1;
}

#
# Insert a Log entry for a node.
#
# usage: TBSetNodeLogEntry(char *node, char *uid, char *type, char *message)
#        Returns 1 if okay.
#        Returns 0 if failed.
#
sub TBSetNodeLogEntry($$$$)
{
    my ($node_id, $dbuid, $type, $message) = @_;

    my $node = Node->Lookup($node_id);
    return 0
	if (! defined($node));

    return ($node->InsertNodeLogEntry(User->Lookup($dbuid),
				      $type, $message) == 0 ? 1 : 0);
}

#
# Set event state for a node.
#
# usage: TBSetNodeEventState(char *node, char *state)
#        Returns 1 if okay.
#        Returns 0 if failed.
#
sub TBSetNodeEventState($$)
{
    my ($node, $state) = @_;

    #
    # If using the event system, we send out an event for the state daemon to
    # pick up. Otherwise, we just set the state in the database ourselves
    #
    if ($EVENTSYS) {
	return EventSendFatal(objtype   => TBDB_TBEVENT_NODESTATE,
			      objname   => $node,
			      eventtype => $state,
			      host      => $BOSSNODE);
    } else {
	my $now = time();
	return DBQueryFatal("update nodes set eventstate='$state', " .
			    "state_timestamp=$now where node_id='$node'");
    }
}

#
# Get event state for a node.
#
# usage: TBGetNodeEventState(char *node, char \*state)
#        Returns 1 if okay (and sets state).
#        Returns 0 if failed.
#
sub TBGetNodeEventState($$)
{
    my ($node, $state) = @_;

    my $query_result =
	DBQueryFatal("select eventstate from nodes where node_id='$node'");

    if ($query_result->numrows == 0) {
	return 0;
    }
    my @row = $query_result->fetchrow_array();
    if (defined($row[0])) {
	$$state = $row[0];
    }
    else {
	$$state = TBDB_NODESTATE_UNKNOWN;
    }
    return 1;
}

#
# Check if the event state for a node was updated recently.
#
# usage: TBNodeEventStateUpdated(char *node, int tolerance)
#        Returns 1 if the state was updated.
#        Returns 0 if failed.
#
sub TBNodeEventStateUpdated($$)
{
    my ($node, $tol) = @_;

    my $query_result =
	DBQueryFatal("select UNIX_TIMESTAMP(now()) - state_timestamp < $tol ".
		     "from nodes where node_id='$node'");

    if ($query_result->numrows == 0) {
	return 0;
    }
    my ($under) = $query_result->fetchrow_array();

    return $under;
}

#
# Check if a node has timed out in its current state. If it has, it gets
# stated involved to handle the situation.
#
# usage: TBNodeStateTimeout(char *node)
#        Returns 1 if it has timed out and stated was notified
#        Returns 0 if it is okay (still within time limits)
#
sub TBNodeStateTimeout($)
{
    my ($node) = @_;

    my $notimeout = TBDB_NO_STATE_TIMEOUT;

    my $query_result =
	DBQueryFatal("select now() - state_timestamp > timeout as over, ".
		     "timeout='$notimeout' as none ".
		     "from nodes as n left join state_timeouts as st ".
		     "on n.eventstate=st.state and n.op_mode=st.op_mode ".
		     "where node_id='$node'");

    if ($query_result->numrows == 0) {
	warn("*** TBNodeStateTimeout: Couldn't check node '$node'\n");
	return 0;
    }
    my ($over,$none) = $query_result->fetchrow_array();
    if ($over && !$none) {
	# We're overtime... send an event and return 1
	if ($EVENTSYS) {
	    EventSendFatal(objtype   => TBDB_TBEVENT_CONTROL,
			   objname   => $node,
			   eventtype => TBDB_TBCONTROL_TIMEOUT,
			   host      => $BOSSNODE);
	} else {
	    # Don't know what to do... how are state timeouts handled
	    # if we don't have stated?
	}
	return 1;
    } else {
	# We're good... return 0
	return 0;
    }
}

#
# Set operational mode for a node.
#
# usage: TBSetNodeOpMode(char *node, char *mode)
#        Returns 1 if okay.
#        Returns 0 if failed.
#
# DEPRECATED - stated handles these transitions now. See TBSetNodeNextOpMode
# below.
#
sub TBSetNodeOpMode($$)
{
    my ($node, $mode) = @_;

    #
    # If using the event system, we send out an event for the state daemon to
    # pick up. Otherwise, we just set the mode in the database ourselves
    #
    if ($EVENTSYS) {
	return EventSendFatal(objtype   => TBDB_TBEVENT_NODEOPMODE,
			      objname   => $node,
			      eventtype => $mode,
			      host      => $BOSSNODE);
    } else {
	my $now = time();
	return DBQueryFatal("update nodes set op_mode='$mode', " .
			    "op_mode_timestamp=$now where node_id='$node'");
    }
}

#
# Set the next operational mode for a node.
#
# usage: TBSetNodeNextOpMode(char *node, char *mode)
#        Returns 1 if okay.
#        Returns 0 if failed.
#
sub TBSetNodeNextOpMode($$)
{
    my ($node, $mode) = @_;

    #
    # Just set it in the DB. The next time the node changes state, stated will
    # make the transition happen.
    #
    return DBQueryFatal("update nodes set next_op_mode='$mode' " .
	"where node_id='$node'");
}

#
# Get operational mode for a node.
#
# usage: TBGetNodeOpMode(char *node, char \*mode)
#        Returns 1 if okay (and sets state).
#        Returns 0 if failed.
#
sub TBGetNodeOpMode($$)
{
    my ($node, $mode) = @_;

    my $query_result =
	DBQueryFatal("select op_mode from nodes where node_id='$node'");

    if ($query_result->numrows == 0) {
	return 0;
    }
    my @row = $query_result->fetchrow_array();
    if (defined($row[0])) {
	$$mode = $row[0];
    }
    else {
	$$mode = TBDB_NODEOPMODE_UNKNOWN;
    }
    return 1;
}


#
# Set alloc state for a node.
#
# usage: TBSetNodeAllocState(char *node, char *state)
#        Returns 1 if okay.
#        Returns 0 if failed.
#
sub TBSetNodeAllocState($$)
{
    my ($node, $state) = @_;
    my $now = time();
    return DBQueryFatal("update nodes set allocstate='$state', " .
			"allocstate_timestamp=$now where node_id='$node'");
}

#
# Get alloc state for a node.
#
# usage: TBGetNodeAllocState(char *node, char \*state)
#        Returns 1 if okay (and sets state).
#        Returns 0 if failed.
#
sub TBGetNodeAllocState($$)
{
    my ($node, $state) = @_;

    my $query_result =
	DBQueryFatal("select allocstate from nodes where node_id='$node'");

    if ($query_result->numrows == 0) {
	return 0;
    }
    my @row = $query_result->fetchrow_array();
    if (defined($row[0])) {
	$$state = $row[0];
    }
    else {
	$$state = TBDB_ALLOCSTATE_UNKNOWN;
    }
    return 1;
}

#
# Is a node imageable?
#
# usage TBIsNodeImageable(char *node)
#        Returns 1 if yes.
#        Returns 0 if no.
#
sub TBIsNodeImageable($)
{
    my ($nodeid) = @_;

    my $node = Node->Lookup($nodeid);

    return 0
	if (!defined($node));

    my $imageable;
    
    return 0
	if ($node->NodeTypeAttribute("imageable", \$imageable) != 0);

    $imageable = 0
	if (!defined($imageable));

    return $imageable;
}

#
# Is a node remote?
#
# usage TBIsNodeRemote(char *node)
#        Returns 1 if yes.
#        Returns 0 if no.
#
sub TBIsNodeRemote($)
{
    my ($nodeid) = @_;

    my $query_result =
	DBQueryFatal("select isremotenode from nodes as n ".
		     "left join node_types as t on t.type=n.type ".
		     "where n.node_id='$nodeid'");

    if (! $query_result->num_rows) {
	return 0;
    }

    my @row = $query_result->fetchrow_array();
    return($row[0]);
}

#
# Is a node virtual (or "multiplexed"). Optionally return jailflag and a
# Plab flag.
#
# usage TBIsNodeVirtual(char *node, int *jailed, int *plabbed)
#        Returns 1 if yes.
#        Returns 0 if no.
#
sub TBIsNodeVirtual($;$$)
{
    my ($nodeid, $jailed, $plabbed) = @_;

    my $query_result =
	DBQueryFatal("select isvirtnode,n.jailflag,t.isplabdslice ".
		     "from nodes as n ".
		     "left join node_types as t on t.type=n.type ".
		     "where n.node_id='$nodeid'");

    if (! $query_result->num_rows) {
	return 0;
    }

    my @row = $query_result->fetchrow_array();
    if (defined($jailed)) {
	$$jailed = $row[1];
    }
    if (defined($plabbed)) {
	$$plabbed = $row[2];
    }
    return($row[0]);
}

#
# Get the username used to log in to a particular vnode allocated on Plab
#
# usage TBPlabNodeUsername(char *node, char \*username)
#        Returns 1 if successful
#        Returns 0 if node is not allocated with Plab
#
sub TBPlabNodeUsername($$)
{
    my ($nodeid, $username) = @_;

    my $query_result =
	DBQueryFatal("select slicename from plab_slice_nodes ".
		     "where node_id='$nodeid'");

    if (! $query_result->num_rows) {
	return 0;
    }

    my @row = $query_result->fetchrow_array();
    if (defined($row[0])) {
	$$username = $row[0];
	return 1;
    }
    return 0;
}

#
# Mark a Phys node as down. Cannot use next reserve since the pnode is not
# going to go through the free path.
#
# usage: MarkPhysNodeDown(char *nodeid)
#
sub MarkPhysNodeDown($)
{
    my($pnode) = $_[0];
    my($pid, $eid);

    $pid = NODEDEAD_PID;
    $eid = NODEDEAD_EID;
    
    my $exptidx;
    if (!TBExptIDX($pid, $eid, \$exptidx)) {
	print "*** WARNING: No such experiment $pid/$eid!\n";
	return -1;
    }

    DBQueryFatal("update reserved set " .
		 "  exptidx=$exptidx, pid='$pid',eid='$eid',rsrv_time=now() ".
		 "where node_id='$pnode'");

    TBSetNodeHistory($pnode, TB_NODEHISTORY_OP_MOVE, $UID, $pid, $eid);
}

#
# Return the working directory name for an experiment. This is where
# the scripts work. The logs are copied over to the user's version of
# the directory later.
#
sub TBExptLogDir($$)
{
    my($pid, $eid) = @_;

    my $query_result =
	DBQueryFatal("select idx from experiments ".
		     "where pid='$pid' and eid='$eid'");

    my ($idx) = $query_result->fetchrow_array;

    return "$TB/expinfo/${pid}-${eid}.${idx}";
}

#
# Return the IDX for a current experiment. 
#
# usage: TBExptIDX(char $pid, char *gid, int \$idx)
#        returns 1 if okay.
#	 returns 0 if error.
#
sub TBExptIDX($$$)
{
    my($pid, $eid, $idxp) = @_;

    my $query_result =
	DBQueryWarn("select idx from experiments ".
		    "where pid='$pid' and eid='$eid'");

    if (!$query_result || !$query_result->numrows) {
	return 0;
    }
    my ($idx) = $query_result->fetchrow_array;
    $$idxp = $idx;
    return 1;
}

#
# Return the log directory name for an experiment. This is where
# we keep copies of the files for later inspection.
#
sub TBExptWorkDir($$)
{
    my($pid, $eid) = @_;

    return TBDB_EXPT_WORKDIR() . "/${pid}/${eid}";
}

#
# Return the user's experiment directory name. This is a path in the /proj
# tree. We keep these separate to avoid NFS issues, and users generally
# messing with things they should not (by accident or otherwise).
#
sub TBExptUserDir($$)
{
    my($pid, $eid) = @_;

    my $query_result =
	DBQueryFatal("select path from experiments ".
		     "where pid='$pid' and eid='$eid'");

    my ($path) = $query_result->fetchrow_array;

    return $path;
}

#
# Return the min/max node counts for an experiment.
#
# usage: TBExptMinMaxNodes(char $pid, char *gid, int \$min, int \$max)
#        returns 1 if okay.
#	 returns 0 if error.
#
sub TBExptMinMaxNodes($$$$)
{
    my($pid, $eid, $minp, $maxp) = @_;

    my $query_result =
	DBQueryWarn("select minimum_nodes,maximum_nodes from experiments ".
		    "where eid='$eid' and pid='$pid'");

    if (!$query_result || !$query_result->numrows) {
	return 0;
    }
    my ($min, $max) = $query_result->fetchrow_array();

    $$minp = $min
	if (defined($minp));
    $$maxp = $max
	if (defined($maxp));
    return 1;
}

#
# Return the security level for an experiment.
#
# usage: TBExptSecurityLevel(char $pid, char *gid, int \$level)
#        returns 1 if okay.
#	 returns 0 if error.
#
sub TBExptSecurityLevel($$$)
{
    my($pid, $eid, $levelp) = @_;

    my $query_result =
	DBQueryWarn("select security_level from experiments ".
		    "where eid='$eid' and pid='$pid'");

    if (!$query_result || !$query_result->numrows) {
	return 0;
    }
    my ($level) = $query_result->fetchrow_array();

    $$levelp = $level
	if (defined($levelp));
    return 1;
}

#
# Check if a site-specific variable exists.
#
# usage: TBSiteVarExists($name)
#        returns 1 if variable exists;
#        returns 0 otherwise.
#
sub TBSiteVarExists($)
{
    my($name) = @_;

    $name = DBQuoteSpecial( $name );

    my $query_result =
	DBQueryWarn("select name from sitevariables where name=$name");

    return 0
	if (!$query_result);
    
    return $query_result->numrows;
}

#
# Get site-specific variable.
# Get the value of the variable, or the default value if
# the value is undefined (NULL).
#
# usage: TBGetSiteVar($name, char \*rptr )
#        Without rptr: returns value if variable is defined; dies otherwise.
#        With rptr:    returns value in $rptr if variable is defined; returns
#                      zero otherwise, or any failure.
#
sub TBGetSiteVar($;$)
{
    my ($name, $rptr) = @_;
    my $value;

    $name = DBQuoteSpecial( $name );
    
    my $query_string =
	"select value,defaultvalue from sitevariables where name=$name";

    my $query_result;
    if (defined($rptr)) {
	#
	# I added the result parameter as an option to avoid changing every
	# call to TBGetSiteVar(). Sorry. When called in this manner, it is
	# up to the caller to decide what to do when it fails. 
	#
	$query_result = DBQueryWarn($query_string);

	return 0
	    if (! $query_result)
    }
    else {
	$query_result = DBQueryFatal($query_string);
    }

    if ($query_result->numrows > 0) {
	my ($curvalue, $defaultvalue) = $query_result->fetchrow_array();

	if (defined($curvalue)) {
	    $value = $curvalue;
	}
	elsif (defined($defaultvalue)) {
	    $value = $defaultvalue;
	}
    }
    if (defined($rptr)) {
	if (defined($value)) {
	    $$rptr = $value;
	    return 1;
	}
	return 0;
    }
    elsif (defined($value)) {
	return $value;
    }
    die("*** $0:\n".
	"    Attempted to fetch unknown site variable $name\n");
}

#
# Set a sitevar. Assumed to be a real sitevar.
#
# usage: TBSetSiteVar($name, $value)
#
sub TBSetSiteVar($$)
{
    my ($name, $value) = @_;

    $name  = DBQuoteSpecial($name);
    $value = DBQuoteSpecial($value);

    my $query_result =
	DBQueryWarn("update sitevariables set value=$value where name=$name");

    return 0
	if (!$query_result);
    return 1;
}

#
# Get pid,eid of current experiment using the robot lab. This is just
# plain silly for now.
#
sub TBRobotLabExpt($$)
{
    my ($ppid, $peid) = @_;
    
    my $query_result =
	DBQueryWarn("select r.pid,r.eid from reserved as r ".
		    "left join nodes as n on n.node_id=r.node_id ".
		    "left join node_types as nt on nt.type=n.type ".
		    "where nt.class='robot' and r.pid!='$TBOPSPID'");

    return 0
	if (!$query_result || !$query_result->numrows);

    my ($pid, $eid) = $query_result->fetchrow_array();
    $$ppid = $pid;
    $$peid = $eid;
    return 1;
}

#
# is a certain type/class node present?
# args: pid, eid, valid type/class
# 
sub TBExptContainsNodeCT($$$) 
{
    my ($pid,$eid,$ntc) = @_;

    # find out if this is a valid class or type...
    my $dbq = DBQueryWarn("select v.pid,v.eid,v.type from virt_nodes as v " .
			  "left join node_types as nt on v.type=nt.type " .
			  "where v.pid='$pid' and v.eid='$eid' and " .
			  "(nt.class='$ntc' or nt.type='$ntc')");

    return 0 
	if (!$dbq || !$dbq->numrows());

    return 1;
}

#
# List of tables used for experiment removal/backup/restore.
#
@virtualTables  = ("virt_nodes",
		   "virt_lans",
		   "virt_lan_lans",
		   "virt_lan_settings",
		   "virt_lan_member_settings",
		   "virt_trafgens",
		   "virt_agents",
		   "virt_routes",
		   "virt_vtypes",
		   "virt_programs",
		   "virt_node_desires",
		   "virt_node_startloc",
		   "virt_simnode_attributes",
		   "virt_user_environment",
		   "virt_parameters",
		   # vis_nodes is locked during update in prerender, so we
		   # will get a consistent dataset when we backup.
		   "vis_nodes",
		   "vis_graphs",
		   "nseconfigs",
		   "eventlist",
		   "event_groups",
		   "virt_firewalls",
		   "firewall_rules",
		   "virt_tiptunnels",
		   "ipsubnets");

@physicalTables = ("delays",
		   "tunnels",
		   "ipport_ranges",
		   "v2pmap",
		   "linkdelays",
		   "traces",
		   "portmap");

#
# Clear the backup crap we create below.
#
sub TBExptClearBackupState($$)
{
    my ($pid, $eid) = @_;
    my $pstateDir = TBExptWorkDir($pid, $eid) . "/pstate";
    my $vstateDir = TBExptWorkDir($pid, $eid) . "/vstate";

    system("/bin/rm -rf $pstateDir")
	if (-e $pstateDir);
    system("/bin/rm -rf $vstateDir")
	if (-e $vstateDir);
}

#
# Return the list of subnodes for the given node.
#
sub TBNodeSubNodes($)
{
    my ($node) = @_;
    my (@row);
    my (@nodes);

    my $result = DBQueryFatal("SELECT n.node_id FROM nodes AS n " .
			      "LEFT JOIN node_types " .
			      "    AS nt ON n.type = nt.type " .
			      "WHERE n.phys_nodeid='$node' and ".
			      "      nt.issubnode!=0");
    
    if (! $result or $result->numrows == 0) {
	return ();
    }
    while (@row = $result->fetchrow_array()) {
	my $node = $row[0];

	#
	# Taint check. I do not understand this sillyness, but if I
	# taint check these node names, I avoid warnings throughout.
	#
	if ($node =~ /^([-\w]+)$/) {
	    $node = $1;

	    push(@nodes, $node);
	}
	else {
	    print "*** $0: WARNING: Bad node name: $node.\n";
	}
    }
    return @nodes;
}

#
# Return a node's type and class, in a two-element array
# If the caller asked for a scalar, give them only the type
# Returns undef if the node doesn't exist
#
sub TBNodeType($)
{
    my ($node) = @_;
    my $result = DBQueryFatal("SELECT n.type, class FROM nodes AS n " .
			      "LEFT JOIN node_types " .
			      "    AS nt ON n.type = nt.type " .
			      "WHERE n.node_id='$node'");
    if ($result->num_rows() != 1) {
	return undef;
    }
    
    my ($type, $class) = $result->fetchrow();
    if (!$class) {
	return undef;
    }

    if (wantarray) {
	return ($type, $class);
    } else {
	return $type;
    }
}

sub TBNodeAdminOSID($)
{
    my ($nodeid) = @_;

    my $node = Node->Lookup($nodeid);

    return 0
	if (!defined($node));

    my $mfs;
    
    return 0
	if ($node->NodeTypeAttribute("adminmfs_osid", \$mfs) != 0);

    $mfs = TB_OSID_FREEBSD_MFS()
	if (!defined($mfs));

    return $mfs;
}

sub TBNodeDiskloadOSID($)
{
    my ($nodeid) = @_;

    my $node = Node->Lookup($nodeid);

    return 0
	if (!defined($node));

    my $mfs;
    
    return 0
	if ($node->NodeTypeAttribute("diskloadmfs_osid", \$mfs) != 0);

    $mfs = TB_OSID_FREEBSD_MFS()
	if (!defined($mfs));

    return $mfs;
}

#
# Return a node's type CPU type and speed, in a two-element array
# Returns undef if the type can't be found
#
sub TBNodeTypeProcInfo($)
{
    my ($type) = @_;

    my $typeinfo = NodeType->Lookup($type);

    return undef
	if (!defined($typeinfo));

    my ($processor, $frequency);

    return undef
	if ($typeinfo->processor(\$processor) ||
	    $typeinfo->frequency(\$frequency));

    return ($processor, $frequency);
}

#
# Return a node's type bios waittime.
#        returns >= 1 if there is a waittime
#        returns undef if there is no waittime
#        returns 0 if not valid.
#
sub TBNodeTypeBiosWaittime($)
{
    my ($type) = @_;

    my $typeinfo = NodeType->Lookup($type);

    return 0
	if (!defined($typeinfo));

    my $bios_waittime;

    return 0
	if ($typeinfo->bios_waittime(\$bios_waittime));

    return $bios_waittime;
}

#
# Remove the virtual state of an experiment from the DB,
# returning the number of queries which didn't work.
#
sub TBExptRemoveVirtualState($$)
{
    my ($pid, $eid) = @_;
    my $errors = 0;

    foreach my $table (@virtualTables) {
	DBQueryWarn("DELETE FROM $table WHERE pid='$pid' AND eid='$eid'")
	    or $errors++;
    }
    return $errors;
}

#
# Remove the physical state of an experiment from the DB,
# returning the number of queries which didn't work.
#
sub TBExptRemovePhysicalState($$)
{
    my ($pid, $eid) = @_;
    my $errors = 0;

    my $experiment = Experiment->Lookup($pid, $eid);
    return 1
	if (!defined($experiment));

    return 1
	if (Lan->DestroyExperimentLans($experiment) != 0);
    
    foreach my $table (@physicalTables) {
	DBQueryWarn("DELETE FROM $table WHERE pid='$pid' AND eid='$eid'")
	    or $errors++;
    }
    return $errors;
}

#
# Backs up specified virtual state of pid/eid into directory in tmp.
#
sub TBExptBackupVirtualState($$)
{
    my ($pid, $eid) = @_;
    my $errors    = 0;
    my $vstateDir = TBExptWorkDir($pid, $eid) . "/vstate";

    if (! -e $vstateDir) {
	mkdir($vstateDir, 0777)
	    or return 1;

	chmod(0777, $vstateDir)
	    or return 1;
    }

    foreach my $table (@virtualTables) {
	DBQueryWarn("SELECT * FROM $table ".
		    "WHERE pid='$pid' AND eid='$eid' ".
		    "INTO OUTFILE '$vstateDir/$table' ")
	    or $errors++;
    }
    return $errors;
}

#
# Backs up specified physical state of pid/eid into directory in tmp.
#
sub TBExptBackupPhysicalState($$)
{
    my ($pid, $eid) = @_;
    my $errors    = 0;
    my $pstateDir = TBExptWorkDir($pid, $eid) . "/pstate";

    if (! -e $pstateDir) {
	mkdir($pstateDir, 0777)
	    or return 1;

	chmod(0777, $pstateDir)
	    or return 1;
    }

    my $experiment = Experiment->Lookup($pid, $eid);
    return 1
	if (!defined($experiment));

    return 1
	if (Lan->BackupExperimentLans($experiment, $pstateDir) != 0);
    
    foreach my $table (@physicalTables) {
	DBQueryWarn("SELECT * FROM $table WHERE pid='$pid' AND eid='$eid' ".
		    "INTO OUTFILE '$pstateDir/$table' ")
	    or $errors++;
    }
    return $errors;
}

#
# Restores backed up virtual state of pid/eid from directory in /tmp.
#
sub TBExptRestoreVirtualState($$)
{
    my ($pid, $eid) = @_;
    my $errors    = 0;
    my $vstateDir = TBExptWorkDir($pid, $eid) . "/vstate";

    foreach my $table (@virtualTables) {
	DBQueryWarn("LOAD DATA INFILE '$vstateDir/$table' INTO TABLE $table")
	    or $errors++;
    }
    return $errors;
}

#
# Restores backed up virtual state of pid/eid from directory in /tmp.
#
sub TBExptRestorePhysicalState($$)
{
    my ($pid, $eid) = @_;
    my $errors    = 0;
    my $pstateDir = TBExptWorkDir($pid, $eid) . "/pstate";

    foreach my $table (@physicalTables) {
	DBQueryWarn("LOAD DATA INFILE '$pstateDir/$table' INTO TABLE $table")
	    or $errors++;
    }
    return $errors;
}

#
# Restores backed up virtual state of pid/eid from directory in /tmp.
#
sub TBExptSetSwapUID($$$)
{
    my ($pid, $eid, $uid) = @_;

    return DBQueryWarn("update experiments set expt_swap_uid='$uid' ".
		       "where pid='$pid' and eid='$eid'");
}

#
# Set the thumbnail for an experiment. Comes in as a binary string, which
# must be quoted before DB insertion. Returns 1 if the thumbnail was
# succesfully updated, 0 if it was not.
#
sub TBExptSetThumbNail($$$)
{
    my ($pid, $eid, $bindata) = @_;

    $bindata = DBQuoteSpecial($bindata);

    # Need the resource ID first.
    my $query_result =
	DBQueryFatal("select rsrcidx from experiments as e ".
		     "left join experiment_stats as s on e.idx=s.exptidx ".
		     "where e.pid='$pid' and e.eid='$eid'");
    if ($query_result->num_rows() != 1) {
	return 0;
    }
    my ($rsrcidx) = $query_result->fetchrow_array();

    # Now do the insert.
    DBQueryFatal("update experiment_resources set thumbnail=$bindata ".
		 "where idx=$rsrcidx");
    #
    # Since the above is a QueryFatal, if it failed, we won't even get here
    #
    return 1;
}

#
# Get the port range for an experiment.
#
# usage TBExptPortRange(char *pid, char *eid, int \*low, int \*high)
#	Return 1 if success.
#	Return 0 if error.
#
sub TBExptPortRange($$$$)
{
    my ($pid, $eid, $high, $low) = @_;

    my $query_result =
	DBQueryFatal("select low,high from ipport_ranges ".
		     "where pid='$pid' and eid='$eid'");

    if ($query_result->numrows == 0) {
	return 0;
    }
    my @row = $query_result->fetchrow_array();
    $$low  = $row[0];
    $$high = $row[1];
    return 1;
}

#
# Get elabinelab info for an experiment. An experiment with a zero elabinelab
# flag, but a non-null elabinelab_eid means its an experiment that is linked
# to an elabinelab experiment cause of its security level.
#
# usage TBExptIsElabInElab(char *pid, char *eid,
#                          int \*elabinelab, char \*elabinelab_eid)
#	Return 1 if success.
#	Return 0 if error.
#
sub TBExptIsElabInElab($$$;$)
{
    my ($pid, $eid, $elabinelab, $elabinelab_eid) = @_;

    my $query_result =
	DBQueryFatal("select elab_in_elab,elabinelab_eid from experiments ".
		     "where pid='$pid' and eid='$eid'");

    if ($query_result->numrows == 0) {
	return 0;
    }
    my @row = $query_result->fetchrow_array();
    $$elabinelab     = $row[0];
    $$elabinelab_eid = (defined($row[1]) ? $row[1] : undef)
	if (defined($elabinelab_eid));
    return 1;
}

#
# Get plabinelab info for an experiment. Returns 1 in plabinelab
# if any node in the experiment is either a plab 'plc' or 'node'.
#
# usage TBExptIsPlabInElab(char *pid, char *eid, int \*plabinelab)
#	Return 1 if success.
#	Return 0 if error.
#
sub TBExptIsPlabInElab($$$)
{
    my ($pid, $eid, $plabinelab) = @_;

    my $query_result =
	DBQueryFatal("select plab_role from virt_nodes ".
		     "where pid='$pid' and eid='$eid' ".
		     "and plab_role!='none'");

    if ($query_result->numrows == 0) {
	$$plabinelab = 0;
    } else {
	$$plabinelab = 1;
    }
    return 1;
}

#
# Return the PLC node for a swapped in plabinelab experiment.
# Returns 0 if no PLC.  Returns 1 and the name of the node otherwise.
#
sub TBExptPlabInElabPLC($$$)
{
    my ($pid, $eid, $plcnode) = @_;

    my $query_result =
	DBQueryFatal("select node_id from reserved ".
		     "where pid='$pid' and eid='$eid' and plab_role='plc'");
    if ($query_result->numrows > 0) {
	my @row = $query_result->fetchrow_array();
	if (defined($row[0])) {
	    $$plcnode = $row[0];
	    return 1;
	}
    }
    return 0;
}

#
# Return a list of inner plab nodes for a swapped in plabinelab experiment.
# Returns 0 on failure.  Returns 1 and a list of nodes otherwise.
#
sub TBExptPlabInElabNodes($$$)
{
    my ($pid, $eid, $nodes) = @_;

    my $query_result =
	DBQueryFatal("select node_id from reserved ".
		     "where pid='$pid' and eid='$eid' and plab_role='node'");

    while (my @row = $query_result->fetchrow_array()) {
	push(@{$nodes}, $row[0]);
    }

    return 0;
}

#
# Similar function for batchmode.
#
sub TBExptIsBatchExp($$$)
{
    my ($pid, $eid, $batchmode) = @_;

    my $query_result =
	DBQueryFatal("select batchmode from experiments ".
		     "where pid='$pid' and eid='$eid'");

    if ($query_result->numrows == 0) {
	return 0;
    }
    my @row = $query_result->fetchrow_array();
    $$batchmode     = $row[0];
    return 1;
}

#
# Get the control network IP for a node (underlying physical node!).
#
# usage TBControlNetIP(char *nodeid, char \*ip)
#	Return 1 if success.
#	Return 0 if error.
#
sub TBControlNetIP($$)
{
    my ($nodeid, $pip) = @_;

    my $query_result =
	DBQueryFatal("select IP from nodes as n2 ".
		     "left join nodes as n1 on n1.node_id=n2.phys_nodeid ".
		     "left join interfaces as i on ".
		     "     i.node_id=n1.node_id and ".
		     "     i.role='" . TBDB_IFACEROLE_CONTROL() . "' " .
		     "where n2.node_id='$nodeid'");

    if ($query_result->numrows == 0) {
	return 0;
    }
    my @row = $query_result->fetchrow_array();
    if (defined($row[0])) {
	$$pip = $row[0];
	return 1;
    }
    return 0;
}

#
# Map network IP for a node to its nodeid
#
# usage TBIPtoNodeID(char *ip, char \*nodeid)
#	Return 1 if success.
#	Return 0 if error.
#
sub TBIPtoNodeID($$)
{
    my ($ip, $pnodeid) = @_;

    my $query_result =
	DBQueryFatal("select i.node_id from interfaces as i ".
		     "where i.IP='$ip' and ".
		     "      role='" . TBDB_IFACEROLE_CONTROL() . "'");

    if ($query_result->numrows == 0) {
	return 0;
    }
    my @row = $query_result->fetchrow_array();
    if (defined($row[0])) {
	$$pnodeid = $row[0];
	return 1;
    }
    return 0;
}

#
# Get the underlying physical node. Might be the same as the node if its
# not a virtual node.
#
# usage TBPhysNodeID(char *nodeid, char \*phys_nodeid)
#	Return 1 if success.
#	Return 0 if error.
#
sub TBPhysNodeID($$)
{
    my ($nodeid, $pphys) = @_;

    my $query_result =
	DBQueryFatal("select phys_nodeid from nodes ".
		     "where node_id='$nodeid'");

    if ($query_result->numrows == 0) {
	return 0;
    }
    my @row = $query_result->fetchrow_array();
    if (defined($row[0])) {
	$$pphys = $row[0];
	return 1;
    }
    return 0;
}

#
# From the physical node name, get the name that the should be used in the
# widearea_* tables
#
# usage TBWideareaNodeID(char *nodeid, char \*widearea_nodeid)
#	Return 1 if success.
#	Return 0 if error. (Currently, not possible)
#
sub TBWideareaNodeID($$)
{
    my ($nodeid, $pwide) = @_;

    if (TBIsNodeRemote($nodeid)) {
	$$pwide = $nodeid;
    } else {
	$$pwide = TBDB_WIDEAREA_LOCALNODE;
    }

    return 1;
}

#
# Mark a node as needing account updates. This variant does it based
# on node type, and all of the nodes of that type are marked. This is
# used for marking widearea nodes.
#
# usage TBNodeUpdateAccountsByType(char type)
#    Returns 1 all the time.
#
sub TBNodeUpdateAccountsByType($)
{
    my ($nodetype) = @_;

    #
    # No point in incrementing the flag past 2 since all that does is
    # cause needless updates.
    #
    DBQueryFatal("update nodes set update_accounts=update_accounts+1 ".
		 "where type='$nodetype' and update_accounts<2");

    return 1;
}

#
# Mark a node as needing account updates. This variant does it based
# on pid; all of the nodes in that pid are marked. Not very efficient!
#
# usage TBNodeUpdateAccountsByPid(char pid)
#    Returns 1 all the time.
#
sub TBNodeUpdateAccountsByPid($)
{
    my ($pid) = @_;

    my $query_result =
	DBQueryWarn("select r.node_id from reserved as r ".
		    "left join nodes as n on r.node_id=n.node_id ".
		    "where r.pid='$pid' and n.update_accounts=0");

    if (! $query_result ||
	! $query_result->numrows) {
	return 1;
    }

    while (my @row = $query_result->fetchrow_array()) {
	my $nodeid = $row[0];

	#
	# No point in incrementing the flag past 2 since all that does is
	# cause needless updates.
	#
	DBQueryFatal("update nodes set update_accounts=update_accounts+1 ".
		     "where node_id='$nodeid' and update_accounts<2");
    }
    return 1;
}

#
# Schedule account updates on all the nodes that this person has
# an account on.
#
# There are two sets of nodes. The first is all of the local nodes in
# all of projects the user is a member of. The second is all of the
# widearea nodes that the project has access to. Rather than operate
# on a per node basis.  grab the project names (for the reserved
# table) and the remote types to match against the node types. Of
# course, the pcremote_ok slot is a set, so need to parse that.
#
# usage TBNodeUpdateAccountsByPid(char pid)
#    Returns 1 all the time.
#
sub TBNodeUpdateAccountsByUID($)
{
    my ($uid) = @_;

    DBQueryFatal("update users set usr_modified=now() where uid='$uid'");

    my $query_result =
	DBQueryFatal("select p.pid,pcremote_ok from users as u ".
		     "left join group_membership as g on ".
		     "  u.uid_idx=g.uid_idx and g.pid=g.gid ".
		     "left join projects as p on p.pid=g.pid ".
		     "where u.uid='$uid' and u.status='active' and ".
		     "      p.pid is not null");

    while (my %row = $query_result->fetchhash()) {
	my $pid      = $row{'pid'};
	my $pcremote = $row{'pcremote_ok'};

	if (defined($pcremote)) {
	    my @typelist = split(',', $pcremote);

	    foreach my $nodetype (@typelist) {
		TBNodeUpdateAccountsByType($nodetype);
	    }
	}
	TBNodeUpdateAccountsByPid($pid);
    }
    #
    # Also update on widearea nodes if entries in widearea_accounts
    #
    $query_result =
	DBQueryFatal("select node_id from widearea_accounts ".
		     "where uid='$uid' and trust!='none'");

    while (my %row = $query_result->fetchhash()) {
	my $node_id = $row{'node_id'};

	DBQueryFatal("update nodes set update_accounts=update_accounts+1 ".
		     "where node_id='$node_id' and update_accounts<2");
    }

    #
    # Finally update nodes who are accessible by the user via the 'dp_projects'
    # node attribute.
    #
    # XXX big ugly query alert!
    #
    $query_result = 
	DBQueryFatal("select n.node_id from projects as p, ".
		     "  groups as g, group_membership as gm, ".
		     "  nodes as n, node_attributes as na ".
		     "where p.pid=g.pid and p.approved!=0 ".
		     "  and g.gid=gm.gid and p.pid=gm.pid ".
		     "  and n.node_id=na.node_id ".
		     "  and FIND_IN_SET(g.gid_idx, na.attrvalue) > 0 ".
		     "  and na.attrkey='dp_projects' ".
		     "  and gm.uid='$uid'");

    while (my %row = $query_result->fetchhash()) {
	my $node_id = $row{'node_id'};

	DBQueryFatal("update nodes set update_accounts=update_accounts+1 ".
		     "where node_id='$node_id' and update_accounts<2");
    }

    return 1;
}

#
# Clear various bits of info from a node, just as if it was booting for
# the first time in an experiment.
#
sub TBNodeBootReset($)
{
    my ($nodeid) = @_;

    DBQueryFatal("update nodes set ready=0, ".
		 "startstatus='" . NODESTARTSTATUS_NOSTATUS() . "', ".
		 "bootstatus='"  . NODEBOOTSTATUS_UNKNOWN()   . "' ".
		 "where node_id='$nodeid'");

    return 0;
}

sub TBNodeConsoleTail ($$) {
    my ($pc, $fh) = @_;

    my $query_result =
	DBQueryFatal("select server from tiplines where node_id='$pc'");
    
    if (!$query_result->numrows) {
	return;
    }
    my ($tipserver) = $query_result->fetchrow_array();

    print $fh "Tail of $pc console:\n";
    my $oldeuid = $EUID;
    $EUID = $UID;
    open(CONTAIL, "$TB/sbin/spewconlog -l 10 $pc |");
    while (<CONTAIL>) {
	s/[^ -~\t\n]/./g;
	print $fh "$pc: $_";
    }
    close(CONTAIL);
    print $fh "\n";
    $EUID = $oldeuid;
}

#
# Wait for a node to hit a certain state. Provide a start time and a max
# wait time.
#
# NB: This function is not as general purpose as it might seem; there are
#     not many "terminal" states that you can wait for (like isup).
#     Still, it avoids duplication in 4 scripts.
#     Also, watch for events not filtering through stated in time.
#
sub TBNodeStateWait ($$$$@) {
    my ($pc, $waitstart, $maxwait, $actual, @waitstates) = @_;

    #
    # Start a counter going, relative to the time we rebooted the first
    # node.
    #
    my $waittime  = 0;
    my $minutes   = 0;

    #
    # Wait for the node to finish booting, as recorded in database
    #
    while (1) {
	my $state;
	if (!TBGetNodeEventState($pc, \$state)) {
	    print "*** Error getting event state for $pc.\n";
	    return 1;
	}

	if (grep {$_ eq $state} @waitstates) {
	    $$actual = $state
		if (defined($actual));
	    return 0;
	}

	$waittime = time - $waitstart;
	if ($waittime > $maxwait) {
	    $minutes = int($waittime / 60);
	    print "*** Giving up on $pc - it's been $minutes minute(s).\n";
	    TBNodeConsoleTail($pc, *STDOUT);
	    return 1;
	}
	if (int($waittime / 60) > $minutes) {
	    $minutes = int($waittime / 60);
	    print "Still waiting for $pc - it's been $minutes minute(s).\n";
	}
	sleep(1);
    }
}

#
# Control net VLAN firewall stuff.
#
# reserved:cnet_vlan is set for a allocated node if the node is behind a
#       firewall.  In this case, cnet_vlan indicates the VLAN number that
#	this nodes' control net interface is a part of.
#
# firewalls:fwname is the virtual name of the node which is a firewall
#	for a particular experiment.
#
# firewalls:vlan is the VLAN number of the firewalled control net.
#
# It is possible for a node to be both a firewall and behind another
# firewall.  In that case, the firewalls table vlan column for
# pid/eid/thisnode-virt-name is the VLAN number for the firewalled control
# net that thisnode is implementing.  Thisnode's reserved table cnet_vlan
# column will contain the VLAN number of the firewalled control net that
# thisnode is a part of.
#

#
# Determine if there is a firewall for a particular experiment.
# Optionally returns the pname of the firewall node and the VLAN info.
#
# XXX only returns true for experiments with VLAN-based firewalls.
# XXX this will need to change if we support multiple firewalls per experiment.
#
sub TBExptFirewall ($$;$$$) {
    my ($pid, $eid, $fwnodep, $fwvlanidp, $fwvlanp) = @_;
    my $query_result;

    #
    # Short form: is there a firewall? Use the virt_firewalls table so can
    # be called for a swapped or active experiment.
    #
    if (!defined($fwnodep)) {
	$query_result =
	    DBQueryWarn("SELECT eid FROM virt_firewalls ".
			"WHERE pid='$pid' and eid='$eid' ".
			"AND type LIKE '%-vlan'");
	if (!$query_result || $query_result->num_rows == 0) {
	    return 0;
	}
	return 1;
    }

    #
    # Long form: want at least the name of the firewall node returned.
    # The experiment should be swapped in or else the returned node_id
    # will be NULL.
    #
    $query_result =
	DBQueryWarn("select r.node_id,f.vlan,f.vlanid from ".
		    "   virt_firewalls as v ".
		    "left join firewalls as f on f.pid=v.pid and f.eid=v.eid ".
		    "left join reserved as r on r.pid=v.pid and ".
		    "     r.eid=v.eid and r.vname=v.fwname ".
		    "where v.pid='$pid' and v.eid='$eid'");
    if (!$query_result || $query_result->num_rows == 0) {
	return 0;
    }

    my @row = $query_result->fetchrow_array();
    if (!defined($row[0])) {
	print STDERR "*** WARNING: attempted fetch of Firewall info for ".
	    "swapped experiment $pid/$eid\n";
	$$fwnodep = ""
	    if (defined($fwnodep));
    } else {
	$$fwnodep = $row[0]
	    if (defined($fwnodep));
    }
    $$fwvlanp = $row[1]
	if (defined($fwvlanp));
    $$fwvlanidp = $row[2]
	if (defined($fwvlanidp));
    return 1;
}

#
# Get the firewall node name and port number for an experiment;
# e.g., for use in an snmpit call.
# Return 1 if successful, 0 on error.
#
sub TBExptFirewallAndPort($$$$) {
    my ($pid, $eid, $fwnodep, $fwportp) = @_;
    my $fwnode;

    if (!TBExptFirewall($pid, $eid, \$fwnode)) {
	return 0;
    }

    my $query_result = 
	DBQueryWarn("select card1 from wires ".
		    "where node_id1='$fwnode' AND type='Control'");
    if (!$query_result || !$query_result->numrows) {
	return 0;
    }

    $$fwnodep = $fwnode;
    ($$fwportp) = $query_result->fetchrow_array();

    return 1;
}

#
# Set the firewall VLAN number for an experiment.
#
# XXX this will need to change if we support multiple firewalls per experiment.
#
sub TBSetExptFirewallVlan($$$$) {
    my ($pid, $eid, $fwvlanid, $fwvlan) = @_;
    my $fwnode;

    if (!TBExptFirewall($pid, $eid, \$fwnode)) {
	return 0;
    }

    my $exptidx;
    if (!TBExptIDX($pid, $eid, \$exptidx)) {
	print "*** WARNING: No such experiment $pid/$eid!\n";
	return -1;
    }

    #
    # Need the virtual name since we use that to ensure uniqness in the
    # firewalls table.
    #
    my $query_result =
	DBQueryWarn("select fwname from virt_firewalls ".
		    "WHERE pid='$pid' AND eid='$eid'");

    return -1
	if (!$query_result || $query_result->num_rows == 0);

    my ($fwname) = $query_result->fetchrow_array();

    #
    # Change the firewalls table entry to reflect the VLAN
    #
    DBQueryWarn("replace into firewalls (exptidx,pid,eid,fwname,vlan,vlanid) ".
		"values ('$exptidx', '$pid', '$eid', ".
		"        '$fwname', $fwvlan, $fwvlanid)");

    #
    # Change the reserved table entries for all firewalled nodes to reflect it.
    #
    DBQueryWarn("UPDATE reserved set cnet_vlan=$fwvlan ".
		"WHERE pid='$pid' AND eid='$eid' AND node_id!='$fwnode'");
}

#
# Clear the firewall VLAN number for an experiment.
#
# XXX this will need to change if we support multiple firewalls per experiment.
#
sub TBClearExptFirewallVlan($$)
{
    my ($pid, $eid) = @_;

    #
    # Clear entry from the firewalls table.
    #
    DBQueryWarn("delete from firewalls ".
		"where pid='$pid' and eid='$eid'");

    #
    # XXX when clearing, do not bother with reserved since the row may
    # already be gone.
    #
}

#
# Determines if a node is part of a firewalled experiment.
# If so, optionally returns the name and VLAN number for the firewall.
#
sub TBNodeFirewall ($$$) {
    my ($nodeid, $fwnodep, $fwvlanp) = @_;

    #
    # If they are only interested in a yes/no answer, just look in the
    # nodes table to set if the cnet_vlan is non-null.
    #
    if (!defined($fwnodep) && !defined($fwvlanp)) {
	my $query_result =
	    DBQueryWarn("select cnet_vlan from reserved ".
			"where node_id='$nodeid'");

	if (!$query_result || $query_result->num_rows == 0) {
	    return 0;
	}
	my ($res) = $query_result->fetchrow_array();
	if (!defined($res) || $res eq "") {
	    return 0;
	}
	return 1;
    }

    #
    # Otherwise extract the firewall name and vlan number for the node
    # This is probably not the best query in the world.  The first join
    # matches up nodes with their firewall info, the second "resolves"
    # each firewall's virtname to a physname.
    #
    my $query_result =
	DBQueryWarn("SELECT r2.node_id,f.vlan FROM firewalls AS f ".
		    "LEFT JOIN reserved AS r ".
		    "  ON r.pid=f.pid AND r.eid=f.eid AND r.cnet_vlan=f.vlan ".
		    "LEFT JOIN reserved AS r2 ".
		    "  ON r2.pid=f.pid AND r2.eid=f.eid AND r2.vname=f.fwname ".
		    "WHERE r.node_id='$nodeid'");
    if (!$query_result || $query_result->num_rows == 0) {
	return 0;
    }

    my @row = $query_result->fetchrow_array();
    $$fwnodep = $row[0]
	if (defined($fwnodep));
    $$fwvlanp = $row[1]
	if (defined($fwvlanp));
    return 1;
}

#
# Set the paniced bit for an experiment.
#
sub TBExptSetPanicBit($$;$) {
    my ($pid, $eid, $value) = @_;

    $value = 1
	if (!defined($value));

    return DBQueryWarn("update experiments set ".
		       "    paniced=$value,panic_date=now() ".
		       "where pid='$pid' and eid='$eid'");
}

#
# Clear the panic bit.
# 
sub TBExptClearPanicBit($$) {
    my ($pid, $eid) = @_;

    return DBQueryWarn("update experiments set ".
		       "    paniced=0,panic_date=NULL ".
		       "where pid='$pid' and eid='$eid'");
}

#
# Get the value of the paniced bit. 
# 
sub TBExptGetPanicBit($$$) {
    my ($pid, $eid, $panicp) = @_;

    my $query_result =
	DBQueryWarn("select paniced,panic_date from experiments ".
		    "where pid='$pid' and eid='$eid'");
    if (!$query_result || $query_result->num_rows == 0) {
	return 0;
    }
    my @row = $query_result->fetchrow_array();
    $$panicp = $row[0];

    return 1;
}

#
# Get the value of the swapout state.
# Right now this is just the savedisk field.
# Returns 1 if there is swap state, 0 otherwise.
# 
sub TBExptGetSwapState($$$) {
    my ($pid, $eid, $statep) = @_;

    my $query_result =
	DBQueryWarn("select savedisk from experiments ".
		    "where pid='$pid' and eid='$eid'");
    if (!$query_result || $query_result->num_rows == 0) {
	return 0;
    }
    my @row = $query_result->fetchrow_array();
    $$statep = $row[0];

    return 1;
}

#
# See if there is an admin MFS swapout action associated with the experiment.
# For now we just look at a globally defined action via sitevar.
#
# Returns 1 if there is a swapout action (with $ref hash filled in),
# 0 otherwise.
#
sub TBExptGetSwapoutAction($$$) {
    my ($pid, $eid, $ref) = @_;
    my ($action, $faction, $timeout);

    if (TBGetSiteVar("swap/swapout_command", \$action)) {
	my $failisfatal = 1;

	#
	# Swapout-time state saving.
	# Only perform if the experiment has desired state saving.
	#
	if ($action =~ /create-swapimage/) {
	    my $doit = 0;
	    my $query_result =
		DBQueryWarn("select savedisk from experiments ".
			    "where pid='$pid' and eid='$eid'");
	    if ($query_result && $query_result->num_rows != 0) {
		($doit) = $query_result->fetchrow_array();
	    }
	    if (!$doit) {
		%$ref = ();
		return 0;
	    }
	}

	if (TBGetSiteVar("swap/swapout_command_failaction", \$faction)) {
	    $failisfatal = ($faction eq "fail");
	}
	TBGetSiteVar("swap/swapout_command_timeout", \$timeout);

	%$ref = ('command' => $action,
		 'isfatal' => $failisfatal,
		 'timeout' => $timeout);
	return 1;
    }

    # Someday maybe check for per-experiment setting
    %$ref = ();
    return 0;
}

#
# Issue a DB query. Argument is a string. Returns the actual query object, so
# it is up to the caller to test it. I would not for one moment view this
# as encapsulation of the DB interface. I'm just tired of typing the same
# silly stuff over and over.
#
# usage: DBQuery(char *str)
#        returns the query object result.
#
# Sets $DBErrorString is case of error; saving the original query string and
# the error string from the DB module. Use DBFatal (below) to print/email
# that string, and then exit.
#
sub DBQueryN($$)
{
    my($dbnum, $query)   = @_;
    my $maxtries = $DBQUERY_MAXTRIES;
    my $result;

    # Not really forever :-)
    if (!$maxtries) {
	$maxtries = 100000;
    }

    # Reconnect to mysqld in child of fork.
    if ($DB[$dbnum]->db_pid() != $PID) {
	if (TBDBReconnect(1) != 0) {
	    $DBErrorString =
		"  Query: $query\n".
		"  Error: Could not reconnect to mysqld";
	    return undef;
	}
    }

    if ($DBQUERY_DEBUG) {
	print STDERR "Query: '$query'\n";
    }

    while ($maxtries) {
	# Get this each time through the loop since we try reconnect below.
	my $db = $DB[$dbnum];

	$result = $db->query($query);

	if (! defined($result)) {
	    my $err = $db->err;

	    $DBErrorString =
		"  Query: $query\n".
		"  Error: " . $db->errstr . " ($err)";
	}
	if (defined($result) ||
	    ($db->err != 2006) && ($db->err != 1053) && ($db->err != 2013) &&
	    ($db->err != 1046)) {
	    last;
	}

	#
	# If we lose the connection to mysqld; lets try to reconnect. 
	#
	if ($db->err == 2006 || $db->err == 2013) {
	    # This is just for the mysqld watchdog daemon.
	    return undef
		if (! $DBQUERY_RECONNECT);

	    if (TBDBReconnect(1) != 0) {
		$DBErrorString =
		    "  Query: $query\n".
		    "  Error: Could not reconnect to mysqld";

		return undef;
	    }
	    next;
	}

	$maxtries--;
	DBWarn("mysqld went away in process $PID. $maxtries tries left", 0);
	sleep(1);
    }
    return $result;
}
sub DBQuery($) {return DBQueryN(0,$_[0]);}

#
# Same as above, but die on error.
#
sub DBQueryFatalN($$)
{
    my($dbnum, $query) = @_;
    my($result);

    $result = DBQueryN($dbnum, $query);

    if (! $result) {
	DBFatal("DB Query failed");
    }
    return $result;
}
sub DBQueryFatal($) {return DBQueryFatalN(0,$_[0]);}

#
# Same as above, but just send email on error. This info is useful
# to the TB system, but the caller has to retain control.
#
sub DBQueryWarnN($$)
{
    my($dbnum, $query) = @_;
    my($result);

    $result = DBQueryN($dbnum, $query);

    if (! $result) {
	DBWarn("DB Query failed");
    }
    return $result;
}
sub DBQueryWarn($) {return DBQueryWarnN(0,$_[0]);}

#
# Warn and send email after a failed DB query. First argument is the error
# message to display. The contents of $DBErrorString is also printed.
#
# usage: DBWarn(char *message)
#
sub DBWarn($;$)
{
    my($message, $nomail) = @_;
    
    DBError(\&tbwarn, $message, $nomail);
}

#
# Same as above, but die after the warning.
#
# usage: DBFatal(char *message);
#
sub DBFatal($;$)
{
    my($message,$nomail) = $_[0];
    
    DBError(\&tbdie, $message, $nomail);
}

#
# DBError, common parts of DBWarn and DBFatal
#
# usage: DBError(log function, message, nomail)
#
sub DBError($$;$) 
{
    my($f, $message, $nomail) = @_;
    
    if (! defined($nomail)) {
	libtestbed::SENDMAIL($TBOPS, "DBError - $message",
			     "$message - In $SCRIPTNAME\n".
			     "$DBErrorString\n");
    }

    $f->({cause=>'software'}, "$message:\n$DBErrorString");
}

#
# Quote a string for DB insertion.
#
# usage: char *DBQuoteSpecial(char *string);
#
sub DBQuoteSpecial($)
{
    my($string) = $_[0];

    $string = $DB[0]->quote($string);

    return $string;
}

#
# Get the Error From the Last Database query
#
sub DBErrN($)
{
    return $DB[$_[0]]->err;
}
sub DBErr()
{
    return $DB[0]->err;
}

#
# Return a (current) string suitable for DB insertion in datetime slot.
# Of course, you can use this for anything you like!
#
# usage: char *DBDateTime(int seconds-to-add);
#
sub DBDateTime(;$)
{
    my($seconds) = @_;

    if (! defined($seconds)) {
	$seconds = 0;
    }

    return strftime("20%y-%m-%d %H:%M:%S", localtime(time() + $seconds));
}

#
# Helper. Test if numeric. Convert to dbuid if numeric.
#
sub MapNumericUID($)
{
    my ($uid) = @_;
    my $name;

    if ($uid =~ /^[0-9]+$/) {
	my $user = User->LookupByUnixId($uid);
	if (!defined($user)) {
	    die("*** $uid not a valid Emulab user!\n");
	}
	$name = $user->uid();
    }
    else {
	$name = $uid;
    }
    return $name;
}

#
# Map a generic OSID to a specific OSID for the actual node in question.
# The intent is that, for example, RHL-STD needs to be mapped to the
# specific version of RHL that is loaded on the machine. This bit of code
# does that mapping, return 0 if no mapping could be made.
#
# usage: MapNodeOSID(char *node, char *osid)
#        Return the new osid if mapping successful (or actual osid loaded).
#        Return 0 for all errors and if mapping not possible.
#
sub MapNodeOSID($$)
{
    my ($node, $osid) = @_;

    #
    # See if this OSID is actually loaded on the machine.
    #
    my $p_result =
	DBQueryWarn("select * from partitions ".
		    "where node_id='$node' and osid='$osid'");
    if (!$p_result) {
	return 0;
    }

    if ($p_result->numrows) {
	return $osid;
    }

    #
    # Get OSID info.
    #
    my $osid_result =
	DBQueryWarn("select * from os_info where osid='$osid'");

    if (!$osid_result || $osid_result->numrows == 0) {
	return 0;
    }
    my %osid_row   = $osid_result->fetchhash();

    #
    # If its a specific Version, and its not loaded on the machine,
    # nothing to do.
    #
    if (defined($osid_row{'version'}) && $osid_row{'version'} ne "") {
	return 0;
    }

    #
    # Try to map from a generic name to the specific name of the OS
    # that *is* loaded.
    #
    my $o_result =
	DBQueryWarn("select o1.* from partitions as p ".
		    "left join os_info as o1 on o1.osid=p.osid ".
		    "left join os_info as o2 on o2.OS=o1.OS ".
		    "where p.node_id='$node' and o2.osid='$osid'");

    if (!$o_result || $o_result->numrows == 0) {
	return 0;
    }

    my %o_row  = $o_result->fetchhash();
    my $n_osid = $o_row{'osid'};

    return $n_osid;
}

#
# Save off the log files for an experiment to long term storage.
#
sub TBSaveExpLogFiles($$)
{
    my($pid, $eid) = @_;

    my $workdir = TBExptWorkDir($pid, $eid);
    my $logdir  = TBExptLogDir($pid, $eid);

    # What the hell is this file! Very annoying.
    if (-e "$workdir/.rnd") {
	system("/bin/rm -f $workdir/.rnd");
    }
    system("/bin/cp -Rpf $workdir/ $logdir");

    return 1;
}

#
# Grab the tipserver list and return.
#
sub TBTipServers()
{
    my @tipservers = ();

    my $query_result =
	DBQueryFatal("select server from tipservers");

    while (my ($server) = $query_result->fetchrow_array) {
	push(@tipservers, $server);
    }
    return @tipservers;
}

#
# Report some activity for a node
#
# usage: TBActivityReport(char *node)
#        Returns 1 if okay.
#        Returns 0 if failed.
#
sub TBActivityReport($)
{
    my ($node) = @_;

    # Set last_ext_act to now(), but don't update the last_report
    return DBQueryFatal("update node_activity set last_ext_act= now() " .
			"where node_id='$node'");
}

#
# Return the number of *available* nodes. These are nodes that are not
# reserved and in the proper state. See corresponding code in ptopgen
# and in the web server which reports the free node counts to users.
#
# usage: TBAvailablePCs(char *pid)
#        Returns count.
#
sub TBAvailablePCs(;$)
{
    my ($pid) = @_;
    my $clause = (defined($pid) ? "or p.pid='$pid'" : "");

    my $query_result =
	DBQueryFatal("select count(a.node_id) from nodes as a ".
		     "left join reserved as b on a.node_id=b.node_id ".
		     "left join node_types as nt on a.type=nt.type ".
		     "left join nodetypeXpid_permissions as p ".
		     "  on a.type=p.type ".
		     "where b.node_id is null and a.role='testnode' and ".
		     "      nt.class='pc' and ".
                     "      (a.eventstate='" . TBDB_NODESTATE_ISUP . "' or ".
                     "       a.eventstate='" . TBDB_NODESTATE_PXEWAIT . "') and".
		     "      (p.pid is null $clause)");

    my ($count) = $query_result->fetchrow_array();
    return $count;
}

#
# Gather Assign stats. Its expected that the hash that comes in
# will reflect the slot names in the DB.
#
# usage: GatherAssignStats(char *pid, char *eid,
#			   char *mode, int code, int flags)
#        Mode is one of preload, start, in, out, modify, end.
#
sub GatherAssignStats($$%)
{
    my ($pid, $eid, %stats) = @_;
    my @updates = ();

    local $DBQUERY_MAXTRIES = 5;

    my $query_result =
	DBQueryWarn("select e.gid,e.idx,s.rsrcidx from experiments as e ".
		    "left join experiment_stats as s on e.idx=s.exptidx ".
		    "where e.pid='$pid' and e.eid='$eid'");
    if (!$query_result || !$query_result->numrows) {
	return;
    }
    my ($gid,$exptidx,$rsrcidx) = $query_result->fetchrow_array;

    # experiment records not inserted in testmode, but I use testmode
    # at home when doing development too.
    if (!defined($rsrcidx)) {
	return
	    if ($TESTMODE);
	die("*** $0:\n".
	    "    No stat record for record for $pid/$eid\n");
    }

    foreach my $key (keys(%stats)) {
	my $val = $stats{$key};

	push (@updates, "$key=$val");
    }
    DBQueryFatal("update experiment_resources ".
		 "set " . join(",", @updates) . " ".
		 "where idx=$rsrcidx");
}

sub max ( $$ ) {
    return ($_[0] > $_[1] ? $_[0] : $_[1]);
}

sub min ( $$ ) {
    return ($_[0] < $_[1] ? $_[0] : $_[1]);
}

sub hash_recurse2($%);
sub hash_recurse(%) {
    my (%hash) = @_;
    return hash_recurse2("",%hash);
}

sub array_recurse2($%);
sub array_recurse(%) {
    my (%array) = @_;
    return array_recurse2("",%array);
}

sub hash_recurse2($%) {
    my ($indent, %hash) = @_;
    my $level = "  ";
    my $str = "HASH:\n";
    my $tab = $indent.$level;
    foreach my $k (sort keys %hash) {
	$str .= $tab."$k => ";
	my $v = $hash{$k};
	my $type = ref($v);
	if (!$type) {
	    # scalar
	    $str .= "$v\n";
	} elsif ($type eq "HASH") {
	    $str .= hash_recurse2($tab,%$v);
	} elsif ($type eq "ARRAY") {
	    $str .= array_recurse2($tab,@$v);
	} elsif ($type eq "SCALAR") {
	    $str .= "(REF) ".$$v."\n";
	} else {
	    $str .= "(TYPE $type) $v\n";
	}
    }
    return $str;
}

sub array_recurse2($%) {
    my ($indent, @array) = @_;
    my $level = "  ";
    my $str = "ARRAY:\n";
    my $tab = $indent.$level;
    foreach my $v (@array) {
	my $type = ref($v);
	if (!$type) {
	    # Not a ref, therefore, a scalar
	    $str .= $tab."$v\n";
	} elsif ($type eq "HASH") {
	    $str .= hash_recurse2($tab,%$v);
	} elsif ($type eq "ARRAY") {
	    $str .= array_recurse2($tab,@$v);
	} elsif ($type eq "SCALAR") {
	    $str .= "(REF) ".$$v."\n";
	} else {
	    $str .= "(TYPE $type) $v\n";
	}
    }
    return $str;
}

#
# Support for checking field values against what is specified.
#
my %DBFieldData;
my $DBFieldErrstr = "";

sub TBFieldErrorString() { return $DBFieldErrstr; }

#
# Download all data from the DB and store in hash for latter access.
#
sub TBGrabFieldData()
{
    %DBFieldData = ();

    my $query_result =
	DBQueryFatal("select * from table_regex");

    while (my %row = $query_result->fetchhash()) {
	my $table_name  = $row{"table_name"};
	my $column_name = $row{"column_name"};

	$DBFieldData{$table_name . ":" . $column_name} =
	    { "check"       => $row{"check"},
	      "check_type"  => $row{"check_type"},
	      "column_type" => $row{"column_type"},
	      "min"         => $row{"min"},
	      "max"         => $row{"max"}
	    };
    }
}

#
# Return the field data for a specific table/slot. If none, return the default
# entry.
#
# The top level entry defines some stuff that is not to be overidden by the
# redirected entries. For example, the top level entry is the only place we
# can specify a field is optional when inserting a record. We could do this
# with default entries in the DB table defintion, but I do not like that idea.
# The min/max lengths also override, unless they are both zero in which case
# let the first non-zero defs set them.
#
sub TBFieldData($$;$)
{
    my ($table, $column, $flag) = @_;
    my $toplevel;
    my $fielddata;

    if (! %DBFieldData) {
	TBGrabFieldData();
    }
    my $key = $table . ":" . $column;

    while (exists($DBFieldData{$key})) {
	$fielddata = $DBFieldData{$key};

	#
	# See if a redirect to another entry.
	#
	if ($fielddata->{"check_type"} eq "redirect") {
	    if (!defined($toplevel)) {
		$toplevel = $fielddata;
	    }

	    $key = $fielddata->{"check"};
#	    print STDERR "Redirecting to $key for $table/$column!\n";
	    next;
	}
	last;
    }
    # Resort to a default entry.
    if (!defined($fielddata)) {
	$DBFieldErrstr = "Error-checking pattern missing from the database";
	
	if (defined($flag)) {
	    if ($flag & TBDB_CHECKDBSLOT_WARN()) {
		print STDERR "*** $0:\n" .
		             "    WARNING: No slot data for $table/$column!\n";
	    }
	    return undef
		if ($flag & TBDB_CHECKDBSLOT_ERROR());
	}
	$fielddata = $DBFieldData{"default:default"};
    }
    # Return both entries.
    if (defined($toplevel) &&
	($toplevel->{"min"} || $toplevel->{"max"})) {
	return ($fielddata, $toplevel);
    }
    return ($fielddata);
}

#
# Generic wrapper to check a slot.
#
sub TBcheck_dbslot($$$;$)
{
    my ($token, $table, $column, $flag) = @_;
    
    $DBFieldErrstr = "Unknown Error";

    my ($fielddata,$toplevel) = TBFieldData($table, $column, $flag);

    return 0
	if (!defined($fielddata));

    my $check       = $fielddata->{"check"};
    my $check_type  = $fielddata->{"check_type"};
    my $column_type = $fielddata->{"column_type"};
    my $min         = (defined($toplevel) ?
		       $toplevel->{"min"} : $fielddata->{"min"});
    my $max         = (defined($toplevel) ?
		       $toplevel->{"max"} : $fielddata->{"max"});

#    print STDERR "Using $check/$check_type/$column_type/$min/$max for ".
#	"$table/$column\n";

    #
    # Functional checks not implemented yet.
    #
    if ($check_type eq "function") {
	die("*** $0:\n" .
	    "    Functional DB checks not implemented: $table/$column!\n");
    }

    # Make sure the regex is anchored. Its a mistake not to be!
    $check = "^" . $check
	if (! ($check =~ /^\^/));

    $check = $check . "\$"
	if (! ($check =~ /\Q$/));

    # Check regex.
    if (! ("$token" =~ /$check/)) {
	$DBFieldErrstr = "Illegal Characters";
	return 0;
    }

    # Check min/max.
    if ($column_type eq "text") {
	my $len = length($token);

	# Any length is okay if no min or max. 
	return 1
	    if ((!($min || $max)) ||
		($len >= $min && $len <= $max));
	$DBFieldErrstr = "Too Short"
	    if ($min && $len < $min);
	$DBFieldErrstr = "Too Long"
	    if ($max && $len > $max);
    }
    elsif ($column_type eq "int" ||
	   $column_type eq "float") {
	# If both min/max are zero, then skip check; allow anything.
	return 1
	    if ((!($min || $max)) || ($token >= $min && $token <= $max));
	$DBFieldErrstr = "Too Small"
	    if ($min && $token < $min);
	$DBFieldErrstr = "Too Big"
	    if ($max && $token > $max);
    }
    else {
	die("*** $0:\n" .
	    "    Unrecognized column_type $column_type\n");
    }
    return 0;
}

#
# Return a unique index from emulab_indicies for the indicated name.
# Updates the index to be, well, unique.
# Eats flaming death on error.
#
# WARNING: this will unlock all locked tables, be careful where you call it!
#
sub TBGetUniqueIndex($;$$)
{
    my ($name, $initval, $nolock) = @_;

    #
    # Lock the table to avoid conflict, but not if the caller already did it.
    #
    $nolock = 0
	if (!defined($nolock));
    
    DBQueryFatal("lock tables emulab_indicies write")
	if (!$nolock);

    my $query_result =
	DBQueryFatal("select idx from emulab_indicies ".
		     "where name='$name'");
    my ($curidx) = $query_result->fetchrow_array();
    if (!defined($curidx)) {
	$curidx = (defined($initval) ? $initval : 1);
    }
    my $nextidx = $curidx + 1;

    DBQueryFatal("replace into emulab_indicies (name, idx) ".
		 "values ('$name', $nextidx)");
    DBQueryFatal("unlock tables")
	if (!$nolock);

    return $curidx;
}

sub TBSetNodeHistory($$$$$)
{
    my ($nodeid, $op, $uid, $pid, $eid) = @_;
    my $exptidx;

    #
    # XXX Eventually this should change, but the use of $UID is funky.
    #
    my $dbid;
    my $node = Node->Lookup($nodeid);
    my $experiment = Experiment->Lookup($pid, $eid);
    my $this_user;

    if (!defined($node)) {
	print "*** WARNING: No such node $nodeid!\n";
	return 0;
    }
    if (!defined($experiment)) {
	print "*** WARNING: No such experiment $pid/$eid!\n";
	return 0;
    }

    if ($uid =~ /^[0-9]+$/) {
	if ($uid == 0) {
	    # Node->SetNodeHistory() is okay with this.
	    $this_user = undef;
	}
	else {
	    $this_user = User->LookupByUnixId($uid);
	    if (! defined($this_user)) {
		print "*** WARNING: $UID does not exist in the DB!";
		return 0;
	    }
	}
    }
    else {
	$this_user = User->Lookup($uid);
	if (! defined($this_user)) {
	    print "*** WARNING: $UID does not exist in the DB!";
	    return 0;
	}
    }
    return $node->SetNodeHistory($op, $this_user, $experiment);
}

sub TBGetOSBootCmd($$$)
{
    my ($osid, $role, $default_cmdline) = @_;
    my $retval = $default_cmdline;
    
    my $query_result =
	DBQueryFatal("SELECT ob.boot_cmd_line FROM os_info as oi ".
		     "LEFT JOIN os_boot_cmd as ob on ob.OS=oi.OS and ".
		     "  ob.version=oi.version ".
		     "WHERE oi.osid='$osid' and ob.role='$role'");
    
    if ($query_result->num_rows == 1) {
	($retval) = $query_result->fetchrow_array();
    }
    
    return $retval;
}

END {
    # Call it here otherwise may get:
    #   (in cleanup) Can't call method "FETCH" on an undefined value at 
    #   /usr/local/lib/perl5/site_perl/5.8.8/mach/Mysql.pm line 91 during 
    #   global destruction.
    # where line 91 is:
    #  	my $oldvalue = $self->{'dbh'}->{'InactiveDestroy'};
    # which is in setInactiveDestroy() which get called in libdb.pm in:
    #   if ($self->db_pid() != $$) {
    #       $self->setInactiveDestroy(1);
    #   }
    # which is in TestbedDBHandle::DESTROY (still in libdb.pm even
    # though it is a diffrent package)
    #
    # This error is probably due to some object being destroyed too
    # soon somewhere in the DBI/DBD modules.
    TBDBDisconnect();
}

# _Always_ make sure that this 1 is at the end of the file...

1;

