#!/usr/bin/perl -wT
#
# EMULAB-COPYRIGHT
# Copyright (c) 2007 University of Utah and the Flux Group.
# All rights reserved.
#
package OSinfo;

use strict;
use Exporter;
use vars qw(@ISA @EXPORT);

@ISA    = "Exporter";
@EXPORT = qw ( );

# Must come after package declaration!
use lib '@prefix@/lib';
use libdb;
use libtestbed;
use Project;
use User;
use English;
use Data::Dumper;
use overload ('""' => 'Stringify');

# Configure variables
my $TB		  = "@prefix@";
my $BOSSNODE      = "@BOSSNODE@";
my $CONTROL	  = "@USERNODE@";
my $TBOPS         = "@TBOPSEMAIL@";
my $TBAPPROVAL    = "@TBAPPROVALEMAIL@";
my $TBAUDIT       = "@TBAUDITEMAIL@";
my $TBBASE        = "@TBBASE@";
my $TBWWW         = "@TBWWW@";

# Cache of instances to avoid regenerating them.
my %osids	= ();
my $debug	= 0;

# Valid features. Mirrored in the web interface. The value is a user-okay flag.
my %FEATURES	= ( "ping"	 => 1,
		    "ssh",	 => 1,
		    "ipod"	 => 1,
		    "isup"	 => 1,
		    "veths"	 => 0,
		    "mlinks"	 => 0,
		    "linktest"	 => 1,
		    "linkdelays" => 0 );

# Valid OS names. Mirrored in the web interface. The value is a user-okay flag.
my %OSLIST	= ( "Linux"	 => 1,
		    "Fedora"	 => 1,
		    "FreeBSD"	 => 1,
		    "NetBSD"	 => 1,
		    "Windows"	 => 1,
		    "TinyOS"	 => 1,
		    "Oskit"	 => 0,
		    "Other"	 => 1 );

# Default OSID boot wait timeouts in seconds. Mirrored in the web interface. 
my %WAITTIMES    = ("Linux"	 => 120,
		    "Fedora"	 => 120,
		    "FreeBSD"	 => 120,
		    "NetBSD"	 => 120,
		    "Windows"	 => 240,
		    "TinyOS"	 => 60,
		    "Oskit"	 => 60,
		    "Other"	 => 60 );

# OP modes. Mirrored in the web interface. The value is a user-okay flag.
my %OPMODES	 = ("NORMALv2"	 => 1,
		    "NORMALv1"	 => 0,
		    "MINIMAL"	 => 1,
		    "NORMAL"	 => 1,
		    "ALWAYSUP"	 => 1 );

# Little helper and debug function.
sub mysystem($)
{
    my ($command) = @_;

    print STDERR "Running '$command'\n"
	if ($debug);
    return system($command);
}

#
# Lookup by idx or pid,osname, depending on the args.
#
sub Lookup($$;$)
{
    my ($class, $arg1, $arg2) = @_;
    my $osid;

    #
    # A single arg is either an index or a "pid,osname" or "pid/osname" string.
    #
    if (!defined($arg2)) {
	if ($arg1 =~ /^(\d*)$/) {
	    $osid = $1;
	}
	elsif ($arg1 =~ /^([-\w]*),([-\w\.\+]*)$/ ||
	       $arg1 =~ /^([-\w]*)\/([-\w\.\+]*)$/) {
	    $arg1 = $1;
	    $arg2 = $2;
	}
	else {
	    return undef;
	}
    }
    elsif (! (($arg1 =~ /^[-\w\.\+]*$/) && ($arg2 =~ /^[-\w\.\+]*$/))) {
	return undef;
    }

    #
    # Two args means pid/osname lookup instead of gid_idx.
    #
    if (defined($arg2)) {
	my $osid_result =
	    DBQueryWarn("select osid from os_info ".
			"where pid='$arg1' and osname='$arg2'");

	return undef
	    if (! $osid_result || !$osid_result->numrows);

	($osid) = $osid_result->fetchrow_array();
    }

    # Look in cache first
    return $osids{"$osid"}
        if (exists($osids{"$osid"}));
    
    my $query_result =
	DBQueryWarn("select * from os_info where osid='$osid'");

    return undef
	if (!$query_result || !$query_result->numrows);

    my $self           = {};
    $self->{'OSINFO'}  = $query_result->fetchrow_hashref();

    bless($self, $class);
    
    # Add to cache. 
    $osids{"$osid"} = $self;
    
    return $self;
}
# accessors
sub field($$) { return ((! ref($_[0])) ? -1 : $_[0]->{'OSINFO'}->{$_[1]}); }
sub osname($)           { return field($_[0], "osname"); }
sub osid($)             { return field($_[0], "osid"); }
sub pid($)	        { return field($_[0], "pid"); }
sub gid($)	        { return field($_[0], "gid"); }
sub pid_idx($)          { return field($_[0], "pid_idx"); }
sub gid_idx($)          { return field($_[0], "gid_idx"); }
sub creator($)          { return field($_[0], "creator"); }
sub creator_idx($)      { return field($_[0], "creator_idx"); }
sub created($)          { return field($_[0], "created"); }
sub description($)      { return field($_[0], "description"); }
sub OS($)		{ return field($_[0], "OS"); }
sub version($)		{ return field($_[0], "version"); }
sub path($)             { return field($_[0], "path"); }
sub magic($)            { return field($_[0], "magic"); }
sub machinetype($)      { return field($_[0], "machinetype"); }
sub osfeatures($)       { return field($_[0], "osfeatures"); }
sub ezid($)		{ return field($_[0], "ezid"); }
sub shared($)		{ return field($_[0], "shared"); }
sub mustclean($)	{ return field($_[0], "mustclean"); }
sub op_mode($)		{ return field($_[0], "op_mode"); }
sub nextosid($)		{ return field($_[0], "nextosid"); }
sub max_concurrent($)   { return field($_[0], "max_concurrent"); }
sub mfs($)              { return field($_[0], "mfs"); }
sub reboot_waittime($)  { return field($_[0], "reboot_waittime"); }

#
# Create a new os_info. This installs the new record in the DB,
# and returns an instance. There is some bookkeeping along the way.
#
sub Create($$$$)
{
    my ($class, $project, $creator, $osname, $argref, $usrerr_ref) = @_;
    my $idx;
    my $now = time();

    return undef
	if (ref($class) || !ref($project));

    my $pid     = $project->pid();
    my $pid_idx = $project->pid_idx();
    my $uid     = $creator->uid();
    my $uid_idx = $creator->uid_idx();

    #
    # The pid/osid has to be unique, so lock the table for the check/insert.
    #
    DBQueryWarn("lock tables os_info write, emulab_indicies write")
	or return undef;

    my $query_result =
	DBQueryWarn("select osname from os_info ".
		    "where pid_idx='$pid_idx' and osname='$osname'");

    if ($query_result->numrows) {
	DBQueryWarn("unlock tables");
	$$usrerr_ref = "Error: OS $osname in project $pid already exists!";
	return undef;
    }

    #
    # Grab unique ID. Table already locked.
    # 
    my $osid  = TBGetUniqueIndex("next_osid", undef, 1);
    my $uuid  = NewUUID();
    my $desc  = "''";
    my $magic = "''"; 

    # Some fields special cause of quoting.
    #
    if (exists($argref->{'description'})) {
	$desc = DBQuoteSpecial($argref->{'description'});
	delete($argref->{'description'});
    }
    if (exists($argref->{'magic'})) {
	$magic = DBQuoteSpecial($argref->{'magic'});
	delete($argref->{'magic'});
    }
    
    my $query = "insert into os_info set ".
	join(",", map("$_='" . $argref->{$_} . "'", keys(%{$argref})));

    # Append the rest
    $query .= ",osname='$osname'";
    $query .= ",osid='$osid'";
    $query .= ",uuid='$uuid'";
    $query .= ",pid='$pid',pid_idx='$pid_idx'";
    $query .= ",creator='$uid',creator_idx='$uid_idx'";
    $query .= ",created=now()";
    $query .= ",description=$desc";    
    $query .= ",magic=$magic";    
    
    if (! DBQueryWarn($query)) {
	DBQueryWarn("unlock tables");
	tberror("Error inserting new os_info record for $pid/$osname!");
	return undef;
    }
    DBQueryWarn("unlock tables");

    return OSinfo->Lookup($osid);
}

#
# Refresh a class instance by reloading from the DB.
#
sub Refresh($)
{
    my ($self) = @_;

    return -1
	if (! ref($self));

    my $osid = $self->osid();
    
    my $query_result =
	DBQueryWarn("select * from os_info where osid=$osid");

    return -1
	if (!$query_result || !$query_result->numrows);

    $self->{'OSINFO'} = $query_result->fetchrow_hashref();

    return 0;
}

#
# Stringify for output.
#
sub Stringify($)
{
    my ($self) = @_;
    
    my $pid    = $self->pid();
    my $osid   = $self->osid();
    my $osname = $self->osname();

    return "[OS $osid: $pid,$osname]";
}

#
# Perform some updates ...
#
sub Update($$)
{
    my ($self, $argref) = @_;

    # Must be a real reference. 
    return -1
	if (! ref($self));

    my $osid = $self->osid();

    my $query = "update os_info set ".
	join(",", map("$_='" . $argref->{$_} . "'", keys(%{$argref})));

    $query .= " where osid='$osid'";

    return -1
	if (! DBQueryWarn($query));

    return Refresh($self);
}

#
# Load the project object for an osid
#
sub GetProject($)
{
    my ($self) = @_;

    # Must be a real reference. 
    return undef
	if (! ref($self));

    my $project = Project->Lookup($self->pid_idx());
    
    if (! defined($project)) {
	print("*** WARNING: Could not lookup project object for $self!", 1);
	return undef;
    }
    return $project;
}

#
# Check permissions.
#
sub AccessCheck($$$)
{
    my ($self, $user, $access_type) = @_;

    # Must be a real reference. 
    return 0
	if (! ref($self));

    my $mintrust;

    if ($access_type < TB_OSID_MIN || $access_type > TB_OSID_MAX) {
	print "*** Invalid access type $access_type!\n";
	return 0;
    }
    # Admins do whatever they want!
    return 1
	if ($user->IsAdmin());

    #
    # Global OSIDs can be read by anyone, but must be admin to write.
    #
    if ($self->shared()) {
	if ($access_type == TB_OSID_READINFO) {
	    return 1;
	}
	return 0;
    }

    my $project = $self->GetProject();
    return 0
	if (!defined($project));

    #
    # Otherwise must have proper trust in the project.
    #
    if ($access_type == TB_OSID_READINFO) {
	$mintrust = PROJMEMBERTRUST_USER;
    }
    else {
	$mintrust = PROJMEMBERTRUST_LOCALROOT;
    }

    return TBMinTrust($project->Trust($user), $mintrust);
}

#
# Class method to get the default reboot time for an os type.
#
sub RebootWaitTime($$)
{
    my ($self, $os) = @_;

    return $WAITTIMES{"other"}
	if (!exists($WAITTIMES{$os}));

    return $WAITTIMES{$os};
}

#
# Class method to check the OS is legal.
#
sub ValidOS($$)
{
    my ($self, $os) = @_;

    return (exists($OSLIST{$os}) ? 1 : 0);
}

#
# Class method to check the OPmode is legal.
#
sub ValidOpMode($$)
{
    my ($self, $opmode) = @_;

    return (exists($OPMODES{$opmode}) ? 1 : 0);
}

# _Always_ make sure that this 1 is at the end of the file...
1;
