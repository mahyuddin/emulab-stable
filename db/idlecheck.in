#!/usr/bin/perl -w

#
# EMULAB-COPYRIGHT
# Copyright (c) 2000-2002 University of Utah and the Flux Group.
# All rights reserved.
#

# idlecheck - See if node/expt is active

# Configure variables
use lib '@prefix@/lib';
use libdb;
use English;

# Turn off line buffering on output
$| = 1;

$h = 0; #help mode
$t=0;
$p=0;
$f=0;
$u=0;
$s=0;
$d = 0; #debug mode

sub help {
    die("Usage:
idlecheck [-h] [-t hours] [-p pph] [-f min] [-u] [-s] [-d]
 -h\tThis help message
 -t\tTime (in hours) of inactivity required to be considered idle
 -p\tPackets per hour required on average to be considered active
 -f\tMaximum minutes elapsed for data to be considered fresh
 -u\tShow unswappable experiments
 -s\tShow experiments with stale data
 -d\tDebug/verbose mode
Check activity for all experiments.
Currently the following qualify as activity:
 * Packets sent/received on the experimental network
 * Use of a tty
Activity does not currently include:
 * Network traffic for nodes using automatic routing or trafgen daemons
 * Computation (non-idle load averages)
 * Control net traffic
 * Control without the use of a tty\n"
       );
}

print "Got ARGV = ",join(" ",@ARGV),"\n" if $d > 1;

my %args = ();
while ($#ARGV >= 0) {
    $_ = shift;
    $_ =~ /^(.)(.)/;
    if ($1 ne '-') { next; }
    if ($2 ne 'h' && $2 ne 't' && $2 ne 'p' && $2 ne 'f' &&
	$2 ne 'u' && $2 ne 's' && $2 ne 'd') { next; }
    my $opt="\L$2";
    my $val = shift if ($#ARGV >= 0 && ($ARGV[0] =~ /^[^-]/));
    if (!defined($val)) { $val=1; }
    # Let -d be used multiple times
    if ($opt eq 'd') { $d++; } else {
	$$opt=$val;
    }
    if ($d>1) { print "$opt = $$opt\n"; }
}
if ($h) { help(); }

# Only root or admin types!
if (($UID != 0) && (!TBAdmin($UID))) {
    die("Only root or TB administrators can run idlecheck.\n");
}

# Configurable parameters
my $idlehours = $t || 12;
my $minpph = $p || 1; # Min packets per hour a non-idle interface sends/rcvs
my $stalemin = $f || 65; # Max minutes of staleness for latest report

# Derived params
my $minpkts = $idlehours * $minpph;
my $idlesec = $idlehours * 3600;
my $stalesec = $stalemin * 60;
my $rtype="ospf";
my $node1="";
my $node2="";
my $node3="";
if ($n) {
    $node1="a.node_id,";
    $node2="and a.node_id=\"$n\"";
    $node3=",node_id";
}
my %active=();
my %fresh=();
my %router=();

# This query finds how many packets the non-control net interfaces
# have sent in the last $idlesec seconds, and saves it in a temporary
# table. It then aggregates that and shows a list of pid/eid (and
# maybe nodes) that have an interface that sent/rcvd at least $minpkts
# packets in the time period. It also makes sure to only count entries
# since they've been swapped in, and makes sure they were swapped in
# at least $idlesec seconds ago.

# The last query below finds the last reported tty use for each
# expt. It only counts reports that have been received in the last
# $stalemin minutes and that have been since the expt was swapped in,
# and only shows expts that have been used in the last $idlesec seconds.

for my $cmd ("drop table if exists idletemp;",
	     "create temporary table idletemp 
select r.pid,r.eid, routertype as router, $node1
max(ipkts)-min(ipkts) as idiff , max(opkts)-min(opkts) as odiff
from iface_counters as a
left join reserved as r on a.node_id = r.node_id 
left join nodes as n on a.node_id=n.node_id
left join virt_trafgens as v on r.vname=v.vnode
left join interfaces as i on a.mac=i.mac 
left join experiments as e on e.pid=r.pid and e.eid=r.eid
where tstamp >= expt_swapped 
and v.vnode is null
and (unix_timestamp(now())-unix_timestamp(tstamp) <= $idlesec) 
and (unix_timestamp(now())-unix_timestamp(expt_swapped) >= $idlesec) 
and (routertype=\"$rtype\" or i.IP not like \"155.101.%\") $node2
group by r.pid,r.eid,a.mac;",
	     "select pid,eid, max(idiff), max(odiff) from idletemp 
group by pid,eid $node3
having (max(idiff) >= $minpkts) or (max(odiff) >= $minpkts);",
# Ordering matters here! Make sure that the router query comes
# _after_ the idletemp query and _before_ all the other select queries!
	     "select pid, eid, router from idletemp
where router=\"$rtype\"
group by pid,eid ,router;",
	     "select r.pid,r.eid,max(last_tty) as lastuse ,max(tstamp) as t
from node_idlestats as n 
left join reserved as r on n.node_id=r.node_id
left join experiments as e on e.pid=r.pid and e.eid=r.eid
where tstamp >= expt_swapped and r.pid is not null and r.eid is not null
group by pid,eid 
having (unix_timestamp(now())-unix_timestamp(lastuse) <= $idlesec)
order by pid,eid,last_tty,tstamp;") {

    print "Sending cmd:\n$cmd\n" if $d>1;
    my $result = DBQueryFatal($cmd);
    if ($cmd =~ /^select /i && $result->numrows() > 0) {
	# Add the pid/eid to our list of active expts
	while(@r=$result->fetchrow()) {
	    $pid=$r[0];
	    $eid=$r[1];
	    if (!($cmd =~ /where router/i)) {
		print "Adding $pid/$eid to active list\n" if $d;
		$active{"$pid/$eid"} = 1;
	    } else {
		print "Removing $pid/$eid from active list - it has $rtype routers!\n" if $d;
		$active{"$pid/$eid"} = 0;
		$router{"$pid/$eid"} = 1;
	    }
	}
    }
    print $result->as_string() if ($d>1);
}

# These queries find all experiments that have had all of their nodes
# report in the last $stalesec seconds.

my $result="";
foreach $cmd ("drop table if exists idletemp2",
	      "create temporary table idletemp2
select pid,eid,n.node_id,max(tstamp) as t from reserved as r
left join node_idlestats as n on r.node_id=n.node_id
where r.node_id not like 'sh%' and r.node_id not like 'wireless%'
and r.node_id not like '%ron%'
group by n.node_id order by pid,eid,t;",
	      "select pid,eid,min(t) as oldest from idletemp2
where t is not null group by pid,eid
having (unix_timestamp(now())-unix_timestamp(oldest)<=$stalesec)
order by pid,eid;") {
    print "Sending cmd:\n$cmd\n" if $d>1;
    $result = DBQueryFatal($cmd);
}
while(@r=$result->fetchrow()) {
    $pid=$r[0];
    $eid=$r[1];
    print "Adding $pid/$eid to fresh data list\n" if $d;
    $fresh{"$pid/$eid"} = 1;
}
print $result->as_string() if ($d>1);

my @list=();
# Find expts that have nodes reserved, and look up their bits.
$cmd = "select r.pid,r.eid,swappable,expt_swapped from reserved as r
left join experiments as e on e.pid=r.pid and e.eid=r.eid
where (unix_timestamp(now())-unix_timestamp(expt_swapped) >= $idlesec)
and idle_ignore=0 group by r.pid,r.eid order by r.pid,r.eid";
print "Sending cmd:\n$cmd\n" if $d>1;
$result = DBQueryFatal($cmd);
while(@r=$result->fetchrow()) {
    $pid=$r[0];
    $eid=$r[1];
    $swap=$r[2];
    $idle=!(defined($active{"$pid/$eid"}) && $active{"$pid/$eid"});
    $router=defined($active{"$pid/$eid"}) && $router{"$pid/$eid"};
    $stale=!(defined($fresh{"$pid/$eid"}) && $fresh{"$pid/$eid"});
    print "Checking for $pid/$eid in active list\n" if $d;
    # Now output the results
    # IMPORTANT: If you make changes to output format, be sure to update
    # testbed/www/showexp_list.php3 as well, since it reads this output
    my $str= "$pid/$eid";
    $str = $str . " " x (28-length($str))." ";
    $str .= ($idle? "inactive\t" : "\t\t" );
    $str .= ($stale?"stale\t" : "\t" );
    $str .= (!$swap? "unswappable\t" : "\t\t" );
    $str .= ($router? "$rtype\n" : "\n" );
    if (($idle && !$stale && $swap) ||
	($stale && $s) || 
	(!$swap && $u)) { print $str; }
    if ($idle) { push(@list,"(pid='$pid' and eid='$eid')"); }
}
print $result->as_string() if ($d>1);

if (@list > 0) {
    $cmd = "update experiments set swap_requests=0 where not (".
      join(" or ",@list).")";
    print "Sending cmd:\n$cmd\n" if $d>1;
    DBQueryWarn($cmd);
}

exit(0);
