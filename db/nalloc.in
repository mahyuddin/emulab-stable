#!/usr/bin/perl -w
#
# EMULAB-COPYRIGHT
# Copyright (c) 2000-2004 University of Utah and the Flux Group.
# All rights reserved.
#
use English;
use Getopt::Std;

#
# nalloc - allocate nodes to an experiment. Takes a pid, and eid, and
# a list of nodes. Only nodes that are free can be allocated.
#
# Exit status is important! Exit with -1 if an error, else the number
# of nodes that could not be allocated. Otherwise zero.
#
sub usage()
{
    print("Usage: nalloc [-v] [-p] <pid> <eid> <node> <node> <...>\n".
	  "		-p enables partial allocation mode\n".
	  "		-v enables debugging output\n");
    exit(-1);
}
my $optlist = "dp";
my $debug   = 0;
my $partial = 0;

#
# Configure variables
#
my $TB          = "@prefix@";
my $consetup    = "$TB/libexec/console_setup";
my $exportsetup = "$TB/sbin/exports_setup";

#
# Testbed Support libraries
#
use lib '@prefix@/lib';
use libdb;
use libtestbed;

#
# Turn off line buffering on output
#
$| = 1; 

# For perf analysis.
#TBDebugTimeStampsOn();

#
# Parse command arguments. Once we return from getopts, all that should be
# left are the required arguments.
#
%options = ();
if (! getopts($optlist, \%options)) {
    usage();
}
if (defined($options{"d"})) {
    $debug = 1;
}
if (defined($options{"p"})) {
    $partial = 1;
}
if (@ARGV < 2) {
    usage();
}
my $pid		= shift;
my $eid		= shift;
my @node_names	= @ARGV;

#
# Locals
# 
my $error	  = 0;
my $noalloc	  = 0;
my @vals	  = ();
my @nodes	  = ();
my @need_consetup = 0;

TBDebugTimeStamp("nalloc started");
#
# Experiment must exist.
# 
if (!ExpState($pid,$eid)) {
    die "There is no experiment $eid in project $pid\n";
}
TBDebugTimeStamp("nalloc checked exp state");

#
# User must have permission to modify the experiment.
#
if ($UID) {
    if (!TBExptAccessCheck($UID, $pid, $eid, TB_EXPT_MODIFY)) {
        die("*** You not have permission to allocate nodes in $pid/$eid!\n");
    }
}
TBDebugTimeStamp("nalloc checked exp permission");

#
# Before locking any tables, do a quick check to make sure the project
# is allowed to allocate the nodes, by type/class, plus other checks.
#
foreach my $n (@node_names) {
    # Make sure a valid node name first!
    if (! TBValidNodeName($n)) {
	die("*** $0:\n".
	    "    No such node $n!\n");
    }

    # Project allowed to allocated this node type/class?
    if (! TBNodeAllocCheck($pid, $n)) {
	die("*** $0:\n".
	    "    You are not allowed to allocate $n to project $pid!\n");
    }

    # XXX
    # If the node has a tipline, then indicate that we want to call
    # console_setup. We want to avoid calling console_setup if all we
    # got is a zillion virtual nodes on the command line; wasted work.
    #
    my $tiplines_result =
	DBQueryFatal("select tipname,server from tiplines ".
		     "where node_id='$n'");

    if ($tiplines_result->numrows) {
	$need_consetup++;
    }
}
TBDebugTimeStamp("nalloc checked node permission ");

# Must lock this table!
DBQueryFatal("lock tables reserved write");
TBDebugTimeStamp("nalloc locked tables");

# Make a list of nodes to reserve.
foreach my $n (@node_names) {
    my ($r_pid, $r_eid);
    
    if (NodeidToExp($n, \$r_pid, \$r_eid)) {
	# Someone has already reserved this node
	if (($r_pid eq $pid) && ($r_eid eq $eid)) {
	    print "Already reserved: '$n'\n";
	    # Do not increment error code since that throws off caller.
	    next;
	}
	elsif (NodeidToExpOldReserved($n, \$r_pid, \$r_eid) &&
	       (($r_pid eq $pid) && ($r_eid eq $eid))) {
	    print "Already reserved in holding reservation: '$n'\n";
	}
	else {
	    print "Someone else has already reserved node '$n'.\n";
	    $noalloc++;
	    next;
	}
    }

    #
    # Add info the list of nodes to reserve; done in a single query below.
    # 
    push(@vals,  "('$n','$pid','$eid','$n','','')");
    push(@nodes, "$n");
}
TBDebugTimeStamp("nalloc checked all nodes");

if ($debug) {
    print "List Ready: @vals\nError=$error\n";
}

# Now make the reservations in the DB.
if ((!$noalloc || $partial) && @vals) {
    print "Reserving nodes...\n"
	if ($debug);

    if (! DBQueryWarn("replace into reserved ".
		      "  (node_id,pid,eid,vname,old_pid,old_eid) ".
		      "values ". join(",",@vals))) {
	$error++;
    }
}
TBDebugTimeStamp("nalloc allocated all nodes");

# Unlock tables.
DBQueryFatal("unlock tables");
TBDebugTimeStamp("nalloc unlocked tables");

# Update node_activity table; no need to do this with tables locked.
if (!$error && (!$noalloc || $partial) && @nodes) {
    print "Resetting node activity\n"
	if ($debug);

    # It isn't an error if this fails...
    DBQueryWarn("update node_activity set last_ext_act=now() ".
		"where " . join(" or ",map("node_id='$_'", @nodes)));

    TBDebugTimeStamp("nalloc updated node_activity table");
}

# Now setup consoles if needed.
if ($need_consetup && !$error && @nodes) {
    system("$consetup @nodes") == 0 or
	print STDERR "WARNING: $consetup @nodes failed!\n";
    TBDebugTimeStamp("nalloc finished console setup");
}

#
# Exit with -1 if an error, else the number of nodes that could not
# be allocated.
#
my $exitval = ($error ? -1 : $noalloc);
if ($debug) { print "Returning with value $exitval\n"; }
exit($exitval);
