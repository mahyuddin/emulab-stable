#!/usr/bin/perl -w
#
# EMULAB-COPYRIGHT
# Copyright (c) 2000-2005, 2007 University of Utah and the Flux Group.
# All rights reserved.
#
use English;
use Getopt::Std;

#
# nalloc - allocate nodes to an experiment. Takes a pid, and eid, and
# a list of nodes. Only nodes that are free can be allocated.
#
# Exit status is important! Exit with -1 if an error, else the number
# of nodes that could not be allocated. Otherwise zero.
#
sub usage()
{
    print("Usage: nalloc [-v] [-p] <pid> <eid> <node> <node> <...>\n".
	  "		-p enables partial allocation mode\n".
	  "		-v enables debugging output\n");
    exit(-1);
}
my $optlist = "dp";
my $debug   = 0;
my $partial = 0;

#
# Configure variables
#
my $TB          = "@prefix@";
my $consetup    = "$TB/libexec/console_setup";
my $exportsetup = "$TB/sbin/exports_setup";

#
# Testbed Support libraries
#
use lib '@prefix@/lib';
use libdb;
use libtestbed;

#
# Turn off line buffering on output
#
$| = 1; 

# For perf analysis.
#TBDebugTimeStampsOn();

#
# Parse command arguments. Once we return from getopts, all that should be
# left are the required arguments.
#
%options = ();
if (! getopts($optlist, \%options)) {
    usage();
}
if (defined($options{"d"})) {
    $debug = 1;
}
if (defined($options{"p"})) {
    $partial = 1;
}
if (@ARGV < 2) {
    usage();
}
my $pid		= shift;
my $eid		= shift;
my @node_names	= @ARGV;

#
# Locals
# 
my $error	  = 0;
my $noalloc	  = 0;
my @newvals	  = ();
my @oldnodes	  = ();
my @nodes	  = ();
my @need_consetup = 0;
my @need_history  = ();
my @need_clearbl  = ();

TBDebugTimeStamp("nalloc started");
#
# Experiment must exist.
# 
if (!ExpState($pid,$eid)) {
    warn "There is no experiment $eid in project $pid\n";
    exit -1;
}
TBDebugTimeStamp("nalloc checked exp state");

#
# User must have permission to modify the experiment.
#
if ($UID) {
    if (!TBExptAccessCheck($UID, $pid, $eid, TB_EXPT_MODIFY)) {
        warn("*** You not have permission to allocate nodes in $pid/$eid!\n");
        exit -1;
    }
}
TBDebugTimeStamp("nalloc checked exp permission");

my $exptidx;
if (!TBExptIDX($pid, $eid, \$exptidx)) {
    print "*** WARNING: No such experiment $pid/$eid!\n";
    exit -1;
}

#
# Before locking any tables, do a quick check to make sure the project
# is allowed to allocate the nodes, by type/class, plus other checks.
#
foreach my $n (@node_names) {
    # Make sure a valid node name first!
    if (! TBValidNodeName($n)) {
	warn("*** $0:\n".
	     "    No such node $n!\n");
        exit -1;
    }

    # Project allowed to allocated this node type/class?
    if (! TBNodeAllocCheck($pid, $n)) {
	warn("*** $0:\n".
	     "    You are not allowed to allocate $n to project $pid!\n");
        exit -1;
    }

    # XXX
    # If the node has a tipline, then indicate that we want to call
    # console_setup. We want to avoid calling console_setup if all we
    # got is a zillion virtual nodes on the command line; wasted work.
    #
    my $tiplines_result =
	DBQueryFatal("select tipname,server from tiplines ".
		     "where node_id='$n'");

    if ($tiplines_result->numrows) {
	$need_consetup++;
    }
}
TBDebugTimeStamp("nalloc checked node permission ");

# Must lock this table!
DBQueryFatal("lock tables reserved write");
TBDebugTimeStamp("nalloc locked tables");

# Make a list of nodes to reserve.
foreach my $n (@node_names) {
    my ($r_pid, $r_eid);
    
    if (NodeidToExp($n, \$r_pid, \$r_eid)) {
	# Someone has already reserved this node
	if (($r_pid eq $pid) && ($r_eid eq $eid)) {
	    print "Already reserved: '$n'\n";
	    # Do not increment error code since that throws off caller.
	    next;
	}
	elsif (NodeidToExpOldReserved($n, \$r_pid, \$r_eid) &&
	       (($r_pid eq $pid) && ($r_eid eq $eid))) {
	    print "Already reserved in holding reservation: '$n'\n";
	    push(@oldnodes, $n);
	    next;
	}
	else {
	    print "Someone else has already reserved node '$n'.\n";
	    $noalloc++;
	    next;
	}
    }
    else {
	# Freshly allocated nodes need a history entry.
	push(@need_history, $n);
        # ... and need to have their bootlogs purged.
        push(@need_clearbl, $n);
    }

    #
    # Add info the list of nodes to reserve; done in a single query below.
    # 
    push(@newvals,  "('$n',$exptidx,'$pid','$eid','$n','','')");
    push(@nodes, "$n");
}
TBDebugTimeStamp("nalloc checked all nodes");

if ($debug) {
    print "List Ready: @newvals\nError=$error\n";
}

# Now make the reservations in the DB.
if ((!$noalloc || $partial) && (@newvals || @oldnodes)) {
    print "Reserving nodes...\n"
	if ($debug);

    if (@newvals &&
	! DBQueryWarn("replace into reserved ".
		      "  (node_id,exptidx,pid,eid,vname,old_pid,old_eid) ".
		      "values ". join(",",@newvals))) {
	$error++;
    }
    # Do this instead of creating new entries so as not to lose any
    # other info in the reserved table entries. I think this might be;
    # wrong; might need to rethink this.
    foreach my $node (@oldnodes) {
	if (!DBQueryWarn("update reserved " .
			 "set exptidx=$exptidx,pid='$pid',eid='$eid', ".
			 "    old_exptidx=0, old_pid='', old_eid='' ".
			 "where node_id='$node'")) {
	    $error++;
	}
    }
}
TBDebugTimeStamp("nalloc allocated all nodes");

# Unlock tables.
DBQueryFatal("unlock tables");
TBDebugTimeStamp("nalloc unlocked tables");

# Okay, not safe to do this

# Update node_activity table; no need to do this with tables locked.
if (!$error && (!$noalloc || $partial) && @nodes) {
    print "Resetting node activity\n"
	if ($debug);

    # It isn't an error if this fails...
    DBQueryWarn("update node_activity set last_ext_act=now() ".
		"where " . join(" or ",map("node_id='$_'", @nodes)));

    TBDebugTimeStamp("nalloc updated node_activity table");

    foreach my $n (@need_history) {
	TBSetNodeHistory($n, TB_NODEHISTORY_OP_ALLOC, $UID, $pid, $eid);
    }

    # Clear boot logs - maybe this should be done before alloc?
    #  - only a small window of opportunity at any rate.
    # This is sort of wasteful as it should be the same set of nodes
    # as in the node history loop above, but that could change at some point.
    foreach my $n (@need_clearbl) {
        DBQueryWarn("delete from node_bootlogs where node_id='$n'");
    }
}

# Now setup consoles if needed.
if ($need_consetup && !$error && @nodes) {
    system("$consetup @nodes") == 0 or
	print STDERR "WARNING: $consetup @nodes failed!\n";
    TBDebugTimeStamp("nalloc finished console setup");
}

#
# Exit with -1 if an error, else the number of nodes that could not
# be allocated.
#
my $exitval = ($error ? -1 : $noalloc);
if ($debug) { print "Returning with value $exitval\n"; }
exit($exitval);
