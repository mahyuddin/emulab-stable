#!/usr/bin/perl

#
# nfree - Takes pysical node names, and frees them from the experiment they
# are allocated to. If nodes are ommited, frees up all nodes in the given
# experiment. Looks in the scheduled_reloads and next_reserve tables to see
# if this node should be re-reserved into another experiment and/or reloaded,
# rather than being put back into the pool of free nodes
#

#
# Configure variables
#
my $TB       = "@prefix@";
use lib '@prefix@/lib';
use libdb;

if (@ARGV < 2) {
    die("Usage: nfree <pid> <eid> [<node> <node> <...>]\n".
	"Releases all nodes in the specified experiment. If nodes are listed,\n".
	"nfree releases only the listed nodes.\n");
}

my $error = 0;
my $consetup="$TB/libexec/console_setup";
my $exportsetup="$TB/sbin/exports_setup";
my $os_load = "$TB/bin/os_load -r ";
my $reloadpid="emulab-ops";
my $reload_pendingeid="reloadpending";
my $reloadeid="reloading";

my @node_names=();
my @freed_nodes=();

my $pid = shift;
my $eid = shift;

use strict;
use English;

#
# Turn off line buffering on output
#
$| = 1;

# Make sure that the experiment actually exists
# NOTE: project permissions checking is done later, on an individual
# node basis.
if (!ExpState($pid,$eid)) {
    die("There is no experiment '$eid' in project '$pid'.\n");
}

#
# Make sure the user has the ability to modify this experiment
#
if (!TBExptAccessCheck($UID, $pid, $eid, TB_EXPT_MODIFY)) {
    die("You don't have sufficient access to modify '$eid' in project '$pid'.\n");
}

######################################################################
# Step 1 - Free nodes
#
# Find nodes that can be freed at this time, and do so. Nodes which
# are awaiting reloads and which have been scheduled to be reserved
# to another experiment, are put into lists so that they can be
# handled later
######################################################################

# Make a list of nodes given on the command line
foreach my $n (@ARGV) {
    # Shark hack
    if ($n =~ /(sh\d+)/ ) {
	#
	# It's a shark - do the whole shelf if its not done already.
	#
	my $shelf = $1;
	if ( ! (join(",",@node_names) =~ /,$shelf-\d,/)) {
	    # Shelf hasn't been done yet...
	    foreach my $n ( 1 .. 8 ) {
		push(@node_names,"$shelf-$n");
	    }
	}
	# End shark hack

    } else {
	# its not a shark - just add it in...
	push(@node_names,"$n");
    }
}
 
#
# Lock all of the tables we'll be reading, so that we get a consistent
# view of the current state
#
DBQueryFatal("lock tables nodes write, node_types read, " .
	     "scheduled_reloads read, interfaces write, delays write, " .
	     "reserved write, last_reservation write, current_reloads write, " .
	     "next_reserve read");

#
# If no nodes were given on the command line, fill the list with all nodes
# in the experiment.
#
if (@node_names == 0) {
    print "Releasing all nodes from experiment '$eid' in project '$pid'...\n";
    push @node_names,ExpNodes($pid,$eid);
}

my @reloads = ();
my %reserves= ();
foreach my $n (@node_names) { 
    #
    # Check to make sure they have acutally reserved the nodes.
    #
    my $result = DBQueryFatal("select * from reserved where node_id='$n' ".
	"and eid='$eid' and pid='$pid'");
    if ($result->numrows == 0) {
	print "Node '$n' is not reserved by your experiment.\n";
	$error++;
	next;
    } else {
	push(@freed_nodes,$n);
    }

    #
    # This little sillyness is for disk reloading. Kill the last reservation.
    #
    DBQueryWarn("delete from last_reservation where node_id='$n'") || $error++;

    #
    # If the node has a reloads entry, change the reservation so that the
    # reload_daemon will pick it up.
    #
    $result = DBQueryFatal("select node_id,image_id from scheduled_reloads " .
			  "where node_id='$n'");
    if ( $result->numrows() > 0 ) {

	my @row = $result->fetchrow();
	my $image_id = $row[1];
	my $reload_type = $row[2];

	print "Adding scheduled reload for $n to the list.\n";
	push(@reloads,$n);

    } else {
	#
	# If the node has a next_reserve entry, change the reservation
	#
	my $result = DBQueryFatal("select node_id,pid,eid from next_reserve ".
				  "where node_id='$n'");

	if ( $result->num_rows() > 0 ) {
	    # 
	    # Add the reservation to a list to be taken care of later
	    #
	    my ($node, $next_pid, $next_eid) = $result->fetchrow_array();
	    $reserves{$node} = "$next_pid:$next_eid";
	} else {
	    #
	    # No reloads or reservation changes, so really free the node
	    #
	    # This little sillyness is for disk reloading. Remember the last
	    # project a node was reserved into.
	    #
	    DBQuery("insert into last_reservation values ('$n', '$pid')");

	    print "Releasing node '$n'...";
	    if (DBQueryWarn("delete from reserved " .
			    "where node_id='$n' and eid='$eid'")) {
		"Succeeded.\n";
	    } else {
		$error++;
	    }
	}
    }

    #
    # Find the control net interface for this node type, as well as some
    # of the default values for its node type
    #
    $result = DBQueryFatal("select control_net,osid,node_types.pxe_boot_path " .
	"from node_types " .
	"left join nodes on nodes.type=node_types.type " .
	"where node_id='$n'");
    my ($control, $osid, $pxe_boot_path) = $result->fetchrow_array();
    if (! ($n =~ /sh\d+/)) { # If its not a shark
	# Clean out all IPs except the control net
	DBQueryWarn("update interfaces set IP='' " .
	    "where node_id='$n' and card!='$control'") || $error++;
    } else {
	# Shark hack
	# it is a shark, so clear out the alias(es)
	DBQueryWarn("update interfaces set IPalias='' ".
		    "where node_id='$n'") || $error++;
	# End shark hack
    }

    #
    # Clean out all delays
    #
    DBQueryWarn("delete from delays where node_id='$n'") || $error++;

    #
    # And clean out various tidbits from the nodes table.
    #
    DBQueryWarn("update nodes set def_boot_osid='$osid', def_boot_cmd_line='',".
	"def_boot_path='',startupcmd='',rpms='',deltas='',tarballs='',".
	"pxe_boot_path='$pxe_boot_path', next_pxe_boot_path='' ".
	"where node_id='$n'") || $error++;

    #
    # Clean out the current_reloads table
    #
    DBQueryWarn("delete from current_reloads where node_id='$n'") || $error++;
}

DBQueryFatal("unlock tables");

######################################################################
# Step 2 - Set up reserves and reloads
#
# If any nodes were awaiting reloads, put them in the proper
# experiment, and issue an os_load, if appropriate. If any nodes were
# set up for simple reservations, we take care of that in this stage
# too.
######################################################################
 
if ((@reloads > 0) || (keys %reserves > 0)) {
    #
    # Lock tables to maintain consistency
    #
    print "Locking tables.\n";
    DBQueryFatal("lock tables nodes read, node_types read, scheduled_reloads read, ".
		 "interfaces write, reserved write, next_reserve write");
  
    #
    # Take care of reloads by putting them into a special experiment,
    # which is processed by the reload_daemon
    #
    foreach my $n ( @reloads ) {
	#
	# Change reservation (don't delete or we'll get races)
	#
	print "Changing reservation for $n to $reloadpid/$reload_pendingeid...\n";
	DBQueryWarn("update reserved set ".
	    "pid='$reloadpid',eid='$reload_pendingeid',vname=NULL ".
	    "where node_id='$n'") || $error++;
    }
  
    #
    # Handle scheduled reservations
    #
    foreach my $n ( keys %reserves ) {
	my ($next_pid,$next_eid) = split (":",$reserves{$n});
	#
	# Change reservation (don't delete or we'll get races)
	#
	print "Changing reservation for $n to $next_pid/$next_eid...\n";
	DBQueryWarn("update reserved set pid='$next_pid',eid='$next_eid'," .
		    "vname=NULL where node_id='$n'") || $error++;
	DBQueryWarn("delete from next_reserve where node_id='$n'") || $error++;
    }

    #
    # Done, so we can now unlock tables
    #
    print "Unlocking tables.\n";
    DBQueryFatal("unlock tables");

}

######################################################################
# Step 3 - Set up console for freed nodes.
#
# Using a list of freed nodes build eariler, run consetup to reset
# their serial consoles.
######################################################################

if (@freed_nodes) {
    my @conlist=();
    my @sharks=();

    foreach my $n ( @freed_nodes ) {
	# Shark hack
	if ($n =~ /(sh\d+)/) {
	    # Its a shark - do the shelf if it hasn't been done yet
	    my $shelf = $1;
	    if (!(join(",",@sharks) =~ /\b$shelf\b/)) {
		push(@sharks,$shelf);
		push(@conlist,$shelf);
	    }
	}
	# End shark hack
	else {
	    push(@conlist,$n);
	}
    }

    #
    # Finally, run the actual command
    #
    system("$consetup @conlist") == 0 or
    print STDERR "WARNING: $consetup @conlist failed!\n";
}

exit($error);

