#!/usr/bin/perl -wT

#
# EMULAB-COPYRIGHT
# Copyright (c) 2000-2006 University of Utah and the Flux Group.
# All rights reserved.
#
use English;
use Getopt::Std;

#
# nfree - Takes pysical node names, and frees them from the experiment they
# are allocated to. If nodes are omitted, frees up all nodes in the given
# experiment. Looks in the scheduled_reloads and next_reserve tables to see
# if this node should be re-reserved into another experiment and/or reloaded,
# rather than being put back into the pool of free nodes
#
sub usage ()
{
    die("Usage: nfree [-x] [-o] <pid> <eid> [<node> <node> <...>]\n".
	"Releases all nodes in the specified experiment.\n".
	"If nodes are listed, nfree releases only those nodes.\n".
	" '-x' frees all virtual nodes on any physical node that gets freed.\n".
	" '-o' Moves nodes into a oldreserved holding experiment.\n"
	);
}

# Configure variables
my $TB       = "@prefix@";
my $TESTMODE = @TESTMODE@;

# Testbed Support libraries
use lib "@prefix@/lib";
use libdb;
use libtestbed;
use Node;

my $consetup	= "$TB/libexec/console_setup";
my $osselect    = "$TB/bin/os_select";
my $nodereboot  = "$TB/bin/node_reboot";
my $makeconf    = "$TB/sbin/dhcpd_makeconf";
my $reloadpid	= "emulab-ops";
my $pendingeid  = "reloadpending";
my $reloadeid   = "reloading";
my $rppendingeid= "repositionpending";
my $oldreserved_pid = OLDRESERVED_PID;
my $oldreserved_eid = OLDRESERVED_EID;
my $lockedpid   = NFREELOCKED_PID();
my $lockedeid   = NFREELOCKED_EID();

my @nodes;
my @freed_nodes=();
my @dynanodes=();
my $error = 0;
my %mustzero=();

$| = 1;  # Turn off line buffering on output

# Untaint the path
$ENV{'PATH'} = "/bin:/usr/bin:/sbin:/usr/sbin";
delete @ENV{'IFS', 'CDPATH', 'ENV', 'BASH_ENV'};

#
# Parse command arguments. Once we return from getopts, all that should
# left are the required arguments.
#
my  $optlist = "xo";

%options = ();

if (! getopts($optlist, \%options)) {
    usage();
}

my $freeDependantVirtuals = 0;
my $moveToOldReserved = 0;

if (defined($options{"x"})) {
    $freeDependantVirtuals = 1;
}
if (defined($options{"o"})) {
    $moveToOldReserved = 1;
}

if (@ARGV < 2) {
    usage();
}

my $pid = shift;
my $eid = shift;

# Untaint args.
if ($pid =~ /^([-\@\w]+)$/) { $pid = $1; }
else { die("Bad data in pid: $pid."); }
if ($eid =~ /^([-\@\w]+)$/) { $eid = $1; }
else { die("Bad data in eid: $eid."); }

# Make sure that the experiment actually exists
if (!ExpState($pid,$eid)) {
    die("There is no experiment '$eid' in project '$pid'.\n");
}

# Make sure the user has the ability to modify this experiment
if (!TBExptAccessCheck($UID, $pid, $eid, TB_EXPT_MODIFY)) {
    die("You do not have permission to modify '$eid' in project '$pid'.\n");
}

# Make a list of nodes given on the command line, or get the whole list from
# the DB if none provided.
if (@ARGV) {
    foreach my $n (@ARGV) {
	# Taint check first! Solves silly perl problems.
	if ($n =~ /^([-\w]+)$/) { $n = $1; }
	else { die("*** $0:\n    Bad node name: $n.\n"); }

	push(@nodes, $n);

	# if -x was specified, remove any 
	# mapping to a node which has a phys_nodeid of $n.
	if ($freeDependantVirtuals) {
	    my $result = 
		DBQueryFatal("SELECT r.node_id FROM reserved AS r ".
			     "LEFT JOIN nodes AS n ".
			     "ON r.node_id=n.node_id ".
			     "WHERE n.phys_nodeid='$n' AND ".
			     "r.eid='$eid' AND r.pid='$pid'");
	    while (my ($dependantVirtual) = $result->fetchrow_array()) {
		if (defined $dependantVirtual && $dependantVirtual ne $n) {
		    push(@nodes, $dependantVirtual);
		}
	    }
	}
    }
} else {
    print "Releasing all nodes from experiment '$eid' in project '$pid'.\n";
    @nodes = ExpNodes($pid, $eid);
    if (! $moveToOldReserved ) {
	push( @nodes, ExpNodesOldReserved($pid, $eid) );
    }
}

my $mustmakeconf = 0;

######################################################################
# Step 1
#
# See what nodes need to be freed, and then lock them down my moving
# them to a holding reservation.
#
# We lock just the reserved table. The prevents races between multiple
# invocations of nfree trying to free the same node. Rather than lock
# a zillion tables, move the reservation into a holding pattern. This
# effectively prevents someone else from freeing the same nodes, and from
# someone else allocating the nodes until we are done cleaning things up.
#
# NOTE: My reason for not wanting to lock all those tables (9 in the
# original version) is that library calls will fail since mysql locking
# requires that every table used within the locked area, be locked.
# Of course, who knows what tables the library uses, so thats a silly
# way to go.
#
######################################################################

DBQueryFatal("lock tables reserved write");

foreach my $n (@nodes) {
    # Check to make sure they have actually reserved the nodes.
    my $result =
	DBQueryFatal("select * from reserved where node_id='$n' ".
		     "and eid='$eid' and pid='$pid'");
    if ($result->numrows == 0) {
	print "Node '$n' is not reserved by your experiment.\n";
	$error++;
	next;
    }

    #
    # Remember if the node's disk must be zeroed
    #
    my $rowref = $result->fetchrow_hashref();
    if ($rowref->{'mustwipe'}) {
	$mustzero{$n} = $rowref->{'mustwipe'};
    } else {
	$mustzero{$n} = 0;
    }

    if ( $moveToOldReserved ) {
	# Move to holding reservation. Node is not free, but is no longer
	# owned by the pid/eid, so cannot be mucked with.
	if (! DBQueryWarn("update reserved " .
			  "set vname='$n', pid='$oldreserved_pid', ".
			  "eid='$oldreserved_eid', old_pid='$pid', ".
			  "old_eid='$eid' where node_id='$n'")) {
	    print "*** WARNING: Error moving node $n to holding pid/eid: ".
	          "$oldreserved_pid/$oldreserved_eid\n";
	    next;
	}
    } else {
	# Move to locked reservation. Node is not free, but is no longer
	# owned by the pid/eid, so cannot be mucked with.
	if (! DBQueryWarn("update reserved " .
			  "set vname='$n', pid='$lockedpid', eid='$lockedeid', ".
			  "old_pid='', old_eid='' ".
			  "where node_id='$n'")) {
	    print "*** WARNING: Error locking down node $n!\n";
	    next;
	}

	# Any node that was part of an elabinelab or plabinelab experiment
	# that is freed requires that we remake the dhcpd.conf file.
	if ($rowref->{'inner_elab_boot'} || $rowref->{'plab_boot'}) {
	    if (!DBQueryWarn("update reserved " .
			     "set inner_elab_boot=0, plab_boot=0 " .
			     "where node_id='$n'")) {
		print "*** WARNING: Error clearing elab/plab boot on $n!\n";
	    }
	    $mustmakeconf = 1;
	}

	push(@freed_nodes, $n);
    }

}

DBQueryFatal("unlock tables");

# We are done if called with a -o
if( $moveToOldReserved ) {
    exit($error);
}

######################################################################
# Step 1b
#
# Ugh.  If we are resetting the PXE boot program for any of the nodes
# we need to clear them and regenerate the dhcpd.conf file now, before
# we start freeing up nodes in Step 2.  If we delayed HUP'ing til after
# Step 2, then nodes might have already been rebooted by the reload
# daemon.
#
######################################################################
if (@freed_nodes > 0) {
    my $nodelist = "(" . join(",", map("'$_'", @freed_nodes)) . ")";

    my $result = 
	DBQueryFatal("select node_id from nodes where ".
		     "pxe_boot_path is not NULL and node_id in $nodelist");
    if ($result->num_rows()) {
	DBQueryFatal("update nodes set pxe_boot_path=NULL where ".
		     "node_id in $nodelist");
	$mustmakeconf = 1;
    }
}
if ($mustmakeconf) {
    system("$makeconf -i -r") == 0 ||
	print STDERR "WARNING: $makeconf failed!\n";
}

######################################################################
# Step 2
#
# Go through the list of nodes we successfully locked down, and clean
# up the node state (nodes, delays, interfaces, etc). Once that is done,
# move them to whatever new reservations are pending, or free the node.
#
######################################################################

foreach my $n (@freed_nodes) {
    my $mustclean = 1;

    # Clean out all delays
    DBQueryWarn("delete from delays where node_id='$n'") || $error++;

    # Find the default values for its node type.
    my $result =
	DBQueryFatal("select nt.osid,n.eventstate, " .
		     "       nt.isvirtnode, nt.imageable, o.mustclean, ".
		     "       nt.isdynamic ".
		     " from nodes as n " .
		     "left join node_types as nt on n.type=nt.type " .
		     "left join os_info as o on o.osid=n.def_boot_osid ".
		     "where node_id='$n'");
    my ($osid, $estate, $isvirt, $imageable, $clean, $isdynamic) =
	$result->fetchrow_array();

    # See if the OS it was running was marked as mustclean or not. Basically,
    # this is an OSKit hack to avoid reloading disks that have not been
    # touched by the kernel. If a def_boot_path was set, there is nothing
    # we can figure out, so just reload it. This needs to be more general
    # purpose.
    if ($isvirt || !$imageable) {
	# VIRTNODE HACK: Virtual nodes are special. Do not clean or reload.
	$mustclean = 0;
	$mustzero{$n} = 0;
    }
    elsif (defined($clean)) {
	# If def_boot_osid set, then $clean is defined. Otherwise not set
	# so default to cleaning node. 
	$mustclean = $clean;
    }

    #
    # If the node is a dynamic virtual node, just save it for later.
    # We will call into the Node library to delete it. 
    #
    if ($isdynamic) {
	push(@dynanodes, $n);
	next;
    }

    if (! $isvirt) {
        # On real nodes, clean out all interfaces except the control net.
	DBQueryWarn("update interfaces set IP='',IPaliases=NULL,mask=NULL,".
		    "       rtabid='0',vnode_id=NULL,current_speed='0' ".
		    "where node_id='$n' and ".
		    "  role='" . TBDB_IFACEROLE_EXPERIMENT() . "'")
	    || $error++;
	# And log phys nodes freed from hwdown
	my $dbuid;
	if ($pid eq NODEDEAD_PID() && $eid eq NODEDEAD_EID()
	    && UNIX2DBUID($UID, \$dbuid)) {
	    TBSetNodeLogEntry($n, $dbuid, "misc",
			      "'Moved from hwdown; nfree'");
	}
    }

    my $allocFreeState = TBDB_ALLOCSTATE_FREE_DIRTY();

    DBQueryWarn("update nodes set startupcmd='',rpms='',deltas='', ".
		"tarballs='',failureaction='fatal', routertype='none', ".
		"def_boot_cmd_line='',next_boot_cmd_line='', ".
		"temp_boot_osid='',next_boot_osid='', ".
		"update_accounts=0,ipport_next=ipport_low, ".
		"sfshostid=NULL,allocstate='$allocFreeState',boot_errno=0 ".
		"where node_id='$n'") || $error++;

    #
    # If the node is a virtnode, force its state to SHUTDOWN. This is mostly
    # to avoid silly stated warnings for nodes that do not have a physical
    # representation most of the time!
    #
    TBSetNodeEventState($n, TBDB_NODESTATE_SHUTDOWN)
	if ($isvirt && $estate ne TBDB_NODESTATE_SHUTDOWN());

    # Clean out the SFS hostid. What about the other keys?
    DBQueryWarn("update node_hostkeys set ".
		"  sfshostid=NULL ".
		"where node_id='$n'") || $error++;

    # Clean out the current_reloads table (a just in case measure).
    DBQueryWarn("delete from current_reloads where node_id='$n'") || $error++;

    # Reset its port allocation stuff.
    DBQueryWarn("delete from nodeipportnum where node_id='$n'") || $error++;

    # Clean the vinterfaces table for this node.
    DBQueryWarn("delete from vinterfaces where node_id='$n'") || $error++;

    # Clean the interface_settings table for this node.
    DBQueryWarn("delete from interface_settings where node_id='$n'") || $error++;

    # If it's a robot, we need to reset its physical location.
    $result =
	DBQueryFatal("select building,floor,loc_x,loc_y,orientation ".
		     "from node_startloc where node_id='$n'");
    if ($result->num_rows()) {
	while (my ($bldg,$floor,$x,$y,$o) = $result->fetchrow_array()) {
	    my $subresult = 
		DBQueryFatal("select pixels_per_meter from floorimages ".
			     "where building='$bldg'");
	    if ($subresult->num_rows()) {
		my ($pixels_per_meter) = $subresult->fetchrow_array();

		$x = int($x * $pixels_per_meter);
		$y = int($y * $pixels_per_meter);
		DBQueryWarn("update location_info set ".
			    "loc_x=$x,loc_y=$y,orientation=$o ".
			    "where node_id='$n' and building='$bldg' ".
			    "and floor=$floor") || $error++;
	    }
	    else {
		warn "No building named $bldg in floorimages";
	    }
	}
    }
    DBQueryWarn("update nodes set destination_x=NULL,destination_y=NULL,".
		"destination_orientation=NULL where node_id='$n'") || $error++;

    # Now its safe to change the reservation.

    # If the node has a next_reserve entry, change the reservation.
    $result =
	DBQueryFatal("select node_id,pid,eid from next_reserve ".
		     "where node_id='$n'");

    if ($result->num_rows()) {
	my ($node, $next_pid, $next_eid) = $result->fetchrow_array();
	
	print "Moving $n to $next_pid/$next_eid.\n";

	DBQueryWarn("update reserved set pid='$next_pid',eid='$next_eid'," .
		    "vname='$n' where node_id='$n'")
	    || $error++;
	
	TBSetNodeHistory($n, TB_NODEHISTORY_OP_MOVE, $UID,
			 $next_pid, $next_eid);
	
	DBQueryWarn("delete from next_reserve where node_id='$n'")
	    || $error++;

	# This little sillyness is for disk reloading.
	# Kill the last reservation since this path is special.
	DBQueryWarn("delete from last_reservation where node_id='$n'") ||
	    $error++;

	next;
    }

    # If the node has a reloads entry, change the reservation so that the
    # reload_daemon will pick it up.
    $result =
	DBQueryFatal("select node_id,image_id from scheduled_reloads " .
		     "where node_id='$n'");
    my $inreloads = $result->numrows();

    # XXX
    if ($inreloads && !$imageable) {
	print "WARNING: non-imageable node $n in scheduled_reloads\n";
	$inreloads = 0;
    }

    if (TBNodeType($n) eq "garcia") {
	print "Moving $n to $reloadpid/$rppendingeid.\n";
	
	DBQueryWarn("update reserved set pid='$reloadpid',".
		    "eid='$rppendingeid',vname='$n' where node_id='$n'") ||
	    $error++;

	DBQueryWarn("REPLACE INTO scheduled_reloads set node_id='$n'") || 
	    $error++;

	TBSetNodeHistory($n, TB_NODEHISTORY_OP_MOVE, $UID,
			 $reloadpid, $rppendingeid);

	# This little sillyness is for disk reloading.
	# Kill the last reservation since this path is special.
	DBQueryWarn("delete from last_reservation where node_id='$n'") ||
	    $error++;

	next;
    }
    elsif (!$TESTMODE &&
	   ((!$isvirt && $imageable) || # XXX force reload hack!
	    $inreloads || $mustzero{$n})) { # XXX Garcia hack
	print "Moving $n to $reloadpid/$pendingeid.\n";
	
	DBQueryWarn("update reserved set pid='$reloadpid',eid='$pendingeid',".
		    "vname='$n' where node_id='$n'") || $error++;

	TBSetNodeHistory($n, TB_NODEHISTORY_OP_MOVE, $UID,
			 $reloadpid, $pendingeid);

	# This little sillyness is for disk reloading.
	# Kill the last reservation since this path is special.
	DBQueryWarn("delete from last_reservation where node_id='$n'") ||
	    $error++;

	next;
    }

    # No reloads or reservation changes, so really free the node
    #
    # This little sillyness is for disk reloading. Remember the last
    # project a node was reserved into. At present, there might already
    # be an entry. Eventually, os_setup will look for this and force
    # a reload.
    if ($mustclean) {
	DBQueryWarn("replace into last_reservation values ('$n', '$pid')");
    }

    print "Releasing node '$n' ... ";
    if (DBQueryWarn("delete from reserved where node_id='$n'")) {
	print "Succeeded.\n";
	
	TBSetNodeHistory($n, TB_NODEHISTORY_OP_FREE, $UID, $pid, $eid);
    }
    else {
	print "Failed!\n";
	$error++;
    }
}

# Release dynamic nodes.
if (@dynanodes) {
    Node::DeleteVnodes(@dynanodes);
}

######################################################################
# Step 3 - Set up console for freed nodes.
#
# Using a list of freed nodes build eariler, run consetup to reset
# their serial consoles.
#
# NOTE: While it may seem like a race to do this after releasing the
# reservation, it really is not. Even if the node is allocated again
# console_setup looks at the current reservation and does the right
# thing, and since nalloc locks the reserved table, ordering will be
# preserved.
#
######################################################################

if (@freed_nodes) {
    system("$consetup @freed_nodes") == 0 ||
	print STDERR "WARNING: $consetup @freed_nodes failed!\n";
}

exit($error);

