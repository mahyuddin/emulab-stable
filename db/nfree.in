#!/usr/bin/perl -w
#
# EMULAB-COPYRIGHT
# Copyright (c) 2000-2008 University of Utah and the Flux Group.
# All rights reserved.
#
use strict;
use English;
use Getopt::Std;

#
# nfree - Takes pysical node names, and frees them from the experiment they
# are allocated to. If nodes are omitted, frees up all nodes in the given
# experiment. Looks in the scheduled_reloads and next_reserve tables to see
# if this node should be re-reserved into another experiment and/or reloaded,
# rather than being put back into the pool of free nodes
#
sub usage ()
{
    die("Usage: nfree [-x] [-o] <pid> <eid> (-a | <node> <node> <...>)\n".
	"Releases all nodes in the specified experiment if -a is given.\n".
	"If nodes are listed, nfree releases only those nodes.\n".
	" '-x' frees all virtual nodes on any physical node that is freed.\n".
	" '-o' Moves nodes into a oldreserved holding experiment.\n"
	);
}
my $optlist = "xoaq";
my $freeDependantVirtuals = 0;
my $moveToOldReserved     = 0;
my $freeAllNodes          = 0;
my $quiet                 = 0;

# Configure variables
my $TB       = "@prefix@";
my $TESTMODE = @TESTMODE@;

# Turn off line buffering on output
$| = 1;

# Untaint the path
$ENV{'PATH'} = "/bin:/usr/bin:/sbin:/usr/sbin";
delete @ENV{'IFS', 'CDPATH', 'ENV', 'BASH_ENV'};

# Testbed Support libraries
use lib "@prefix@/lib";
use libdb;
use libtestbed;
use User;
use Experiment;
use Node;
use OSinfo;

# Local stuff
my $consetup	    = "$TB/libexec/console_setup";
my $osselect        = "$TB/bin/os_select";
my $nodereboot      = "$TB/bin/node_reboot";
my $makeconf        = "$TB/sbin/dhcpd_makeconf";
my $reloadpid	    = "emulab-ops";
my $pendingeid      = "reloadpending";
my $rppendingeid    = "repositionpending";
my $oldreserved_pid = OLDRESERVED_PID;
my $oldreserved_eid = OLDRESERVED_EID;
my $lockedpid       = NFREELOCKED_PID();
my $lockedeid       = NFREELOCKED_EID();
my @nodes;
my @freed_nodes     = ();
my @dynanodes       = ();
my $error           = 0;
my %mustzero        = ();
my $mustmakeconf    = 0;

#
# Parse command arguments. Once we return from getopts, all that should
# left are the required arguments.
#
my %options = ();
if (! getopts($optlist, \%options)) {
    usage();
}
if (defined($options{"x"})) {
    $freeDependantVirtuals = 1;
}
if (defined($options{"q"})) {
    $quiet = 1;
}
if (defined($options{"o"})) {
    $moveToOldReserved = 1;
}
if (defined($options{"a"})) {
    $freeAllNodes = 1;
}
if (@ARGV < 2 || @ARGV == 2 && !$freeAllNodes) {
    usage();
}
my $pid = shift;
my $eid = shift;

if (@ARGV > 0 && $ARGV[0] eq '-a') {
    $freeAllNodes = 1;
    shift;
}
if ($freeAllNodes && @ARGV > 0) {
    usage();
}

# Make sure that the experiment actually exists
my $experiment = Experiment->Lookup($pid, $eid);
if (!defined($experiment)) {
    die("*** $0:\n".
        "    There is no experiment '$eid' in project '$pid'.\n");
}
# Need these below.
my $pid_idx = $experiment->pid_idx();
my $exptidx = $experiment->idx();

# Map a bunch of experiments we might need to reserve nodes to.
my $oldreserved_experiment = Experiment->Lookup($oldreserved_pid,
						$oldreserved_eid);
if (!defined($oldreserved_experiment)) {
    die("*** $0:\n".
        "    There is no experiment $oldreserved_pid/$oldreserved_eid!\n");
}
my $locker_experiment = Experiment->Lookup($lockedpid, $lockedeid);
if (!defined($locker_experiment)) {
    die("*** $0:\n".
        "    There is no experiment $lockedpid/$lockedeid!\n");
}
my $reloading_experiment = Experiment->Lookup($reloadpid, $pendingeid);
if (!defined($reloading_experiment)) {
    die("*** $0:\n".
        "    There is no experiment $reloadpid/$pendingeid!\n");
}
# Only in Utah, see below
my $repositioning_experiment;

#
# Verify user and get his DB uid for later. 
#
my $this_user = User->ThisUser();
if (! defined($this_user)) {
    die("*** $0:\n".
	"    You ($UID) do not exist!\n");
}
my $user_uid = $this_user->uid();

# Make sure the user has the ability to modify this experiment
if (!$experiment->AccessCheck($this_user, TB_EXPT_MODIFY)) {
    die("*** $0:\n".
	"    You do not have permission to modify $experiment.\n");
}

# Make a list of nodes given on the command line, or get the whole list from
# the DB if none provided.
if (@ARGV) {
    foreach my $n (@ARGV) {
	my $node = Node->Lookup($n);
	if (!defined($node)) {
	    die("*** $0:\n".
		"    No such node $n!\n");
	}
	push(@nodes, $node);

	# if -x was specified, remove any 
	# mapping to a node which has a phys_nodeid of $n.
	if ($freeDependantVirtuals) {
	    my @virtuals = ();
	    if ($node->VirtualNodes(\@virtuals) != 0) {
		die("*** $0:\n".
		    "    Could not get virtual node list for $node\n");
	    }
	    push(@nodes, @virtuals)
		if (@virtuals);
	}
    }
}
else {
    print "Releasing all nodes from experiment $experiment.\n"
	if (!$quiet);
    @nodes = $experiment->NodeList(0, 1);
    if (! $moveToOldReserved) {
	my @oldnodes = ();
	if ($experiment->OldReservedNodeList(\@oldnodes) != 0) {
	    die("*** $0:\n".
		"    Could not get oldreserved node list for $experiment\n");

	}
	push(@nodes, @oldnodes);
    }
}

######################################################################
# Step 1
#
# See what nodes need to be freed, and then lock them down my moving
# them to a holding reservation.
#
# We lock just the reserved table. The prevents races between multiple
# invocations of nfree trying to free the same node. Rather than lock
# a zillion tables, move the reservation into a holding pattern. This
# effectively prevents someone else from freeing the same nodes, and from
# someone else allocating the nodes until we are done cleaning things up.
#
# NOTE: My reason for not wanting to lock all those tables (9 in the
# original version) is that library calls will fail since mysql locking
# requires that every table used within the locked area, be locked.
# Of course, who knows what tables the library uses, so thats a silly
# way to go.
#
######################################################################

DBQueryFatal("lock tables reserved write");

foreach my $node (@nodes) {
    my $node_id = $node->node_id();
    
    # Check to make sure they have actually reserved the nodes, now that
    # the reserved table is locked.
    my $rowref = $node->ReservedTableEntry();
    if (!defined($rowref)) {
	print STDERR "$node is not reserved by your experiment.\n";
	$error++;
	next;
    }

    #
    # Remember if the node's disk must be zeroed
    #
    if ($rowref->{'mustwipe'}) {
	$mustzero{$node_id} = $rowref->{'mustwipe'};
    }
    else {
	$mustzero{$node_id} = 0;
    }

    if ($moveToOldReserved) {
	# Move to holding reservation. Node is not free, but is no longer
	# owned by the pid/eid, so cannot be mucked with.
	if ($node->MoveReservation($oldreserved_experiment) != 0) {
	    print "*** WARNING: Error moving $node to holding experiment!\n";
	    next;
	}
    }
    else {
	# Move to locked reservation. Node is not free, but is no longer
	# owned by the pid/eid, so cannot be mucked with.
	if ($node->MoveReservation($locker_experiment) != 0) {
	    print "*** WARNING: Error locking down $node!\n";
	    next;
	}

	# Any node that was part of an elabinelab or plabinelab experiment
	# that is freed requires that we remake the dhcpd.conf file.
	if ($rowref->{'inner_elab_boot'} || $rowref->{'plab_boot'}) {
	    if ($node->ModifyReservation({"inner_elab_boot" => 0,
					  "plab_boot"       => 0}) != 0) {
		print "*** WARNING: Error clearing elab/plab boot for $node\n";
	    }
	    $mustmakeconf = 1;
	}
	push(@freed_nodes, $node);
    }

}
DBQueryFatal("unlock tables");

# We are done if called with a -o
if ($moveToOldReserved) {
    exit($error);
}

######################################################################
# Step 1b
#
# Ugh.  If we are resetting the PXE boot program for any of the nodes
# we need to clear them and regenerate the dhcpd.conf file now, before
# we start freeing up nodes in Step 2.  If we delayed HUP'ing til after
# Step 2, then nodes might have already been rebooted by the reload
# daemon.
#
# NOTE: this does not happen very often. elabinelab, plabinelab?
#
foreach my $node (@freed_nodes) {
    if ($node->pxe_boot_path() && $node->pxe_boot_path() ne "") {
	$node->Update({"pxe_boot_path" => "NULL"}) == 0 or
	    die("*** $0:\n".
		"    Could not update pxe_boot_path for $node\n");
	$mustmakeconf = 1;
    }
}
if ($mustmakeconf) {
    system("$makeconf -i -r") == 0 ||
	print STDERR "*** WARNING: $makeconf failed!\n";
}

######################################################################
# Step 2
#
# Go through the list of nodes we successfully locked down, and clean
# up the node state (nodes, delays, interfaces, etc). Once that is done,
# move them to whatever new reservations are pending, or free the node.
#
######################################################################

foreach my $node (@freed_nodes) {
    my $node_id       = $node->node_id();
    my $mustclean     = 1;
    my $estate        = $node->eventstate();
    my $isvirt        = $node->isvirtnode();
    my $isdynamic     = $node->isdynamic();
    my $def_boot_osid = $node->def_boot_osid();
    my $imageable     = $node->imageable();

    # Clean out all delays
    DBQueryWarn("delete from delays where node_id='$node_id'") || $error++;

    #
    # See if the OS it was running was marked as mustclean or not. Basically,
    # this is an OSKit hack to avoid reloading disks that have not been
    # touched by the kernel. If a def_boot_path was set, there is nothing
    # we can figure out, so just reload it. This needs to be more general
    # purpose.
    #
    my $clean;
    if (defined($def_boot_osid)) {
	my $osinfo = OSinfo->Lookup($def_boot_osid);
	if (!defined($osinfo)) {
	    print "*** Unable to lookup OSinfo object for $def_boot_osid\n";
	    $error++;
	    next;
	}
	$clean = $osinfo->mustclean();
    }
    if ($isvirt || !$imageable) {
	# VIRTNODE HACK: Virtual nodes are special. Do not clean or reload.
	$mustclean = 0;
	$mustzero{$node_id} = 0;
    }
    elsif (defined($clean)) {
	# If def_boot_osid set, then $clean is defined. Otherwise not set
	# so default to cleaning node. 
	$mustclean = $clean;
    }

    #
    # If the node is a dynamic virtual node, just save it for later.
    # We will call into the Node library to delete it. 
    #
    if ($isdynamic) {
	push(@dynanodes, $node);
	next;
    }

    if (! $isvirt) {
        # On real nodes, clean out all interfaces except the control net.
	$node->ClearInterfaces() == 0
	    or $error++;
	
	# And log phys nodes freed from hwdown
	if ($pid eq NODEDEAD_PID() && $eid eq NODEDEAD_EID() && $user_uid) {
	    $node->InsertNodeLogEntry($this_user, "misc",
				      "Moved from hwdown; nfree");
	}
    }

    my $allocFreeState = TBDB_ALLOCSTATE_FREE_DIRTY();

    DBQueryWarn("update nodes set startupcmd='',rpms='',deltas='', ".
		"tarballs='',failureaction='fatal', routertype='none', ".
		"def_boot_cmd_line='',next_boot_cmd_line='', ".
		"temp_boot_osid=NULL,next_boot_osid=NULL, ".
		"update_accounts=0,ipport_next=ipport_low, ".
		"sfshostid=NULL,allocstate='$allocFreeState',boot_errno=0, ".
		"destination_x=NULL,destination_y=NULL, ".
		"destination_orientation=NULL ".
		"where node_id='$node_id'") || $error++;

    #
    # If the node is a virtnode, force its state to SHUTDOWN. This is mostly
    # to avoid silly stated warnings for nodes that do not have a physical
    # representation most of the time!
    #
    $node->SetEventState(TBDB_NODESTATE_SHUTDOWN)
	if ($isvirt && $estate ne TBDB_NODESTATE_SHUTDOWN());

    # Clean out the SFS hostid. What about the other keys?
    DBQueryWarn("update node_hostkeys set ".
		"  sfshostid=NULL ".
		"where node_id='$node_id'")
	or $error++;

    # Clean out the current_reloads table (a just in case measure).
    DBQueryWarn("delete from current_reloads where node_id='$node_id'")
	or $error++;

    # Reset its port allocation stuff.
    DBQueryWarn("delete from nodeipportnum where node_id='$node_id'")
	or $error++;

    # Clean the vinterfaces table for this node.
    DBQueryWarn("delete from vinterfaces where node_id='$node_id'")
	or $error++;

    # Clean the interface_settings table for this node.
    DBQueryWarn("delete from interface_settings where node_id='$node_id'")
	or $error++;

    # If it's a robot, we need to reset its physical location.
    my $result =
	DBQueryFatal("select building,floor,loc_x,loc_y,orientation ".
		     "from node_startloc where node_id='$node_id'");
    if ($result->num_rows()) {
	while (my ($bldg,$floor,$x,$y,$o) = $result->fetchrow_array()) {
	    my $subresult = 
		DBQueryFatal("select pixels_per_meter from floorimages ".
			     "where building='$bldg'");
	    if ($subresult->num_rows()) {
		my ($pixels_per_meter) = $subresult->fetchrow_array();

		$x = int($x * $pixels_per_meter);
		$y = int($y * $pixels_per_meter);
		DBQueryWarn("update location_info set ".
			    "loc_x=$x,loc_y=$y,orientation=$o ".
			    "where node_id='$node_id' and building='$bldg' ".
			    "and floor=$floor") || $error++;
	    }
	    else {
		warn "No building named $bldg in floorimages";
	    }
	}
    }
    # Now its safe to change the reservation.

    # If the node has a next_reserve entry, change the reservation.
    my $next_reservation = $node->NextReservation();
    if (defined($next_reservation)) {
	print "Moving $node to $next_reservation\n"
	    if (!$quiet);

	if ($node->MoveReservation($next_reservation) == 0) {
	    $node->SetNodeHistory(TB_NODEHISTORY_OP_MOVE, $this_user,
				  $next_reservation);
	    
	    DBQueryWarn("delete from next_reserve where node_id='$node_id'")
		or $error++;

	    # This little sillyness is for disk reloading.
	    # Kill the last reservation since this path is special.
	    DBQueryWarn("delete from last_reservation ".
			"where node_id='$node_id'")
		or $error++;
	}
	else {
	    $error++;
	}
	next;
    }

    # If the node has a reloads entry, change the reservation so that the
    # reload_daemon will pick it up.
    $result =
	DBQueryFatal("select image_id from scheduled_reloads " .
		     "where node_id='$node_id'");
    my $inreloads = $result->numrows();

    # XXX
    if ($inreloads && !$imageable) {
	print "WARNING: non-imageable node $node in scheduled_reloads\n";
	$inreloads = 0;
    }

    #
    # XXX Robots.
    #
    if ($node->type() eq "garcia") {
	if (!defined($repositioning_experiment)) {
	    $repositioning_experiment = Experiment->Lookup($reloadpid,
							   $rppendingeid);
	    if (!defined($repositioning_experiment)) {
		print STDERR "*** WARNING: No repositioning experiment!\n";
		$error++;
		next;
	    }
	}
	print "Moving $node to $repositioning_experiment\n"
	    if (!$quiet);

	if ($node->MoveReservation($repositioning_experiment) == 0) {
	    $node->SetNodeHistory(TB_NODEHISTORY_OP_MOVE, $this_user,
				  $repositioning_experiment);
	    
	    DBQueryWarn("replace into scheduled_reloads ".
			"set node_id='$node_id'")
		or $error++;

	    # This little sillyness is for disk reloading.
	    # Kill the last reservation since this path is special.
	    DBQueryWarn("delete from last_reservation ".
			"where node_id='$node_id'")
		or $error++;
	}
	else {
	    $error++;
	}
	next;
    }
    elsif (!$TESTMODE && !exists($ENV{'NORELOAD'}) &&
	   ((!$isvirt && $imageable) || # XXX force reload hack!
	    $inreloads || $mustzero{$node_id})) { # XXX Garcia hack
	print "Moving $node to $reloading_experiment\n"
	    if (!$quiet);

	if ($node->MoveReservation($reloading_experiment) == 0) {
	    $node->SetNodeHistory(TB_NODEHISTORY_OP_MOVE, $this_user,
				  $reloading_experiment);

	    # This little sillyness is for disk reloading.
	    # Kill the last reservation since this path is special.
	    DBQueryWarn("delete from last_reservation ".
			"where node_id='$node_id'")
		or $error++;
	}
	next;
    }

    # No reloads or reservation changes, so really free the node
    #
    # This little sillyness is for disk reloading. Remember the last
    # project a node was reserved into. At present, there might already
    # be an entry. Eventually, os_setup will look for this and force
    # a reload.
    if ($mustclean) {
	DBQueryWarn("replace into last_reservation (pid_idx,node_id,pid)".
		    "values ($pid_idx, '$node_id', '$pid')");
    }

    print "Releasing node '$node_id' ...\n"
	if (!$quiet);
    if (DBQueryWarn("delete from reserved where node_id='$node_id'")) {
	$node->SetNodeHistory(TB_NODEHISTORY_OP_FREE, $this_user,
			      $experiment);
    }
    else {
	print STDERR "*** Failed to release node '$node_id'!\n";
	$error++;
    }
}

# Release dynamic nodes.
if (@dynanodes) {
    my @nodeids = map($_->node_id(), @dynanodes);

    Node::DeleteVnodes(@nodeids);
}

######################################################################
# Step 3 - Set up console for freed nodes.
#
# Using a list of freed nodes build eariler, run consetup to reset
# their serial consoles.
#
# NOTE: While it may seem like a race to do this after releasing the
# reservation, it really is not. Even if the node is allocated again
# console_setup looks at the current reservation and does the right
# thing, and since nalloc locks the reserved table, ordering will be
# preserved.
#
######################################################################

if (@freed_nodes) {
    my @nodeids = map($_->node_id(), @freed_nodes);
    
    system("$consetup @nodeids") == 0 ||
	print STDERR "WARNING: $consetup @nodeids failed!\n";
}

exit($error);

