#!/usr/local/bin/perl -w
use Mysql;

#
# Configure variables
#
my $TB       = "@prefix@";
my $DBNAME   = "@TBDBNAME@";

my $dbh = Mysql->connect("localhost",$DBNAME,"script","none");

if ($#ARGV < 1) {
  die("Usage: nfree <pid> <eid> [<node> <node> <...>]\n".
      "Releases all nodes in the specified experiment. If nodes are listed,\n".
      "nfree releases only the listed nodes.\n");
}

my $error = 0;
my $consetup="$TB/libexec/console_setup";
my $exportsetup="$TB/sbin/exports_setup";
my $reloadpid="emulab-ops";
my $reloadeid="reloadpending";
my $pid = shift;
my $eid = shift;
my @node_names=();
my @freed_nodes=();

foreach my $n (@ARGV) {
  if ($n =~ /(sh\d+)/ ) {
    # its a shark - do the whole shelf if its not done already.
    my $shelf = $1;
    if ( ! (join(",",@node_names) =~ /,$shelf-\d,/)) {
      # Shelf hasn't been done yet...
      foreach my $n ( 1 .. 8 ) {
	push(@node_names,"$shelf-$n");
      }
    }
  } else {
    # its not a shark - just add it in...
    push(@node_names,"$n");
  }
}


my $cmd = "";
my $sth = "";

$cmd = "select * from experiments where eid='$eid' and pid='$pid'";
$sth = $dbh->query($cmd);
if ($sth->numrows < 1) {	
  die("There is no experiment '$eid' in project '$pid'.\n");
}
 
$cmd = "lock tables nodes write, node_types read, scheduled_reloads read, ".
  "interfaces write, delays write, reserved write, last_reservation write,".
  "next_reserve read";
$sth = $dbh->query($cmd) 
  || die("Locking error:\n$cmd\nError string is:".$dbh->errstr."\n");

# If list is empty, put in all the nodes
if ($#node_names == -1) {
  print "Releasing all nodes from experiment '$eid' in project '$pid'...\n";
  $sth = $dbh->
    query("select node_id from reserved where pid='$pid' and eid='$eid'");
  while (@row = $sth->fetchrow_array()) {
    push(@node_names, $row[0]);
  }
}

my @reloads = ();
my %reserves= ();
foreach my $n (@node_names) { 
  $sth = $dbh->query("select * from reserved where node_id='$n' ".
		     "and eid='$eid' and pid='$pid'");
  if ($sth->numrows == 0) {
    print "Node '$n' is not reserved by your experiment.\n";
    $error++;
    next;
  } else {
    push(@freed_nodes,$n);
  }

  # This little sillyness is for disk reloading. Kill the last reservation.
  $cmd = "delete from last_reservation where node_id='$n'";
  $dbh->query($cmd);

  # If the node has a reloads entry, change the reservation and start it
  $cmd = "select node_id,image_id from scheduled_reloads where node_id='$n'";
  $sth = $dbh->query($cmd)
    || (print "Failed Command:\n$cmd\nError string is:".$dbh->errstr."\n"
	&& $error++);

  if ( ($sth->num_rows()) > 0) {
    print "Adding scheduled reload for $n to the list.\n";
    push(@reloads,$n);
  } else {
    # If the node has a next_reserve entry, change the reservation and start it
    $cmd = "select node_id,pid,eid from next_reserve where node_id='$n'";
    $sth = $dbh->query($cmd)
      || (print "Failed Command:\n$cmd\nError string is:".$dbh->errstr."\n"
	  && $error++);
    if ( ($sth->num_rows()) > 0) {
      my @reserve;
      print "Adding next reservation for $n to the list.\n";
      my $i = 0;
      my $max = $sth->num_rows();
      while ( $i < $max  ) {
	$i++;
	@reserve = $sth->fetchrow_array();
	my ($node, $next_pid, $next_eid) = @reserve;
	$reserves{$node} = "$next_pid:$next_eid";
      }
    } else {
      # No reloads or reservation changes, so really free the node
      # This little sillyness is for disk reloading. Remember the last
      # project a node was reserved into.
      $cmd = "insert into last_reservation values ('$n', '$pid')";
      $dbh->query($cmd);
      print "Releasing node '$n'...";
      $cmd = "delete from reserved where node_id='$n' and eid='$eid'";
      $sth = $dbh->query($cmd) && print "Succeeded.\n"
	|| (print "Failed Command:\n$cmd\nError string is:".$dbh->errstr."\n"
	    && $error++);
    }
  }

  # Find the control net interface for this node type
  $sth = 
    $dbh->query("select control_net,osid,node_types.pxe_boot_path " .
		"from node_types " .
		"left join nodes on nodes.type=node_types.type " .
		"where node_id='$n'");
  my @row= $sth->fetchrow_array();
  my $control= $row[0];
  my $osid= $row[1];
  my $pxe_boot_path = $row[2];
  if (! ($n =~ /sh\d+/)) { #If its not a shark
    # Clean out all IPs except the control net
    $cmd = 
      "update interfaces set IP='' where node_id='$n' and card!='$control'";
    $sth = $dbh->query($cmd)
      || (print "Failed Command:\n$cmd\nError string is:".$dbh->errstr."\n"
	  && $error++);
  } else {
    # it is a shark, so clear out the alias(es)
    $cmd = "update interfaces set IPalias='' where node_id='$n'";
    $sth = $dbh->query($cmd)
      || (print "Failed Command:\n$cmd\nError string is:".$dbh->errstr."\n"
	  && $error++);
  }

  # Clean out all delays
  $cmd = 
    "delete from delays where node_id='$n'";
  $sth = $dbh->query($cmd)
    || (print "Failed Command:\n$cmd\nError string is:".$dbh->errstr."\n"
	&& $error++);

  # And clean out various tidbits from the nodes table.
  $cmd = "update nodes set def_boot_osid='$osid', def_boot_cmd_line='',".
      "def_boot_path='',startupcmd='',rpms='',deltas='',tarballs='',".
	  "pxe_boot_path='$pxe_boot_path' where node_id='$n'";
  $sth = $dbh->query($cmd)
    || (print "Failed Command:\n$cmd\nError string is:".$dbh->errstr."\n"
	&& $error++);

  # Clean out the current_reloads table
  $cmd = "delete from current_reloads where node_id='$'";
  $sth = $dbh->query($cmd)
    || (print "Failed Command:\n$cmd\nError string is:".$dbh->errstr."\n"
	&& $error++);


}

$cmd = "unlock tables";
$sth = $dbh->query($cmd) 
  || die("Locking error:\n$cmd\nError string is:".$dbh->errstr."\n");

if ( (@reloads > 0) || (keys %reserves > 0) ) {
  print "Locking tables.\n";
  $cmd = "lock tables nodes read, node_types read, scheduled_reloads read, ".
    "interfaces write, reserved write, next_reserve write";
  $sth = $dbh->query($cmd) 
    || die("Locking error:\n$cmd\nError string is:".$dbh->errstr."\n");
  
  foreach $n ( @reloads ) {
    # Change reservation (don't delete or we'll get races)
    print "Changing reservation for $n to $reloadpid/$reloadeid...\n";
    $cmd = "update reserved set pid='$reloadpid',eid='$reloadeid' where ".
      "node_id='$n'";
    $sth = $dbh->query($cmd)
      || (print "Failed Command:\n$cmd\nError string is:".$dbh->errstr."\n"
	  && $error++ && next);
  }
  
  foreach $n ( keys %reserves ) {
    my ($next_pid,$next_eid) = split (":",$reserves{$n});
    # Change reservation (don't delete or we'll get races)
    print "Changing reservation for $n to $next_pid/$next_eid...\n";
    $cmd = "update reserved set pid='$next_pid',eid='$next_eid' where ".
      "node_id='$n'";
    $sth = $dbh->query($cmd)
      || (print "Failed Command:\n$cmd\nError string is:".$dbh->errstr."\n"
	  && $error++ && next);
    $cmd = "delete from next_reserve where node_id='$n'";
    $sth = $dbh->query($cmd)
      || (print "Failed Command:\n$cmd\nError string is:".$dbh->errstr."\n"
	  && $error++ && next);
  }

  print "Unlocking tables.\n";
  $cmd = "unlock tables";
  $sth = $dbh->query($cmd) 
    || die("Locking error:\n$cmd\nError string is:".$dbh->errstr."\n");
}

if (@freed_nodes) {
    my @conlist=();
    my @sharks=();
    
    foreach $n ( @freed_nodes ) {
	if ($n =~ /(sh\d+)/) {
	    # Its a shark - do the shelf if it hasn't been done yet
	    my $shelf = $1;
	    if (!(join(",",@sharks) =~ /\b$shelf\b/)) {
		push(@sharks,$shelf);
		push(@conlist,$shelf);
	    }
	}
	else {
	    push(@conlist,$n);
	}
    }
    system("$consetup @conlist") == 0 or
	print STDERR "WARNING: $consetup @conlist failed!\n";
}

exit($error);

