#!/usr/bin/perl -wT

#
# EMULAB-COPYRIGHT
# Copyright (c) 2000-2002 University of Utah and the Flux Group.
# All rights reserved.
#
use English;

#
# nfree - Takes pysical node names, and frees them from the experiment they
# are allocated to. If nodes are ommited, frees up all nodes in the given
# experiment. Looks in the scheduled_reloads and next_reserve tables to see
# if this node should be re-reserved into another experiment and/or reloaded,
# rather than being put back into the pool of free nodes
#
sub usage ()
{
    die("Usage: nfree <pid> <eid> [<node> <node> <...>]\n".
	"Releases all nodes in the specified experiment.\n".
	"If nodes are listed, nfree releases only those nodes.\n");
}

#
# Configure variables
#
my $TB       = "@prefix@";

#
# Testbed Support libraries
#
use lib "@prefix@/lib";
use libdb;
use libtestbed;

my $consetup	= "$TB/libexec/console_setup";
my $reloadpid	= "emulab-ops";
my $pendingeid  = "reloadpending";
my $reloadeid   = "reloading";

my @nodes;
my @freed_nodes=();
my $error = 0;

#
# Turn off line buffering on output
#
$| = 1;

#
# Untaint the path
# 
$ENV{'PATH'} = "/bin:/usr/bin:/sbin:/usr/sbin";
delete @ENV{'IFS', 'CDPATH', 'ENV', 'BASH_ENV'};

if (@ARGV < 2) {
    usage();
}
my $pid = shift;
my $eid = shift;

#
# Untaint args.
#
if ($pid =~ /^([-\@\w]+)$/) {
    $pid = $1;
}
else {
    die("Bad data in pid: $pid.");
}
if ($eid =~ /^([-\@\w]+)$/) {
    $eid = $1;
}
else {
    die("Bad data in eid: $eid.");
}

#
# Make sure that the experiment actually exists
#
if (!ExpState($pid,$eid)) {
    die("There is no experiment '$eid' in project '$pid'.\n");
}

#
# Make sure the user has the ability to modify this experiment
#
if (!TBExptAccessCheck($UID, $pid, $eid, TB_EXPT_MODIFY)) {
    die("You do not have permission to modify '$eid' in project '$pid'.\n");
}

#
# Make a list of nodes given on the command line, or get the whole list from
# the DB if none provided. 
#
if (@ARGV) {
    foreach my $n (@ARGV) {
	#
	# Taint check first! Solves silly perl problems.
	# 
	if ($n =~ /^([-\w]+)$/) {
	    $n = $1;
	}
	else {
	    die("*** $0:\n".
		"    Bad node name: $n.\n");
	}

	# Shark hack
	if ($n =~ /(sh\d+)/ ) {
	    #
	    # It's a shark - do the whole shelf if its not done already.
	    #
	    my $shelf = $1;
	    if ( ! (join(",", @nodes) =~ /,$shelf-\d,/)) {
		# Shelf hasn't been done yet...
		foreach my $n ( 1 .. 8 ) {
		    push(@nodes, "$shelf-$n");
		}
	    }
	    # End shark hack
	}
	else {
	    # its not a shark - just add it in...
	    push(@nodes, $n);
	}
    }
}
else {
    print "Releasing all nodes from experiment '$eid' in project '$pid'.\n";
    @nodes = ExpNodes($pid, $eid);
}

######################################################################
# Step 1
#
# See what nodes need to be freed, and then lock them down my moving
# them to a holding reservation.
#
# We lock just the reserved table. The prevents races between multiple
# invocations of nfree trying to free the same node. Rather than lock
# a zillion tables, move the reservation into a holding pattern. This
# effectively prevents someone else from freeing the same nodes, and from
# someone else allocating the nodes until we are done cleaning things up.
#
# NOTE: My reason for not wanting to lock all those tables (9 in the
# original version) is that library calls will fail since mysql locking
# requires that every table used within the locked area, be locked.
# Of course, who knows what tables the library uses, so thats a silly
# way to go. 
#
######################################################################

#
# Form a unique temporary EID. I want this to be unique in case something
# goes wrong, and they get left in the DB.
# 
my $lockedeid = "nfree-locked-$PID";

DBQueryFatal("lock tables reserved write");

foreach my $n (@nodes) { 
    #
    # Check to make sure they have actually reserved the nodes.
    #
    my $result =
	DBQueryFatal("select * from reserved where node_id='$n' ".
		     "and eid='$eid' and pid='$pid'");
    if ($result->numrows == 0) {
	print "Node '$n' is not reserved by your experiment.\n";
	$error++;
	next;
    }

    #
    # Move to locked reservation. Node is not free, but is no longer
    # owned by the pid/eid, so cannot be mucked with.
    # 
    if (! DBQueryWarn("update reserved " .
		      "set vname=NULL, pid='$reloadpid', eid='$lockedeid' ".
		      "where node_id='$n'")) {
	print "*** WARNING: Error locking down node $n!\n";
	next;
    }

    push(@freed_nodes, $n);
}

DBQueryFatal("unlock tables");

######################################################################
# Step 2
#
# Go through the list of nodes we successfully locked down, and clean
# up the node state (nodes, delays, interfaces, etc). Once that is done,
# move them to whatever new reservations are pending, or free the node.
#
######################################################################

foreach my $n (@freed_nodes) {
    my $mustclean = 1;
    
    #
    # Clean out all delays
    #
    DBQueryWarn("delete from delays where node_id='$n'") || $error++;

    #
    # Find the control net interface for this node type, as well as some
    # of the default values for its node type.
    #
    my $result =
	DBQueryFatal("select control_net,nt.osid,nt.pxe_boot_path, " .
		     " n.def_boot_osid,n.def_boot_path, ".
		     " nt.isvirtnode ".
		     " from node_types as nt " .
		     "left join nodes as n on n.type=nt.type " .
		     "where node_id='$n'");
    my ($control,$osid,$pxe_boot_path,$def_boot_osid,$def_boot_path,$isvirt) =
	$result->fetchrow_array();

    #
    # See if the OS it was running was marked as mustclean or not. Basically,
    # this is an OSKit hack to avoid reloading disks that have not been
    # touched by the kernel. If a def_boot_path was set, there is nothing
    # we can figure out, so just reload it. This needs to be more general
    # purpose.
    #
    if ($isvirt) {
	#
	# VIRTNODE HACK: Virtual nodes are special. Do not clean or reload.
	# 
	$mustclean = 0;
    }
    elsif (! defined($def_boot_osid) ||
	 (defined($def_boot_path) && $def_boot_path ne "")) {
	$mustclean = 1;
    }
    else {
	my $result =
	    DBQueryFatal("select mustclean from os_info " .
			 "where osid='$def_boot_osid'");
	if ($result->numrows()) {
	    ($mustclean) = $result->fetchrow_array();
	}
    }

    #
    # Clean up interfaces by clearing IPs and/or aliases.
    #
    if (! ($n =~ /sh\d+/)) {
        # Its not a shark, so clean out all IPs except the control net.
	DBQueryWarn("update interfaces set IP='' " .
		    "where node_id='$n' and card!='$control'") || $error++;
    }
    else {
	# XXX Shark Hack!
	DBQueryWarn("update interfaces set IPalias='' ".
		    "where node_id='$n'") || $error++;
    }

    #
    # Map the default OSID to something that is actually loaded on the
    # machine. I think this is a hack, but its the best I can come up
    # with right now. 
    #
    if (! $isvirt) {
	my $mapped_osid = MapNodeOSID($n, $osid);
	if ($mapped_osid) {
	    $osid = $mapped_osid;
	}
    }

    #
    # Clean up the nodes table so that its in a moderately clean state.
    #

    #foreach $var ( 'osid','pxe_boot_path','n') {
	#print "\$$var = ";
	#if (!defined ${$var}) {
	#    print "(null)";
	#} else {
	#    print ${$var};
        #}
        #print "\n";
    #}
    DBQueryWarn("update nodes set def_boot_osid='$osid',def_boot_cmd_line='',".
		"def_boot_path='',startupcmd='',rpms='',deltas='', ".
		"tarballs='',pxe_boot_path='$pxe_boot_path', ".
		"failureaction='fatal', routertype='none', ".
		"next_pxe_boot_path='' where node_id='$n'") || $error++;

    #
    # Clean out the current_reloads table (a just in case measure). 
    #
    DBQueryWarn("delete from current_reloads where node_id='$n'") || $error++;

    #
    # Reset its port allocation stuff.
    #
    DBQueryWarn("delete from nodeipportnum where node_id='$n'") || $error++;

    #
    # Now its safe to change the reservation.
    #
    #
    # If the node has a next_reserve entry, change the reservation.
    #
    $result =
	DBQueryFatal("select node_id,pid,eid from next_reserve ".
		     "where node_id='$n'");

    if ($result->num_rows()) {
	my ($node, $next_pid, $next_eid) = $result->fetchrow_array();
	
	print "Moving $n to $next_pid/$next_eid.\n";

	DBQueryWarn("update reserved set pid='$next_pid',eid='$next_eid'," .
		    "vname=NULL where node_id='$n'")
	    || $error++;
	
	DBQueryWarn("delete from next_reserve where node_id='$n'")
	    || $error++;

	#
	# This little sillyness is for disk reloading.
	# Kill the last reservation since this path is special.
	#
	DBQueryWarn("delete from last_reservation where node_id='$n'") ||
	    $error++;

	next;
    }
    
    #
    # If the node has a reloads entry, change the reservation so that the
    # reload_daemon will pick it up.
    #
    $result =
	DBQueryFatal("select node_id,image_id from scheduled_reloads " .
		     "where node_id='$n'");

    if ($result->numrows()) {
	print "Moving $n to $reloadpid/$pendingeid.\n";
	
	DBQueryWarn("update reserved set ".
		    "pid='$reloadpid',eid='$pendingeid' ".
		    "where node_id='$n'") || $error++;

	#
	# This little sillyness is for disk reloading.
	# Kill the last reservation since this path is special.
	#
	DBQueryWarn("delete from last_reservation where node_id='$n'") ||
	    $error++;

	next;
    }

    #
    # No reloads or reservation changes, so really free the node
    #
    # This little sillyness is for disk reloading. Remember the last
    # project a node was reserved into. At present, there might already
    # be an entry. Eventually, os_setup will look for this and force
    # a reload.
    #
    if ($mustclean) {
	DBQueryWarn("replace into last_reservation values ('$n', '$pid')");
    }
    
    print "Releasing node '$n' ... ";
    if (DBQueryWarn("delete from reserved where node_id='$n'")) {
	print "Succeeded.\n";
    }
    else {
	print "Failed!\n";
	$error++;
    }
}

######################################################################
# Step 3 - Set up console for freed nodes.
#
# Using a list of freed nodes build eariler, run consetup to reset
# their serial consoles.
#
# NOTE: While it may seem like a race to do this after releasing the
# reservation, it really is not. Even if the node is allocated again
# console_setup looks at the current reservation and does the right
# thing, and since nalloc locks the reserved table, ordering will be
# preserved.
# 
######################################################################

if (@freed_nodes) {
    system("$consetup @freed_nodes") == 0 ||
	print STDERR "WARNING: $consetup @freed_nodes failed!\n";
}

exit($error);

