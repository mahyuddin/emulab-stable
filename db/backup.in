#!/usr/bin/perl -wT

#
# EMULAB-COPYRIGHT
# Copyright (c) 2000-2003 University of Utah and the Flux Group.
# All rights reserved.
#
use English;

#
# Back up the DB, rolling the base and update logs. The approach is to
# open up the index file and see what the name of the current update file
# is. It has a numeric extension. Rename the base log to base.XXX,
# and then snapshot the DB into backup.XXX So, the combination of
# update.XXX and base.XXX is the DB history since the last time the script
# was run. The file backup.XXX corresponds to the DB at this point in time.
#
# To restore (or track the changes of) a DB, simply take backup.XXX and 
# apply the changes that are stored in update.XXX+1 (which are the changes
# made since backup.XXX was made). This should give you a DB that is the
# same as backup.XXX+1. You can go back further, and just apply all the
# subsequent update.XXX files. 
# 

#
# Configure variables
#
my $TB		= "@prefix@";
my $DBNAME	= "@TBDBNAME@";
my $TBOPS       = "@TBOPSEMAIL@";

my $BACKUPDIR	= "$TB/backup";
my $LOGDIR	= "$TB/log/mysql";
my $BASE	= "base";
my $UPD		= "update";
my $SLOW	= "slowqueries";
my $BACK	= "tbdb";
my $extension;

# un-taint path
$ENV{'PATH'} = '/bin:/usr/bin:/usr/local/bin:/usr/site/bin';
delete @ENV{'IFS', 'CDPATH', 'ENV', 'BASH_ENV'};

#
# Turn off line buffering on output
#
$| = 1; 

# Load the Testbed support stuff.
use lib "@prefix@/lib";
use libtestbed;

#
# Only real root can call this.
# 
if ($UID != 0) {
    print STDERR "You must be root to run this script!\n";
    exit(-1);
}

#
# Create a temporary name for a log file and untaint it.
#
#
# Form a temp name.
#
my $logname = `mktemp /tmp/dbbackup.XXXXXX`;

if ($logname =~ /^([-\@\w.\/]+)$/) {
    $logname = $1;
} else {
    die "Bad data in $logname";
}

#
# Reopen both stdout and stderr so that we can record all the output for
# later mailing.
# 
open(STDERR, ">> $logname") or die("opening $logname for STDERR: $!");
open(STDOUT, ">> $logname") or die("opening $logname for STDOUT: $!");

if (! chdir($BACKUPDIR)) {
    fatal("Could not chdir to $BACKUPDIR: $!");
}

#
# Open up the index file to see what the current update file extension is.
# The base/backup files correspond to this most recent update file, and
# so should be named with that extension.
#
# Read through to the last line and get its extension. This becomes
# the extension for the other files. No locking is needed.
#
open(IDX, "< $LOGDIR/update.index") or
    fatal("Could not open $LOGDIR/update.index: $!");

while (<IDX>) {
    if ($_ =~ /^.*\.([0-9]*)$/) {
	$extension = $1;
    }
}
close(IDX);
print "Extension:        $extension\n";

my $backname  = "$BACK.$extension";
my $basename  = "$BASE.$extension";
my $updname   = "$UPD.$extension";
my $slowname  = "$SLOW.$extension";

print "Backup file name: $backname\n";
print "Base file name:   $basename\n";
print "Update file name: $updname\n";
print "Slow file name:   $slowname\n";

#
# Move base log out of the way since flush-logs will reset it too.
#
if (-e "$LOGDIR/$BASE") {
    if (system("/bin/mv $LOGDIR/$BASE $LOGDIR/$basename")) {
	print STDERR "Could not move $LOGDIR/$BASE to $LOGDIR/$basename!";
    }
}
if (-e "$LOGDIR/$SLOW") {
    if (system("/bin/mv $LOGDIR/$SLOW $LOGDIR/$slowname")) {
	print STDERR "Could not move $LOGDIR/$SLOW to $LOGDIR/$slowname!";
    }
}

#
# Do a mysqldump. This will reset the log files.
#
if (system("mysqldump --all --flush-logs --lock-tables $DBNAME > $backname")) {
    fatal("mysqldump failed!");
}

#
# Compress the files.
# 
if (system("gzip -9 $backname")) {
    fatal("gzip $backname failed!");
}

if (! chdir($LOGDIR)) {
    fatal("Could not chdir to $LOGDIR: $!");
}

if (-e "$basename" && system("gzip -9 $basename")) {
    fatal("gzip $basename failed!");
}

if (-e "$updname" && system("gzip -9 $updname")) {
    fatal("gzip $updname failed!");
}

if (-e "$slowname" && system("gzip -9 $slowname")) {
    fatal("gzip $slowname failed!");
}

# Should do this too, but right now I do it by hand ...
if (0) {
    system("find . \( -name 'base.*.gz' -o -name 'update.*.gz' ".
	   "         -o -name 'slowqueries.*.gz' \) ".
	   "-mtime +35 -print -delete");
}

#SENDMAIL("stoller", "DB Backup Finished", "", undef, undef, ($logname));
unlink("$logname");
exit 0;

sub fatal($) {
    my ($msg) = @_;

    print STDERR "$msg\n";

    SENDMAIL($TBOPS, "DB Backup Failed", $msg, undef, undef, ($logname));
    unlink("$logname");
    exit(1);
}
