<?xml version="1.0" encoding="utf-8"?>
<components:DefaultWindow xmlns:fx="http://ns.adobe.com/mxml/2009" 
						  xmlns:s="library://ns.adobe.com/flex/spark" 
						  xmlns:mx="library://ns.adobe.com/flex/mx"
						  xmlns:components="protogeni.display.components.*"
						  title="Virtual Node">
	<components:layout>
		<s:VerticalLayout gap="0" />
	</components:layout>
	<fx:Declarations>
		<s:RadioButtonGroup id="boundGroup" valueCommit="boundGroup_valueCommitHandler(event)"/>
	</fx:Declarations>
	<fx:Script>
		<![CDATA[
			import mx.collections.ArrayCollection;
			import mx.collections.XMLListCollection;
			import mx.controls.Alert;
			import mx.events.CloseEvent;
			import mx.events.FlexEvent;
			
			import protogeni.NetUtil;
			import protogeni.XmlUtil;
			import protogeni.display.components.DocumentWindow;
			import protogeni.resources.DiskImage;
			import protogeni.resources.ExecuteService;
			import protogeni.resources.GeniManager;
			import protogeni.resources.InstallService;
			import protogeni.resources.LoginService;
			import protogeni.resources.PhysicalNode;
			import protogeni.resources.Pipe;
			import protogeni.resources.PipeCollection;
			import protogeni.resources.ProtogeniRspecProcessor;
			import protogeni.resources.Sliver;
			import protogeni.resources.SliverType;
			import protogeni.resources.SliverTypes;
			import protogeni.resources.VirtualComponent;
			import protogeni.resources.VirtualInterface;
			import protogeni.resources.VirtualInterfaceCollection;
			import protogeni.resources.VirtualLink;
			import protogeni.resources.VirtualLinkCollection;
			import protogeni.resources.VirtualNode;
			import protogeni.resources.VirtualNodeCollection;
			
			import spark.collections.Sort;
			import spark.collections.SortField;
			
			[Bindable]
			public var backgroundColor:uint = 0xFFFFFF;
			[Bindable]
			public var titleColor:uint = 0x000000;
			
			[Bindable]
			private var node:VirtualNode;
			
			[Bindable]
			private var managers:ArrayCollection = new ArrayCollection();
			[Bindable]
			private var physicalNodes:ArrayCollection = new ArrayCollection();
			[Bindable]
			private var sliverTypes:ArrayCollection = new ArrayCollection();
			[Bindable]
			private var hardwareForVirtual:ArrayList = new ArrayList();
			[Bindable]
			private var diskImages:ArrayCollection = new ArrayCollection();
			[Bindable]
			private var planetlabInitscripts:ArrayCollection = new ArrayCollection();
			[Bindable]
			private var pipes:ArrayCollection = new ArrayCollection();
			[Bindable]
			private var interfaces:ArrayCollection = new ArrayCollection();
			
			private function get SelectedManager():GeniManager
			{
				return managerList.selectedItem as GeniManager;
			}
			private function get SelectedBounded():Boolean
			{
				return boundRadiobutton.selected;
			}
			private function get SelectedBoundNode():PhysicalNode
			{
				return boundDropDownList.selectedItem as PhysicalNode;
			}
			private function get SelectedSliverType():String
			{
				if(sliverTypeDropDownList.selectedItem == null)
					return "";
				else
					return sliverTypeDropDownList.selectedItem;
			}
			
			public function loadNode(n:VirtualNode):void
			{
				node = n;
				physicalNodes = new ArrayCollection();
				var nameSort:Sort = new Sort();
				var dataSortField:SortField = new SortField("name");
				nameSort.fields = [dataSortField];
				
				physicalNodes.sort = nameSort;
				
				// Build up lists
				managers.removeAll();
				for each(var manager:GeniManager in Main.geniHandler.GeniManagers)
				{
					if(manager.Status == GeniManager.STATUS_VALID)
						managers.addItem(manager);
				}
				
				clientIdInput.text = node.clientId;
				backgroundColor = ColorUtil.colorsDark[node.manager.colorIdx];
				errorButton.visible = node.error.length > 0;
				manifestButton.visible = node.manifest != null;
				if(node.status.length > 0)
				{
					statusImage.visible = true;
					switch(node.status)
					{
						case VirtualComponent.STATUS_READY:
							this.statusImage.source = ImageUtil.flagGreenIcon;
							break;
						case VirtualComponent.STATUS_FAILED:
							this.statusImage.source = ImageUtil.flagRedIcon;
							break;
						case VirtualComponent.STATUS_NOTREADY:
						case VirtualComponent.STATUS_CHANGING:
						case VirtualComponent.STATUS_STOPPED:
							statusImage.source = ImageUtil.flagYellowIcon;
							break;
						case VirtualComponent.STATUS_UNKNOWN:
						default:
							statusImage.visible = false;
					}
				}
				if(node.loginServices.length > 0)
				{
					loginGroup.visible = true;
					usernameText.text = node.loginServices[0].username;
					hostnameText.text = node.loginServices[0].hostname + (node.loginServices[0].port.length>0 ? ":"+node.loginServices[0].port : "");
				}
				
				managerList.selectedItem = node.manager;
				if(node.physicalNode != null)
				{
					boundRadiobutton.selected = true;
					boundDropDownList.selectedItem = node.physicalNode;
					loadBound();
				}
				else
				{
					unboundRadiobutton.selected = true;
					loadUnbound();
				}
				exclusiveCheckbox.selected = node.exclusive;
				
				diskImageText.text = node.diskImage;
				
				if(node.installServices.length > 0)
				{
					for each(var installService:InstallService in node.installServices)
						addInstallService(installService);
				}
				if(node.executeServices.length > 0)
				{
					for each(var executeService:ExecuteService in node.executeServices)
						addExecuteService(executeService);
				}
				interfaces = new ArrayCollection();
				for each(var iface:VirtualInterface in node.interfaces.collection)
				{
					interfaces.addItem(
						{
							source: iface,
							clientId: iface.id,
							macAddress: iface.macAddress,
							ipaddress: iface.ip,
							ipnetmask: iface.netmask,
							iptype: iface.type
						}
					);
				}
				
				pipes = new ArrayCollection();
				var i:int;
				// Make sure we have pipes for all interfaces
				for(i = 0; i < interfaces.length; i++)
				{
					var first:VirtualInterface = node.interfaces.collection[i];
					for(var j:int = i+1; j < interfaces.length; j++)
					{
						var second:VirtualInterface = node.interfaces.collection[j];
						
						var firstPipe:Pipe = node.pipes.getFor(first, second);
						if(firstPipe == null)
							firstPipe = new Pipe(first, second, Math.min(first.capacity, second.capacity));
						pipes.addItem(
							{
								source: firstPipe,
								capacity: firstPipe.capacity,
								latency: firstPipe.latency,
								packetLoss: firstPipe.packetLoss
							}
						);
						
						var secondPipe:Pipe = node.pipes.getFor(second, first);
						if(secondPipe == null)
							secondPipe = new Pipe(second, first, Math.min(first.capacity, second.capacity));
						pipes.addItem(
							{
								source: secondPipe,
								capacity: secondPipe.capacity,
								latency: secondPipe.latency,
								packetLoss: secondPipe.packetLoss
							}
						);
					}
				}
			}
			
			public function initExtensions():void
			{
				extensionsTextarea.text = node.extensionsNodes.toXMLString();
			}
			
			public function visitHost():void
			{
				if(node.loginServices.length > 0)
				{
					NetUtil.openWebsite("http://" + node.loginServices[0].hostname);
				}
			}
			
			public function openSsh():void
			{
				if(node.loginServices.length > 0)
				{
					NetUtil.openWebsite("ssh://" + node.loginServices[0].username + "@" + node.loginServices[0].hostname + ":" + node.loginServices[0].port);
				}
			}
			
			public function previewRspec():void
			{
				Alert.show("This preview will not show any changes made if changes have been made without applying.  Would you like to apply any changes before previewing?",
					"Apply?",
					Alert.YES|Alert.NO|Alert.CANCEL,
					this,
					function closeEvent(event:CloseEvent):void {
						switch(event.detail) {
							case Alert.CANCEL:
								return;
							case Alert.YES:
								if(save())
									return;
								loadNode(node);
							default:
								var previewRspec:DocumentWindow = new DocumentWindow();
								previewRspec.title = "Preview Request RSPEC for: " + node.clientId;
								previewRspec.loadXml((node.manager.rspecProcessor as ProtogeniRspecProcessor).generateNodeRspec(node, true));
								previewRspec.showWindow();
						}
					});
			}
			
			public function viewManifest():void
			{
				if(node.manifest != null)
				{
					var rspecWindow:DocumentWindow = new DocumentWindow;
					rspecWindow.showWindow();
					rspecWindow.title = "Last Successful RSPEC from " + node.sliverId;
					rspecWindow.loadXml(node.manifest);
				} else {
					Alert.show("No previous RSPEC is available");
				}
			}
			
			protected function managerList_valueCommitHandler(event:FlexEvent):void
			{
				physicalNodes.removeAll();
				hardwareForVirtual.removeAll();
				if(SelectedManager != null)
				{
					backgroundColor = ColorUtil.colorsDark[SelectedManager.colorIdx];
					var selectableNodes:Vector.<PhysicalNode> = SelectedManager.AllNodes;
					for each(var phyNode:PhysicalNode in selectableNodes)
						physicalNodes.addItem(phyNode);
					if(node.physicalNode != null
						&& SelectedManager == node.physicalNode.manager
						&& !physicalNodes.contains(node.physicalNode))
					{
						physicalNodes.addItem(node.physicalNode);
					}
					
					physicalNodes.refresh();
					
					hardwareForVirtual = SelectedManager.getTypes();
					
					unboundVgroup.enabled = SelectedManager.supportsSharedNodes || SelectedManager.supportsExclusiveNodes;
					if(SelectedManager != node.manager)
					{
						if(unboundVgroup.enabled)
						{
							unboundRadiobutton.selected = true;
							loadUnbound();
						}
						else
						{
							boundRadiobutton.selected = true;
						}
					}
					
					sliverTypes.removeAll();
					if(SelectedManager.type == GeniManager.TYPE_PLANETLAB)
						sliverTypes.addItem(SliverTypes.PLANETLAB);
					else
					{
						if(SelectedManager.Hrn == "shadownet.cm")
							sliverTypes.addItem(SliverTypes.JUNIPER_LROUTER);
						else
						{
							sliverTypes.addItem(SliverTypes.RAWPC);
							sliverTypes.addItem(SliverTypes.EMULAB_OPENVZ);
							if(SelectedManager.supportsDelayNodes)
								sliverTypes.addItem(SliverTypes.DELAY);
						}
					}
					
					diskImages = SelectedManager.DiskImages;
				}
			}
			
			protected function boundDropDownList_valueCommitHandler(event:FlexEvent):void
			{
				boundRadiobutton.selected = true;
				loadBound();
			}
			
			private function loadUnbound():void
			{
				if(node.sliverType.length > 0 && node.sliverType != "N/A")
				{
					if(!sliverTypes.contains(node.sliverType))
						sliverTypes.addItem(node.sliverType);
					sliverTypeDropDownList.selectedItem = node.sliverType;
				}
				
				if(sliverTypeDropDownList.selectedItem == null)
					sliverTypeDropDownList.selectedIndex = 0;
				
				exclusiveCheckbox.enabled = true;
			}
			
			private function loadBound():void
			{
				if(SelectedBoundNode != null)
				{
					exclusiveCheckbox.selected = SelectedBoundNode.exclusive;
					
					for each(var sliverType:SliverType in SelectedBoundNode.sliverTypes)
					{
						if(!sliverTypes.contains(sliverType) && sliverType.name != "N/A")
							sliverTypes.addItem(sliverType);
					}
					
					if(!sliverTypes.contains(node.sliverType) && node.sliverType != "N/A")
						sliverTypes.addItem(node.sliverType);
					if(node.sliverType != "N/A")
						sliverTypeDropDownList.selectedItem = node.sliverType;
					
					if(sliverTypeDropDownList.selectedItem == null)
						sliverTypeDropDownList.selectedIndex = 0;
				}
				
				exclusiveCheckbox.enabled = false;
			}
			
			protected function sliverTypeDropDownList_valueCommitHandler(event:FlexEvent):void
			{
				if(SelectedSliverType != null)
				{
					switch(SelectedSliverType)
					{
						case SliverTypes.EMULAB_OPENVZ:
							exclusiveCheckbox.enabled = true;
							diskImageGroup.visible = false;
							detailsViewstack.selectedChild = detailsView;
							break;
						case SliverTypes.RAWPC:
							exclusiveCheckbox.enabled = false;
							exclusiveCheckbox.selected = true;
							diskImageGroup.visible = true;
							detailsViewstack.selectedChild = detailsView;
							break;
						case SliverTypes.DELAY:
							exclusiveCheckbox.enabled = true;
							diskImageGroup.visible = false;
							detailsViewstack.selectedChild = delayView;
							loadDelayPipes();
							break;
						case SliverTypes.PLANETLAB:
							exclusiveCheckbox.enabled = false;
							exclusiveCheckbox.selected = false;
							diskImageGroup.visible = false;
							detailsViewstack.selectedChild = planetlabView;
							planetlabInitscripts.removeAll();
							if(SelectedBoundNode != null)
							{
								for each(var initscript:String in SelectedBoundNode.planetLabInitscripts)
									planetlabInitscripts.addItem(initscript);
								if(node.selectedPlanetLabInitscript.length > 0)
								{
									if(!planetlabInitscripts.contains(node.selectedPlanetLabInitscript))
										planetlabInitscripts.addItem(node.selectedPlanetLabInitscript);
								}
							}
							
							if(node.selectedPlanetLabInitscript.length > 0)
								planetlabInitscriptDropdownlist.selectedItem = node.selectedPlanetLabInitscript;
							break;
						case SliverTypes.JUNIPER_LROUTER:
							exclusiveCheckbox.enabled = false;
							exclusiveCheckbox.selected = false;
							diskImageGroup.visible = false;
							detailsViewstack.selectedChild = detailsView;
							break;
					}
				}
			}
			
			protected function hardwareList_valueCommitHandler(event:FlexEvent):void
			{
				hardwareTypeCheckbox.selected = hardwareList.selectedItem != null
			}
			
			protected function boundGroup_valueCommitHandler(event:FlexEvent):void
			{
				if(unboundRadiobutton.selected)
					loadUnbound();
				else
					loadBound();
			}
			
			private function addInstallService(installService:InstallService = null):void
			{
				var newInstallComponent:InstallServiceComponent = new InstallServiceComponent();
				if(installService != null)
				{
					newInstallComponent.url = installService.url;
					newInstallComponent.fileType = installService.fileType;
					newInstallComponent.path = installService.installPath;
				}
				installVgroup.addElement(newInstallComponent);
			}
			
			private function addExecuteService(executeService:ExecuteService = null):void
			{
				var newExecuteComponent:ExecuteServiceComponent = new ExecuteServiceComponent();
				if(executeService != null)
				{
					newExecuteComponent.cmd = executeService.command;
					newExecuteComponent.shell = executeService.shell;
				}
				executeVgroup.addElement(newExecuteComponent);
			}
			
			public function fillLinksTo():void
			{
				if(linksVgroup == null || node == null)
					return;
				linksVgroup.removeAllElements();
				var connectedNodes:VirtualNodeCollection = node.GetAllNodes();
				
				for each(var connectedNode:VirtualNode in connectedNodes.collection)
				{
					linksVgroup.addElement(DisplayUtil.getVirtualNodeButton(connectedNode));
					
					var connectedLinks:VirtualLinkCollection = node.GetLinks(connectedNode);
					for each(var connectedLink:VirtualLink in connectedLinks.collection)
					{
						var pointLinkHbox:HGroup = new HGroup();
						var space:Rect = new Rect();
						space.width = 16;
						pointLinkHbox.addElement(space);
						pointLinkHbox.addElement(DisplayUtil.getVirtualLinkButton(connectedLink));
						linksVgroup.addElement(pointLinkHbox);
					}
				}
			}
			
			public function loadDelayPipes():void
			{
				pipes.removeAll();
				if(SelectedSliverType.length>0 && SelectedSliverType == SliverTypes.DELAY)
				{
					for(var i:int = 0; i < node.interfaces.length; i++)
					{
						var first:VirtualInterface = node.interfaces.collection[i];
						for(var j:int = i+1; j < node.interfaces.length; j++)
						{
							var second:VirtualInterface = node.interfaces.collection[j];
							
							var firstPipe:Pipe = node.pipes.getFor(first, second);
							if(firstPipe == null)
							{
								firstPipe = new Pipe(first, second, Math.min(first.capacity, second.capacity));
								pipes.addItem(firstPipe);
							}
							
							var secondPipe:Pipe = node.pipes.getFor(second, first);
							if(secondPipe == null)
							{
								secondPipe = new Pipe(second, first, Math.min(first.capacity, second.capacity));
								pipes.addItem(secondPipe);
							}
						}
					}
				}
			}
			
			public function trySaveAndClose():void
			{
				if(save())
					return;
				closeWindow();
			}
			
			public function save():Boolean
			{
				// Make sure we HAVE a client id
				if(clientIdInput.text.length == 0)
				{
					Alert.show("Either choose an unbound node or choose a node to bind to.", "No bound node indicated");
					return true;
				}
				
				// Make sure the client_id is not taken
				if(!this.node.sliver.slice.slivers.isIdUnique(this.node, this.clientIdInput.text)) {
					Alert.show(this.clientIdInput.text + " is already in use, please choose a different client id");
					return true;
				}
				
				// Guarentee we have enough selected
				if(boundRadiobutton.selected && SelectedBoundNode == null)
				{
					Alert.show("Either choose an unbound node or choose a node to bind to.", "No bound node indicated");
					return true;
				}
				
				// Make sure extensions are valid
				if(this.extensionsTextarea != null) {
					try {
						var extensions:XMLList = new XMLList(extensionsTextarea.text);
						// Add any new namespaces to the sliver
						for each(var extension:XML in extensions) {
							var newNamespaces:Array = [];
							for each(var extensionNamespace:Namespace in extension.namespaceDeclarations()) {
								if(!XmlUtil.isKnownNamespace(extensionNamespace) && this.node.sliver.extensionNamespaces.indexOf(extensionNamespace) == -1) {
									this.node.sliver.extensionNamespaces.push(extensionNamespace);
								}
							}
						}
						this.node.extensionsNodes = new XMLListCollection(extensions);
					} catch(e:Error) {
						if(e.errorID == 1063)
							Alert.show("Prefixes must have namespaces declared. If they are, check that the XML is valid.");
						else
							Alert.show("There was a problem parsing the extensions XML, please make sure the XML is valid.");
						return true;
					}
				}
				
				node.clientId = clientIdInput.text;
				
				if(SelectedManager != node.manager)
				{
					var newManager:GeniManager = this.managerList.selectedItem;
					var newSliver:Sliver = node.sliver.slice.getOrCreateForManager(newManager);
					node.sliver.nodes.remove(node);
					newSliver.nodes.add(node);
					for each(var vi:VirtualInterface in node.interfaces.collection) {
						for each(var vl:VirtualLink in vi.virtualLinks.collection) {
							// See if we need to change the link due to the manager change
							for each(var otherInterface:VirtualInterface in vl.interfaces.collection) {
								if(otherInterface != vi) {
									// Now will be links to another manager
									if(otherInterface.owner.manager == node.manager) {
										vl.setUpTunnels();
										newSliver.links.add(vl);
										break;
									}
										// Now the same manager
									else if(otherInterface.owner.manager == newManager) {
										vl.linkType = VirtualLink.TYPE_NORMAL;
										node.sliver.links.remove(vl);
										break;
									}
									// Otherwise still different managers, no changes needed
								}
							}
						}
					}
				}
				
				// Save changes based on binding
				if(this.unboundRadiobutton.selected)
				{
					if(!hardwareTypeCheckbox.selected)
						this.node.hardwareType = "";
					else
						this.node.hardwareType = hardwareList.selectedItem;
					node.physicalNode = null;
				}
				else
				{
					node.hardwareType = "";
					node.physicalNode = this.SelectedBoundNode;
				}
				
				node.sliverType = SelectedSliverType;
				node.exclusive = exclusiveCheckbox.selected;
				
				// Save changes based on sliver type
				if(node.sliverType == SliverTypes.RAWPC)
					node.setDiskImage(diskImageText.text);
				else
					node.diskImage = "";
				
				node.installServices = new Vector.<InstallService>()
				node.executeServices = new Vector.<ExecuteService>();
				if(node.sliverType == SliverTypes.RAWPC || node.sliverType == SliverTypes.EMULAB_OPENVZ)
				{
					var serviceIdx:int;
					for(serviceIdx = 0; serviceIdx < installVgroup.numElements; serviceIdx++)
					{
						var installService:InstallService = (installVgroup.getElementAt(serviceIdx) as InstallServiceComponent).Service;
						if(installService.url.length > 0)
							node.installServices.push(installService);
					}
					for(serviceIdx = 0; serviceIdx < executeVgroup.numElements; serviceIdx++)
					{
						var executeService:ExecuteService = (executeVgroup.getElementAt(serviceIdx) as ExecuteServiceComponent).Service;
						if(executeService.command.length > 0)
							node.executeServices.push(executeService);
					}
				}
				
				// Save changes to pipes
				node.pipes = new PipeCollection();
				if(node.sliverType == SliverTypes.DELAY)
				{
					for each(var pipeObj:Object in pipes)
					{
						var pipe:Pipe = pipeObj.source;
						pipe.capacity = pipeObj.capacity;
						pipe.latency = pipeObj.latency;
						pipe.packetLoss = pipeObj.packetLoss;
						node.pipes.add(pipe);
					}
				}
				
				if(node.sliverType != SliverTypes.PLANETLAB || planetlabInitscriptDropdownlist.selectedItem == null)
					node.selectedPlanetLabInitscript = "";
				else
					node.selectedPlanetLabInitscript = planetlabInitscriptDropdownlist.selectedItem;
				
				// Save changes to interfaces
				for each(var ifaceObj:Object in interfaces)
				{
					var iface:VirtualInterface = ifaceObj.source;
					iface.id = ifaceObj.clientId;
					iface.ip = ifaceObj.ipaddress;
					iface.netmask = ifaceObj.ipnetmask;
					iface.type = ifaceObj.iptype;
				}
				
				
				Main.geniDispatcher.dispatchSliceChanged(node.sliver.slice);
				
				return false;
			}
			
		]]>
	</fx:Script>
	
	<s:Group width="100%">
		<s:Rect width="100%" height="100%">
			<s:fill><s:SolidColor color="{backgroundColor}" /></s:fill>
		</s:Rect>
		
		<s:HGroup width="100%"
				  verticalAlign="middle"
				  paddingLeft="4"
				  paddingRight="4"
				  paddingTop="4"
				  paddingBottom="4">
			<s:TextInput id="clientIdInput"
						 width="100%"
						 fontWeight="bold"
						 fontSize="16"
						 restrict="a-zA-Z0-9\\-"
						 toolTip="{node.clientId}" />
			<s:Image id="statusImage"
					 visible="false" includeInLayout="{statusImage.visible}"
					 toolTip="Status: {node.status}, State: {node.state}" />
			<components:ImageButton id="errorButton"
									visible="false"
									includeInLayout="{errorButton.visible}"
									click="Alert.show(node.error,'Error Message')" />
			<s:Button id="manifestButton"
					  icon="{ImageUtil.pageWhiteCodeIcon}"
					  visible="false"
					  includeInLayout="{manifestButton.visible}"
					  label="View Manifest"
					  toolTip="View Manifest RSPEC"
					  click="viewManifest()" height="24" />
			<s:Button id="previewButton"
					  icon="{ImageUtil.pageCodeIcon}"
					  label="View Preview"
					  toolTip="View Preview RSPEC"
					  click="previewRspec()" height="24" />
		</s:HGroup>
		
	</s:Group>
	
	<s:HGroup id="loginGroup"
			  width="100%"
			  verticalAlign="middle"
			  visible="false"
			  horizontalAlign="center"
			  paddingTop="4"
			  paddingLeft="4"
			  paddingRight="4"
			  paddingBottom="4"
			  includeInLayout="{loginGroup.visible}">
		<s:Label text="Username" fontWeight="bold" />
		<mx:Label id="usernameText" selectable="true" />
		<s:Label text="Hostname" fontWeight="bold" />
		<mx:Label id="hostnameText" selectable="true" />
		<s:Button label="Visit" click="visitHost()" />
		<s:Button label="SSH" click="openSsh()" />
	</s:HGroup>
	
	<s:ButtonBar dataProvider="{sectionViewstack}"
				 requireSelection="true"
				 skinClass="protogeni.display.skins.ButtonBarSkin"
				 width="100%" />
	<mx:ViewStack id="sectionViewstack"
				  width="100%"
				  height="100%"
				  paddingTop="4"
				  paddingLeft="4"
				  paddingRight="4"
				  paddingBottom="4">
		<s:NavigatorContent icon="{ImageUtil.infoIcon}" toolTip="Basic" height="100%" width="100%">
			<s:VGroup height="100%" width="100%">
				<s:HGroup width="100%">
					<s:VGroup width="20%">
						<s:Label text="Manager" fontWeight="bold" />
						<s:DropDownList id="managerList"
										toolTip="Select a manager..."
										prompt="Select a manager..."
										width="100%" height="24"
										labelField="Hrn"
										dataProvider="{managers}"
										valueCommit="managerList_valueCommitHandler(event)" />
					</s:VGroup>
					
					<s:VGroup width="60%">
						<s:Label text="Binding" fontWeight="bold" />
						<s:HGroup width="100%" verticalAlign="middle" id="unboundVgroup">
							<s:RadioButton id="unboundRadiobutton"
										   group="{boundGroup}"
										   label="Unbound" />
							<s:CheckBox id="hardwareTypeCheckbox" />
							<s:DropDownList id="hardwareList"
											toolTip="Type..."
											prompt="Type..."
											enabled="{!SelectedBounded}"
											requireSelection="{hardwareTypeCheckbox.selected}"
											labelField="name"
											valueCommit="hardwareList_valueCommitHandler(event)"
											dataProvider="{hardwareForVirtual}"
											width="100%" height="24" />
						</s:HGroup>
						<s:HGroup width="100%" verticalAlign="middle" id="boundVgroup">
							<s:RadioButton id="boundRadiobutton"
										   group="{boundGroup}"
										   label="Bound to" />
							<s:DropDownList id="boundDropDownList"
											dataProvider="{physicalNodes}"
											width="100%" height="24"
											valueCommit="boundDropDownList_valueCommitHandler(event)"
											labelField="name" />
							<components:ImageButton id="viewPhysicalNode"
													icon="{ImageUtil.infoIcon}"
													enabled="{boundDropDownList.selectedItem != null}"
													click="DisplayUtil.viewPhysicalNode(boundDropDownList.selectedItem)" />
						</s:HGroup>
						
					</s:VGroup>
					<s:VGroup width="20%">
						<s:Label text="Sliver Type" fontWeight="bold" />
						<s:DropDownList id="sliverTypeDropDownList"
										dataProvider="{sliverTypes}"
										width="100%" height="24"
										labelField="name"
										valueCommit="sliverTypeDropDownList_valueCommitHandler(event)" />
						<s:CheckBox id="exclusiveCheckbox"
									label="Exclusive?" />
					</s:VGroup>
				</s:HGroup>
				<mx:ViewStack id="detailsViewstack" width="100%" height="100%">
					<s:NavigatorContent id="detailsView" width="100%" height="100%">
						<s:VGroup id="nodeOptionsVgroup" width="100%" height="100%">
							<s:VGroup id="diskImageGroup" width="100%" includeInLayout="{diskImageGroup.visible}">
								<s:HGroup width="100%" verticalAlign="middle">
									<s:Label text="Disk Image" fontWeight="bold" />
									<s:Rect />
									<s:DropDownList id="diskImageSelect" width="100%" height="24"
													prompt="Select image to override default"
													dataProvider="{diskImages}"
													labelField="description"
													change="diskImageText.text = diskImageSelect.selectedItem.name" />
								</s:HGroup>
								<s:TextInput id="diskImageText" width="100%" height="24"
											 prompt="Select image above, paste URN, or manually type OSID" />
							</s:VGroup>
							<s:HGroup width="100%" height="100%" id="servicesGroup">
								<s:VGroup id="installServicesVgroup" width="50%" height="100%">
									<s:HGroup width="100%" verticalAlign="middle">
										<s:Label text="Install" fontWeight="bold" />
										<s:Rect percentWidth="100" />
										<s:Button id="addInstallButton"
												  icon="{ImageUtil.addIcon}"
												  label="Add Install Service"
												  click="addInstallService()" height="24" />
									</s:HGroup>
									
									<s:Scroller width="100%" height="100%">
										<s:VGroup id="installVgroup" width="100%" paddingRight="4" />
									</s:Scroller>
								</s:VGroup>
								<s:VGroup id="executeServicesVgroup" width="50%" height="100%">
									<s:HGroup width="100%" verticalAlign="middle">
										<s:Label text="Execute" fontWeight="bold" />
										<s:Rect percentWidth="100" />
										<s:Button id="addExecuteButton" height="24"
												  icon="{ImageUtil.addIcon}"
												  label="Add Execute Service"
												  click="addExecuteService()" />
									</s:HGroup>
									<s:Scroller width="100%" height="100%">
										<s:VGroup id="executeVgroup" width="100%" paddingRight="4" />
									</s:Scroller>
								</s:VGroup>
							</s:HGroup>
						</s:VGroup>
					</s:NavigatorContent>
					<s:NavigatorContent id="planetlabView" width="100%" height="100%">
						<s:VGroup height="100%" width="100%">
							<s:CheckBox id="usePlanetlabInitCheckbox"
										label="Run" />
							<s:DropDownList id="planetlabInitscriptDropdownlist"
											dataProvider="{planetlabInitscripts}"
											valueCommit="if(planetlabInitscriptDropdownlist.selectedItem != null) usePlanetlabInitCheckbox.selected = true"
											width="100%" height="24" />
						</s:VGroup>
					</s:NavigatorContent>
					<s:NavigatorContent id="delayView" width="100%" height="100%">
						<s:DataGrid id="delayGrid" width="100%" height="100%" 
									dataProvider="{pipes}"
									rowHeight="24"
									editable="true">
							<s:columns>
								<s:ArrayList>
									<s:GridColumn headerText="Pipe" editable="false">
										<s:itemRenderer>
											<fx:Component>
												<s:GridItemRenderer>
													<s:HGroup height="100%" verticalAlign="middle" paddingLeft="2">
														<s:Label text="{data.src.clientId}" fontWeight="bold" />
														<s:Label text="->" />
														<s:Label text="{data.dst.clientId}" fontWeight="bold" />
													</s:HGroup>
												</s:GridItemRenderer>
											</fx:Component>
										</s:itemRenderer>
									</s:GridColumn>
									<s:GridColumn dataField="capacity"
												  headerText="Capacity"
												  itemRenderer="protogeni.display.components.NumericGridRenderer"
												  itemEditor="protogeni.display.components.NumericEditor">
									</s:GridColumn>
									<s:GridColumn dataField="latency" 
												  headerText="Latency"
												  itemRenderer="protogeni.display.components.NumericGridRenderer"
												  itemEditor="protogeni.display.components.NumericEditor">
									</s:GridColumn>
									<s:GridColumn dataField="packetLoss" 
												  headerText="Packet Loss"
												  itemRenderer="protogeni.display.components.NumericGridRenderer"
												  itemEditor="protogeni.display.components.NumericEditor">
									</s:GridColumn>
								</s:ArrayList> 
							</s:columns>
						</s:DataGrid> 
					</s:NavigatorContent>
				</mx:ViewStack>
			</s:VGroup>
		</s:NavigatorContent>
		<s:NavigatorContent icon="{ImageUtil.linkIcon}" toolTip="Interfaces and Links" height="100%" width="100%">
			<s:VGroup creationComplete="fillLinksTo();" width="100%" height="100%">
				<s:DataGrid id="interfaceGrid" width="100%" height="40%" 
							dataProvider="{interfaces}"
							rowHeight="24"
							editable="true">
					<s:columns>
						<s:ArrayList>
							<s:GridColumn dataField="clientId"
										  headerText="Interface">
								<s:itemEditor>
									<fx:Component>
										<s:DefaultGridItemEditor />
									</fx:Component>
								</s:itemEditor>
								<s:itemRenderer>
									<fx:Component>
										<s:DefaultGridItemRenderer />
									</fx:Component>
								</s:itemRenderer>
							</s:GridColumn>
							<s:GridColumn dataField="macAddress"
										  headerText="MAC"
										  editable="false">
								<s:itemRenderer>
									<fx:Component>
										<s:DefaultGridItemRenderer />
									</fx:Component>
								</s:itemRenderer>
							</s:GridColumn>
							<s:GridColumn dataField="ipaddress"
										  headerText="IP">
								<s:itemEditor>
									<fx:Component>
										<s:DefaultGridItemEditor />
									</fx:Component>
								</s:itemEditor>
								<s:itemRenderer>
									<fx:Component>
										<s:DefaultGridItemRenderer />
									</fx:Component>
								</s:itemRenderer>
							</s:GridColumn>
							<s:GridColumn dataField="ipnetmask" 
										  headerText="Mask">
								<s:itemEditor>
									<fx:Component>
										<s:DefaultGridItemEditor />
									</fx:Component>
								</s:itemEditor>
								<s:itemRenderer>
									<fx:Component>
										<s:DefaultGridItemRenderer />
									</fx:Component>
								</s:itemRenderer>
							</s:GridColumn>
						</s:ArrayList> 
					</s:columns>
				</s:DataGrid>
				<s:Scroller width="100%" height="60%">
					<s:VGroup width="100%" height="100%" id="linksVgroup" />
				</s:Scroller>
			</s:VGroup>
		</s:NavigatorContent>
		<s:NavigatorContent icon="{ImageUtil.extensionsIcon}" toolTip="Extensions" height="100%" width="100%">
			<s:VGroup width="100%" height="100%" creationComplete="initExtensions()">
				<s:Label text="ALL Namespace declarations MUST be included for new extensions pasted below." />
				<s:TextArea id="extensionsTextarea" width="100%" height="100%" />
			</s:VGroup>
		</s:NavigatorContent>
	</mx:ViewStack>
	
	<components:controlBarLayout>
		<s:HorizontalLayout gap="4" paddingBottom="4" paddingTop="4" paddingRight="4" paddingLeft="4" />
	</components:controlBarLayout>
	<components:controlBarContent>
		<s:Button id="okButton"
				  label="Apply"
				  icon="{ImageUtil.availableIcon}"
				  click="trySaveAndClose();" height="24" />
		<s:Button id="cancelButton"
				  label="Cancel"
				  icon="{ImageUtil.cancelIcon}"
				  click="closeWindow();" height="24" />
	</components:controlBarContent>
</components:DefaultWindow>