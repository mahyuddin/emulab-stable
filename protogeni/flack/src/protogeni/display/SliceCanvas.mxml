<?xml version="1.0" encoding="utf-8"?>
<s:BorderContainer xmlns:fx="http://ns.adobe.com/mxml/2009" 
				   xmlns:s="library://ns.adobe.com/flex/spark" 
				   xmlns:mx="library://ns.adobe.com/flex/mx"
				   width="100%" height="100%" backgroundColor="#F6F6F6" borderStyle="solid" borderColor="#CDC2C2"
				   dragEnter="dragEnterHandler(event)"  dragDrop="dragDropHandler(event)"
				   mouseMove="mouseMoveHandler(event)"
				   mouseUp="mouseUpHandler(event)">
	<fx:Script>
		<![CDATA[
			import mx.collections.ArrayCollection;
			import mx.events.DragEvent;
			import mx.managers.DragManager;
			
			import protogeni.display.mapping.GeniMapMarker;
			import protogeni.resources.PhysicalNode;
			import protogeni.resources.Slice;
			import protogeni.resources.Sliver;
			import protogeni.resources.VirtualLink;
			import protogeni.resources.VirtualLinkCollection;
			import protogeni.resources.VirtualNode;
			import protogeni.resources.VirtualNodeCollection;
			
			import spark.components.List; 
			
			[Bindable]
			public var slice:Slice;
			
			public var startNode:SliceNode = null;
			public var currentNode:SliceNode = null;
			public var tempLink:SliceLink;
			public var hostWindow:SliceWindow;
			
			public var allNodes:SliceNodeCollection = new SliceNodeCollection();
			public var allLinks:SliceLinkCollection = new SliceLinkCollection();
			
			private var edited:Boolean = false;
			
			public function load(newSlice:Slice):void
			{
				slice = newSlice.clone(false);
				
				// Nodes
				for each(var sliver:Sliver in slice.slivers.collection)
				{
					for each(var n:VirtualNode in sliver.nodes.collection)
						this.addVirtualNodeToCanvas(n);
				}
				
				// Links
				for each(var s:Sliver in slice.slivers.collection)
				{
					for each(var l:VirtualLink in s.links.collection)
						this.addVirtualLinkToCanvas(l);
				}
				
				edited = !slice.isCreated();
			}
			
			public function refreshSlice():void
			{
				redrawAllLinks();
				
				if(!slice.hasAllAllocatedResources() && !slice.isStaged())
					return;
				
				var unaddedNodes:VirtualNodeCollection = slice.GetAllNodes();
				
				// Remove/replace old nodes
				for(var i:int = 0; i < this.allNodes.length; i++)
				{
					var sn:SliceNode = allNodes[i];
					var vn:VirtualNode = slice.getVirtualNodeWithId(sn.lastId);
					if(vn == null)
					{
						this.removeElement(sn);
						allNodes.removeItemAt(i);
						i--;
					}
					else
					{
						for(var j:int = 0; j < unaddedNodes.length; j++)
						{
							if(unaddedNodes.collection[j].clientId == sn.lastId)
							{
								unaddedNodes.remove(unaddedNodes.collection[j]);
								break;
							}
						}
						//unadded.removeItemAt(unadded.getItemIndex(vn));
						sn.setNode(slice.getVirtualNodeWithId(sn.lastId));
						sn.resetToStatus();
					}
				}
				
				// Add new nodes
				for each(var unaddedNode:VirtualNode in unaddedNodes.collection)
					this.addVirtualNodeToCanvas(unaddedNode);
				
				var unaddedLinks:VirtualLinkCollection = slice.GetAllLinks();
				
				// Remove/replace old links
				for(i = 0; i < this.allLinks.length; i++)
				{
					var sl:SliceLink = allLinks[i];
					var vl:VirtualLink = slice.getVirtualLinkWithId(sl.lastId);
					if(vl == null)
					{
						this.removeElement(sl.group);
						this.removeElement(sl);
						allLinks.removeItemAt(i);
						i--;
					}
					else
					{
						for(j = 0; j < unaddedLinks.length; j++)
						{
							if(unaddedLinks.collection[j].clientId == sl.lastId)
							{
								unaddedLinks.remove(unaddedLinks.collection[j]);
								break;
							}
						}
						//unadded.removeItemAt(unadded.getItemIndex(vl));
						sl.setLink(slice.getVirtualLinkWithId(sl.lastId));
					}
				}
				
				// Add new
				for each(var unaddedLink:VirtualLink in unaddedLinks.collection)
					this.addVirtualLinkToCanvas(unaddedLink);
				
				hostWindow.loadNodes();
				
				edited = !slice.isCreated();
			}
			
			public function refreshStatus():void
			{
				switch(this.slice.Status())
				{
					case Sliver.STATUS_READY:
						this.setStyle("borderColor", "green");
						this.setStyle("backgroundColor", "#CCFFCC");
						break;
					case Sliver.STATUS_FAILED:
						this.setStyle("borderColor", "red");
						this.setStyle("backgroundColor", "#FFD9D9");
						break;
					case Sliver.STATUS_CHANGING:
					case Sliver.STATUS_NOTREADY:
					case Sliver.STATUS_UNKOWN:
					case Sliver.STATUS_MIXED:
						this.setStyle("borderColor", "#FF7F00");
						this.setStyle("backgroundColor", "#FFE0C1");
						break;
					default:
						this.setStyle("borderColor", "#CDC2C2");
						this.setStyle("backgroundColor", "#F6F6F6");
				}
			}
			
			private  function dragEnterHandler(event:DragEvent):void {
				if (event.dragSource.hasFormat("canvas") ||
					event.dragSource.hasFormat("marker") ||
					event.dragSource.hasFormat("physicalnode") ||
					(event.dragInitiator is List &&
						(List(event.dragInitiator).selectedItem is VirtualNode ||
							(List(event.dragInitiator).selectedItem is PhysicalNode &&
								PhysicalNode(List(event.dragInitiator).selectedItem).available &&
								!allNodes.containsPhysicalNode(PhysicalNode(List(event.dragInitiator).selectedItem))))))
				{
					DragManager.acceptDragDrop(SliceCanvas(event.currentTarget));
				}
			}
			
			private function dragDropHandler(event:DragEvent):void {
				// Handle dragging from lists
				if(event.dragInitiator is List)
				{
					if(List(event.dragInitiator).selectedItem is PhysicalNode)
					{
						addPhysicalNode(List(event.dragInitiator).selectedItem as PhysicalNode,
							SliceCanvas(event.currentTarget).mouseX,
							SliceCanvas(event.currentTarget).mouseY);
						
					} else if(List(event.dragInitiator).selectedItem is VirtualNode) {
						var dragNode:VirtualNode = List(event.dragInitiator).selectedItem as VirtualNode;
						var nvn:VirtualNode = new VirtualNode(slice.getOrCreateSliverFor(dragNode.manager));
						nvn.Exclusive = dragNode.Exclusive;
						nvn.clientId = slice.getUniqueVirtualNodeId(nvn);
						this.addVirtualNode(nvn,
							SliceCanvas(event.currentTarget).mouseX,
							SliceCanvas(event.currentTarget).mouseY);
					}
				}
				else if(event.dragSource.hasFormat("marker"))
				{
					var dragSource:GeniMapMarker = event.dragSource.dataForFormat('marker') as GeniMapMarker;
					var vn:VirtualNode = new VirtualNode(slice.getOrCreateSliverFor(dragSource.nodeGroups.collection[0].collection[0].manager));
					vn.clientId = slice.getUniqueVirtualNodeId(vn);
					this.addVirtualNode(vn,
						SliceCanvas(event.currentTarget).mouseX,
						SliceCanvas(event.currentTarget).mouseY);
				} else if(event.dragSource.hasFormat("physicalnode")) {
					addPhysicalNode(event.dragSource.dataForFormat('physicalnode') as PhysicalNode,
						SliceCanvas(event.currentTarget).mouseX,
						SliceCanvas(event.currentTarget).mouseY);
				}
				
				// Handle dragging old one
				else if(this.contains(event.dragInitiator as DisplayObject))
				{
					SliceNode(event.dragInitiator).setLocation(SliceCanvas(event.currentTarget).mouseX - SliceNode(event.dragInitiator).startX,
						SliceCanvas(event.currentTarget).mouseY - SliceNode(event.dragInitiator).startY);
					redrawAllLinks();
				}
			}
			
			public function removeVirtualNode(vn:VirtualNode):void
			{
				for each(var sn:SliceNode in this.allNodes)
				{
					if(sn.node == vn)
						removeSliceNode(sn);
				}
			}
			
			public function removeSliceNode(sn:SliceNode):void
			{
				// Remove subnodes
				for each(var sub:VirtualNode in sn.node.subNodes.collection)
					removeVirtualNode(sub);
				
				// Remove links
				while(sn.links.length > 0)
					sn.links[0].removeLink();
				
				// Remove nodes and slivers
				for each(var s:Sliver in sn.node.slivers.collection)
				{
					if(s.nodes.contains(sn.node))
						s.nodes.remove(sn.node);
					if(s.nodes.length == 0 && slice.slivers.contains(s))
						slice.slivers.remove(s);
				}
				
				this.removeElement(sn);
				allNodes.removeItemAt(allNodes.getItemIndex(sn));
				hostWindow.loadNodes();
				edited = true;
			}
			
			public function addVirtualLinkToCanvas(vl:VirtualLink):SliceLink
			{
				if(this.allLinks.containsVirtualLink(vl))
					return this.allLinks.getForVirtualLink(vl);
				
				var sl:SliceLink = new SliceLink(this);
				sl.establishFromExisting(vl);
				sl.drawEstablished();
				this.addElement(sl);
				validateNow();
				redrawAllLinks();
				edited = true;
				return sl;
			}
			
			public function addVirtualNodeToCanvas(vn:VirtualNode, x:int = -1, y:int = -1):SliceNode
			{
				if(allNodes.containsVirtualNode(vn))
					return allNodes.getForVirtualNode(vn);
				
				var sn:SliceNode = new SliceNode();
				sn.setNode(vn);
				addSliceNode(sn, x, y);
				return sn;
			}
			
			public function addVirtualNode(vn:VirtualNode, x:int = -1, y:int = -1):SliceNode
			{
				// Don't duplicate
				if(allNodes.containsVirtualNode(vn))
					return allNodes.getForVirtualNode(vn);
				
				var sn:SliceNode = addVirtualNodeToCanvas(vn, x, y);
				if(!vn.slivers.collection[0].nodes.contains(vn))
					vn.slivers.collection[0].nodes.add(vn);
				
				// See if we need to connect to a parent node
				if(vn.superNode != null)
				{
					if(!allNodes.containsVirtualNode(vn.superNode))
						sn.node.superNode = addVirtualNode(vn.superNode, x + 40, y + 40).node;
					else
						sn.node.superNode = allNodes.getForVirtualNode(vn.superNode).node;
					sn.node.superNode.subNodes.add(sn.node);
				} else if(vn.physicalNode != null && vn.physicalNode.subNodeOf != null)
				{
					if(!allNodes.containsPhysicalNode(vn.physicalNode.subNodeOf))
						sn.node.superNode = addPhysicalNode(vn.physicalNode.subNodeOf, x + 40, y + 40).node;
					else
						sn.node.superNode = allNodes.getForPhysicalNode(vn.physicalNode.subNodeOf).node;
					sn.node.superNode.subNodes.add(sn.node);
				}
				
				return sn;
			}
			
			public function addPhysicalNodeToCanvas(pn:PhysicalNode, x:int = -1, y:int = -1):SliceNode
			{
				if(allNodes.containsPhysicalNode(pn))
					return allNodes.getForPhysicalNode(pn);
				
				var sn:SliceNode = new SliceNode();
				var newVirtualNode:VirtualNode = new VirtualNode(slice.getOrCreateSliverFor(pn.manager));
				newVirtualNode.setToPhysicalNode(pn);
				sn.setNode(newVirtualNode);
				addSliceNode(sn, x, y);
				return sn;
			}
			
			public function addPhysicalNode(pn:PhysicalNode, x:int = -1, y:int = -1):SliceNode
			{
				// Don't duplicate
				if(allNodes.containsPhysicalNode(pn))
					return allNodes.getForPhysicalNode(pn);
				
				var sn:SliceNode = addPhysicalNodeToCanvas(pn, x, y);
				if(!sn.node.slivers.collection[0].nodes.contains(sn.node))
					sn.node.slivers.collection[0].nodes.add(sn.node);
				
				// See if we need to connect to a parent node
				if(pn.subNodeOf != null)
				{
					if(!allNodes.containsPhysicalNode(pn.subNodeOf))
						sn.node.superNode = addPhysicalNode(pn.subNodeOf, x + 40, y + 40).node;
					else
						sn.node.superNode = allNodes.getForPhysicalNode(pn.subNodeOf).node;
					sn.node.superNode.subNodes.add(sn.node);
				}
				edited = true;
				return sn;
			}
			
			public function addSliceNode(sn:SliceNode, x:int = -1, y:int = -1):void
			{
				if(allNodes.contains(sn))
					return;
				sn.canvas = this;
				this.addElement(sn);
				this.validateNow();
				var addX:int = (x == -1) ? sn.node.flackX : x;
				var addY:int = (y == -1) ? sn.node.flackY : y;
				sn.setLocation(addX, addY);
				sn.adjustWidth();
				allNodes.addItem(sn);
				edited = true;
				
				if(sn.node.physicalNode != null && hostWindow.nodes != null && hostWindow.nodes.getItemIndex(sn.node.physicalNode) > -1)
					hostWindow.nodes.removeItemAt(hostWindow.nodes.getItemIndex(sn.node.physicalNode));
			}
			
			public function startLinkingFrom(node:SliceNode):void
			{
				startNode = node;
				tempLink = new SliceLink(this);
			}
			
			protected function mouseMoveHandler(event:MouseEvent):void
			{
				if(startNode != null)
				{
					// See if a node is under
					currentNode = null;
					for each(var sn:SliceNode in allNodes)
					{
						if(sn != startNode
							&& sn.getRect(this).contains(mouseX, mouseY)
							&& !allLinks.hasLinkFor(startNode, sn)) {
							currentNode = sn;
							break;
						}
					}
					
					// Add sprite to Canvas display list
					tempLink.drawEstablishing(startNode.x + startNode.width/2,
						startNode.y + startNode.height/2,
						mouseX,
						mouseY, currentNode != null);
					addElement(tempLink);
				} else if(tempLink != null && this.contains(tempLink))
					removeElement(tempLink);
			}
			
			protected function mouseUpHandler(event:MouseEvent):void
			{
				// Add link if needed
				if(startNode != null && currentNode != null) {
					if(tempLink.establish(startNode, currentNode)) {
						tempLink.drawEstablished();
						edited = true;
					} else
						removeElement(tempLink);
				} else if(tempLink != null && contains(tempLink))
					removeElement(tempLink);
				validateNow();
				
				// Reset
				startNode = null;
				currentNode = null;
				tempLink = null;
				redrawAllLinks();
			}
			
			public function clear():void {
				while(this.allNodes.length > 0)
					this.removeSliceNode(this.allNodes.getItemAt(0) as SliceNode);
			}
			
			public function isEdited():Boolean {
				if(edited) {
					return slice.isCreated() || this.allNodes.length > 0;
				} else
					return false;
			}
			
			// RAW CHILDREN FUNCTIONS
			public function redrawAllLinks():void
			{
				for each(var sl:SliceLink in allLinks)
				{
					sl.drawEstablished();
					this.setElementIndex(sl, 0);
				}
			}
		]]>
	</fx:Script>
</s:BorderContainer>
