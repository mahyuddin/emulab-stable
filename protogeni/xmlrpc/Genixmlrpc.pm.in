#!/usr/bin/perl -w
#
# EMULAB-COPYRIGHT
# Copyright (c) 2008 University of Utah and the Flux Group.
# All rights reserved.
#
# Perl code to access an XMLRPC server using http. Derived from the
# Emulab library (pretty sure Dave wrote the http code in that file,
# and I'm just stealing it).
#
package Genixmlrpc;
use strict;
use Exporter;
use vars qw(@ISA @EXPORT);
@ISA    = "Exporter";
@EXPORT = qw();

# Must come after package declaration!
use lib '@prefix@/lib';
use English;
use GeniResponse;
use RPC::XML;
use RPC::XML::Parser;
use LWP::UserAgent;
use HTTP::Request::Common qw(POST);
use HTTP::Headers;
use Data::Dumper;

# Configure variables
my $TB		= "@prefix@";
my $TBOPS       = "@TBOPSEMAIL@";
my $BOSSNODE    = "@BOSSNODE@";
my $EMULAB_PEMFILE = "@prefix@/etc/genisa.pem";

my $debug = 0;

##
# The package version number
#
my $PACKAGE_VERSION = 0.1;

#
# This is the "structure" returned by the RPC server. It gets converted into
# a perl hash by the unmarshaller, and we return that directly to the caller
# (as a reference).
#
# class EmulabResponse:
#    def __init__(self, code, value=0, output=""):
#        self.code     = code            # A RESPONSE code
#        self.value    = value           # A return value; any valid XML type.
#        self.output   = output          # Pithy output to print
#        return
#

#
# Call to a non-Emulab xmlrpc server.  
# If there was an HTTP error, the hash also contains the keys
# httpcode and httpmsg.
#
sub CallMethodHTTP($$$@)
{
    my ($httpURL, $user, $method, @args) = @_;

    #
    # This is for the Crypt::SSL library, many levels down. It appears to
    # be the only way to specify this. Even worse, when we want to use
    # an encrypted key belonging to a user, have to use the pkcs12 format
    # of the file, since that is the only format for which we can provide
    # the passphrase.
    #
    if (!defined($user)) {
	$ENV{'HTTPS_CERT_FILE'} = $EMULAB_PEMFILE;
	$ENV{'HTTPS_KEY_FILE'}  = $EMULAB_PEMFILE;
    }
    else {
	my $pkcs12 = $user->HomeDir() . "/.ssl/encrypted.p12";
	my $password;
	$user->SSLPassPhrase(1,\$password);
	$ENV{'HTTPS_PKCS12_FILE'}     = $pkcs12;
	$ENV{'HTTPS_PKCS12_PASSWORD'} = $password;
	print "$password, $pkcs12\n";
    }

    my $request = new RPC::XML::request($method, @args);
    if ($debug > 1) {
	print STDERR "xml request: " . $request->as_string();
	print STDERR "\n";
    }

    #
    # Send an http post.
    #
    my $reqstr = $request->as_string();
    my $ua = LWP::UserAgent->new();
    my $hreq = HTTP::Request->new(POST => $httpURL);
    $hreq->content_type('text/xml');
    $hreq->content($reqstr);
    my $hresp = $ua->request($hreq);

    if ($debug) {
	print STDERR "xml response: " . $hresp->as_string();
	print STDERR "\n";
    }
    
    if (!$hresp->is_success()) {
	return GeniResponse->new(GENIRESPONSE_RPCERROR,
				 $hresp->code(), $hresp->message());
    }

    #
    # Read back the xmlgoo from the child.
    #
    my $xmlgoo = $hresp->content();

    if ($debug) {
	print STDERR "xmlgoo: " . $xmlgoo;
	print STDERR "\n";
    }

    #
    # Convert the xmlgoo to Perl and return it.
    #
    my $parser   = RPC::XML::Parser->new();
    my $goo      = $parser->parse($xmlgoo);
    my ($value,$output,$code);

    #print Dumper($goo);
    
    # Python servers seem to return faults in structs, not as <fault> elements.
    # Sigh.
    if (!ref($goo)) {
        print STDERR "Error in XMLRPC parse: $goo\n";
        return undef;
    }
    elsif ($goo->value()->is_fault() 
	|| (ref($goo->value()) && UNIVERSAL::isa($goo->value(),"HASH") 
	    && exists($goo->value()->{'faultCode'}))) {
	$code   = $goo->value()->{"faultCode"}->value;
	$value  = $code;
	$output = $goo->value()->{"faultString"}->value;
    }
    else {
	$code   = $goo->value()->{'code'}->value;
	$value  = $goo->value()->{'value'}->value;
	$output = $goo->value()->{'output'}->value;
    }
    return GeniResponse->new($code, $value, $output);
}

# _Always_ make sure that this 1 is at the end of the file...

1;
