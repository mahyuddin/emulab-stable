#!/usr/bin/perl -w
#
# GENIPUBLIC-COPYRIGHT
# Copyright (c) 2008-2010 University of Utah and the Flux Group.
# All rights reserved.
#

#
# Simple CGI interface to the GENI xmlrpc interface. This script is invoked
# from the web server. The certificate information is in the environment
# set up by apache.
#
use strict;
use English;
use Frontier::Responder;
use Frontier::RPC2;
use Data::Dumper;
use POSIX;
use Crypt::X509;
use Crypt::OpenSSL::X509;

# Yack. apache does not close fds before the exec, and if this dies
# we are left with a giant mess.
BEGIN {
    no warnings;
    for (my $i = 3; $i < 1024; $i++) {
      POSIX:close($i);
    }
}

# Do this early so that we talk to the right DB.
use vars qw($GENI_DBNAME);
BEGIN { $GENI_DBNAME = "geni-cm"; }

# Configure variables
my $EMULAB_PEMFILE = "@prefix@/etc/genicm.pem";
my $MAINSITE 	   = @TBMAINSITE@;
my $VERSION	   = "1.0";

# Testbed libraries.
use lib '@prefix@/lib';
use GeniAM;
use Genixmlrpc;
use GeniResponse;
use libaudit;

# Geniuser.
my $user  = "geniuser";
my $group = "GeniSlices";

# Need a command line option.
my $debug = 0;

# Determined by version.
my $responder;

#
# Turn off line buffering on output
#
$| = 1;

#
# Untaint the path
#
$ENV{'PATH'} = '/bin:/usr/bin:/usr/local/bin';
delete @ENV{'IFS', 'CDPATH', 'ENV', 'BASH_ENV'};

#
# So we know who/what we are acting as.
#
my $certificate = GeniCertificate->LoadFromFile($EMULAB_PEMFILE);
if (!defined($certificate)) {
    die("*** $0:\n".
	"    Could not get uuid from $EMULAB_PEMFILE\n");
}
$ENV{'MYUUID'} = $certificate->uuid();
# The URN could also come from the certificate, and that might be preferable
# in some ways (if anybody is doing something silly like authenticating
# with somebody else's certificate).  But that would require everybody to
# upgrade to URNs in their certificates, so we can't assume it yet.
$ENV{'MYURN'} = "urn:publicid:IDN+@OURDOMAIN@+authority+cm";

#
# Helper function to return a properly formated XML error.
#
sub XMLError($$)
{
    my ($code, $string) = @_;

    my $decoder = Frontier::RPC2->new();
    print "Content-Type: text/xml \n\n";
    print $decoder->encode_fault($code, $string);
    exit(0);
}

#
# Make sure the client presented a valid certificate that apache says
# is okay.
#
# THIS HAS TO BE HERE! Why? Cause recent security patches disable SSL
# renegotiation, which is needed when a subdir turns on ssl client
# verification (as httpd.conf used to). Now, we set it to "optional",
# which avoids the renegotiation problem, but we have to make that
# this interface is always invoked by a client supplying a verifiable
# certificate. 
#
if (! (exists($ENV{'SSL_CLIENT_VERIFY'}) &&
       $ENV{'SSL_CLIENT_VERIFY'} eq "SUCCESS")) {
    XMLError(-1, "Invalid or missing certificate");
}

#
# In the prototype, we accept certificate signed by trusted roots
# (CA certs we have locally cached). This script runs as "geniuser"
# so that there is an emulab user context, or many of the scripts we
# invoke will complain and croak. 
#
my $unix_uid = getpwnam("$user") or
    die("*** $0:\n".
	"    No such user $user\n");
my $unix_gid = getgrnam("$group") or
    die("*** $0:\n".
	"    No such group $group\n");

# Flip to user and never go back
$GID            = $unix_gid;
$EGID           = "$unix_gid $unix_gid";
$EUID = $UID    = $unix_uid;
$ENV{'USER'}    = $user;
$ENV{'LOGNAME'} = $user;

#
# The UUID of the client certificate is in the env var SSL_CLIENT_S_DN_CN.
# If it actually looks like a UUID, then this correponds to an actual user,
# and the supplied credentials/tickets must match. At present, if there is
# no UUID, it is another emulab making a request directly, with no user
# context, and we just let that pass for now.
#
if (exists($ENV{'SSL_CLIENT_S_DN_CN'}) &&
    $ENV{'SSL_CLIENT_S_DN_CN'} =~ /^\w+\-\w+\-\w+\-\w+\-\w+$/) {
    $ENV{'GENIUSER'} = $ENV{'SSL_CLIENT_S_DN_CN'};
    $ENV{'GENIUUID'} = $ENV{'SSL_CLIENT_S_DN_CN'};
}
else {
    XMLError(-1, "Invalid certificate; no UUID");
}

#
# The CERT data from apache holds the URN of the caller. 
#
if (exists($ENV{'SSL_CLIENT_CERT'})) {
    my $x509 = eval {
	Crypt::OpenSSL::X509->new_from_string($ENV{'SSL_CLIENT_CERT'}); };
    if ($@) {
	XMLError(-1, "Invalid certificate: $@");
    }
    my $cert = $x509->as_string(Crypt::OpenSSL::X509::FORMAT_ASN1);
    XMLError(-1, "Could not convert certificate to ASN1")
	if (!defined($cert) || $cert eq '');
    my $decoded = Crypt::X509->new( cert => $cert );
    if ($decoded->error) {
	XMLError(-1, "Error decoding certificate:" . $decoded->error);
    }
    foreach my $tmp (@{ $decoded->SubjectAltName }) {
	if ($tmp =~ /^uniformResourceIdentifier=(.*)$/ ||
	    $tmp =~ /^(urn:.*)$/) {
	    $ENV{'GENIURN'} = $1;
	}
    }
}
XMLError(-1, "Invalid authentication certificate; no URN. Please regenerate.")
    if (!exists($ENV{'GENIURN'}));

#
# Reaching into the Frontier code so I can debug this crap.
#
my $request = Frontier::Responder::get_cgi_request();
if (!defined($request)) {
    print "Content-Type: text/txt\n\n";
    exit(0);
}

if (exists($ENV{'PATH_INFO'}) && $ENV{'PATH_INFO'} ne "") {
    my $pathinfo = $ENV{'PATH_INFO'};
    $pathinfo =~ s/^\///;
    my @parts = split(/\//, $pathinfo);
    if (@parts) {
	my $v = $parts[0];
	if ($v =~ /^[\d\.]+$/) {
	    $VERSION = "$v";
	}
    }
}

#
# Create and set our RPC context for any calls we end up making.
#
Genixmlrpc->SetContext(Genixmlrpc->Context($certificate));

if ($VERSION eq "1.0") {
    $responder = Frontier::Responder->new( "methods" => {
        "GetVersion"    => \&GeniAM::GetVersion,
        "ListResources" => \&GeniAM::ListResources,
        "CreateSliver"  => \&GeniAM::CreateSliver,
        "DeleteSliver"  => \&GeniAM::DeleteSliver,
        "SliverStatus"  => \&GeniAM::SliverStatus,
        "RenewSliver"   => \&GeniAM::RenewSliver,
        "Shutdown"      => \&GeniAM::Shutdown,
    },);
}
else {
    XMLError(-3, "Invalid API Version");
}

#
# Use libaudit to capture any output from libraries and programs.
# Send that to tbops so they can be fixed.
#
if ($MAINSITE) {
    LogStart(0);
    AddAuditInfo("to", "protogeni-errors\@flux.utah.edu")
}
else {
    LogStart(0, undef, LIBAUDIT_LOGTBOPS());
}

# Add stuff for log message if sent.
AddAuditInfo("message", $request);
# CC errors to Utah for now.
AddAuditInfo("cc", "protogeni-errors\@flux.utah.edu")
    if (!$MAINSITE);

my $response = $responder->{'_decode'}->serve($request,
					      $responder->{'methods'});

# Add stuff for log message if sent.
AddAuditInfo("message", $response . "\n\n" . $request);

#----------------------------------------------------------------------
# Morph the ProtoGENI response (a hash with three keys; a
# GeniResponse) into a GENI AM response (a single value or a fault if
# there is an error).
#
# $response is an XML RPC response, which is a three element hash. The
# value element is the GeniResponse hash.
#----------------------------------------------------------------------
my $decoder = Frontier::RPC2->new();
my $object  = $decoder->decode($response);
my $geni_response = $object->{'value'}[0];
if (GeniResponse::IsError($geni_response)) {
    # An error result gets mapped to an XML RPC fault
    $response = $decoder->encode_fault(GeniResponse::code($geni_response),
                                       GeniResponse::output($geni_response));
} else {
    # A successful result means return the value
    $response = $decoder->encode_response(GeniResponse::value($geni_response));
}

#
# Terminate the log capture so that we can print the response to STDOUT
# for the web server.
#
LogEnd(0);

print "Content-Type: text/xml \n\n" . $response;
exit(0);

#
# Want to prevent bad exit.
#
END {
    my $exitcode = $?;

    if ($exitcode) {
	LogEnd(0);

	my $decoder = Frontier::RPC2->new();
	print "Content-Type: text/xml \n\n";
	print $decoder->encode_fault(-2, "XMLRPC Server Error");

	# Since we converted to a normal error and sent the log message.
	$? = 0;
    }
}

