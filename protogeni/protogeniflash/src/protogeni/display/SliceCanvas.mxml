<?xml version="1.0" encoding="utf-8"?>
<mx:Canvas xmlns:mx="http://www.adobe.com/2006/mxml"
		   width="100%" height="100%" borderStyle="solid" backgroundColor="#F6F6F6"
		   dragEnter="dragEnterHandler(event)"  dragDrop="dragDropHandler(event)"
		   mouseMove="mouseMoveHandler(event)" mouseUp="mouseUpHandler(event)" borderColor="#CDC2C2">
	
	<mx:Script>
		<![CDATA[
			import mx.collections.ArrayCollection;
			import mx.controls.List;
			import mx.core.UIComponent;
			import mx.events.DragEvent;
			import mx.managers.DragManager;
			import mx.managers.PopUpManager;
			
			import protogeni.ProtogeniEvent;
			import protogeni.ProtogeniHandler;
			import protogeni.resources.PhysicalNode;
			import protogeni.resources.Slice;
			import protogeni.resources.Sliver;
			import protogeni.resources.VirtualNode; 
			
			[Bindable]
			public var slice:Slice;
			
			public var startNode:SliceNode = null;
			public var currentNode:SliceNode = null;
			public var tempLink:SliceLink;
			public var hostWindow:SliceWindow;
			
			public var allNodes:SliceNodeCollection = new SliceNodeCollection();
			public var allLinks:SliceLinkCollection = new SliceLinkCollection();
			//public var addedRawChildren:ArrayCollection = new ArrayCollection();
			
			public function load(newSlice:Slice):void
			{
				slice = newSlice.clone(false);
				
				for each(var s:Sliver in slice.slivers)
				{
					// load!
				}
				
				Main.protogeniHandler.addEventListener(ProtogeniEvent.SLICE_CHANGED, refreshSlice);
			}
			
			public function refreshSlice(junk:*):void
			{
				for each(var sn:SliceNode in this.allNodes)
					sn.resetToStatus();
			}
			
			private  function dragEnterHandler(event:DragEvent):void {
				if (event.dragSource.hasFormat("canvas") ||
						(event.dragInitiator is List &&
						List(event.dragInitiator).selectedItem is PhysicalNode &&
						PhysicalNode(List(event.dragInitiator).selectedItem).available &&
						!allNodes.containsPhysicalNode(PhysicalNode(List(event.dragInitiator).selectedItem))))
				{
					DragManager.acceptDragDrop(Canvas(event.currentTarget));
				}
			}
			
			private function dragDropHandler(event:DragEvent):void {
				// Handle dragging new node
				if(event.dragInitiator is List && List(event.dragInitiator).selectedItem is PhysicalNode)
				{
					addPhysicalNode(List(event.dragInitiator).selectedItem as PhysicalNode,
						Canvas(event.currentTarget).mouseX,
						Canvas(event.currentTarget).mouseY);
					
				}
				// Handle dragging old one
				else if(this.contains(event.dragInitiator as DisplayObject))
				{
					SliceNode(event.dragInitiator).x = Canvas(event.currentTarget).mouseX - SliceNode(event.dragInitiator).startX;
					SliceNode(event.dragInitiator).y = Canvas(event.currentTarget).mouseY - SliceNode(event.dragInitiator).startY;
					redrawAllLinks();
				}
			}
			
			public function removeVirtualNode(vn:VirtualNode):void
			{
				for each(var sn:SliceNode in this.allNodes)
				{
					if(sn.node == vn)
						removeSliceNode(sn);
				}
			}
			
			public function removeSliceNode(sn:SliceNode):void
			{
				// Remove subnodes
				for each(var sub:VirtualNode in sn.node.subNodes)
					removeVirtualNode(sub);
				
				// Remove links
				while(sn.links.length > 0)
					sn.links[0].removeLink()
				
				// Remove nodes and slivers
				for each(var s:Sliver in sn.node.slivers)
				{
					s.nodes.removeItemAt(s.nodes.getItemIndex(sn.node));
					if(s.nodes.length == 0)
						slice.slivers.removeItemAt(slice.slivers.getItemIndex(s));
				}

				this.removeChild(sn);
				allNodes.removeItemAt(allNodes.getItemIndex(sn));
				hostWindow.loadNodes();
			}
			
			public function addPhysicalNode(pn:PhysicalNode, x:int = -1, y:int = -1):SliceNode
			{
				// Don't duplicate
				if(allNodes.containsPhysicalNode(pn))
					return allNodes.getForPhysicalNode(pn);
				
				var sn:SliceNode = new SliceNode();
				var newVirtualNode:VirtualNode = new VirtualNode(slice.getOrCreateSliverFor(pn.manager));
				newVirtualNode.setToPhysicalNode(pn);
				sn.setNode(newVirtualNode);
				sn.canvas = this;
				this.addChild(sn);
				this.validateNow();
				sn.width = sn.width + (sn.nameLabel.textWidth - sn.nameLabel.width)
				sn.x = x - (sn.width/2);
				sn.y = y - (sn.height/2);
				allNodes.addItem(sn);
				hostWindow.loadNodes();
				newVirtualNode.slivers[0].nodes.addItem(newVirtualNode);
				
				// See if we need to connected to a parent node
				if(pn.subNodeOf != null)
				{
					if(!allNodes.containsPhysicalNode(pn.subNodeOf))
						sn.node.superNode = addPhysicalNode(pn.subNodeOf, x + 40, y + 40).node;
					else
						sn.node.superNode = allNodes.getForPhysicalNode(pn.subNodeOf).node;
					sn.node.superNode.subNodes.push(sn.node);
					
				}
				
				return sn;
			}
			
			public function startLinkingFrom(node:SliceNode):void
			{
				startNode = node;
				tempLink = new SliceLink(this);
			}

			protected function mouseMoveHandler(event:MouseEvent):void
			{
				if(startNode != null)
				{
					// See if a node is under
					currentNode = null;
					for each(var sn:SliceNode in allNodes)
					{
						if(sn != startNode
								&& sn.getRect(this).contains(mouseX, mouseY)
								&& !allLinks.hasLinkFor(startNode, sn)) {
							currentNode = sn;
							break;
						}
					}

					// Add sprite to Canvas display list
					tempLink.drawEstablishing(startNode.x + startNode.width/2,
											startNode.y + startNode.height/2,
											mouseX,
											mouseY, currentNode != null);
					addChild(tempLink);

				} else if(tempLink != null && this.getChildren().contains(tempLink))
					removeChild(tempLink);
			}


			protected function mouseUpHandler(event:MouseEvent):void
			{
				// Add link if needed
				if(startNode != null && currentNode != null) {
					if(tempLink.establish(startNode, currentNode)) {
						tempLink.drawEstablished();
					} else
						removeChild(tempLink);
				} else if(tempLink != null && getChildren().contains(tempLink))
					removeChild(tempLink);
				validateNow();
				
				// Reset
				startNode = null;
				currentNode = null;
				tempLink = null;
				redrawAllLinks();
			}
			
			// RAW CHILDREN FUNCTIONS
			public function redrawAllLinks():void
			{
				for each(var sl:SliceLink in allLinks)
					sl.drawEstablished();
					this.setChildIndex(sl, 0);
			}

		]]>
	</mx:Script>

</mx:Canvas>
