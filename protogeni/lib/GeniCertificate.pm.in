#!/usr/bin/perl -wT
#
# GENIPUBLIC-COPYRIGHT
# Copyright (c) 2008-2010 University of Utah and the Flux Group.
# All rights reserved.
#
package GeniCertificate;

#
# Some simple certificate stuff.
#
use strict;
use Exporter;
use vars qw(@ISA @EXPORT);

@ISA    = "Exporter";
@EXPORT = qw ( );

# Must come after package declaration!
use GeniDB;
use emutil qw(TBGetUniqueIndex);
use English;
use XML::Simple;
use XML::LibXML;
use Data::Dumper;
use File::Temp qw(tempfile);
use overload ('""' => 'Stringify');

# Configure variables
my $TB		   = "@prefix@";
my $TBOPS          = "@TBOPSEMAIL@";
my $TBAPPROVAL     = "@TBAPPROVALEMAIL@";
my $TBAUDIT   	   = "@TBAUDITEMAIL@";
my $BOSSNODE       = "@BOSSNODE@";
my $OURDOMAIN      = "@OURDOMAIN@";
my $SIGNCRED	   = "$TB/sbin/signgenicred";
my $VERIFYCRED	   = "$TB/sbin/verifygenicred";
my $NFREE	   = "$TB/bin/nfree";
my $OPENSSL	   = "/usr/bin/openssl";
my $MKCERT         = "$TB/sbin/mksyscert";

# Cache of instances to avoid regenerating them.
my %certificates  = ();
BEGIN { use GeniUtil; GeniUtil::AddCache(\%certificates); }

#
# Lookup by URN (and also UUID, for compatibility).
#
sub Lookup($$)
{
    my ($class, $token) = @_;
    my $query_result;
    my $uuid;

    # Look in cache first
    return $certificates{"$token"}
        if (exists($certificates{"$token"}));

    if (GeniHRN::IsValid($token)) {
	$query_result =
	    DBQueryWarn("select uuid from geni_certificates ".
			"where urn='$token'");

	return undef
	    if (! ($query_result && $query_result->numrows));
	
	($uuid) = $query_result->fetchrow_array();
	
    }
    elsif ($token =~ /^\w+\-\w+\-\w+\-\w+\-\w+$/) {
	$uuid = $token;
    }
    else {
	return undef;
    }

    $query_result =
	DBQueryWarn("select * from geni_certificates where uuid='$uuid'");
    
    return undef
	if (!$query_result || !$query_result->numrows);

    my $self          = {};
    $self->{'CERT'}   = $query_result->fetchrow_hashref();
    $self->{'stored'} = 1;
    bless($self, $class);
    my $cert = $self->cert();

    # Add to cache. 
    $certificates{$uuid} = $self;
    $certificates{$token} = $self
	if $token ne $uuid;
    
    return $self;
}

#
# Stringify for output.
#
sub Stringify($)
{
    my ($self) = @_;
    
    my $uuid = $self->uuid();
    my $hrn  = $self->hrn();

    return "[GeniCertificate: $uuid, $hrn]";
}

# accessors
sub field($$) { return ((! ref($_[0])) ? -1 : $_[0]->{'CERT'}->{$_[1]}); }
sub uuid($)		{ return field($_[0], "uuid"); }
# This will always be undefined, but we need the method.
sub expires($)		{ return undef; }
sub created($)		{ return field($_[0], "created"); }
sub cert($)		{ return field($_[0], "cert"); }
sub DN($)		{ return field($_[0], "DN"); }
sub privkey($)		{ return field($_[0], "privkey"); }
sub revoked($)		{ return field($_[0], "revoked"); }
sub certfile($)		{ return field($_[0], "certfile"); }
sub uri($)              { return field($_[0], "uri"); }
sub urn($)              { return field($_[0], "urn"); }
sub GetCertificate($)   { return $_[0]; }

#
# The fields are buried inside the DN.
#
sub hrn($)
{
    my ($self) = @_;

    if ($self->DN() =~ /\/OU=([-\w\.]+)\//) {
	return $1
	    if ($1 ne "");
    }
    # GENI AM compatibility with PlanetLab
    # Use the URN from the Subject Alt Name to create the HRN
    my ($authority, $type, $name) = GeniHRN::Parse($self->urn());
    # Match authority up to the first colon, then add "." and name.
    if ($authority =~ /^([^:]+):/) {
        my $hrn = $1 . "." . $name;
        return $hrn;
    }
    print STDERR "Cannot find hrn inside DN: '" . $self->DN() . "'\n";
    print STDERR "Cannot find hrn inside urn: '" . $self->urn() . "'\n";
    return "unknown";
}
sub email($)
{
    my ($self) = @_;

    if ($self->DN() =~ /\/emailAddress=(.*)/) {
	return $1
	    if ($1 ne "");
    }
    print STDERR "Cannot find email inside DN: '" . $self->DN() . "'\n";
    return "unknown";
}

#
# Create a certificate pair, which gives us a uuid to use for an object.
#
sub Create($$$$$;$$)
{
    my ($class, $what, $urn, $hrn, $email, $uuid, $url) = @_;
    # Let mkcert generate a new one.
    $uuid = ""
	if (!defined($uuid));
    $url  = (defined($url) ? "-u $url" : "");

    if (! open(CERT, "$MKCERT -i \"$urn\" $url -e \"$email\" $hrn $uuid |")) {
	print STDERR "Could not start $MKCERT\n";
	return undef;
    }
    my @certlines = ();
    while (<CERT>) {
	push(@certlines, $_);
    }
    if (!close(CERT)) {
	print STDERR "$MKCERT failed!\n";
	return undef;
    }
    my $cert;
    my $privkey;
    my $string;
    foreach my $line (@certlines) {
	if ($line =~ /^-----BEGIN CERT/ ||
	    $line =~ /^-----BEGIN RSA/) {
	    $string = "";
	    next;
	}
	if ($line =~ /^-----END CERT/) {
	    $cert = $string;
	    $string = undef;
	    next;
	}
	if ($line =~ /^-----END RSA/) {
	    $privkey = $string;
	    $string = undef;
	    next;
	}
	$string .= $line
	    if (defined($string));
    }
    if (! (defined($privkey) && defined($cert))) {
	print STDERR "Could not generate a new certificate with $MKCERT\n";
	foreach my $line (@certlines) {
	    print STDERR $line;
	}
	return undef;
    }
    if (! ($cert =~ /^[\012\015\040-\176]*$/)) {
	print STDERR "Improper chars in certificate string\n";
	foreach my $line (@certlines) {
	    print STDERR $line;
	}
	return undef;
    }

    my $certificate = GeniCertificate->LoadFromString($cert);
    return undef
	if (!defined($certificate));

    $certificate->{'CERT'}->{'privkey'} = $privkey;
    if ($certificate->Store() != 0) {
	print STDERR "Could not write new certificate to DB\n";
	return undef;
    }
    return $certificate;
}

#
# Delete ...
#
sub Delete($)
{
    my ($self) = @_;
    my $uuid = $self->uuid();

    return -1
	if ($self->{'stored'} &&
	    !DBQueryWarn("delete from geni_certificates where uuid='$uuid'"));

    # Delete from cache. 
    delete($certificates{$uuid});

    return 0;
}

#
# Flush from our little cache.
#
sub Flush($)
{
    my ($self) = @_;

    $self->GetCertificate()->Flush();
    delete($certificates{$self->uuid()});
}

#
# Load a certificate from a string. This creates an object, but does
# not store it in the DB.
#
sub LoadFromString($$)
{
    my ($class, $string) = @_;

    if (! ($string =~ /^[\012\015\040-\176]*$/)) {
	print STDERR "Improper chars in certificate string\n";
	return undef;
    }
    my ($tempfile, $filename) = tempfile(UNLINK => 1);
    if (!$tempfile) {
	print STDERR "Could not create tempfile for cert string\n";
	return undef;
    }

    # The certificate might already have the header and footer
    # so only add them if needed.
    if ($string =~ /^-----BEGIN CERTIFICATE-----/) {
        print $tempfile $string;
    } else {
        print $tempfile "-----BEGIN CERTIFICATE-----\n";
        print $tempfile $string;
        print $tempfile "-----END CERTIFICATE-----\n";
    }

    my $certificate = GeniCertificate->LoadFromFile($filename);
    unlink($filename);
    return undef
	if (!defined($certificate));
    
    $certificate->{'CERT'}->{'certfile'} = undef;
    return $certificate;
}

#
# Load a certificate from a file. This creates an object, but does
# not store it in the DB.
#
sub LoadFromFile($$)
{
    my ($class, $filename) = @_;
    my $url;
    my $urn;

    if (! open(X509, "$OPENSSL x509 -in $filename -subject -text |")) {
	print STDERR "Could not start $OPENSSL on $filename\n";
	return undef;
    }
    my @certlines = ();
    while (<X509>) {
	push(@certlines, $_);
    }
    if (!close(X509) || !@certlines) {
	print STDERR "Could not load certificate from $filename\n";
	return undef;
    }

    #
    # The first line is the DN (subject).
    #
    my $DN = shift(@certlines);
    chomp($DN);

    #
    # The text output is next. Look for the URL in the extensions. Stop
    # when we get to the certificate line.
    #
    my ($alturi,$accessuri);
    my $altname = 0;
    my $accessinfo = 0;
    while (@certlines) {
	my $line = shift(@certlines);
	last
	    if ($line =~ /^-----BEGIN CERT/);

	if( $line =~ /^\s+X509v3 Subject Alternative Name:\s*$/ ) {
	    $altname = 1;
	} elsif( $line =~ /^\s+Authority Information Access:\s*$/ ) {
	    $accessinfo = 1;
	} elsif( $altname ) {
	    m'^\s*URI:(urn:publicid:[-!#$%()*+,./0-9:;=?@A-Z_a-z~]+)\s*$' and $alturi = $1
		foreach split( /, /, $line );
	    $altname = 0;
	} elsif( $accessinfo ) {
	    m'^\s*[0-9.]+ - URI:([-!#$%()*+,./0-9:;=?@A-Z_a-z~]+)\s*$' 
		and $accessuri = $1 foreach split( /, /, $line );
	    $accessinfo = 0;
	}
    }
    if (!@certlines) {
	print STDERR "Could not parse certificate from $filename\n";
	return undef;
    }

    if( defined( $alturi ) && $alturi =~ /^urn:/ ) {
	$urn = $alturi;
    }

    if( defined( $accessuri ) ) {
	$url = $accessuri;
    } elsif( defined( $alturi ) && $alturi !~ /^urn:/ ) {
	$url = $alturi;
    }

    #
    # Throw away last line; the cert is rest.
    #
    pop(@certlines);
    my $cert = join("", @certlines);

    # Dig out the uuid.
    my $uuid;
    if ($DN =~ /\/CN=([-\w]*)/) {
	$uuid = $1;
    }
    else {
	print STDERR "Could not find uuid in 'DN'\n";
	return undef;
    }
    
    # GENI AM: CN might not be a UUID, so check it.
    # If it is not a UUID, make one up.
    if ($uuid !~ /^\w+\-\w+\-\w+\-\w+\-\w+$/) {
        $uuid = GeniUtil::NewUUID();
    }

    my $self          = {};
    $self->{'CERT'}   = {};
    $self->{'stored'} = 0;
    bless($self, $class);

    $self->{'CERT'}->{'uuid'}      = $uuid;
    $self->{'CERT'}->{'cert'}      = $cert;
    $self->{'CERT'}->{'DN'}        = $DN;
    $self->{'CERT'}->{'privkey'}   = undef;
    $self->{'CERT'}->{'revoked'}   = undef;
    $self->{'CERT'}->{'created'}   = undef;
    $self->{'CERT'}->{'certfile'}  = $filename;
    $self->{'CERT'}->{'uri'}       = $url;
    $self->{'CERT'}->{'urn'}       = $urn;
    return $self;
}

#
# Store a certificate that was loaded from a string/file.
#
sub Store($)
{
    my ($self) = @_;

    return 0
	if ($self->{'stored'});

    my @inserts = ();
    push(@inserts, "created=now()");
    push(@inserts, "uuid=" . DBQuoteSpecial($self->uuid()));
    push(@inserts, "cert=" . DBQuoteSpecial($self->cert()));
    push(@inserts, "DN=" . DBQuoteSpecial($self->DN()));
    push(@inserts, "privkey=" . DBQuoteSpecial($self->privkey()))
	if (defined($self->privkey()));
    push(@inserts, "uri=" . DBQuoteSpecial($self->uri()))
	if (defined($self->uri()));
    push(@inserts, "urn=" . DBQuoteSpecial($self->urn()))
	if (defined($self->urn()));

    return -1
	if (!DBQueryWarn("replace into geni_certificates set ".
			 join(",", @inserts)));
    
    $self->{'stored'} = 1;
    return 0;
}

#
# Write a certificate and private key to a tempfile, as for signing with it.
#
sub WriteToFile($;$)
{
    my ($self, $withkey) = @_;

    $withkey = 0
	if (!defined($withkey));
    
    # We want this file to be passed back. 
    my ($tempfile, $filename) = tempfile(UNLINK => 1);
    print $tempfile "-----BEGIN CERTIFICATE-----\n";
    print $tempfile $self->cert();
    print $tempfile "-----END CERTIFICATE-----\n";
    if ($withkey && $self->privkey()) {
	print $tempfile "-----BEGIN RSA PRIVATE KEY-----\n";
	print $tempfile $self->privkey();
	print $tempfile "-----END RSA PRIVATE KEY-----\n";
    }
    return $filename;
}

#
# The URL is buried in an extension so we have to parse the text output.
#
sub URL($)
{
    my ($self) = @_;
    my $url    = $self->{'URL'};

    return $url
	if (defined($url));

    my $filename = $self->WriteToFile();
    if (! open(X509, "$OPENSSL x509 -in $filename -text -noout |")) {
	print STDERR "Could not start $OPENSSL on $filename\n";
	return undef;
    }
    # Note that we really want to put only URNs in the subjectAltName,
    # and all URLs in the subjectInfoAccess.  However, old certificates
    # used subjectAltName for URLs, so for temporary backward compatibility
    # we'll look in both places.
    my ($alturl,$accessurl);
    my $altname = 0;
    my $accessinfo = 0;
    while (<X509>) {
	if( /^\s+X509v3 Subject Alternative Name:\s*$/ ) {
	    $altname = 1;
	} elsif( /^\s+Authority Information Access:\s*$/ ) {
	    $accessinfo = 1;
	} elsif( $altname ) {
	    # Gah!  OpenSSL is horrible.  Apparently the text output format
	    # for the subject alternative name is fixed, and neither
	    # -nameopt nor -certopt will help us.  Worse still, the
	    # directory entries (e.g. URI, email) are comma separated...
	    # but commas are legal characters in URIs (see RFC 3986, section
	    # 2.2)!  We'll have to assume the delimiter is the ", " (comma,
	    # space) pair...
	    m'^\s*URI:([-!#$%()*+,./0-9:;=?@A-Z_a-z~]+)\s*$' and $alturl = $1
		foreach split( /, / );
	    $altname = 0;
	} elsif( $accessinfo ) {
	    m'^\s*[0-9.]+ - URI:([-!#$%()*+,./0-9:;=?@A-Z_a-z~]+)\s*$' and $accessurl = $1
		foreach split( /, / );
	    $accessinfo = 0;
	}
    }
    $url = defined( $accessurl ) ? $accessurl : 
	defined( $alturl ) ? $alturl : undef;
    if (!close(X509) || !defined($url)) {
	print STDERR "Could not find url in certificate from $filename\n";
	return undef;
    }
    unlink($filename);
    $self->{'CERT'}->{'uri'} = $url;
    $self->{'URL'} = $url;
    return $url;
}
# So a certificate looks like other things (authorities).
sub url($) { return $_[0]->URL(); }

#
# The URN is slightly easier, since it is always in the same place.
#
sub URN($)
{
    my ($self) = @_;
    my $urn    = $self->{'URN'};

    return $urn
	if (defined($urn));

    my $filename = $self->WriteToFile();
    if (! open(X509, "$OPENSSL x509 -in $filename -text -noout |")) {
	print STDERR "Could not start $OPENSSL on $filename\n";
	return undef;
    }
    my $altname = 0;
    while (<X509>) {
	if( /^\s+X509v3 Subject Alternative Name:\s*$/ ) {
	    $altname = 1;
	} elsif( $altname ) {
	    m'^\s*URI:([-!#$%()*+,./0-9:;=?@A-Z_a-z~]+)\s*$' and $urn = $1
		foreach split( /, / );
	    $altname = 0;
	}
    }
    if (!close(X509) || !defined($urn)) {
	print STDERR "Could not find URN in certificate from $filename\n";
	return undef;
    }
    unlink($filename);
    $self->{'URN'} = $urn;
    return $urn;
}

sub asText($)
{
    my ($self) = @_;
    my $text   = "";

    my $filename = $self->WriteToFile();
    if (! open(X509, "$OPENSSL x509 -in $filename -text |")) {
	print STDERR "Could not start $OPENSSL on $filename\n";
	return undef;
    }
    while (<X509>) {
	$text .= $_;
    }
    if (!close(X509) || $text eq "") {
	print STDERR "Could not dump text of certificate from $filename\n";
	return undef;
    }
    unlink($filename);
    return $text;
}

#
# Load a CRL and store it.
#
sub StoreCRL($$$)
{
    my ($class, $authority, $string) = @_;

    my ($tempfile, $filename) = tempfile(UNLINK => 1);
    print $tempfile $string;

    my $uuid    = $authority->uuid();
    my $expires = `$OPENSSL crl -noout -nextupdate -in $filename`;
    chomp($expires);
    if (! (defined($expires) && ($expires =~ /^nextupdate/i))) {
	print STDERR "Could not get nextupdate from CRL\n";
	return -1;
    }
    $expires =~ s/^nextupdate=//i;
    my $issuer = `$OPENSSL crl -noout -issuer -in $filename`;
    chomp($issuer);
    if (! (defined($issuer) && ($issuer =~ /^issuer/i))) {
	print STDERR "Could not get issuer from CRL\n";
	return -1;
    }
    $issuer =~ s/^issuer=//i;
    my $safe_cert    = DBQuoteSpecial($string);
    my $safe_expires = DBQuoteSpecial($expires);
    my $safe_issuer  = DBQuoteSpecial($issuer);
    my $dateconvert  = "DATE_SUB(STR_TO_DATE($safe_expires, ".
	"'%b %e %T %Y'), INTERVAL 1 DAY)";

    DBQueryWarn("replace into geni_crls set ".
		"  uuid='$uuid', created=now(), expires=$dateconvert, ".
		"  cert=$safe_cert, DN=$safe_issuer")
	or return -1;
    unlink($filename);
    return 0;
}

#
# Remove a CRL.
#
sub DeleteCRL($$)
{
    my ($class, $authority) = @_;

    my $uuid = $authority->uuid();
    
    DBQueryWarn("delete from geni_crls where uuid='$uuid'")
	or return -1;

    return 0;
}

############################################################################
#
# Wrapper for local users.
#
package GeniCertificate::LocalUser;
use GeniHRN;
use English;
use emdb;

#
# Create a wrapper, with the same access names.
#
sub Create($$)
{
    my ($class, $user) = @_;
    my $uid_idx = $user->uid_idx();

    my $query_result =
	DBQueryWarn("select * from user_sslcerts ".
		    "where uid_idx='$uid_idx' and encrypted=1 and ".
		    "      revoked is null");
		    
    return undef
	if (!defined($query_result) || !$query_result->numrows);

    my $self           = {};
    $self->{'CERT'}    = $query_result->fetchrow_hashref();
    $self->{'CERT'}->{'urn'} = GeniHRN::Generate( $OURDOMAIN, "user",
						  $self->{'CERT'}->{'uid'} );
    $self->{'stored'}  = 1;
    bless($self, $class);

    return $self;
}

sub field($$) { return ((! ref($_[0])) ? -1 : $_[0]->{'CERT'}->{$_[1]}); }
sub uuid($)		{ return field($_[0], "uuid"); }
sub created($)		{ return field($_[0], "created"); }
sub cert($)		{ return field($_[0], "cert"); }
sub privkey($)		{ return field($_[0], "privkey"); }
sub revoked($)		{ return field($_[0], "revoked"); }
sub uri($)              { return undef; }
sub urn($)              { return field($_[0], "urn"); }
sub URL($)              { return undef; }
sub URN($)              { return field($_[0], "urn"); }

#
# Need to add DN to the emulab table.
#
sub DN($)
{
    my ($self) = @_;

    return $self->{'CERT'}->{'DN'}
        if (exists($self->{'CERT'}->{'DN'}));
    
    # Deleted when scope is left.
    my $tempfile = new File::Temp(UNLINK => 1);
    my $filename = $tempfile->filename;    
    print $tempfile "-----BEGIN CERTIFICATE-----\n";
    print $tempfile "$self->cert()";
    print $tempfile "-----END CERTIFICATE-----\n";

    my $dn = `$OPENSSL x509 -in $filename -noout -subject`;
    if ($?) {
	print STDERR "Failed to convert $filename to uuid!\n";
	return undef;
    }
    chomp($dn);
    $self->{'CERT'}->{'DN'} = $dn;
    unlink($filename);
    return $dn;
}

# _Always_ make sure that this 1 is at the end of the file...
1;
