#!/usr/bin/perl -wT
#
# GENIPUBLIC-COPYRIGHT
# Copyright (c) 2008-2011 University of Utah and the Flux Group.
# All rights reserved.
#
package GeniRegistry;

#
# Server side of a Registry.
#
use strict;
use Exporter;
use vars qw(@ISA @EXPORT);

@ISA    = "Exporter";
@EXPORT = qw ( );

use Genixmlrpc;
use GeniResponse;
use English;
use Data::Dumper;

#
# This is currently a hack since we have no ability to actually deal
# with multiple clearinghouses/registries. For now, we know about PLC
# or the Protogeni clearinghouse.
#
sub Create($$$$)
{
    my ($class, $target, $context, $credential) = @_;

    my ($auth,$type,$id) = GeniHRN::Parse($target);
    return undef
	if (!defined($auth));

    if ($auth =~ /^plc:/) {
	return GeniRegistry::PLC->Create("plc", $context);
    }
    else {
	return GeniRegistry::ClearingHouse->Create($context, $credential);
    }
    return undef;
}

##########################################################################
#
package GeniRegistry::Client;

use Genixmlrpc;
use GeniResponse;
use GeniCredential;
use English;
use Data::Dumper;
use Date::Parse;
use POSIX qw(strftime tmpnam);
use Time::Local;

#
# Create an object that represents a client connection to a registry.
#
sub Create($$;$$)
{
    my ($class, $authority, $context, $credential) = @_;

    if (!defined($credential)) {
	$credential = GeniRegistry::Client->GetCredential($authority);
	return undef
	    if (!defined($credential));
    }

    my $self              = {};
    $self->{'authority'}  = $authority;
    $self->{'context'}    = $context;
    $self->{'credential'} = $credential;
    bless($self, $class);

    return $self;
}
sub authority($)	{ return $_[0]->{"authority"}; }
sub context($)		{ return $_[0]->{"context"}; }
sub credential($)	{ return $_[0]->{"credential"}; }

sub GetCredential($;$$)
{
    my ($class, $authority, $context) = @_;

    my $credential =
	GeniCredential->Lookup($authority->uuid(), $ENV{'MYUUID'});

    if (defined($credential) &&
	defined($credential->expires())) {
	my $expires = str2time($credential->expires());
	
	# Some buffer.
	if ($expires > time() + 3600) {
	    #print STDERR "Reusing clearinghouse credential\n";
	    return $credential;
	}
	$credential->Delete();
    }
    #print STDERR "Getting new clearinghouse credential\n";

    $context = Genixmlrpc->GetContext()
	if (!defined($context));
    
    if (!defined($context)) {
	print STDERR "Need a context to create a registry credential\n";
	return undef;
    }

    my $url = $authority->url();
    if (!defined($url)) {
	print STDERR "$authority has no URL\n";
	return undef;
    }
    my $response =
	Genixmlrpc::CallMethod($url, $context, "GetCredential",
			       {"gid" => $context->certificate()->cert()});
	
    return undef
	if (!defined($response));
    
    if ($response->IsError()) {
	print STDERR "GeniRegistry::Client->GetCredential: " .
	    $response->Dump() . "\n";
	return undef;
    }
    $credential = GeniCredential->CreateFromSigned($response->value(), 1);
    if (!defined($credential)) {
	print STDERR "Could not parse credential from $authority\n";
	return undef;
    }
    $credential->Store();
    
    return $credential;
}

#
# Lookup a record.
#
sub Resolve($$$$)
{
    my ($self, $token, $type, $pref) = @_;

    $$pref = undef;
    my $which = "uuid";

    if ($token =~ /^\w+\-\w+\-\w+\-\w+\-\w+$/) {
	$which = "uuid";
    }
    elsif (GeniHRN::IsValid($token)) {
	$which = "urn";
    }
    else {
	$which = "hrn";
    }
    my $response =
	Genixmlrpc::CallMethod($self->authority()->url(),
			       $self->context(), 
			       "Resolve",
			       { "credential" =>
				     $self->credential()->asString(),
				 "type"       => $type,
				 $which       => $token });
    return -1
	if (!defined($response));

    if ($response->IsError()) {
	print STDERR "Resolve: " . $response->Dump() . "\n"
	    if ($response->code() != GENIRESPONSE_SEARCHFAILED());
	return -1;
    }
    
    $$pref = $response->value();
    return 0;
}

#
# Lookup a user.
#
sub LookupUser($$$)
{
    my ($self, $urn, $pref) = @_;

    return $self->Resolve($urn, "User", $pref);
}

#
# Lookup a slice.
#
sub LookupSlice($$$)
{
    my ($self, $urn, $pref) = @_;

    return $self->Resolve($urn, "Slice", $pref);
}

#
# Register a record.
#
sub Register($$$$)
{
    my ($self, $type, $cert, $info) = @_;

    $info = {} if (!defined($info));

    my $response =
	Genixmlrpc::CallMethod($self->authority()->url(),
			       $self->context(),
			       "Register",
			       { "credential" =>
				     $self->credential()->asString(),
				 "type"       => $type,
			         "gid"        => $cert,
			         "info"       => $info });

    return -1
	if (!defined($response));

    if ($response->IsError()) {
	print STDERR "Register: " . $response->Dump() . "\n";
	return -1;
    }
    return 0;
}

#
# Register a user.
#
sub RegisterUser($$$$$)
{
    my ($self, $name, $email, $cert, $keys) = @_;

    my $info = { "name"   => $name,
		 "email"  => $email };

    return $self->Register("User", $cert, $info);
}

#
# Register a slice.
#
sub RegisterSlice($$$$$)
{
    my ($self, $creator_urn, $expiration, $cert, $bindings) = @_;

    my $info = { "creator_urn"   => $creator_urn,
		 "expiration"    => $expiration,
	         "userbindings"  => $bindings };

    return $self->Register("Slice", $cert, $info);
}

#
# Remove a record.
#
sub Remove($$$)
{
    my ($self, $type, $urn) = @_;

    my $response =
	Genixmlrpc::CallMethod($self->authority()->url(),
			       $self->context(),
			       "Remove",
			       { "credential" =>
				     $self->credential()->asString(),
				 "type"       => $type,
			         "urn"        => $urn });
    return -1
	if (!defined($response));

    if ($response->IsError()) {
	print STDERR "Remove: " . $response->Dump() . "\n"
	    if ($response->code() != GENIRESPONSE_SEARCHFAILED());
	return -1;
    }
    return 0;
}

#
# Delete a slice registration.
#
sub RemoveSlice($$)
{
    my ($self, $urn) = @_;

    return $self->Remove("Slice", $urn);
}

#
# Emergency shutdown
#
sub Shutdown($$$)
{
    my ($self, $urn, $clear) = @_;

    my $response =
	Genixmlrpc::CallMethod($self->authority()->url(),
			       $self->context(),
			       "Shutdown",
			       { "credential"  =>
				     $self->credential()->asString(),
				 "clear"       => $clear,
			         "urn"         => $urn });
    return -1
	if (!defined($response));

    if ($response->IsError()) {
	print STDERR "Shutdown: " . $response->Dump() . "\n";
	return -1;
    }
    return 0;
}

#
# List components.
#
sub ListComponents($$$)
{
    my ($self, $slice, $pref) = @_;

    my $response =
	Genixmlrpc::CallMethod($self->authority()->url(),
			       $self->context(),
			       "CH::DiscoverResources",
			       { "credential" =>
				     $self->credential()->asString() });

    return -1
	if (!defined($response));

    if ($response->IsError()) {
	print STDERR "ListComponents: " . $response->Dump() . "\n";
	return -1;
    }
    $$pref = $response->value();
    return 0;
}

#
# Post the CRL
#
sub PostCRL($$)
{
    my ($self, $cert) = @_;

    my $response =
	Genixmlrpc::CallMethod($self->authority()->url(),
			       $self->context(),
			       "PostCRL",
			       { "credential" =>
				     $self->credential()->asString(),
			         "cert"       => $cert });
    return -1
	if (!defined($response));

    if ($response->IsError()) {
	print STDERR "PostCRL: " . $response->Dump() . "\n";
	return -1;
    }
    return 0;
}

#
# Register a sliver at an SA
#
sub RegisterSliver($$$)
{
    my ($self, $slice_urn, $info) = @_;

    my $response =
	Genixmlrpc::CallMethod($self->authority()->url(),
			       $self->context(),
			       "RegisterSliver",
			       { "credential" =>
				     $self->credential()->asString(),
			         "slice_urn"  => $slice_urn,
			         "info"       => $info });
    return -1
	if (!defined($response));

    if ($response->IsError()) {
	print STDERR "RegisterSliver: " . $response->Dump() . "\n";
	return -1;
    }
    return 0;
}

#
# UnRegister a sliver at an SA
#
sub UnRegisterSliver($$)
{
    my ($self, $slice_urn) = @_;

    my $response =
	Genixmlrpc::CallMethod($self->authority()->url(),
			       $self->context(),
			       "UnRegisterSliver",
			       { "credential" =>
				     $self->credential()->asString(),
			         "slice_urn"  => $slice_urn });
    return -1
	if (!defined($response));

    if ($response->IsError()) {
	print STDERR "UnRegisterSliver: " . $response->Dump() . "\n";
	return -1;
    }
    return 0;
}

sub GetVersion($$)
{
    my ($self, $pref) = @_;

    my $response =
	Genixmlrpc::CallMethod($self->authority()->url(),
			       $self->context(), "GetVersion",
			       { "credential" =>
				     $self->credential()->asString()});
    return -1
	if (!defined($response));

    if ($response->IsError()) {
	print STDERR "UnRegisterSliver: " . $response->Dump() . "\n";
	return -1;
    }
    $$pref = $response->value();
    return 0;
}

##########################################################################
#
package GeniRegistry::ClearingHouse;

use Genixmlrpc;
use GeniResponse;
use GeniCertificate;
use GeniCredential;
use Date::Parse;
use POSIX qw(strftime tmpnam);
use Time::Local;

#
# The clearinghouse is a registry.
#
# XXX This needs to go ... we cannot create a clearinghouse credential
# locally since we cannot sign it (target_urn!=our_urn).
#
sub Create($;$$)
{
    my ($class, $context, $credential) = @_;
    
    if (!defined($credential)) {
	$credential = GeniRegistry::ClearingHouse->GetCredential();
	if (!defined($credential)) {
	    print STDERR "Could not create clearinghouse credential\n";
	    return undef;
	}
    }
    $context = Genixmlrpc->GetContext()
	if (!defined($context));

    if (!defined($context)) {
	print STDERR "Need a context to create clearinghouse credential\n";
	return undef;
    }
    return GeniRegistry::Client->Create($credential->target_cert(),
					$context, $credential);
}

#
# Load the CH certificate.
#
sub GetCertificate($)
{
    my ($class) = @_;
    my $ETCDIR  = "@prefix@/etc";

    my $certfile = ((-s "$ETCDIR/genich-local.pem") ?
		    "$ETCDIR/genich-local.pem" : "$ETCDIR/genich.pem");
    if (! -e $certfile) {
	print STDERR "$certfile does not exist!\n";
	return undef;
    }
    my $certificate = GeniCertificate->LoadFromFile($certfile);
    if (!defined($certificate)) {
	print STDERR "Could not load CH certificate from $certfile\n";
	return undef;
    }
    return $certificate;
}

#
# Get a credential from the clearinghouse to talk to it.
#
sub GetCredential($;$$)
{
    my ($class, $context, $certfile) = @_;

    $context = Genixmlrpc->GetContext()
	if (!defined($context));

    #
    # If there is no UUID in the environment, then try to figure it
    # out from the context.
    #
    my $myuuid = (exists($ENV{'MYUUID'}) ? $ENV{'MYUUID'} : undef);
    if (!defined($myuuid) && defined($context)) {
	$myuuid = $context->certificate()->uuid();
    }
    if (!defined($myuuid)) {
	print STDERR "*** GeniRegistry::ClearingHouse::GetCredential: ".
	    "No context or MYUUID for RPC\n";
	return undef;
    }

    my $clearinghousecert = GeniRegistry::ClearingHouse->GetCertificate();
    if (!defined($clearinghousecert)) {
	return undef;
    }
    my $clearinghousecred =
	GeniCredential->Lookup($clearinghousecert->uuid(), $myuuid);

    #print "$clearinghousecred\n" if (defined($clearinghousecred));

    if (defined($clearinghousecred) &&
	defined($clearinghousecred->expires())) {
	my $expires = str2time($clearinghousecred->expires());
	
	# Some buffer.
	if ($expires > time() + 3600) {
	    #print STDERR "Reusing clearinghouse credential\n";
	    return $clearinghousecred;
	}
	$clearinghousecred->Delete();
    }
    #print STDERR "Getting new clearinghouse credential\n";

    my $url = $clearinghousecert->URL();
    if (!defined($url)) {
	print STDERR "No URI extension in $clearinghousecert\n";
	return undef;
    }
    my $response =
	Genixmlrpc::CallMethod($url, $context, "GetCredential",
			       {"gid" => $context->certificate()->cert()});
	
    return undef
	if (!defined($response));
    
    if ($response->IsError()) {
	print STDERR "GeniRegistry::ClearingHouse->GetCredential: " .
	    $response->Dump() . "\n";
	return undef;
    }
    $clearinghousecred =
	GeniCredential->CreateFromSigned($response->value(), 1);
    if (!defined($clearinghousecred)) {
	print STDERR "Could not parse credential from clearinghouse\n";
	return undef;
    }
    if ($clearinghousecred->Store()) {
	print STDERR "*** GeniRegistry::ClearingHouse::GetCredential: ".
	    "Could not store credential for clearinghouse\n";
	return undef;
    }
    return $clearinghousecred;
}

##########################################################################
#
package GeniRegistry::PLC;

use Genixmlrpc;
use GeniResponse;
use GeniCertificate;
use GeniCredential;
use overload ('""' => 'Stringify');

#
# Interoperate with the PLC registry.
#
# We do not need to do much with PLC; just resolve things. For this we
# need to supply a self credential.
#
sub Create($;$$)
{
    my ($class, $aggregate, $context) = @_;
    
    $context = Genixmlrpc->GetContext()
	if (!defined($context));

    if (!defined($context)) {
	print STDERR "GeniRegistry::PLC::Create: ".
	    "Need a context to create self credential\n";
	return undef;
    }
    my $me = GeniAuthority->Lookup($context->certificate()->uuid());
    if (!defined($me)) {
	print STDERR "Could not find my own authority for $context\n";
	return undef;
    }
    my $credential = GeniCredential->GetSelfCredential($me);
    if (!defined($credential)) {
	print STDERR "Could not create self credential for $me\n";
	return undef;
    }

    #
    # At the moment, we support only plc. Eventually support others once
    # plc exports proper certs and resolve of aggregates (that include url).
    #
    my $self              = {};
    $self->{'url'}        = "https://www.planet-lab.org:12345";
    $self->{'context'}    = $context;
    $self->{'credential'} = $credential;
    $self->{'aggregate'}  = $aggregate;
    bless($self, $class);

    return $self;
}
sub authority($)	{ return undef; }
sub url($)		{ return $_[0]->{"url"}; }
sub context($)		{ return $_[0]->{"context"}; }
sub credential($)	{ return $_[0]->{"credential"}; }
sub aggregate($)	{ return $_[0]->{"aggregate"}; }

#
# Stringify for output.
#
sub Stringify($)
{
    my ($self) = @_;
    my $aggregate = $self->aggregate();

    return "[GeniRegistry: $aggregate]";
}

#
# Lookup a record.
#
sub Resolve($$$$)
{
    my ($self, $urn, $type, $pref) = @_;

    $$pref = undef;

    my $response =
	Genixmlrpc::CallMethod($self->url(), $self->context(), "Resolve",
			       $urn, $self->credential()->asString());

    return -1
	if (!defined($response));

    if ($response->IsError()) {
	print STDERR "Resolve: " . $response->Dump() . "\n"
	    if ($response->code() != GENIRESPONSE_SEARCHFAILED());
	return -1;
    }
    
    $$pref = $response->value();
    return 0;
}

# _Always_ make sure that this 1 is at the end of the file...
1;
