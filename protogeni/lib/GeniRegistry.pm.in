#!/usr/bin/perl -wT
#
# GENIPUBLIC-COPYRIGHT
# Copyright (c) 2008-2009 University of Utah and the Flux Group.
# All rights reserved.
#
package GeniRegistry;

#
# Server side of a Registry.
#
use strict;
use Exporter;
use vars qw(@ISA @EXPORT);

@ISA    = "Exporter";
@EXPORT = qw ( );

use Genixmlrpc;
use GeniResponse;
use English;
use Data::Dumper;

##########################################################################
#
package GeniRegistry::GeniSlice;

use GeniDB;
use GeniCertificate;
use GeniHRN;
use emutil qw(TBGetUniqueIndex);
use English;
use Data::Dumper;
use overload ('""' => 'Stringify');

#
# Lookup by idx or uuid.
#
sub Lookup($$)
{
    my ($class, $token) = @_;
    my $query_result;
    my $idx;

    if( GeniHRN::IsValid( $token ) ) {
	return undef if !GeniHRN::Authoritative( $token, "@OURDOMAIN@" );

	my ($authority, $type, $id) = GeniHRN::Parse( $token );

	return undef if $type ne "slice";
	
	# Prefixing @PROTOGENI_DOMAIN@. is horribly ugly, but necessary
	# at the moment to maintain database compatibility... this should
	# probably go away.
	$query_result =
	    DBQueryWarn("select idx from geni_slices ".
			"where hrn='@PROTOGENI_DOMAIN@.$id'");

	return undef
	    if (! $query_result || !$query_result->numrows);

	($idx) = $query_result->fetchrow_array();
    }
    elsif ($token =~ /^\d+$/) {
	$idx = $token;
    }
    elsif ($token =~ /^\w+\-\w+\-\w+\-\w+\-\w+$/) {
	$query_result =
	    DBQueryWarn("select idx from geni_slices ".
			"where uuid='$token'");
	    return undef
		if (! $query_result || !$query_result->numrows);

	    ($idx) = $query_result->fetchrow_array();
    }
    elsif ($token =~ /^[-\w\.]*$/) {
	$query_result =
	    DBQueryWarn("select idx from geni_slices ".
			"where hrn='$token'");
	    return undef
		if (! $query_result || !$query_result->numrows);

	    ($idx) = $query_result->fetchrow_array();
    }
    else {
	return undef;
    }

    $query_result =
	DBQueryWarn("select * from geni_slices where idx='$idx'");
    return undef
	if (!$query_result || !$query_result->numrows);

    my $self         = {};
    $self->{'SLICE'} = $query_result->fetchrow_hashref();
    bless($self, $class);

    #
    # Grab the certificate, since we will probably want it.
    #
    my $uuid = $self->{'SLICE'}->{'uuid'};
    my $certificate = GeniCertificate->Lookup($uuid);
    if (!defined($certificate)) {
	print STDERR "Could not find certificate for slice $idx ($uuid)\n";
	return undef;
    }
    $self->{'CERT'}     = $certificate;
    $self->{'BINDINGS'} = undef;
    $self->{'LOCKED'}   = 0;
    
    return $self;
}
# accessors
sub field($$) { return ((! ref($_[0])) ? -1 : $_[0]->{'SLICE'}->{$_[1]}); }
sub idx($)		{ return field($_[0], "idx"); }
sub hrn($)		{ return field($_[0], "hrn"); }
sub uuid($)		{ return field($_[0], "uuid"); }
sub creator_uuid($)	{ return field($_[0], "creator_uuid"); }
sub created($)		{ return field($_[0], "created"); }
sub shutdown($)		{ return field($_[0], "shutdown"); }
sub expires($)		{ return field($_[0], "expires"); }
sub sa_uuid($)		{ return field($_[0], "sa_uuid"); }
sub exptidx($)		{ return field($_[0], "exptidx"); }
sub needsfirewall($)	{ return field($_[0], "needsfirewall"); }
sub cert($)		{ return $_[0]->{'CERT'}->cert(); }
sub GetCertificate($)   { return $_[0]->{'CERT'}; }
sub LOCKED($)           { return $_[0]->{'LOCKED'}; }

#
# Class function to create new Geni slice and return the object.
#
sub Create($$$$;$)
{
    my ($class, $certificate, $creator_uuid, $authority, $exptidx) = @_;
    my @insert_data = ();

    # Every slice gets a new unique index.
    my $idx = TBGetUniqueIndex('next_exptidx', 1);

    if (!defined($authority)) {
	print STDERR "Need to specify an authority!\n";
	return undef;
    }
    my $sa_uuid = $authority->uuid();

    # Now tack on other stuff we need.
    push(@insert_data, "created=now()");
    push(@insert_data, "expires=DATE_ADD(now(), INTERVAL 1 HOUR)");
    push(@insert_data, "idx='$idx'");
    push(@insert_data, "sa_uuid='$sa_uuid'");
    push(@insert_data, "exptidx=$exptidx")
	if (defined($exptidx));
    
    my $safe_hrn   = DBQuoteSpecial($certificate->hrn());
    my $safe_uuid  = DBQuoteSpecial($certificate->uuid());
    my $safe_cuuid = DBQuoteSpecial($creator_uuid);
    push(@insert_data, "hrn=$safe_hrn");
    push(@insert_data, "uuid=$safe_uuid");
    push(@insert_data, "creator_uuid=$safe_cuuid");

    if ($certificate->Store() != 0) {
	print STDERR "Could not store certificate for new slice.\n";
	return undef;
    }

    # Insert into DB.
    return undef
	if (! DBQueryWarn("insert into geni_slices set " .
			  join(",", @insert_data)));

    return GeniRegistry::GeniSlice->Lookup($idx);
}

#
# Delete the slice.
#
sub Delete($)
{
    my ($self) = @_;

    return -1
	if (! ref($self));

    my $idx  = $self->idx();
    my $uuid = $self->uuid();

    DBQueryWarn("delete from geni_certificates where uuid='$uuid'")
	or return -1;
    DBQueryWarn("delete from geni_slices where idx='$idx'")
	or return -1;
    
    return 0;
}

#
# Class method to check for an existing user that has the same
# uid/email. Lets not allow this for now. Return the number of
# users that match or -1 if an error. 
#
sub CheckExisting($$$)
{
    my ($class, $hrn, $uuid) = @_;

    my $safe_hrn  = DBQuoteSpecial($hrn);
    my $safe_uuid = DBQuoteSpecial($uuid);

    my $query_result =
	DBQueryFatal("select idx from geni_slices ".
		     "where hrn=$safe_hrn or uuid=$safe_uuid");
    return -1
	if (!defined($query_result));

    return $query_result->numrows;
}

#
# List all slices.
#
sub ListAll($$)
{
    my ($class, $pref) = @_;
    my @result = ();
    @$pref = ();

    my $query = "select uuid from geni_slices ";
    my $query_result = DBQueryWarn($query);

    return -1
	if (! $query_result);
    return 0
	if (!$query_result->numrows);

    while (my ($uuid) = $query_result->fetchrow_array()) {
	my $slice = GeniRegistry::GeniSlice->Lookup($uuid);
	if (!defined($slice)) {
	    print STDERR "Could not lookup slice $uuid\n";
	    return -1;
	}
	push(@result, $slice);
    }
    @$pref = @result;
    return 0;
}

#
# Stringify for output.
#
sub Stringify($)
{
    my ($self) = @_;
    
    my $hrn = $self->hrn();
    my $idx = $self->idx();

    return "[GeniSlice: $hrn, IDX: $idx]";
}

##########################################################################
#
package GeniRegistry::ClientSliver;

use GeniDB;
use GeniSlice;
use GeniHRN;
use emutil qw(TBGetUniqueIndex);
use English;
use Data::Dumper;
use overload ('""' => 'Stringify');

#
# Lookup.
#
sub Lookup($$)
{
    my ($class, $token) = @_;
    my $query_result;
    my $idx;

    if( GeniHRN::IsValid( $token ) ) {
	return undef if !GeniHRN::Authoritative($token, "@OURDOMAIN@");

	my ($authority, $type, $id) = GeniHRN::Parse($token);
	return undef if $type ne "sliver";
	
	$query_result = 
	    DBQueryWarn("select idx from client_slivers ".
			"where urn='$token'");
	return undef
	    if (! $query_result || !$query_result->numrows);

	($idx) = $query_result->fetchrow_array();
    }
    elsif ($token =~ /^\d+$/) {
	$idx = $token;
    }
    else {
	return undef;
    }

    $query_result =
	DBQueryWarn("select * from client_slivers where idx='$idx'");
    return undef
	if (!$query_result || !$query_result->numrows);

    my $self         = {};
    $self->{'SLIVER'} = $query_result->fetchrow_hashref();
    bless($self, $class);

    #
    # Grab the slice, since we will probably want it.
    #
    my $slice = GeniSlice->Lookup($self->slice_idx());
    if (!defined($slice)) {
	print STDERR "Could not find slice for slice $idx\n";
	return undef;
    }
    return $self;
}
# accessors
sub field($$) { return ((! ref($_[0])) ? -1 : $_[0]->{'SLIVER'}->{$_[1]}); }
sub idx($)		{ return field($_[0], "idx"); }
sub urn($)		{ return field($_[0], "urn"); }
sub manager_urn($)	{ return field($_[0], "manager_urn"); }
sub slice_idx($)	{ return field($_[0], "slice_idx"); }
sub creator_idx($)	{ return field($_[0], "creator_idx"); }
sub created($)		{ return field($_[0], "created"); }
sub expires($)		{ return field($_[0], "expires"); }
sub manifest($)		{ return field($_[0], "manifest"); }
sub LOCKED($)           { return $_[0]->{'LOCKED'}; }

sub LookupByAuthority($$$)
{
    my ($class, $slice, $urn) = @_;
    my $slice_idx = $slice->idx();
    my $query_result;
    my $idx;

    if (GeniHRN::IsValid($urn)) {
	my $safe_urn = DBQuoteSpecial($urn);

	$query_result = 
	    DBQueryWarn("select idx from client_slivers ".
			"where manager_urn=$safe_urn and ".
			"slice_idx='$slice_idx'");
	return undef
	    if (! $query_result || !$query_result->numrows);

	($idx) = $query_result->fetchrow_array();
    }
    else {
	return undef;
    }
    return GeniRegistry::ClientSliver->Lookup($idx);
}

#
# Class function to create new Geni slice and return the object.
#
sub Create($$$$$)
{
    my ($class, $slice, $manager_urn, $user, $blob) = @_;
    my @insert_data = ();

    # Every one gets a new unique index.
    my $idx = TBGetUniqueIndex('next_clientsliver', 1);
    
    my $slice_idx      = $slice->idx();
    my $user_idx       = $user->idx();
    my $safe_urn       = DBQuoteSpecial($blob->{'urn'});
    my $safe_created   = DBQuoteSpecial($blob->{'created'});
    my $safe_expires   = DBQuoteSpecial($blob->{'expires'});
    my $safe_manager   = DBQuoteSpecial($manager_urn);

    push(@insert_data, "idx='$idx'");
    push(@insert_data, "slice_idx='$slice_idx'");
    push(@insert_data, "creator_idx='$user_idx'");
    push(@insert_data, "urn=$safe_urn");
    push(@insert_data, "manager_urn=$safe_manager");
    push(@insert_data, "created=$safe_created");
    push(@insert_data, "expires=$safe_expires");

    if (exists($blob->{'manifest'})) {
	my $safe_manifest  = DBQuoteSpecial($blob->{'manifest'});
	push(@insert_data, "manifest=$safe_manifest");
    }

    # Insert into DB.
    return undef
	if (! DBQueryWarn("insert into client_slivers set " .
			  join(",", @insert_data)));

    return GeniRegistry::ClientSliver->Lookup($idx);
}

#
# Delete it.
#
sub Delete($)
{
    my ($self) = @_;

    return -1
	if (! ref($self));

    my $idx  = $self->idx();

    DBQueryWarn("delete from client_slivers where idx='$idx'")
	or return -1;
    
    return 0;
}

#
# Stringify for output.
#
sub Stringify($)
{
    my ($self) = @_;
    
    my $urn = $self->urn();
    my $idx = $self->idx();

    return "[ClientSliver: $idx, $urn]";
}

##########################################################################
#
package GeniRegistry::Client;

use Genixmlrpc;
use GeniResponse;
use English;
use Data::Dumper;

#
# Create an object that represents a client connection to a registry.
#
sub Create($$;$$)
{
    my ($class, $authority, $context, $credential) = @_;

    # Cause of the clearinghouse is currently represented by a URL.
    $authority = $authority->url()
	if (ref($authority));

    if (!defined($credential)) {
	my $response =
	    Genixmlrpc::CallMethod($authority, $context, "GetCredential", {});
	
	return undef
	    if (!defined($response) ||
		$response->code() != GENIRESPONSE_SUCCESS);
	$credential = $response->value();
    }
    elsif (ref($credential) eq "GeniCredential") {
	$credential = $credential->asString();
    }

    my $self              = {};
    $self->{'authority'}  = $authority;
    $self->{'context'}    = $context;
    $self->{'credential'} = $credential;
    bless($self, $class);

    return $self;
}
sub authority($)	{ return $_[0]->{"authority"}; }
sub context($)		{ return $_[0]->{"context"}; }
sub credential($)	{ return $_[0]->{"credential"}; }

sub CreateCredential($$;$)
{
    my ($class, $authority, $context) = @_;
    
    #
    # We are creating a self signed credential here, which is fine
    # since we all have the trusted root certs in our caches. This
    # will change later.
    #
    $context = Genixmlrpc->GetContext()
	if (!defined($context));

    if (!defined($context)) {
	print STDERR "Need a context to create a registry credential\n";
	return undef;
    }
    my $credential = GeniCredential->Create($authority->GetCertificate(),
					    $context->certificate());
    if (!defined($credential)) {
	print STDERR "Could not create clearinghouse credential\n";
	return undef;
    }
    if ($credential->Sign($context->certificate()) != 0) {
	$credential->Delete();
	print STDERR "Could not sign clearinghouse credential\n";
	return undef;
    }
    return $credential;
}

#
# Lookup a record.
#
sub Resolve($$$$)
{
    my ($self, $token, $type, $pref) = @_;

    $$pref = undef;
    my $which = "uuid";

    if ($token =~ /^\w+\-\w+\-\w+\-\w+\-\w+$/) {
	$which = "uuid";
    }
    else {
	$which = "hrn";
    }
    my $response =
	Genixmlrpc::CallMethod($self->authority(),
			       $self->context(), 
			       "Resolve",
			       { "credential" => $self->credential(),
				 "type"       => $type,
				 $which       => $token });
    return -1
	if (!defined($response));

    if ($response->IsError()) {
	print STDERR "Resolve: " . $response->Dump() . "\n"
	    if ($response->code() != GENIRESPONSE_SEARCHFAILED());
	return -1;
    }
    
    $$pref = $response->value();
    return 0;
}

#
# Lookup a user.
#
sub LookupUser($$$)
{
    my ($self, $uuid, $pref) = @_;

    return $self->Resolve($uuid, "User", $pref);
}

#
# Lookup a slice.
#
sub LookupSlice($$$)
{
    my ($self, $uuid, $pref) = @_;

    return $self->Resolve($uuid, "Slice", $pref);
}

#
# Register a record.
#
sub Register($$$$)
{
    my ($self, $type, $cert, $info) = @_;

    $info = {} if (!defined($info));

    my $response =
	Genixmlrpc::CallMethod($self->authority(),
			       $self->context(),
			       "Register",
			       { "credential" => $self->credential(),
				 "type"       => $type,
			         "gid"        => $cert,
			         "info"       => $info });

    return -1
	if (!defined($response));

    if ($response->IsError()) {
	print STDERR "Register: " . $response->Dump() . "\n";
	return -1;
    }
    return 0;
}

#
# Register a user.
#
sub RegisterUser($$$$$)
{
    my ($self, $name, $email, $cert, $keys) = @_;

    my $info = { "name"   => $name,
		 "email"  => $email };

    return $self->Register("User", $cert, $info);
}

#
# Register a slice.
#
sub RegisterSlice($$$$)
{
    my ($self, $creator_uuid, $cert, $bindings) = @_;

    my $info = { "creator_uuid"  => $creator_uuid,
	         "userbindings"  => $bindings };

    return $self->Register("Slice", $cert, $info);
}

#
# Remove a record.
#
sub Remove($$$)
{
    my ($self, $type, $uuid) = @_;

    my $response =
	Genixmlrpc::CallMethod($self->authority(),
			       $self->context(),
			       "Remove",
			       { "credential" => $self->credential(),
				 "type"       => $type,
			         "uuid"       => $uuid });
    return -1
	if (!defined($response));

    if ($response->IsError()) {
	print STDERR "Remove: " . $response->Dump() . "\n"
	    if ($response->code() != GENIRESPONSE_SEARCHFAILED());
	return -1;
    }
    return 0;
}

#
# Delete a slice registration.
#
sub RemoveSlice($$)
{
    my ($self, $uuid) = @_;

    return $self->Remove("Slice", $uuid);
}

#
# Emergency shutdown
#
sub Shutdown($$$)
{
    my ($self, $uuid, $clear) = @_;

    my $response =
	Genixmlrpc::CallMethod($self->authority(),
			       $self->context(),
			       "Shutdown",
			       { "credential" => $self->credential(),
				 "clear"      => $clear,
			         "uuid"       => $uuid });
    return -1
	if (!defined($response));

    if ($response->IsError()) {
	print STDERR "Shutdown: " . $response->Dump() . "\n";
	return -1;
    }
    return 0;
}

#
# List components.
#
sub ListComponents($$$)
{
    my ($self, $slice, $pref) = @_;

    my $response =
	Genixmlrpc::CallMethod($self->authority(),
			       $self->context(),
			       "CH::DiscoverResources",
			       { "credential" => $self->credential() });

    return -1
	if (!defined($response));

    if ($response->IsError()) {
	print STDERR "ListComponents: " . $response->Dump() . "\n";
	return -1;
    }
    $$pref = $response->value();
    return 0;
}

#
# Post the CRL
#
sub PostCRL($$)
{
    my ($self, $cert) = @_;

    my $response =
	Genixmlrpc::CallMethod($self->authority(),
			       $self->context(),
			       "PostCRL",
			       { "credential" => $self->credential(),
			         "cert"       => $cert });
    return -1
	if (!defined($response));

    if ($response->IsError()) {
	print STDERR "PostCRL: " . $response->Dump() . "\n";
	return -1;
    }
    return 0;
}

#
# Register a sliver at an SA
#
sub RegisterSliver($$$)
{
    my ($self, $slice_urn, $info) = @_;

    my $response =
	Genixmlrpc::CallMethod($self->authority(),
			       $self->context(),
			       "RegisterSliver",
			       { "credential" => $self->credential(),
			         "slice_urn"  => $slice_urn,
			         "info"       => $info });
    return -1
	if (!defined($response));

    if ($response->IsError()) {
	print STDERR "RegisterSliver: " . $response->Dump() . "\n";
	return -1;
    }
    return 0;
}

#
# UnRegister a sliver at an SA
#
sub UnRegisterSliver($$)
{
    my ($self, $slice_urn) = @_;

    my $response =
	Genixmlrpc::CallMethod($self->authority(),
			       $self->context(),
			       "UnRegisterSliver",
			       { "credential" => $self->credential(),
			         "slice_urn"  => $slice_urn });
    return -1
	if (!defined($response));

    if ($response->IsError()) {
	print STDERR "UnRegisterSliver: " . $response->Dump() . "\n";
	return -1;
    }
    return 0;
}

##########################################################################
#
package GeniRegistry::ClearingHouse;

use Genixmlrpc;
use GeniResponse;
use GeniCertificate;
use GeniCredential;

#
# The clearinghouse is a registry.
#
sub Create($;$$)
{
    my ($class, $context, $credential) = @_;
    
    my $EMULAB_PEMFILE1 = "@prefix@/etc/genima.pem";
    my $EMULAB_PEMFILE2 = "@prefix@/etc/genich.pem";
    my $url;

    if (!defined($credential)) {
	my $pemfile;

	if (-e $EMULAB_PEMFILE1) {
	    $pemfile = $EMULAB_PEMFILE1
	}
	elsif (-e $EMULAB_PEMFILE2) {
	    $pemfile = $EMULAB_PEMFILE2;
	}
	else {
	    print STDERR "Cannot find the pem file for the clearinghouse!\n";
	    return undef;
	}

	#
	# We are creating a self signed credential here, which is fine
	# since the Clearinghouse has the certs of all trusted roots.
	#
	my $certificate = GeniCertificate->LoadFromFile($pemfile);
	if (!defined($certificate)) {
	    print STDERR "Could not load certificate from $pemfile\n";
	    return undef;
	}
	$context = Genixmlrpc->GetContext()
	    if (!defined($context));

	if (!defined($context)) {
	    print STDERR "Need a context to create clearinghouse credential\n";
	    return undef;
	}
	$credential = GeniCredential->Create($certificate,
					     $context->certificate());
	if (!defined($credential)) {
	    print STDERR "Could not create clearinghouse credential\n";
	    return undef;
	}
	if ($credential->Sign($context->certificate()) != 0) {
	    $credential->Delete();
	    print STDERR "Could not sign clearinghouse credential\n";
	    return undef;
	}
    }
    
    return GeniRegistry::Client->Create($credential->target_cert()->URL(),
					$context, $credential->asString());
}

#
# Get a credential from the clearinghouse, as for bootstrapping.
#
sub GetCredential($;$)
{
    my ($class, $context) = @_;

    $context = Genixmlrpc->GetContext()
	if (!defined($context));

    my $EMULAB_PEMFILE = "@prefix@/etc/genich.pem";
    if (!defined($EMULAB_PEMFILE)) {
	print STDERR "$EMULAB_PEMFILE needed to talk to the clearinghouse\n";
	return undef;
    }
    my $certificate = GeniCertificate->LoadFromFile($EMULAB_PEMFILE);
    if (!defined($certificate)) {
	print STDERR "Could not load CH certificate from $EMULAB_PEMFILE\n";
	return undef;
    }
    my $url = $certificate->URL();
    if (!defined($url)) {
	print STDERR "No URI extension in $EMULAB_PEMFILE\n";
	return undef;
    }
    my $response =
	Genixmlrpc::CallMethod($url, $context, "GetCredential",
			       {"gid" => $context->certificate()->cert()});
	
    return undef
	if (!defined($response) ||
	    $response->code() != GENIRESPONSE_SUCCESS());

    return GeniCredential->CreateFromSigned($response->value(), 1);
}

# _Always_ make sure that this 1 is at the end of the file...
1;
