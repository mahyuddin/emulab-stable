#!/usr/bin/perl -wT
#
# EMULAB-COPYRIGHT
# Copyright (c) 2008-2009 University of Utah and the Flux Group.
# All rights reserved.
#
package GeniRegistry;

#
# Server side of a Registry.
#
use strict;
use Exporter;
use vars qw(@ISA @EXPORT);

@ISA    = "Exporter";
@EXPORT = qw ( );

# Must come after package declaration!
use lib '@prefix@/lib';
use Genixmlrpc;
use GeniResponse;
use English;
use Data::Dumper;

##########################################################################
#
package GeniRegistry::Client;

use Genixmlrpc;
use GeniResponse;
use English;
use Data::Dumper;

#
# Create an object that represents a client connection to a registry.
#
sub Create($$;$$)
{
    my ($class, $authority, $context, $credential) = @_;

    # Cause of the clearinghouse is currently represented by a URL.
    $authority = $authority->url()
	if (ref($authority));

    if (!defined($credential)) {
	my $response =
	    Genixmlrpc::CallMethod($authority, $context, "GetCredential", {});
	
	return undef
	    if (!defined($response) ||
		$response->code() != GENIRESPONSE_SUCCESS);
	$credential = $response->value();
    }
    elsif (ref($credential) eq "GeniCredential") {
	$credential = $credential->asString();
    }

    my $self              = {};
    $self->{'authority'}  = $authority;
    $self->{'context'}    = $context;
    $self->{'credential'} = $credential;
    bless($self, $class);

    return $self;
}
sub authority($)	{ return $_[0]->{"authority"}; }
sub context($)		{ return $_[0]->{"context"}; }
sub credential($)	{ return $_[0]->{"credential"}; }

sub CreateCredential($$;$)
{
    my ($class, $authority, $context) = @_;
    
    #
    # We are creating a self signed credential here, which is fine
    # since we all have the trusted root certs in our caches. This
    # will change later.
    #
    $context = Genixmlrpc->GetContext()
	if (!defined($context));

    if (!defined($context)) {
	print STDERR "Need a context to create a registry credential\n";
	return undef;
    }
    my $credential = GeniCredential->Create($authority->GetCertificate(),
					    $context->certificate());
    if (!defined($credential)) {
	print STDERR "Could not create clearinghouse credential\n";
	return undef;
    }
    if ($credential->Sign($context->certificate()) != 0) {
	$credential->Delete();
	print STDERR "Could not sign clearinghouse credential\n";
	return undef;
    }
    return $credential;
}

#
# Lookup a record.
#
sub Resolve($$$$)
{
    my ($self, $uuid, $type, $pref) = @_;

    $$pref = undef;
    
    my $response =
	Genixmlrpc::CallMethod($self->authority(),
			       $self->context(), 
			       "Resolve",
			       { "credential" => $self->credential(),
				 "type"       => $type,
				 "uuid"       => $uuid });
    return -1
	if (!defined($response) || $response->code() != GENIRESPONSE_SUCCESS);
    
    $$pref = $response->value();
    return 0;
}

#
# Lookup a user.
#
sub LookupUser($$$)
{
    my ($self, $uuid, $pref) = @_;

    return $self->Resolve($uuid, "User", $pref);
}

#
# Lookup a slice.
#
sub LookupSlice($$$)
{
    my ($self, $uuid, $pref) = @_;

    return $self->Resolve($uuid, "Slice", $pref);
}

#
# Register a record.
#
sub Register($$$$)
{
    my ($self, $type, $cert, $info) = @_;

    $info = {} if (!defined($info));

    my $response =
	Genixmlrpc::CallMethod($self->authority(),
			       $self->context(),
			       "Register",
			       { "credential" => $self->credential(),
				 "type"       => $type,
			         "gid"        => $cert,
			         "info"       => $info });
    return -1
	if (!defined($response) || $response->code() != GENIRESPONSE_SUCCESS);
    
    return 0;
}

#
# Register a user.
#
sub RegisterUser($$$$$)
{
    my ($self, $name, $email, $cert, $keys) = @_;

    my $info = { "name"   => $name,
		 "email"  => $email };

    return $self->Register("User", $cert, $info);
}

#
# Register a slice.
#
sub RegisterSlice($$$$)
{
    my ($self, $creator_uuid, $cert, $bindings) = @_;

    my $info = { "creator_uuid"  => $creator_uuid,
	         "userbindings"  => $bindings };

    return $self->Register("Slice", $cert, $info);
}

#
# Remove a record.
#
sub Remove($$$)
{
    my ($self, $type, $uuid) = @_;

    my $response =
	Genixmlrpc::CallMethod($self->authority(),
			       $self->context(),
			       "Remove",
			       { "credential" => $self->credential(),
				 "type"       => $type,
			         "uuid"       => $uuid });
    return -1
	if (!defined($response) || $response->code() != GENIRESPONSE_SUCCESS);
    
    return 0;
}

#
# Delete a slice registration.
#
sub RemoveSlice($$)
{
    my ($self, $uuid) = @_;

    return $self->Remove("Slice", $uuid);
}

#
# Emergency shutdown
#
sub Shutdown($$$)
{
    my ($self, $uuid, $onoff) = @_;

    my $response =
	Genixmlrpc::CallMethod($self->authority(),
			       $self->context(),
			       "Shutdown",
			       { "credential" => $self->credential(),
				 "onoff"      => $onoff,
			         "uuid"       => $uuid });
    return -1
	if (!defined($response) || $response->code() != GENIRESPONSE_SUCCESS);
    
    return 0;
}

#
# List components.
#
sub ListComponents($$$)
{
    my ($self, $slice, $pref) = @_;

    my $response =
	Genixmlrpc::CallMethod($self->authority(),
			       $self->context(),
			       "CH::DiscoverResources",
			       { "credential" => $self->credential() });

    return -1
	if (!defined($response));

    return -1
	if ($response->code() != GENIRESPONSE_SUCCESS);

    $$pref = $response->value();
    return 0;
}

#
# Post the CRL
#
sub PostCRL($$)
{
    my ($self, $cert) = @_;

    my $response =
	Genixmlrpc::CallMethod($self->authority(),
			       $self->context(),
			       "PostCRL",
			       { "credential" => $self->credential(),
			         "cert"       => $cert });
    return -1
	if (!defined($response) || $response->code() != GENIRESPONSE_SUCCESS);
    
    return 0;
}

##########################################################################
#
package GeniRegistry::ClearingHouse;

use Genixmlrpc;
use GeniResponse;
use GeniCertificate;
use GeniCredential;

#
# The clearinghouse is a registry.
#
sub Create($;$$)
{
    my ($class, $context, $credential) = @_;
    
    my $EMULAB_PEMFILE1 = "@prefix@/etc/genima.pem";
    my $EMULAB_PEMFILE2 = "@prefix@/etc/genich.pem";
    my $url;

    if (!defined($credential)) {
	my $pemfile;

	if (-e $EMULAB_PEMFILE1) {
	    $pemfile = $EMULAB_PEMFILE1
	}
	elsif (-e $EMULAB_PEMFILE2) {
	    $pemfile = $EMULAB_PEMFILE2;
	}
	else {
	    print STDERR "Cannot find the pem file for the clearinghouse!\n";
	    return undef;
	}

	#
	# We are creating a self signed credential here, which is fine
	# since the Clearinghouse has the certs of all trusted roots.
	#
	my $certificate = GeniCertificate->LoadFromFile($pemfile);
	if (!defined($certificate)) {
	    print STDERR "Could not load certificate from $pemfile\n";
	    return undef;
	}
	$context = Genixmlrpc->GetContext()
	    if (!defined($context));

	if (!defined($context)) {
	    print STDERR "Need a context to create clearinghouse credential\n";
	    return undef;
	}
	$credential = GeniCredential->Create($certificate,
					     $context->certificate());
	if (!defined($credential)) {
	    print STDERR "Could not create clearinghouse credential\n";
	    return undef;
	}
	if ($credential->Sign($context->certificate()) != 0) {
	    $credential->Delete();
	    print STDERR "Could not sign clearinghouse credential\n";
	    return undef;
	}
    }
    
    return GeniRegistry::Client->Create($credential->target_cert()->URL(),
					$context, $credential->asString());
}

#
# Get a credential from the clearinghouse, as for bootstrapping.
#
sub GetCredential($;$)
{
    my ($class, $context) = @_;

    $context = Genixmlrpc->GetContext()
	if (!defined($context));

    my $EMULAB_PEMFILE = "@prefix@/etc/genich.pem";
    if (!defined($EMULAB_PEMFILE)) {
	print STDERR "$EMULAB_PEMFILE needed to talk to the clearinghouse\n";
	return undef;
    }
    my $certificate = GeniCertificate->LoadFromFile($EMULAB_PEMFILE);
    if (!defined($certificate)) {
	print STDERR "Could not load CH certificate from $EMULAB_PEMFILE\n";
	return undef;
    }
    my $url = $certificate->URL();
    if (!defined($url)) {
	print STDERR "No URI extension in $EMULAB_PEMFILE\n";
	return undef;
    }
    my $response =
	Genixmlrpc::CallMethod($url, $context, "GetCredential",
			       {"gid" => $context->certificate()->cert()});
	
    return undef
	if (!defined($response) ||
	    $response->code() != GENIRESPONSE_SUCCESS());

    return GeniCredential->CreateFromSigned($response->value(), 1);
}

# _Always_ make sure that this 1 is at the end of the file...
1;
