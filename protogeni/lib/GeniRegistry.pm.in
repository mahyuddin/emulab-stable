#!/usr/bin/perl -wT
#
# GENIPUBLIC-COPYRIGHT
# Copyright (c) 2008-2010 University of Utah and the Flux Group.
# All rights reserved.
#
package GeniRegistry;

#
# Server side of a Registry.
#
use strict;
use Exporter;
use vars qw(@ISA @EXPORT);

@ISA    = "Exporter";
@EXPORT = qw ( );

use Genixmlrpc;
use GeniResponse;
use English;
use Data::Dumper;

##########################################################################
#
package GeniRegistry::GeniSlice;

use GeniDB;
use GeniCertificate;
use GeniHRN;
use emutil qw(TBGetUniqueIndex);
use English;
use Data::Dumper;
use overload ('""' => 'Stringify');

#
# Lookup by URN, idx or uuid.
#
sub Lookup($$)
{
    my ($class, $token) = @_;
    my $query_result;
    my $idx;

    if( GeniHRN::IsValid( $token ) ) {
	my ($authority, $type, $id) = GeniHRN::Parse( $token );

	return undef if $type ne "slice";
	
	if( GeniHRN::Authoritative( $token, "@OURDOMAIN@" ) ) {
	    # Good: this is one of our slices, and we can confidently
	    # transform the name for direct lookup.  This method is
	    # very general, and will even resolve a URN to a (deprecated)
	    # pre-URN slice.
	    $query_result =
		DBQueryWarn("select idx from geni_slices ".
			    "where hrn='@PROTOGENI_DOMAIN@.$id'");
	} else {
	    # Somebody else's slice.  We'll have to look up the slice
	    # by its certificate, which will work only for post-URN slices.
	    $query_result = DBQueryWarn(
		"SELECT geni_slices.idx FROM geni_slices, geni_certificates " .
		"WHERE geni_slices.uuid = geni_certificates.uuid AND " .
		"geni_certificates.urn='$token';" );
	}

	return undef if (! $query_result || !$query_result->numrows);

	($idx) = $query_result->fetchrow_array();
    }
    elsif ($token =~ /^\d+$/) {
	$idx = $token;
    }
    elsif ($token =~ /^\w+\-\w+\-\w+\-\w+\-\w+$/) {
	$query_result =
	    DBQueryWarn("select idx from geni_slices ".
			"where uuid='$token'");
	    return undef
		if (! $query_result || !$query_result->numrows);

	    ($idx) = $query_result->fetchrow_array();
    }
    elsif ($token =~ /^[-\w\.]*$/) {
	$query_result =
	    DBQueryWarn("select idx from geni_slices ".
			"where hrn='$token'");
	    return undef
		if (! $query_result || !$query_result->numrows);

	    ($idx) = $query_result->fetchrow_array();
    }
    else {
	return undef;
    }

    $query_result =
	DBQueryWarn("select * from geni_slices where idx='$idx'");
    return undef
	if (!$query_result || !$query_result->numrows);

    my $self         = {};
    $self->{'SLICE'} = $query_result->fetchrow_hashref();
    bless($self, $class);

    #
    # Grab the certificate, since we will probably want it.
    #
    my $uuid = $self->{'SLICE'}->{'uuid'};
    my $certificate = GeniCertificate->Lookup($uuid);
    if (!defined($certificate)) {
	print STDERR "Could not find certificate for slice $idx ($uuid)\n";
	return undef;
    }
    $self->{'CERT'}     = $certificate;
    $self->{'BINDINGS'} = undef;
    $self->{'LOCKED'}   = 0;
    
    return $self;
}
# accessors
sub field($$) { return ((! ref($_[0])) ? -1 : $_[0]->{'SLICE'}->{$_[1]}); }
sub idx($)		{ return field($_[0], "idx"); }
sub hrn($)		{ return field($_[0], "hrn"); }
sub uuid($)		{ return field($_[0], "uuid"); }
sub creator_uuid($)	{ return field($_[0], "creator_uuid"); }
sub creator_urn($)	{ return field($_[0], "creator_urn"); }
sub created($)		{ return field($_[0], "created"); }
sub shutdown($)		{ return field($_[0], "shutdown"); }
sub expires($)		{ return field($_[0], "expires"); }
sub sa_uuid($)		{ return field($_[0], "sa_uuid"); }
sub exptidx($)		{ return field($_[0], "exptidx"); }
sub needsfirewall($)	{ return field($_[0], "needsfirewall"); }
sub registered($)	{ return field($_[0], "registered"); }
sub cert($)		{ return $_[0]->{'CERT'}->cert(); }
sub GetCertificate($)   { return $_[0]->{'CERT'}; }
sub LOCKED($)           { return $_[0]->{'LOCKED'}; }

#
# Class function to create new Geni slice and return the object.
#
sub Create($$$$;$$)
{
    my ($class, $certificate, $creator, $authority, $exptidx, $lock) = @_;
    my @insert_data = ();

    # Every slice gets a new unique index.
    my $idx = TBGetUniqueIndex('next_exptidx', 1);

    if (!defined($authority)) {
	print STDERR "Need to specify an authority!\n";
	return undef;
    }
    my $sa_uuid = $authority->uuid();

    # Now tack on other stuff we need.
    push(@insert_data, "created=now()");
    push(@insert_data, "expires=DATE_ADD(now(), INTERVAL 6 HOUR)");
    push(@insert_data, "idx='$idx'");
    push(@insert_data, "sa_uuid='$sa_uuid'");
    push(@insert_data, "exptidx=$exptidx")
	if (defined($exptidx));
    push(@insert_data, "locked=now()")
	if (defined($lock) && $lock);
    
    my $safe_hrn   = DBQuoteSpecial($certificate->hrn());
    my $safe_uuid  = DBQuoteSpecial($certificate->uuid());
    my $safe_cuuid = DBQuoteSpecial($creator->uuid());
    my $safe_curn  = DBQuoteSpecial($creator->urn());
    push(@insert_data, "hrn=$safe_hrn");
    push(@insert_data, "uuid=$safe_uuid");
    push(@insert_data, "creator_uuid=$safe_cuuid");
    push(@insert_data, "creator_urn=$safe_curn");

    if ($certificate->Store() != 0) {
	print STDERR "Could not store certificate for new slice.\n";
	return undef;
    }

    # Insert into DB.
    return undef
	if (! DBQueryWarn("insert into geni_slices set " .
			  join(",", @insert_data)));

    return GeniRegistry::GeniSlice->Lookup($idx);
}

#
# Delete the slice.
#
sub Delete($)
{
    my ($self) = @_;

    return -1
	if (! ref($self));

    my $idx  = $self->idx();
    my $uuid = $self->uuid();

    DBQueryWarn("delete from geni_certificates where uuid='$uuid'")
	or return -1;
    DBQueryWarn("delete from geni_slices where idx='$idx'")
	or return -1;
    
    return 0;
}

#
# Return the URN. This is complicated by the fact that the DB does
# not store the urn, but is in the certificate. Further, it might
# be a slice from an SA not doing URNs yet, in which case set it to
# the uuid and hope for the best.
#
sub urn($)
{
    my ($self) = @_;
    my $urn = $self->GetCertificate()->urn();

    return $urn
	if (defined($urn) && $urn ne "");

    return $self->uuid();
}

#
# List all slices.
#
sub ListAll($$)
{
    my ($class, $pref) = @_;
    my @result = ();
    @$pref = ();

    my $query = "select uuid from geni_slices ";
    my $query_result = DBQueryWarn($query);

    return -1
	if (! $query_result);
    return 0
	if (!$query_result->numrows);

    while (my ($uuid) = $query_result->fetchrow_array()) {
	my $slice = GeniRegistry::GeniSlice->Lookup($uuid);
	if (!defined($slice)) {
	    print STDERR "Could not lookup slice $uuid\n";
	    return -1;
	}
	push(@result, $slice);
    }
    @$pref = @result;
    return 0;
}

#
# Stringify for output.
#
sub Stringify($)
{
    my ($self) = @_;
    
    my $hrn = $self->hrn();
    my $idx = $self->idx();

    return "[GeniSlice: $hrn, IDX: $idx]";
}

##########################################################################
#
package GeniRegistry::ClientSliver;

use GeniDB;
use GeniSlice;
use GeniHRN;
use emutil qw(TBGetUniqueIndex);
use English;
use Data::Dumper;
use overload ('""' => 'Stringify');

#
# Lookup.
#
sub Lookup($$)
{
    my ($class, $token) = @_;
    my $query_result;
    my $idx;

    if( GeniHRN::IsValid( $token ) ) {
	$token = GeniHRN::Normalise( $token );

	my ($authority, $type, $id) = GeniHRN::Parse($token);
	return undef if $type ne "sliver";
	
	$query_result = 
	    DBQueryWarn("select idx from client_slivers ".
			"where urn='$token'");
	return undef
	    if (! $query_result || !$query_result->numrows);

	($idx) = $query_result->fetchrow_array();
    }
    elsif ($token =~ /^\d+$/) {
	$idx = $token;
    }
    else {
	return undef;
    }

    $query_result =
	DBQueryWarn("select * from client_slivers where idx='$idx'");
    return undef
	if (!$query_result || !$query_result->numrows);

    my $self         = {};
    $self->{'SLIVER'} = $query_result->fetchrow_hashref();
    bless($self, $class);

    #
    # Grab the slice, since we will probably want it.
    #
    my $slice = GeniSlice->Lookup($self->slice_idx());
    if (!defined($slice)) {
	print STDERR "Could not find slice for slice $idx\n";
	return undef;
    }
    return $self;
}
# accessors
sub field($$) { return ((! ref($_[0])) ? -1 : $_[0]->{'SLIVER'}->{$_[1]}); }
sub idx($)		{ return field($_[0], "idx"); }
sub urn($)		{ return field($_[0], "urn"); }
sub manager_urn($)	{ return field($_[0], "manager_urn"); }
sub slice_idx($)	{ return field($_[0], "slice_idx"); }
sub creator_idx($)	{ return field($_[0], "creator_idx"); }
sub created($)		{ return field($_[0], "created"); }
sub expires($)		{ return field($_[0], "expires"); }
sub manifest($)		{ return field($_[0], "manifest"); }
sub LOCKED($)           { return $_[0]->{'LOCKED'}; }

sub LookupByAuthority($$$)
{
    my ($class, $slice, $urn) = @_;
    my $slice_idx = $slice->idx();
    my $query_result;
    my $idx;

    if (GeniHRN::IsValid($urn)) {
	my $safe_urn = DBQuoteSpecial($urn);

	$query_result = 
	    DBQueryWarn("select idx from client_slivers ".
			"where manager_urn=$safe_urn and ".
			"slice_idx='$slice_idx'");
	return undef
	    if (! $query_result || !$query_result->numrows);

	($idx) = $query_result->fetchrow_array();
    }
    else {
	return undef;
    }
    return GeniRegistry::ClientSliver->Lookup($idx);
}

# Returns an array of client slivers belonging which belong to a
# particular slice.
sub LookupBySlice($$)
{
    my ($class, $slice) = @_;
    my $slice_idx = $slice->idx();
    my $query_result;
    my @result = ();
    $query_result =
	DBQueryWarn("select idx from client_slivers ".
		    "where slice_idx='$slice_idx'");
    if ($query_result) {
	while (my ($idx) = $query_result->fetchrow_array()) {
	    my $sliver = GeniRegistry::ClientSliver->Lookup($idx);
	    if (defined($sliver)) {
		push(@result, $sliver);
	    }
	}
    }
    return @result;
}

#
# Class function to create new Geni slice and return the object.
#
sub Create($$$$$)
{
    my ($class, $slice, $manager_urn, $user, $blob) = @_;
    my @insert_data = ();

    # Every one gets a new unique index.
    my $idx = TBGetUniqueIndex('next_clientsliver', 1);
    
    my $slice_idx      = $slice->idx();
    my $user_idx       = $user->idx();
    my $safe_urn       = DBQuoteSpecial($blob->{'urn'});
    my $safe_created   = DBQuoteSpecial($blob->{'created'});
    my $safe_expires   = DBQuoteSpecial($blob->{'expires'});
    my $safe_manager   = DBQuoteSpecial($manager_urn);

    push(@insert_data, "idx='$idx'");
    push(@insert_data, "slice_idx='$slice_idx'");
    push(@insert_data, "creator_idx='$user_idx'");
    push(@insert_data, "urn=$safe_urn");
    push(@insert_data, "manager_urn=$safe_manager");
    push(@insert_data, "created=$safe_created");
    push(@insert_data, "expires=$safe_expires");

    if (exists($blob->{'manifest'})) {
	my $safe_manifest  = DBQuoteSpecial($blob->{'manifest'});
	push(@insert_data, "manifest=$safe_manifest");
    }

    # Insert into DB.
    return undef
	if (! DBQueryWarn("insert into client_slivers set " .
			  join(",", @insert_data)));

    return GeniRegistry::ClientSliver->Lookup($idx);
}

#
# Delete it.
#
sub Delete($)
{
    my ($self) = @_;

    return -1
	if (! ref($self));

    my $idx  = $self->idx();

    DBQueryWarn("delete from client_slivers where idx='$idx'")
	or return -1;
    
    return 0;
}

#
# Delete all for a slice.
#
sub SliceDelete($$)
{
    my ($self, $slice) = @_;

    return -1
	if (! ref($self));

    my $slice_idx = $self->slice_idx();

    DBQueryWarn("delete from client_slivers where slice_idx='$slice_idx'")
	or return -1;
    
    return 0;
}

#
# Stringify for output.
#
sub Stringify($)
{
    my ($self) = @_;
    
    my $urn = $self->urn();
    my $idx = $self->idx();

    return "[ClientSliver: $idx, $urn]";
}

##########################################################################
#
package GeniRegistry::Client;

use Genixmlrpc;
use GeniResponse;
use GeniCredential;
use English;
use Data::Dumper;
use Date::Parse;
use POSIX qw(strftime tmpnam);
use Time::Local;

#
# Create an object that represents a client connection to a registry.
#
sub Create($$;$$)
{
    my ($class, $authority, $context, $credential) = @_;

    if (!defined($credential)) {
	$credential = GeniRegistry::Client->GetCredential($authority);
	return undef
	    if (!defined($credential));
    }

    my $self              = {};
    $self->{'authority'}  = $authority;
    $self->{'context'}    = $context;
    $self->{'credential'} = $credential;
    bless($self, $class);

    return $self;
}
sub authority($)	{ return $_[0]->{"authority"}; }
sub context($)		{ return $_[0]->{"context"}; }
sub credential($)	{ return $_[0]->{"credential"}; }

sub GetCredential($;$$)
{
    my ($class, $authority, $context) = @_;

    my $credential =
	GeniCredential->Lookup($authority->uuid(), $ENV{'MYUUID'});

    if (defined($credential) &&
	defined($credential->expires())) {
	my $expires = str2time($credential->expires());
	
	# Some buffer.
	if ($expires > time() + 3600) {
	    #print STDERR "Reusing clearinghouse credential\n";
	    return $credential;
	}
	$credential->Delete();
    }
    #print STDERR "Getting new clearinghouse credential\n";

    $context = Genixmlrpc->GetContext()
	if (!defined($context));
    
    if (!defined($context)) {
	print STDERR "Need a context to create a registry credential\n";
	return undef;
    }

    my $url = $authority->url();
    if (!defined($url)) {
	print STDERR "$authority has no URL\n";
	return undef;
    }
    my $response =
	Genixmlrpc::CallMethod($url, $context, "GetCredential",
			       {"gid" => $context->certificate()->cert()});
	
    return undef
	if (!defined($response));
    
    if ($response->IsError()) {
	print STDERR "GeniRegistry::Client->GetCredential: " .
	    $response->Dump() . "\n";
	return undef;
    }
    $credential = GeniCredential->CreateFromSigned($response->value(), 1);
    if (!defined($credential)) {
	print STDERR "Could not parse credential from $authority\n";
	return undef;
    }
    $credential->Store();
    
    return $credential;
}

#
# Lookup a record.
#
sub Resolve($$$$)
{
    my ($self, $token, $type, $pref) = @_;

    $$pref = undef;
    my $which = "uuid";

    if ($token =~ /^\w+\-\w+\-\w+\-\w+\-\w+$/) {
	$which = "uuid";
    }
    elsif (GeniHRN::IsValid($token)) {
	$which = "urn";
    }
    else {
	$which = "hrn";
    }
    my $response =
	Genixmlrpc::CallMethod($self->authority()->url(),
			       $self->context(), 
			       "Resolve",
			       { "credential" =>
				     $self->credential()->asString(),
				 "type"       => $type,
				 $which       => $token });
    return -1
	if (!defined($response));

    if ($response->IsError()) {
	print STDERR "Resolve: " . $response->Dump() . "\n"
	    if ($response->code() != GENIRESPONSE_SEARCHFAILED());
	return -1;
    }
    
    $$pref = $response->value();
    return 0;
}

#
# Lookup a user.
#
sub LookupUser($$$)
{
    my ($self, $urn, $pref) = @_;

    return $self->Resolve($urn, "User", $pref);
}

#
# Lookup a slice.
#
sub LookupSlice($$$)
{
    my ($self, $urn, $pref) = @_;

    return $self->Resolve($urn, "Slice", $pref);
}

#
# Register a record.
#
sub Register($$$$)
{
    my ($self, $type, $cert, $info) = @_;

    $info = {} if (!defined($info));

    my $response =
	Genixmlrpc::CallMethod($self->authority()->url(),
			       $self->context(),
			       "Register",
			       { "credential" =>
				     $self->credential()->asString(),
				 "type"       => $type,
			         "gid"        => $cert,
			         "info"       => $info });

    return -1
	if (!defined($response));

    if ($response->IsError()) {
	print STDERR "Register: " . $response->Dump() . "\n";
	return -1;
    }
    return 0;
}

#
# Register a user.
#
sub RegisterUser($$$$$)
{
    my ($self, $name, $email, $cert, $keys) = @_;

    my $info = { "name"   => $name,
		 "email"  => $email };

    return $self->Register("User", $cert, $info);
}

#
# Register a slice.
#
sub RegisterSlice($$$$$)
{
    my ($self, $creator_urn, $expiration, $cert, $bindings) = @_;

    my $info = { "creator_urn"   => $creator_urn,
		 "expiration"    => $expiration,
	         "userbindings"  => $bindings };

    return $self->Register("Slice", $cert, $info);
}

#
# Remove a record.
#
sub Remove($$$)
{
    my ($self, $type, $urn) = @_;

    my $response =
	Genixmlrpc::CallMethod($self->authority()->url(),
			       $self->context(),
			       "Remove",
			       { "credential" =>
				     $self->credential()->asString(),
				 "type"       => $type,
			         "urn"        => $urn });
    return -1
	if (!defined($response));

    if ($response->IsError()) {
	print STDERR "Remove: " . $response->Dump() . "\n"
	    if ($response->code() != GENIRESPONSE_SEARCHFAILED());
	return -1;
    }
    return 0;
}

#
# Delete a slice registration.
#
sub RemoveSlice($$)
{
    my ($self, $urn) = @_;

    return $self->Remove("Slice", $urn);
}

#
# Emergency shutdown
#
sub Shutdown($$$)
{
    my ($self, $urn, $clear) = @_;

    my $response =
	Genixmlrpc::CallMethod($self->authority()->url(),
			       $self->context(),
			       "Shutdown",
			       { "credential"  =>
				     $self->credential()->asString(),
				 "clear"       => $clear,
			         "urn"         => $urn });
    return -1
	if (!defined($response));

    if ($response->IsError()) {
	print STDERR "Shutdown: " . $response->Dump() . "\n";
	return -1;
    }
    return 0;
}

#
# List components.
#
sub ListComponents($$$)
{
    my ($self, $slice, $pref) = @_;

    my $response =
	Genixmlrpc::CallMethod($self->authority()->url(),
			       $self->context(),
			       "CH::DiscoverResources",
			       { "credential" =>
				     $self->credential()->asString() });

    return -1
	if (!defined($response));

    if ($response->IsError()) {
	print STDERR "ListComponents: " . $response->Dump() . "\n";
	return -1;
    }
    $$pref = $response->value();
    return 0;
}

#
# Post the CRL
#
sub PostCRL($$)
{
    my ($self, $cert) = @_;

    my $response =
	Genixmlrpc::CallMethod($self->authority()->url(),
			       $self->context(),
			       "PostCRL",
			       { "credential" =>
				     $self->credential()->asString(),
			         "cert"       => $cert });
    return -1
	if (!defined($response));

    if ($response->IsError()) {
	print STDERR "PostCRL: " . $response->Dump() . "\n";
	return -1;
    }
    return 0;
}

#
# Register a sliver at an SA
#
sub RegisterSliver($$$)
{
    my ($self, $slice_urn, $info) = @_;

    my $response =
	Genixmlrpc::CallMethod($self->authority()->url(),
			       $self->context(),
			       "RegisterSliver",
			       { "credential" =>
				     $self->credential()->asString(),
			         "slice_urn"  => $slice_urn,
			         "info"       => $info });
    return -1
	if (!defined($response));

    if ($response->IsError()) {
	print STDERR "RegisterSliver: " . $response->Dump() . "\n";
	return -1;
    }
    return 0;
}

#
# UnRegister a sliver at an SA
#
sub UnRegisterSliver($$)
{
    my ($self, $slice_urn) = @_;

    my $response =
	Genixmlrpc::CallMethod($self->authority()->url(),
			       $self->context(),
			       "UnRegisterSliver",
			       { "credential" =>
				     $self->credential()->asString(),
			         "slice_urn"  => $slice_urn });
    return -1
	if (!defined($response));

    if ($response->IsError()) {
	print STDERR "UnRegisterSliver: " . $response->Dump() . "\n";
	return -1;
    }
    return 0;
}

##########################################################################
#
package GeniRegistry::ClearingHouse;

use Genixmlrpc;
use GeniResponse;
use GeniCertificate;
use GeniCredential;
use Date::Parse;
use POSIX qw(strftime tmpnam);
use Time::Local;

#
# The clearinghouse is a registry.
#
# XXX This needs to go ... we cannot create a clearinghouse credential
# locally since we cannot sign it (target_urn!=our_urn).
#
sub Create($;$$)
{
    my ($class, $context, $credential) = @_;
    
    if (!defined($credential)) {
	$credential = GeniRegistry::ClearingHouse->GetCredential();
	if (!defined($credential)) {
	    print STDERR "Could not create clearinghouse credential\n";
	    return undef;
	}
    }
    $context = Genixmlrpc->GetContext()
	if (!defined($context));

    if (!defined($context)) {
	print STDERR "Need a context to create clearinghouse credential\n";
	return undef;
    }
    return GeniRegistry::Client->Create($credential->target_cert(),
					$context, $credential);
}

#
# Load the CH certificate.
#
sub GetCertificate($)
{
    my ($class) = @_;
    my $ETCDIR  = "@prefix@/etc";

    my $certfile = ((-s "$ETCDIR/genich-local.pem") ?
		    "$ETCDIR/genich-local.pem" : "$ETCDIR/genich.pem");
    if (! -e $certfile) {
	print STDERR "$certfile does not exist!\n";
	return undef;
    }
    my $certificate = GeniCertificate->LoadFromFile($certfile);
    if (!defined($certificate)) {
	print STDERR "Could not load CH certificate from $certfile\n";
	return undef;
    }
    return $certificate;
}

#
# Get a credential from the clearinghouse to talk to it.
#
sub GetCredential($;$$)
{
    my ($class, $context, $certfile) = @_;

    $context = Genixmlrpc->GetContext()
	if (!defined($context));

    #
    # If there is no UUID in the environment, then try to figure it
    # out from the context.
    #
    my $myuuid = (exists($ENV{'MYUUID'}) ? $ENV{'MYUUID'} : undef);
    if (!defined($myuuid) && defined($context)) {
	$myuuid = $context->certificate()->uuid();
    }
    if (!defined($myuuid)) {
	print STDERR "*** GeniRegistry::ClearingHouse::GetCredential: ".
	    "No context or MYUUID for RPC\n";
	return undef;
    }

    my $clearinghousecert = GeniRegistry::ClearingHouse->GetCertificate();
    if (!defined($clearinghousecert)) {
	return undef;
    }
    my $clearinghousecred =
	GeniCredential->Lookup($clearinghousecert->uuid(), $myuuid);

    #print "$clearinghousecred\n";

    if (defined($clearinghousecred) &&
	defined($clearinghousecred->expires())) {
	my $expires = str2time($clearinghousecred->expires());
	
	# Some buffer.
	if ($expires > time() + 3600) {
	    #print STDERR "Reusing clearinghouse credential\n";
	    return $clearinghousecred;
	}
	$clearinghousecred->Delete();
    }
    #print STDERR "Getting new clearinghouse credential\n";

    my $url = $clearinghousecert->URL();
    if (!defined($url)) {
	print STDERR "No URI extension in $clearinghousecert\n";
	return undef;
    }
    my $response =
	Genixmlrpc::CallMethod($url, $context, "GetCredential",
			       {"gid" => $context->certificate()->cert()});
	
    return undef
	if (!defined($response));
    
    if ($response->IsError()) {
	print STDERR "GeniRegistry::ClearingHouse->GetCredential: " .
	    $response->Dump() . "\n";
	return undef;
    }
    $clearinghousecred =
	GeniCredential->CreateFromSigned($response->value(), 1);
    if (!defined($clearinghousecred)) {
	print STDERR "Could not parse credential from clearinghouse\n";
	return undef;
    }
    if ($clearinghousecred->Store()) {
	print STDERR "*** GeniRegistry::ClearingHouse::GetCredential: ".
	    "Could not store credential for clearinghouse\n";
	return undef;
    }
    return $clearinghousecred;
}

# _Always_ make sure that this 1 is at the end of the file...
1;
