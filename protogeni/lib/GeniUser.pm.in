#!/usr/bin/perl -wT
#
# EMULAB-COPYRIGHT
# Copyright (c) 2008 University of Utah and the Flux Group.
# All rights reserved.
#
package GeniUser;

use strict;
use Exporter;
use vars qw(@ISA @EXPORT);

@ISA    = "Exporter";
@EXPORT = qw ( );

# Must come after package declaration!
use lib '@prefix@/lib';
use GeniDB;
use GeniCHClient;
use GeniAuthority;
use GeniCertificate;
use libtestbed;
# Hate to import all this crap; need a utility library.
use libdb qw(TBGetUniqueIndex);
use User;
use English;
use overload ('""' => 'Stringify');
use vars qw();

# Configure variables
my $TB		   = "@prefix@";
my $TBOPS          = "@TBOPSEMAIL@";
my $TBAPPROVAL     = "@TBAPPROVALEMAIL@";
my $TBAUDIT   	   = "@TBAUDITEMAIL@";
my $BOSSNODE       = "@BOSSNODE@";
my $CONTROL	   = "@USERNODE@";
my $OURDOMAIN      = "@OURDOMAIN@";

# Cache of instances to avoid regenerating them.
my %users      = ();
my $debug      = 0;

# Little helper and debug function.
sub mysystem($)
{
    my ($command) = @_;

    print STDERR "Running '$command'\n"
	if ($debug);
    return system($command);
}

#
# Lookup by idx, or uuid.
#
sub Lookup($$)
{
    my ($class, $token) = @_;
    my $query_result;
    my $idx;

    if ($token =~ /^\d+$/) {
	$idx = $token;
    }
    elsif ($token =~ /^\w+\-\w+\-\w+\-\w+\-\w+$/) {
	$query_result =
	    DBQueryWarn("select idx from geni_users ".
			"where uuid='$token' and status='active'");
	    return undef
		if (! $query_result || !$query_result->numrows);

	    ($idx) = $query_result->fetchrow_array();
    }
    else {
	return undef;
    }
    
    # Look in cache first
    return $users{"$idx"}
        if (exists($users{"$idx"}));

    $query_result =
	DBQueryWarn("select * from geni_users where idx='$idx'");
    return undef
	if (!$query_result || !$query_result->numrows);

    my $self         = {};
    $self->{'USER'}  = $query_result->fetchrow_hashref();
    bless($self, $class);

    #
    # Grab the certificate, since we will probably want it.
    #
    my $uuid = $self->{'USER'}->{'uuid'};
    my $certificate = GeniCertificate->Lookup($uuid);
    if (!defined($certificate)) {
	print STDERR "Could not find certificate for user $idx ($uuid)\n";
	return undef;
    }
    $self->{'CERT'} = $certificate;
    
    # Add to cache. 
    $users{$self->{'USER'}->{'idx'}} = $self;
    
    return $self;
}
# accessors
sub field($$) { return ((! ref($_[0])) ? -1 : $_[0]->{'USER'}->{$_[1]}); }
sub idx($)		{ return field($_[0], "idx"); }
sub uid($)		{ return field($_[0], "uid"); }
sub hrn($)		{ return field($_[0], "hrn"); }
sub uuid($)		{ return field($_[0], "uuid"); }
sub status($)		{ return field($_[0], "status"); }
sub created($)		{ return field($_[0], "created"); }
sub archived($)		{ return field($_[0], "archived"); }
sub name($)		{ return field($_[0], "name"); }
sub email($)		{ return field($_[0], "email"); }
sub cert($)		{ return $_[0]->{'CERT'}->cert(); }
sub sa_idx($)		{ return field($_[0], "sa_idx"); }
sub GetCertificate($)   { return $_[0]->{'CERT'}; }

#
# Stringify for output.
#
sub Stringify($)
{
    my ($self) = @_;
    
    my $hrn = $self->hrn();
    my $idx = $self->idx();

    return "[GeniUser: $hrn, IDX: $idx]";
}

#
# Class method to check for an existing user that has the same
# uid/email. Lets not allow this for now. Return the number of
# users that match or -1 if an error. 
#
sub CheckExisting($$$)
{
    my ($class, $hrn, $email) = @_;

    my $safe_hrn   = DBQuoteSpecial($hrn);
    my $safe_email = DBQuoteSpecial($email);

    my $query_result =
	DBQueryFatal("select idx from geni_users ".
		     "where hrn=$safe_hrn and email=$safe_email");
    return -1
	if (!defined($query_result));

    return $query_result->numrows;
}

#
# Class function to create new Geni user and return object. Note that this
# is used by the ClearingHouse *and* the CM/SA to record users. 
#
sub Create($$$$$$$$)
{
    my ($class, $hrn, $uid, $uuid, $name, $email, $cert, $sa_idx) = @_;
    my @insert_data = ();

    # Every user gets a new unique index.
    my $idx = User->NextIDX();

    # Now tack on other stuff we need.
    push(@insert_data, "created=now()");
    push(@insert_data, "idx='$idx'");
    push(@insert_data, "status='active'");

    my $safe_hrn   = DBQuoteSpecial($hrn);
    my $safe_uid   = DBQuoteSpecial($uid);
    my $safe_name  = DBQuoteSpecial($name);
    my $safe_email = DBQuoteSpecial($email);
    my $safe_uuid  = DBQuoteSpecial($uuid);
    my $safe_sa    = DBQuoteSpecial($sa_idx);
    push(@insert_data, "hrn=$safe_hrn");
    push(@insert_data, "uid=$safe_uid");
    push(@insert_data, "name=$safe_name");
    push(@insert_data, "email=$safe_email");
    push(@insert_data, "uuid=$safe_uuid");
    push(@insert_data, "sa_idx=$safe_sa");

    # Insert certificate.
    my $certificate = GeniCertificate->StorePublic($cert);
    if (!defined($certificate)) {
	print STDERR "Could not store certificate for new user\n";
	return undef;
    }

    # Insert into DB.
    DBQueryWarn("insert into geni_users set " . join(",", @insert_data))
	or return undef;

    return GeniUser->Lookup($idx);
}

#
# We wrap up local users so that the interface to them is consistent, but
# do not want to duplicate any data, so use a different class wrapper.
#
sub CreateFromLocal($$)
{
    my ($class, $user) = @_;

    return GeniUser::LocalUser->Create($user);
}

#
# Create a user from the ClearingHouse, by looking up the info.
#
sub CreateFromRegistry($$)
{
    my ($class, $uuid) = @_;

    my $blob;
    return undef
	if (GeniCHClient::LookupUser($uuid, \$blob) != 0);

    my $authority = GeniAuthority->Lookup($blob->{'sa'}->{'uuid'});
    if (!defined($authority)) {
	$authority = GeniAuthority->Create($blob->{'sa'}->{'uuid'},
					   $blob->{'sa'}->{'hrn'},
					   $blob->{'sa'}->{'url'},
					   $blob->{'sa'}->{'cert'});
	if (!defined($authority)) {
	    print STDERR "Could not create new authority record\n";
	    return undef;
	}
    }
    return GeniUser->Create($blob->{'hrn'},
			    $blob->{'uid'},
			    $blob->{'uuid'},
			    $blob->{'name'},
			    $blob->{'email'},
			    $blob->{'cert'},
			    $authority->idx());
}

#
# Delete the user, as for registration errors.
#
sub Delete($)
{
    my ($self) = @_;

    return 0
	if (! ref($self));

    my $idx = $self->idx();

    DBQueryWarn("delete from geni_users where idx='$idx'")
	or return -1;
    
    return 0;
}

#
# Archive user. 
#
sub Archive($)
{
    my ($self) = @_;

    return 0
	if (! ref($self));

    my $idx = $self->idx();

    DBQueryWarn("update geni_users set status='archived' ".
		"where idx='$idx'")
	or return -1;
    
    return 0;
}

############################################################################
#
# Wrapper for local users.
#
package GeniUser::LocalUser;
use English;
use GeniDB;
use GeniCertificate;
use overload ('""' => 'Stringify');

#
# Create a wrapper, with the same access names.
#
sub Create($$)
{
    my ($class, $user) = @_;

    my $self         = {};
    $self->{'USER'}  = $user;

    # And the certificate wrapper.
    my $certificate = GeniCertificate::LocalUser->Create($user);
    return undef
	if (!defined($certificate));
    $self ->{'CERT'} = $certificate;

    bless($self, $class);
    return $self;
}

sub uid($)		{ return $_[0]->{'USER'}->uid(); }
sub uuid                { return $_[0]->{'USER'}->uuid(); }
sub created($)		{ return $_[0]->{'USER'}->created(); }
sub name($)		{ return $_[0]->{'USER'}->name(); }
sub email($)		{ return $_[0]->{'USER'}->email(); }
sub sa_idx($)		{ return 0; }

# Need to construct this since not in User structure.
sub hrn($)		{ return $OURDOMAIN . "." . $_[0]->uid(); }

# And this is in another structure.
sub cert($)             { return $_[0]->{'CERT'}->cert(); }
sub GetCertificate($)   { return $_[0]->{'CERT'}; }

#
# Register this local user at the ClearingHouse.
#
sub Register($)
{
    my ($self) = @_;
    my $blob;

    # Register this user at the ClearingHouse, if not already registered.
    if (GeniCHClient::LookupUser($self->uuid(), \$blob) != 0) {
	return GeniCHClient::RegisterUser($self->hrn(), $self->uuid(),
					  $self->name(), $self->email(),
					  $self->cert());
    }
    return 0;
}
    
#
# Stringify for output.
#
sub Stringify($)
{
    my ($self) = @_;
    my $user = $self->{'USER'};
    
    return "$user";
}

# _Always_ make sure that this 1 is at the end of the file...
1;
