#!/usr/bin/perl -wT
#
# EMULAB-COPYRIGHT
# Copyright (c) 2008 University of Utah and the Flux Group.
# All rights reserved.
#
package GeniSliver;

#
use strict;
use Exporter;
use vars qw(@ISA @EXPORT);

@ISA    = "Exporter";
@EXPORT = qw ( );

# Must come after package declaration
use lib '@prefix@/lib';
use GeniDB;
use GeniComponent;
use GeniCredential;
# Hate to import all this crap; need a utility library.
use libdb qw(TBGetUniqueIndex);
use libtestbed;
use Experiment;
use Node;
use English;
use Data::Dumper;
use File::Temp qw(tempfile);
use overload ('""' => 'Stringify');

# Configure variables
my $TB		   = "@prefix@";
my $TBOPS          = "@TBOPSEMAIL@";
my $TBAPPROVAL     = "@TBAPPROVALEMAIL@";
my $TBAUDIT   	   = "@TBAUDITEMAIL@";
my $BOSSNODE       = "@BOSSNODE@";
my $OURDOMAIN      = "@OURDOMAIN@";
my $SIGNCRED	   = "$TB/sbin/signgenicred";
my $AVAIL	   = "$TB/sbin/avail";
my $NALLOC	   = "$TB/bin/nalloc";
my $NFREE	   = "$TB/bin/nfree";

# Cache of instances to avoid regenerating them.
my %slivers      = ();

#
# Lookup by idx, or uuid.
#
sub Lookup($$)
{
    my ($class, $token) = @_;
    my $query_result;
    my $idx;

    if ($token =~ /^\d+$/) {
	$idx = $token;
    }
    elsif ($token =~ /^\w+\-\w+\-\w+\-\w+\-\w+$/) {
	$query_result =
	    DBQueryWarn("select idx from geni_slivers ".
			"where uuid='$token'");
	    return undef
		if (! $query_result || !$query_result->numrows);

	    ($idx) = $query_result->fetchrow_array();
    }
    else {
	return undef;
    }

    # Look in cache first
    return $slivers{"$idx"}
        if (exists($slivers{"$idx"}));

    $query_result = DBQueryWarn("select * from geni_slivers ".
				"where idx='$idx'");

    return undef
	if (!$query_result || !$query_result->numrows);

    my $self              = {};
    $self->{'SLIVER'}     = $query_result->fetchrow_hashref();
    $self->{'TICKET'}     = undef;	# Server side.
    $self->{'COMPONENT'}  = undef;	# Client side.
    $self->{'CREDENTIAL'} = undef;	# Client side.
    
    bless($self, $class);
    
    # Add to cache. 
    $slivers{$self->{'SLIVER'}->{'idx'}} = $self;
    
    return $self;
}

#
# Stringify for output.
#
sub Stringify($)
{
    my ($self) = @_;
    
    my $uuid = $self->uuid();
    my $idx  = $self->idx();

    return "[GeniSliver: $uuid, IDX: $idx]";
}

#
# Create a sliver record in the DB. On the client side we save the credential
# that allows control of it, for later operations. We also save the component
# pointer, but not sure that is correct.
#
sub Create($$;$)
{
    my ($class, $ticket, $credential) = @_;
    my @insert_data = ();
    my $uuid;

    # Every sliver gets a new unique index.
    my $idx = TBGetUniqueIndex('next_sliver', 1);
    if (defined($credential)) {
	$uuid = $credential->this_uuid();

	# Store the credential
	return undef
	    if ($credential->Store() != 0);
    }
    else {
	# And a new uuid for a local sliver.
	$uuid = NewUUID();
	if (!defined($uuid)) {
	    print "*** WARNING: Could not generate a UUID!\n";
	    return undef;
	}
    }
    my $slice_uuid     = $ticket->slice_uuid();
    my $owner_uuid     = $ticket->owner_uuid();
    my $node_id        = $ticket->rspec()->{'node_id'};

    # Now tack on other stuff we need.
    push(@insert_data, "created=now()");
    push(@insert_data, "idx='$idx'");
    push(@insert_data, "uuid='$uuid'");
    push(@insert_data, "node_id='$node_id'");
    push(@insert_data, "creator_uuid='$owner_uuid'");
    push(@insert_data, "slice_uuid='$slice_uuid'");

    # Only on the client side.
    push(@insert_data, "credential_idx=" . $credential->idx())
	if (defined($credential));
    # Only on the client side.
    push(@insert_data, "component_idx=" . $ticket->component()->idx())
	if (defined($ticket->component()));

    # Insert into DB.
    DBQueryWarn("insert into geni_slivers set " . join(",", @insert_data))
	or return undef;

    my $sliver = GeniSliver->Lookup($idx);
    return undef
	if (!defined($sliver));
    
    $sliver->{'CREDENTIAL'} = $credential
	if (defined($credential));
    $sliver->{'COMPONENT'} = $ticket->component()
	if (defined($ticket->component()));

    return $sliver;
}
# accessors
sub field($$) { return ((! ref($_[0])) ? -1 : $_[0]->{'SLIVER'}->{$_[1]}); }
sub idx($)		{ return field($_[0], "idx"); }
sub uuid($)		{ return field($_[0], "uuid"); }
sub slice_uuid($)	{ return field($_[0], "slice_uuid"); }
sub creator_uuid($)	{ return field($_[0], "creator_uuid"); }
sub created($)		{ return field($_[0], "created"); }
sub credential_idx($)	{ return field($_[0], "credential_idx"); }
sub node_id($)		{ return field($_[0], "node_id"); }
sub ticket_idx($)	{ return field($_[0], "ticket_idx"); }
sub component_idx($)	{ return field($_[0], "component_idx"); }

#
# Delete the sliver. The sliver should not be provisioned when this done.
#
sub Delete($)
{
    my ($self) = @_;

    return -1
	if (! ref($self));

    my $idx = $self->idx();

    DBQueryWarn("delete from geni_slivers where idx='$idx'")
	or return -1;
    
    return 0;
}

#
# Get the experiment for the slice this sliver belongs to.
#
sub GetExperiment($)
{
    my ($self) = @_;

    return undef
	if (! ref($self));

    return Experiment->Lookup($self->slice_uuid());
}

#
# Get the credential for the sliver.
#
sub GetCredential($)
{
    my ($self) = @_;

    return undef
	if (! ref($self));

    return $self->{'CREDENTIAL'} if (defined($self->{'CREDENTIAL'}));

    if (!defined($self->credential_idx())) {
	print STDERR "No credential associated with $self\n";
	return undef;
    }
    my $credential = GeniCredential->Lookup($self->credential_idx());
    if (!defined($credential)) {
	print STDERR "Could not get credential object associated with $self\n";
	return undef;
    }
    $self->{'CREDENTIAL'} = $credential;
    return $credential;
}

#
# Get the component for the sliver.
#
sub GetComponent($)
{
    my ($self) = @_;

    return undef
	if (! ref($self));

    return $self->{'COMPONENT'} if (defined($self->{'COMPONENT'}));

    if (!defined($self->component_idx())) {
	print STDERR "No component associated with $self\n";
	return undef;
    }
    my $component = GeniComponent->Lookup($self->component_idx());
    if (!defined($component)) {
	print STDERR "Could not get component object associated with $self\n";
	return undef;
    }
    $self->{'COMPONENT'} = $component;
    return $component;
}

#
# Provision a slice. We actually did this when the ticket was requested.
#
sub Provision($)
{
    my ($self) = @_;

    return -1
	if (! ref($self));

    #
    # the node is already allocated to the sliver, but still need to enter
    # a virt_nodes entry, and possibly more virt table entries, so that the
    # node will boot properly, and is otherwie controllable.
    #
    my $experiment = Experiment->Lookup($self->slice_uuid());
    if (!defined($experiment)) {
	print STDERR "Could not map $self to its experiment\n";
	return -1;
    }
    my $node_id    = $self->node_id();
    return 0
	if (!defined($node_id));
    my $node       = Node->Lookup($node_id);
    if (!defined($node)) {
	print STDERR "Could not map node $node_id to its object\n";
	return -1;
    }
    my $reservation = $node->Reservation();
    if (!defined($reservation)) {
	print STDERR "$node was already released from $self\n";
	return -1;
    }
    if ($reservation->SameExperiment($experiment)) {
	if ($experiment->InsertVirtNode($node) != 0) {
	    print STDERR "Could not add virtnode entry for $node to $self\n";
	    return -1;
	}
    }
    else {
	print STDERR "$node is reserved to another, not $self\n";
	# Signal error so we can look at what happened.
	return -1;
    }
    return 0;
}

#
# Unprovision a sliver. 
#
sub UnProvision($)
{
    my ($self) = @_;

    return -1
	if (! ref($self));

    my $experiment = Experiment->Lookup($self->slice_uuid());
    if (!defined($experiment)) {
	print STDERR "Could not map $self to its experiment\n";
	return -1;
    }
    my $node_id    = $self->node_id();
    return 0
	if (!defined($node_id));
    my $node       = Node->Lookup($node_id);
    if (!defined($node)) {
	print STDERR "Could not map node $node_id to its object\n";
	return -1;
    }
    my $reservation = $node->Reservation();
    if (!defined($reservation)) {
	print STDERR "$node was already released from $self\n";
	return 0;
    }
    if ($reservation->SameExperiment($experiment)) {
	my $pid = $experiment->pid();
	my $eid = $experiment->eid();

	if ($experiment->DeleteVirtNode($node) != 0) {
	    print STDERR "Could remove virtnode entry for $node from $self\n";
	    return -1;
	}
	
	system("export NORELOAD=1; $NFREE -q $pid $eid $node_id");
	if ($?) {
	    print STDERR "Could not deallocate $node from $self\n";
	    return -1;
	}
    }
    else {
	print STDERR "$node is reserved to another, not $self\n";
	# Signal error so we can look at what happened.
	return -1;
    }
    return 0;
}

#
# Start a slice, which roughly translates to reboot the node.
#
sub Start($)
{
    my ($self) = @_;

    return -1
	if (! ref($self));

    my $experiment = Experiment->Lookup($self->slice_uuid());
    if (!defined($experiment)) {
	print STDERR "Could not map $self to its experiment\n";
	return -1;
    }
    my $node_id    = $self->node_id();
    return 0
	if (!defined($node_id));
    my $node       = Node->Lookup($node_id);
    if (!defined($node)) {
	print STDERR "Could not map node $node_id to its object\n";
	return -1;
    }
    my $reservation = $node->Reservation();
    if (!defined($reservation)) {
	print STDERR "$node was already released from $self\n";
	return -1;
    }
    if ($reservation->SameExperiment($experiment)) {
	#
	# Reboot and wait?
	#
	#system("$NODEREBOOT $node_id");
    }
    else {
	print STDERR "$node is reserved to another, not $self\n";
	# Signal error so we can look at what happened.
	return -1;
    }
    return 0;
}


# _Always_ make sure that this 1 is at the end of the file...
1;
