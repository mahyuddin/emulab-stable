#!/usr/bin/perl -wT
#
# EMULAB-COPYRIGHT
# Copyright (c) 2008 University of Utah and the Flux Group.
# All rights reserved.
#
package GeniSliver;

#
use strict;
use Exporter;
use vars qw(@ISA @EXPORT);

@ISA    = "Exporter";
@EXPORT = qw ( );

# Must come after package declaration
use lib '@prefix@/lib';
use GeniDB;
use GeniComponent;
use GeniSlice;
use GeniCredential;
use GeniCertificate;
use GeniAggregate;
# Hate to import all this crap; need a utility library.
use libdb qw(TBGetUniqueIndex);
use libtestbed;
use Experiment;
use Node;
use English;
use XML::Simple;
use Data::Dumper;
use File::Temp qw(tempfile);
use overload ('""' => 'Stringify');

# Configure variables
my $TB		   = "@prefix@";
my $TBOPS          = "@TBOPSEMAIL@";
my $TBAPPROVAL     = "@TBAPPROVALEMAIL@";
my $TBAUDIT   	   = "@TBAUDITEMAIL@";
my $BOSSNODE       = "@BOSSNODE@";
my $OURDOMAIN      = "@OURDOMAIN@";
my $PGENIDOMAIN    = "@PROTOGENI_DOMAIN@";
my $SIGNCRED	   = "$TB/sbin/signgenicred";
my $AVAIL	   = "$TB/sbin/avail";
my $NALLOC	   = "$TB/bin/nalloc";
my $NFREE	   = "$TB/bin/nfree";
my $NODEREBOOT	   = "$TB/bin/node_reboot";
my $NAMEDSETUP     = "$TB/sbin/named_setup";
my $PLABNODE       = "$TB/sbin/plabnodewrapper";
my $VNODESETUP     = "$TB/sbin/vnode_setup";
my $GENTOPOFILE    = "$TB/libexec/gentopofile";

# Cache of instances to avoid regenerating them.
my %slivers      = ();

#
# Lookup by idx, or uuid.
#
sub Lookup($$)
{
    my ($class, $token) = @_;
    my $query_result;
    my $idx;

    if ($token =~ /^\d+$/) {
	$idx = $token;
    }
    elsif ($token =~ /^\w+\-\w+\-\w+\-\w+\-\w+$/) {
	$query_result =
	    DBQueryWarn("select idx from geni_slivers ".
			"where uuid='$token'");
	    return undef
		if (! $query_result || !$query_result->numrows);

	    ($idx) = $query_result->fetchrow_array();
    }
    else {
	return undef;
    }

    # Look in cache first
    return $slivers{"$idx"}
        if (exists($slivers{"$idx"}));

    $query_result = DBQueryWarn("select * from geni_slivers ".
				"where idx='$idx'");

    return undef
	if (!$query_result || !$query_result->numrows);

    my $self              = {};
    $self->{'SLIVER'}     = $query_result->fetchrow_hashref();
    $self->{'COMPONENT'}  = undef;	# client
    $self->{'SLICE'}      = undef;	# client/server
    $self->{'CREDENTIAL'} = undef;	# client
    $self->{'AGGREGATE'}  = undef;	# server
    $self->{'RSPEC'}      = undef;	# client/server

    my $rspec_string = $self->{'SLIVER'}->{'rspec_string'};
    if (defined($rspec_string) && $rspec_string ne "") {
	$self->{'RSPEC'} = XMLin($rspec_string,
				 ForceArray => ["node", "link"]);
    }

    #
    # Grab the certificate, since we will probably want it.
    #
    my $uuid = $self->{'SLIVER'}->{'uuid'};
    my $certificate = GeniCertificate->Lookup($uuid);
    if (!defined($certificate)) {
	print STDERR "Could not find certificate for sliver $idx ($uuid)\n";
	return undef;
    }
    $self->{'CERTIFICATE'} = $certificate;

    # Bless into sub package if called for.
    my $resource_type = $self->{'SLIVER'}->{'resource_type'};
    if (defined($resource_type) && $resource_type ne "") {
	bless($self, $class . "::" . $resource_type);
    }
    else {
	bless($self, $class);
    }
    
    # Add to cache. 
    $slivers{$self->{'SLIVER'}->{'idx'}} = $self;
    
    return $self;
}

#
# Stringify for output.
#
sub Stringify($)
{
    my ($self) = @_;
    
    my $uuid = $self->uuid();
    my $idx  = $self->idx();

    return "[GeniSliver: $uuid, IDX: $idx]";
}

#
# Create a sliver record in the DB. On the client side we save the credential
# that allows control of it, for later operations.
#
sub Create($$$$$$$$;$$$)
{
    my ($class, $slice, $owner_uuid, $uuid, $resource_uuid, $resource_type,
	$hrn, $nickname,
	$rspec, $credential, $component) = @_;
    my @insert_data = ();
    my $certificate;

    # Every sliver gets a new unique index.
    my $idx = TBGetUniqueIndex('next_sliver', 1);
    if (defined($credential)) {
	$certificate = $credential->target_cert();
	# Store the certificate for later use.
	if ($certificate->Store() != 0) {
	    print STDERR "Could not store certificate\n";
	    return undef;
	}
	$resource_uuid = $uuid = $credential->this_uuid();
	$hrn = $credential->hrn();
	if (defined($credential->extensions()) &&
	    exists($credential->extensions()->{'nickname'})) {
	    $nickname = $credential->extensions()->{'nickname'};
	}
	# Store the credential
	return undef
	    if ($credential->Store() != 0);
    }
    else {
	# Create a cert pair, for this resource uuid. 
	$certificate = GeniCertificate->Create("sliver", $hrn, $TBOPS, $uuid);
	if (!defined($certificate)) {
	    print STDERR "Could not generate new certificate and UUID!\n";
	    return undef;
	}
    }
    my $slice_uuid     = $slice->uuid();

    # Now tack on other stuff we need.
    push(@insert_data, "created=now()");
    push(@insert_data, "idx='$idx'");
    push(@insert_data, "hrn=" . DBQuoteSpecial($hrn));
    push(@insert_data, "nickname=" . DBQuoteSpecial($nickname))
	if (defined($nickname));
    push(@insert_data, "uuid='$uuid'");
    push(@insert_data, "resource_uuid='$resource_uuid'");
    push(@insert_data, "resource_type='$resource_type'");
    push(@insert_data, "creator_uuid='$owner_uuid'");
    push(@insert_data, "slice_uuid='$slice_uuid'");

    # Only on the client side.
    push(@insert_data, "credential_idx=" . $credential->idx())
	if (defined($credential));
    # Only on the client side.
    push(@insert_data, "component_uuid='" . $component->uuid() . "'")
	if (defined($component));

    if (defined($rspec)) {
	my $rspec_string = XMLout($rspec, RootName => "rspec");
	my $safe_rspec   = DBQuoteSpecial($rspec_string);

	push(@insert_data, "rspec_string=$safe_rspec");
    }

    # Insert into DB.
    if (!DBQueryWarn("insert into geni_slivers set " .
		     join(",", @insert_data))) {
	$certificate->Delete();
	return undef;
    }

    my $sliver = GeniSliver->Lookup($idx);
    return undef
	if (!defined($sliver));
    
    $sliver->{'CREDENTIAL'} = $credential
	if (defined($credential));
    $sliver->{'COMPONENT'} = $component
	if (defined($component));
    $sliver->{'AGGREGATE'} = undef;
    $sliver->{'SLICE'}     = undef;

    return $sliver;
}
# accessors
sub field($$) { return ((! ref($_[0])) ? -1 : $_[0]->{'SLIVER'}->{$_[1]}); }
sub idx($)		{ return field($_[0], "idx"); }
sub uuid($)		{ return field($_[0], "uuid"); }
sub hrn($)		{ return field($_[0], "hrn"); }
sub nickname($)		{ return field($_[0], "nickname"); }
sub slice_uuid($)	{ return field($_[0], "slice_uuid"); }
sub creator_uuid($)	{ return field($_[0], "creator_uuid"); }
sub created($)		{ return field($_[0], "created"); }
sub credential_idx($)	{ return field($_[0], "credential_idx"); }
sub resource_uuid($)	{ return field($_[0], "resource_uuid"); }
sub resource_type($)	{ return field($_[0], "resource_type"); }
sub component_uuid($)	{ return field($_[0], "component_uuid"); }
sub aggregate_uuid($)	{ return field($_[0], "aggregate_uuid"); }
sub rspec_string($)     { return field($_[0], "rspec_string"); }
sub status($)		{ return field($_[0], "status"); }
sub cert($)		{ return $_[0]->{'CERTIFICATE'}->cert(); }
sub GetCertificate($)   { return $_[0]->{'CERTIFICATE'}; }
sub rspec($)            { return $_[0]->{'RSPEC'}; }

#
# Delete the sliver. The sliver should not be provisioned when this done.
#
sub Delete($)
{
    my ($self) = @_;

    return -1
	if (! ref($self));

    my $idx  = $self->idx();
    my $uuid = $self->uuid();

    DBQueryWarn("delete from geni_credentials where this_uuid='$uuid'")
	or return -1;
    DBQueryWarn("delete from geni_certificates where uuid='$uuid'")
	or return -1;
    DBQueryWarn("delete from geni_slivers where idx='$idx'")
	or return -1;
    
    return 0;
}

#
# Set the aggregate for a sliver.
#
sub SetAggregate($$)
{
    my ($self, $aggregate) = @_;

    return -1
	if (! (ref($self) && ref($aggregate)));

    my $idx      = $self->idx();
    my $agg_uuid = $aggregate->uuid();

    return -1
	if (!DBQueryWarn("update geni_slivers set ".
			 "  aggregate_uuid='$agg_uuid' ".
			 "where idx='$idx'"));
    
    $self->{'SLIVER'}->{'aggregate_uuid'} = $agg_uuid;
    $self->{'AGGREGATE'} = $aggregate;
    return 0;
}

#
# And clear the aggregate.
#
sub ClearAggregate($$)
{
    my ($self) = @_;

    return -1
	if (! ref($self));

    my $idx      = $self->idx();

    return -1
	if (!DBQueryWarn("update geni_slivers set ".
			 "  aggregate_uuid=NULL ".
			 "where idx='$idx'"));
    
    $self->{'SLIVER'}->{'aggregate_uuid'} = undef;
    $self->{'AGGREGATE'} = undef;
    return 0;
}

#
# Get the aggregate for a sliver.
#
sub GetAggregate($)
{
    my ($self) = @_;

    return undef
	if (! ref($self));

    return $self->{'AGGREGATE'} if (defined($self->{'AGGREGATE'}));
    return undef
	if (!defined($self->aggregate_uuid()));

    my $aggregate = GeniAggregate->Lookup($self->aggregate_uuid());
    if (!defined($aggregate)) {
	print STDERR "Could not get aggregate object associated with $self\n";
	return undef;
    }
    $self->{'AGGREGATE'} = $aggregate;
    return $aggregate;
}

#
# Set the status for the sliver.
#
sub SetStatus($$)
{
    my ($self, $status) = @_;

    return undef
	if (! ref($self));

    my $idx = $self->idx();
    
    return -1
	if (!DBQueryWarn("update geni_slivers set ".
			 "  status='$status' ".
			 "where idx='$idx'"));
    
    $self->{'SLIVER'}->{'status'} = $status;
    return 0;
}

#
# Get the experiment for the slice this sliver belongs to.
#
sub GetExperiment($)
{
    my ($self) = @_;

    return undef
	if (! ref($self));

    return Experiment->Lookup($self->slice_uuid());
}

#
# Get the credential for the sliver.
#
sub GetCredential($$)
{
    my ($self, $user) = @_;

    return undef
	if (! ref($self));

    return $self->{'CREDENTIAL'} if (defined($self->{'CREDENTIAL'}));

    my $credential = GeniCredential->Lookup($self, $user);
    if (!defined($credential)) {
	print STDERR "Could not get credential object associated with $self\n";
	return undef;
    }
    $self->{'CREDENTIAL'} = $credential;
    return $credential;
}

#
# Get the component for the sliver.
#
sub GetComponent($)
{
    my ($self) = @_;

    return undef
	if (! ref($self));

    return $self->{'COMPONENT'} if (defined($self->{'COMPONENT'}));

    if (!defined($self->component_uuid())) {
	print STDERR "No component associated with $self\n";
	return undef;
    }
    my $component = GeniComponent->Lookup($self->component_uuid());
    if (!defined($component)) {
	print STDERR "Could not get component object associated with $self\n";
	return undef;
    }
    $self->{'COMPONENT'} = $component;
    return $component;
}

#
# Get the slice for the sliver.
#
sub GetSlice($)
{
    my ($self) = @_;

    return undef
	if (! ref($self));

    return $self->{'SLICE'} if (defined($self->{'SLICE'}));

    if (!defined($self->slice_uuid())) {
	print STDERR "No slice associated with $self\n";
	return undef;
    }
    my $slice = GeniSlice->Lookup($self->slice_uuid());
    if (!defined($slice)) {
	print STDERR "Could not get slice object associated with $self\n";
	return undef;
    }
    $self->{'SLICE'} = $slice;
    return $slice;
}

#
# Look up a list of slivers for a locally instantiated slice. 
# Used by the CM.
#
sub SliceSlivers($$$)
{
    my ($class, $slice, $pref) = @_;

    my $slice_uuid = $slice->uuid();
    my @result = ();

    my $query_result =
	DBQueryWarn("select idx from geni_slivers ".
		    "where slice_uuid='$slice_uuid'");
    return -1
	if (!$query_result);

    while (my ($idx) = $query_result->fetchrow_array()) {
	my $sliver = GeniSliver->Lookup($idx);
	return -1
	    if (!defined($sliver));
	push(@result, $sliver);
    }
    @$pref = @result;
    return 0;
}

#
# Find slivers "dependent" on this sliver, as for interfaces on nodes.
#
sub DependentSlivers($$)
{
    my ($self, $pref) = @_;

    return -1
	if (! (ref($self) && ref($pref)));
    @$pref = ();

    my $idx = $self->idx();
    my $resource_uuid = $self->resource_uuid();

    my $query_result =
	DBQueryWarn("select idx from geni_slivers ".
		    "where idx!='$idx' and resource_uuid='$resource_uuid'");
    return -1
	if (!$query_result);

    my @result = ();
    while (my ($idx) = $query_result->fetchrow_array()) {
	my $sliver = GeniSliver->Lookup($idx);
	if (!defined($sliver)) {
	    print STDERR "Could not get sliver object for $idx\n";
	    return -1;
	}
	push(@result, $sliver);
    }
    @$pref = @result;
    return 0;
}

#
# Create a signed credential for this sliver, issued to the provided user.
# The credential will grant all permissions for now.
#
# Should we store these credentials in the DB, recording what we hand out?
#
sub NewCredential($$)
{
    my ($self, $owner) = @_;

    return undef
	if (! (ref($self) && ref($owner)));

    my $credential = GeniCredential->Create($self, $owner);
    if (!defined($credential)) {
	print STDERR "Could not create credential for $self, $owner\n";
	return undef;
    }
    if (defined($self->nickname())) {
	$credential->AddExtension("nickname", $self->nickname());
    }
    if ($credential->Sign($self->GetCertificate()) != 0) {
	print STDERR "Could not sign credential for $self, $owner\n";
	return undef;
    }
    return $credential;
}

############################################################################
#
# The client side methods are in packages which inherit from above.
#
package GeniSliver::Client;
use vars qw(@ISA);
@ISA = "GeniSliver";

use GeniDB;
use GeniComponent;
use GeniSlice;
use GeniCredential;
use GeniCertificate;
use GeniAggregate;
use libdb qw(TBDB_ALLOCSTATE_RES_INIT_DIRTY);

sub Create()
{
    my ($class, $slice, $user_uuid, $rspec, $credential, $component) = @_;

    return GeniSliver->Create($slice, $user_uuid, undef, undef,
			      "Client", undef, undef, $rspec, 
			      $credential, $component);
}

#
# Client side method to contact the sliver component and start it.
#
sub Start($$)
{
    my ($self, $user) = @_;

    return -1
	if (! ref($self));

    my $component = $self->GetComponent();
    return -1
	if (!defined($component));

    return -1
	if ($component->StartSliver($self, $user) != 0);

    return 0;
}

#
# Client side method to contact the sliver component and destroy it.
#
sub Destroy($$)
{
    my ($self, $user) = @_;

    return -1
	if (! ref($self));

    my $component = $self->GetComponent();
    return -1
	if (!defined($component));

    return -1
	if ($component->DestroySliver($self, $user) != 0);

    # Delete the local object from the DB.
    $self->Delete() == 0
	or return -1;

    return 0;
}

#
# On the client side, the aggregate points to the parent sliver when it
# contains multiple resources.
#
sub SetAggregate($$)
{
    my ($self, $parent) = @_;

    return -1
	if (! (ref($self) && ref($parent)));

    my $idx         = $self->idx();
    my $parent_uuid = $parent->uuid();

    return -1
	if (!DBQueryWarn("update geni_slivers set ".
			 "  aggregate_uuid='$parent_uuid' ".
			 "where idx='$idx'"));

    return 0;
}
sub ClearAggregate($)
{
    my ($self) = @_;

    return -1
	if (! ref($self));

    my $idx         = $self->idx();

    return -1
	if (!DBQueryWarn("update geni_slivers set ".
			 "  aggregate_uuid=NULL ".
			 "where idx='$idx'"));
    return 0;
}
sub GetAggregate($)
{
    my ($self) = @_;

    return undef
	if (! ref($self));

    return undef
	if (!defined($self->aggregate_uuid()));

    my $parent = GeniSliver->Lookup($self->aggregate_uuid());
    if (!defined($parent)) {
	print STDERR "Could not get parent object associated with $self\n";
	return undef;
    }
    return $parent;
}

############################################################################
#
# The server side methods are in packages which inherit from above.
#
package GeniSliver::Node;
use vars qw(@ISA);
@ISA = "GeniSliver";

use GeniDB;
use GeniComponent;
use GeniSlice;
use GeniCredential;
use GeniCertificate;
use Experiment;
use GeniAggregate;
use XML::Simple;
use libdb qw(TBDB_ALLOCSTATE_RES_INIT_DIRTY);

sub Create($$$$$)
{
    my ($class, $slice, $user_uuid, $resource_uuid, $rspec) = @_;
    my $virtualization_type = $rspec->{'virtualization_type'};
    my $uuid = $resource_uuid;

    my $experiment = $slice->GetExperiment();
    if (!defined($experiment)) {
	print STDERR "Could not map $slice to its experiment\n";
	return undef;
    }

    #
    # the node is already allocated to the sliver, but still need to enter
    # a virt_nodes entry, and possibly more virt table entries, so that the
    # node will boot properly, and is otherwise controllable.
    #
    my $node = Node->Lookup($resource_uuid);
    if (!defined($node)) {
	print STDERR "Could not map node $resource_uuid to its object\n";
	return undef;
    }
    if (! $node->isremotenode()) {
	my $reservation = $node->Reservation();
	if (!defined($reservation)) {
	    print STDERR "$node was already released from $slice\n";
	    return undef;
	}
	if (! $reservation->SameExperiment($experiment)) {
	    print STDERR "$node is reserved to another, not $reservation\n";
	    # Signal error so we can look at what happened.
	    return undef;
	}
    }
    my $hrn = "${PGENIDOMAIN}." . $node->node_id();
    my $nickname = $rspec->{'nickname'};
    
    #
    # The resource UUID refers to the physical node, but the virtualization
    # type might require a vnode.
    # 
    if ($virtualization_type eq "emulab-vnode") {
	my $vtype = "pcfake";

	if ($node->isplabphysnode()) {
	    if ($node->type() =~ /^(\w*)phys$/) {
		$vtype = $1;
	    }
	    else {
		print STDERR "Could not determine vtype for $node\n";
		return undef;
	    }
	}
	
	#
	# Create a virtual node on the physnode. 
	#
	my @vnodes;
	if (Node::CreateVnodes(\@vnodes,
			       {"pid"      => $experiment->pid(),
				"eid"      => $experiment->eid(),
				"count"    => 1,
				"vtype"    => "$vtype",
				"nodeid"   => $node->node_id(),
				"verbose"  => 0 }) < 0) {
	    print STDERR "Could not create new virtual node on $node\n";
	    return undef;
	}
	my $vnode = Node->Lookup($vnodes[0]);
	$uuid = $vnode->uuid();
	$hrn = "${PGENIDOMAIN}." . $vnode->node_id()
    }
    return GeniSliver->Create($slice, $user_uuid, $uuid, $resource_uuid,
			      "Node", $hrn, $nickname, $rspec);
}

#
# Provision a slice. We actually did this when the ticket was requested.
# We fill in some virt table stuff so that tbswap will work.
#
sub Provision($;$)
{
    my ($self, $extraargs) = @_;

    return -1
	if (! ref($self));

    #
    # the node is already allocated to the sliver, but still need to enter
    # a virt_nodes entry, and possibly more virt table entries, so that the
    # node will boot properly, and is otherwise controllable.
    #
    my $experiment = Experiment->Lookup($self->slice_uuid());
    if (!defined($experiment)) {
	print STDERR "Could not map $self to its experiment\n";
	return -1;
    }
    my $uuid = $self->uuid();
    return 0
	if (!defined($uuid));
    my $node       = Node->Lookup($uuid);
    if (!defined($node)) {
	print STDERR "Could not map node $uuid to its object\n";
	return -1;
    }
    my $node_id     = $node->node_id();
    my $reservation = $node->Reservation();
    if (!defined($reservation)) {
	print STDERR "$node was already released from slice\n";
	return -1;
    }
    if (! $reservation->SameExperiment($experiment)) {
	print STDERR "$node is reserved to another, not $reservation\n";
	# Signal error so we can look at what happened.
	return -1;
    }
    my $pid = $experiment->pid();
    my $eid = $experiment->eid();
	
    if ($experiment->InsertVirtNode($node) != 0) {
	print STDERR "Could not add virtnode entry for $node to $self\n";
	return -1;
    }

    if (exists($self->rspec()->{'tmcd_server'}) &&
	exists($self->rspec()->{'tmcd_nodeid'})) {
	my $tmcd_redirect =
	    $self->rspec()->{'tmcd_server'} . ":" .
	    $self->rspec()->{'tmcd_nodeid'};

	if ($node->ModifyReservation({"tmcd_redirect" => $tmcd_redirect})){
	    return -1;
	}
    }

    #
    # An emulab cluster node uses a vnode on the physnode, even for a
    # dedicated physical nodes. We need to tell tmcd about the pnode,
    # but not the vnode since it is going to redirect to tmcd on the
    # remote Emulab controlling the experiment.
    #
    if (!$node->isremotenode() &&
	exists($self->rspec()->{'virtualization_type'}) &&
	$self->rspec()->{'virtualization_type'} eq "emulab-vnode") {
	my $pnode = Node->Lookup($node->phys_nodeid());
	if (!defined($pnode)) {
	    print STDERR "Could not get pnode object for $node\n";
	    return -1;
	}
	    
	if ($experiment->InsertVirtNode($pnode) != 0) {
	    print STDERR "Could not add virtnode entry for $pnode to $self\n";
	    return -1;
	}
	$pnode->ModifyReservation({"genisliver_idx" => $self->idx()});

	# Set it to boot the default OS.
	if ($pnode->SelectOS() != 0) {
	    return -1;
	}
    }
    else {
	#
	# For a "raw" node, there is no vnode, so this is the pnode
	# we need to mark for tmcd.
	#
	if ($node->ModifyReservation({"genisliver_idx" => $self->idx()})) {
	    return -1;
	}
    }
    return 0;
}

#
# Unprovision a sliver. 
#
sub UnProvision($)
{
    my ($self) = @_;

    return -1
	if (! ref($self));

    my $experiment = Experiment->Lookup($self->slice_uuid());
    if (!defined($experiment)) {
	print STDERR "Could not map $self to its experiment\n";
	return -1;
    }
    my $uuid = $self->uuid();
    return 0
	if (!defined($uuid));
    my $node       = Node->Lookup($uuid);
    if (!defined($node)) {
	# Lets call this nonfatal since it might be a virtnode that 
	print STDERR "Could not map node $uuid to its object\n";
	return 0;
    }
    my $reservation = $node->Reservation();
    if (!defined($reservation)) {
	print STDERR "$node was already released from $self\n";
	return 0;
    }
    if ($reservation->SameExperiment($experiment)) {
	my $node_id = $node->node_id();
	my $pid = $experiment->pid();
	my $eid = $experiment->eid();

	if ($node->isremotenode()) {
	    system("$VNODESETUP -p -q -m -k $pid $eid $node_id");
	    if ($?) {
		print STDERR "$VNODESETUP failed\n";
		return -1;
	    }
	}

	if ($experiment->DeleteVirtNode($node) != 0) {
	    print STDERR "Could remove virtnode entry for $node from $self\n";
	    return -1;
	}

	if (!$node->isremotenode() &&
	    $self->rspec()->{'virtualization_type'} eq "emulab-vnode") {
	    my $pnode_id = $node->phys_nodeid();
	    my $pnode = Node->Lookup($pnode_id);
	    if (!defined($pnode)) {
		print STDERR "Could not get pnode object for $pnode_id\n";
		return -1;
	    }
	    if ($experiment->DeleteVirtNode($pnode) != 0) {
		print STDERR
		    "Could remove virtnode entry for $pnode from $self\n";
		return -1;
	    }
	    system("export NORELOAD=1; $NFREE -x -q $pid $eid $pnode_id");
	}
	else {
	    system("export NORELOAD=1; $NFREE -q $pid $eid $node_id");
	}
	if ($?) {
	    print STDERR "Could not deallocate $node from $self\n";
	    $node->Refresh();
	    return -1;
	}
	$node->Refresh();
    }
    else {
	print STDERR "$node is reserved to another, not $self\n";
	# Signal error so we can look at what happened.
	return -1;
    }
    return 0;
}

#
# Start a sliver, which means what?
#
sub Start($)
{
    my ($self) = @_;

    return -1
	if (! ref($self));

    my $experiment = Experiment->Lookup($self->slice_uuid());
    if (!defined($experiment)) {
	print STDERR "Could not map $self to its experiment\n";
	return -1;
    }
    my $uuid = $self->uuid();
    return 0
	if (!defined($uuid));
    my $node       = Node->Lookup($uuid);
    if (!defined($node)) {
	print STDERR "Could not map node $uuid to its object\n";
	return -1;
    }
    my $reservation = $node->Reservation();
    if (!defined($reservation)) {
	print STDERR "$node was already released from $self\n";
	return -1;
    }
    if ($reservation->SameExperiment($experiment)) {
	my $node_id = $node->node_id();

	# XXX Need to fix up this status stuff.
	if ($node->isremotenode() && $self->status() eq "created") {
	    $self->SetStatus("ready");
	    goto done;
	}

	#
	# Reboot pnode if not already running. 
	#
	if ($self->rspec()->{'virtualization_type'} eq "emulab-vnode" &&
	    $self->status() eq "created") {
	    $node_id = $node->phys_nodeid();
	}
	#
	# Reboot and wait?
	#
	system("$NODEREBOOT -s $node_id");
	$self->SetStatus("ready")
	    if (!$?);
	return -1
	    if ($?);
    }
    else {
	print STDERR "$node is reserved to another, not $self\n";
	# Signal error so we can look at what happened.
	return -1;
    }
  done:
    return 0;
}

##########################################################################
#
package GeniSliver::Interface;
use vars qw(@ISA);
@ISA = "GeniSliver";

use GeniDB;
use GeniComponent;
use GeniSlice;
use GeniCredential;
use GeniCertificate;
use GeniAggregate;
use Interface;
use Experiment;
use Node;

sub Create()
{
    my ($class, $slice, $user_uuid,
	$interface_uuid, $node, $rspec) = @_;

    my $nickname = $rspec->{'nickname'};
    my $hrn = "${PGENIDOMAIN}." .
	$node->node_id() . "." . $rspec->{'iface_name'};

    return GeniSliver->Create($slice, $user_uuid, $interface_uuid,
			      $node->uuid(), "Interface",
			      $hrn, $nickname, $rspec);
}

sub Provision($)
{
    my ($self) = @_;

    #
    # This is actually implemented in GeniAggregate since currently "link"
    # is the smallest entity; you cannot operate on an individual interface.
    #
    return -1
	if (! ref($self));

    return 0;
}

#
# Unprovision a single interface from a link/lan. 
#
sub UnProvision($)
{
    my ($self) = @_;

    return -1
	if (! ref($self));

    my $aggregate = $self->GetAggregate();
    if (!defined($aggregate)) {
	print STDERR "Could not find aggregate for $self\n";
	return -1;
    }

    #
    # This is terrible; we need an interface to remove ports form vlans,
    # so that we do not have to tear down the entire vlan and recreate.
    #
    if ($aggregate->UnProvision() != 0) {
	print STDERR "Could not unprovision $aggregate\n";
	return -1;
    }
    $self->ClearAggregate();
    if ($aggregate->Provision() != 0) {
	print STDERR "Could not provision $aggregate\n";
	return -1;
    }
    return 0;
}

#
# Start a sliver.
#
sub Start($)
{
    my ($self) = @_;

    #
    # This is actually implemented in GeniAggregate since currently "link"
    # is the smallest entity; you cannot operate on an individual interface.
    #
    return -1
	if (! ref($self));

    return 0;
}

# _Always_ make sure that this 1 is at the end of the file...
1;
