#!/usr/bin/perl -wT
#
# GENIPUBLIC-COPYRIGHT
# Copyright (c) 2008-2010 University of Utah and the Flux Group.
# All rights reserved.
#
package GeniAM;

#
# The server side of the CM interface on remote sites. Also communicates
# with the GMC interface at Geni Central as a client.
#
use strict;
use Exporter;
use vars qw(@ISA @EXPORT);

@ISA    = "Exporter";
@EXPORT = qw ( );

# Must come after package declaration!
use lib '@prefix@/lib';
use GeniCMV2;
use GeniResponse;
use GeniCredential;

use Compress::Zlib;
use MIME::Base64;
use XML::LibXML;

# Disable UUID checks in GeniCredential.
$GeniCredential::CHECK_UUID = 0;

my $API_VERSION = 1;

#
# Tell the client what API revision we support.  The correspondence
# between revision numbers and API features is to be specified elsewhere.
# No credentials are required.
#
sub GetVersion()
{
    my $blob = {
	"geni_api" => $API_VERSION
    };

    return GeniResponse->Create( GENIRESPONSE_SUCCESS, $blob );
}

# List this aggregates resources. Invokes GeniCMV2::Resolve or
# GeniCMV2::DiscoverResources.
sub ListResources()
{
    my ($credentials, $options) = @_;
    my $available = $options->{'geni_available'};
    my $compress = $options->{'geni_compressed'};
    my $slice_urn = $options->{'geni_slice_urn'};

    my $xml = undef;
    if ($slice_urn) {

        # If $slice_urn is defined, this turns into a Resolve call.  We
        # need to resolve twice: once to get the sliver urn from the
        # slice, then to get the resources associated with the sliver (a
        # manifest rspec).
        my $resolve_args = {
            'urn' => $slice_urn,
            'credentials' => $credentials
        };
        my $response = GeniCMV2::Resolve($resolve_args);
        if (GeniResponse::IsError($response)) {
            return $response;
        }
        # Get the hash out of the response
        my $slice_hash = GeniResponse::value($response);
        my $sliver = $slice_hash->{'sliver_urn'};
        # Resolve the sliver to get the manifest RSpec
        $resolve_args->{'urn'} = $sliver;
        $response = GeniCMV2::Resolve($resolve_args);
        if (GeniResponse::IsError($response)) {
            return $response;
        }
        $xml = GeniResponse::value($response)->{'manifest'};

    } else {

        # No slice was specified, so get the advertisement RSpec.
        my $discover_args = {
            'credentials' => $credentials,
            'available' => $available
        };
        my $response = GeniCMV2::DiscoverResources($discover_args);
        if (GeniResponse::IsError($response)) {
            return $response;
        } else {
            $xml = GeniResponse::value($response)
        }

    }

    # Was compression requested?
    if (defined($compress) && ref($compress) eq 'Frontier::RPC2::Boolean') {
	$compress = $compress->value;
    }
    # If compression was requested, do it. The result is a String
    # whose contents are a base64 encoding of a zlib compressed RSpec.
    if ($compress) {
        my $coder = Frontier::RPC2->new();
        $xml = encode_base64( compress( $xml ) );
    }
    # Finally, return the RSpec
    return GeniResponse->Create(GENIRESPONSE_SUCCESS, $xml);
}

sub auto_add_sa($)
{
    my ($cred_str) = @_;
    my $verify_sig = 1;
    my $cred = GeniCredential->CreateFromSigned($cred_str, $verify_sig);
    my $signers = $cred->signer_certs();

    # The credential has been verified, so the signer derives from a
    # trusted root.
    my $sa_cert = @$signers[0];

    # These are borrowed from protogeni/scripts/addauthority
    my $certificate = GeniCertificate->LoadFromString($sa_cert);
    if (!defined($certificate)) {
        print STDERR "auto_add_sa: could not get certificate from $sa_cert\n";
        return;
    }
    if (! ($certificate->uuid() =~ /\w*-(\w*)$/)) {
        print STDERR "auto_add_sa: could not get prefix from uuid\n";
        return;
    }
    my $url = $certificate->URL();
    if (!defined($url)) {
        print STDERR "auto_add_sa: certificate does not have a URI extension";
        return;
    }
    my $urn = $certificate->urn();
    if (!defined($urn)) {
        print STDERR "auto_add_sa: certificate does not have a URN extension";
        return;
    }
    # Look to see if already registered.
    my $authority = GeniAuthority->Lookup($urn);
    if (defined($authority)) {
	#
	# See if the certificate has changed. If so we want to replace it.
	#
	return
	    if ($certificate->SameCert($authority->GetCertificate()));

	#
	# Do nothing; needs more thought. The problem is that the caller
	# could be from a conforming PG authority, and so setting the url
	# to undef in the code below is wrong. We should probably probe the
	# SA here, to see if it is conforming. Or maybe set the URL and not
	# worry of the sliver registration throws an error. 
	#
	return;
    }

    # if we're auto adding an authority, set the url to null
    # so the PG/Emulab machinery does not try to contact the
    # dynamic sa. It probably won't respond to the PG/Emulab
    # protocols.
    $url = undef;
    if (!GeniAuthority->Create($certificate, $url, "sa")) {
        print STDERR "auto_add_sa: unable to add authority\n";
        return;
    }
    return $certificate;
}

# Create a sliver by allocating and starting resources.
sub CreateSliver()
{
    my ($slice_urn, $credentials, $rspec, $users) = @_;

    foreach my $cred (@$credentials) {
        # If we want to remove the SA(s) after this call, push them
        # onto a list here and remove them at the end of this
        # function. The other AM calls do not need the dynamically
        # added SA.
        auto_add_sa($cred);
    }

    # circulate through the users and bind them to the slice
    my $caller_urn = $ENV{'GENIURN'};
    my $caller_keys = undef;
    foreach my $user (@$users) {
        my $user_urn = $user->{'urn'};
        # Skip if it is not the caller
        next if ($user_urn ne $caller_urn);
        $caller_keys = $user->{keys};
    }

    # Package the caller_keys in a list of hashes the way the CM wants
    # it. Each hash has two keys ('type' and 'key'). 'type' is always
    # 'ssh' for us, and 'key' is the key.

    my $sliver_keys = undef;
    if (defined($caller_keys)) {
        $sliver_keys = [];
        foreach my $key (@$caller_keys) {
            # The CMV2 does not like newlines at the end of the keys.
            chomp($key);
            push(@$sliver_keys, {'type' => 'ssh', 'key' => $key});
        }
    }

    # This only gets us part of the way there. For users that are not
    # *this* user, we need to somehow add their keys, which also
    # requires adding them as a user *without* their certificate. Not
    # sure we'll be able to do that.

    # Invoke CreateSliver
    my $create_args = {
        'slice_urn' => $slice_urn,
        'rspec' => $rspec,
        'credentials' => $credentials,
        'keys' => $sliver_keys
    };

    my $response = GeniCMV2::CreateSliver($create_args);
    if (GeniResponse::IsError($response)) {
        # The create failed, so return the response.
        return $response
    }

    # The create succeeded so gather the response info
    my $listref = GeniResponse::value($response);
    my ($sliver_credential, $manifest_rspec) = @{$listref};
    return GeniResponse->Create( GENIRESPONSE_SUCCESS, $manifest_rspec );
}

# Just delegate to CMV2::DeleteSlice. If we ever change to sliver_urns
# for this call, we'll probably want to call CMV2::DeleteSliver
# instead.
sub DeleteSliver()
{
    my ($slice_urn, $credentials) = @_;

    my $delete_args = {
        'slice_urn' => $slice_urn,
        'credentials' => $credentials
    };
    my $response = GeniCMV2::DeleteSlice($delete_args);
    if (GeniResponse::IsError($response)) {
        return $response;
    } else {
        # Return an XML-RPC boolean
        my $coder = Frontier::RPC2->new();
        return GeniResponse->Create(GENIRESPONSE_SUCCESS, $coder->boolean(1));
    }
}

# No prototype because it is recursive and as such, the prototype
# causes a warning.
#
# Return a hash containing a JSONish representation of the given node.
sub XmlToJson
{
    my ($node) = @_;
 
    my $attrs = {};
    foreach my $attr ($node->attributes) {
        $attrs->{$attr->nodeName()} = $attr->nodeValue();
    }

    my $children = [];
    foreach my $child ($node->childNodes) {
        if ($child->nodeType() == XML_ELEMENT_NODE) {
            push(@$children, XmlToJson($child));
        }
    }

    my $result = {
        "name" => $node->nodeName(),
        "attributes" => $attrs,
        "children" => $children
    };
    return $result;
}

# Get the status of the sliver associated with the given slice. This
# just passes on to the CM SliverStatus operation.
sub SliverStatus()
{
    my ($slice_urn, $credentials) = @_;

    my $status_args = {
        'slice_urn' => $slice_urn,
        'credentials' => $credentials,
    };
    my $response = GeniCMV2::SliverStatus($status_args);
    if (GeniResponse::IsError($response)) {
        return $response
    }
    # $status is a hash ref
    my $pgstatus = GeniResponse::value($response);
    my $status = {};

    $status->{'geni_urn'} = $slice_urn;

    # Determine geni_status. XXX how to determine 'configuring'?
    if ($pgstatus->{'status'} eq 'ready') {
        $status->{'geni_status'} = 'ready';
    } elsif ($pgstatus->{'status'} eq 'failed') {
        $status->{'geni_status'} = 'failed';
    } else {
        $status->{'geni_status'} = 'unknown';
    }

    # include the pg status
    $status->{'pg_status'} = $pgstatus->{'status'};

    # include the expiration
    my $slice = GeniSlice->Lookup($slice_urn);
    $status->{'pg_expires'} = $slice->expires();

    my $details = $pgstatus->{'details'};
    my @children = ();
    while ( my ($pgurn, $pgrstat) = each(%$details) ) {
        # Look up the sliver so we can extract info from the manifest.
        my $sliver = GeniSliver->Lookup($pgurn);
        my $child = {
            'geni_urn' => $pgurn,
            # XXX Need to massage status to one of the AM status values
            'geni_status' => $pgrstat->{'status'},
            'geni_error' => $pgrstat->{'error'},
            'pg_status' => $pgrstat->{'status'},
        };

        # Put manifest info in...
        my $manifest = $sliver->GetManifest(0);
        if (0) {
            # An example of how to include a single element from the
            # manifest. Abondoned this approach and went to XmlToJson
            # instead. Finds the "login", then the "hostname" inside
            # the rspec
            my $login = GeniXML::FindNodes(".//n:services//n:login", $manifest);
            if (defined($login)) {
                my $login = @$login[0];
                my $host = GeniXML::GetText("hostname", $login);
                if (defined($host)) {
                    $child->{'pg_hostname'} = $host;
                }
            }
        }
        $child->{'pg_manifest'} = XmlToJson($manifest);
        #$child->{'pg_xml_manifest'} = GeniXML::Serialize($manifest);
        push @children, $child;
    }
    $status->{'geni_resources'} = \@children;

    return GeniResponse->Create(GENIRESPONSE_SUCCESS, $status);
}

sub RenewSliver()
{
    my ($slice_urn, $credentials, $expiration_time) = @_;

    my $renew_args = {
        'slice_urn' => $slice_urn,
        'expiration' => $expiration_time,
        'credentials' => $credentials
    };
    my $response = GeniCMV2::RenewSlice($renew_args);
    if (GeniResponse::IsError($response)) {
        return $response;
    }

    # Return an XML-RPC boolean
    my $coder = Frontier::RPC2->new();
    return GeniResponse->Create(GENIRESPONSE_SUCCESS, $coder->boolean(1));
}

sub Shutdown()
{
    my ($slice_urn, $credentials) = @_;

    my $shutdown_args = {
        'slice_urn' => $slice_urn,
        'credentials' => $credentials
    };
    my $response = GeniCMV2::Shutdown($shutdown_args);
    if (GeniResponse::IsError($response)) {
        return $response;
    }

    # Return an XML-RPC boolean
    my $coder = Frontier::RPC2->new();
    return GeniResponse->Create(GENIRESPONSE_SUCCESS, $coder->boolean(1));
}

# _Always_ make sure that this 1 is at the end of the file...
1;
