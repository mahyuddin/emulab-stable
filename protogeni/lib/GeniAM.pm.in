#!/usr/bin/perl -wT
#
# GENIPUBLIC-COPYRIGHT
# Copyright (c) 2008-2010 University of Utah and the Flux Group.
# All rights reserved.
#
package GeniAM;

#
# The server side of the CM interface on remote sites. Also communicates
# with the GMC interface at Geni Central as a client.
#
use strict;
use Exporter;
use vars qw(@ISA @EXPORT);

@ISA    = "Exporter";
@EXPORT = qw ( );

# Must come after package declaration!
use lib '@prefix@/lib';
use GeniCMV2;
use GeniResponse;

my $API_VERSION = 1;

#
# Tell the client what API revision we support.  The correspondence
# between revision numbers and API features is to be specified elsewhere.
# No credentials are required.
#
sub GetVersion()
{
    my $blob = {
	"geni_api" => $API_VERSION
    };

    return GeniResponse->Create( GENIRESPONSE_SUCCESS, $blob );
}

# List this aggregates resources. Invokes DiscoverResources.
# XXX Still need to handle the slice urn code path.
sub ListResources()
{
    my ($argref) = @_;
    my $credentials = $argref->{'credentials'};
    my $options = $argref->{'options'};

    my $available = $options->{'geni_available'} || 0;
    my $compress = $options->{'geni_compress'} || 0;
    my $slice_urn = $options->{'geni_slice_urn'};

    # If $slice_urn is defined, this turns into a Resolve call.  We
    # need to resolve twice: once to get the sliver urn from the
    # slice, then to get the resources associated with the sliver (a
    # manifest rspec).

    my $discover_args = {
        'credentials' => $credentials,
        'available' => $available,
        'compress' => $compress
    };
    return GeniCMV2::DiscoverResources($discover_args);
}

# Create a sliver by allocating and starting resources.
sub CreateSliver()
{
    my ($argref)    = @_;
    my $slice_urn   = $argref->{'slice_urn'};
    my $credentials = $argref->{'credentials'};
    my $rspec       = $argref->{'rspec'};

    # Invoke CreateSliver
    my $create_args = {
        'slice_urn' => $slice_urn,
        'rspec' => $rspec,
        'credentials' => $credentials
        # Omit keys, we expect them to be in the rspec
    };

    my $response = GeniCMV2::CreateSliver($create_args);
    if (GeniResponse::IsError($response)) {
        # The create failed, so return the response.
        return $response
    }

    # The create succeeded so gather the response info
    my ($sliver_credential, $manifest_rspec) = GeniResponse::value($response);
    return GeniResponse->Create( GENIRESPONSE_SUCCESS, $manifest_rspec );
}

sub DeleteSliver()
{
    my ($argref)    = @_;
    my $slice_urn   = $argref->{'slice_urn'};
    my $credentials = $argref->{'credentials'};

    # Invoke CreateSliver
    my $stop_args = {
        'slice_urn' => $slice_urn,
        'credentials' => $credentials
    };

    my $response = GeniCMV2::StopSliver($stop_args);
    # Ignore refused error, it means the sliver was not started yet.
    # A better way to go might be to check the sliver state and only
    # invoke stop sliver if the sliver is started.
    if (GeniResponse::IsError($response)
        && GeniResponse::code($response) != GENIRESPONSE_REFUSED()) {
        # The stop failed, so return the response.
        return $response
    }

    # The sliver is stopped, now delete it.
    my $delete_args = {
        'slice_urn' => $slice_urn,
        'credentials' => $credentials
    };
    # XXX Open question: Call "DeleteSlice" or "DeleteSliver"?
    $response = GeniCMV2::DeleteSlice($delete_args);
    if (GeniResponse::IsError($response)) {
        return $response
    }
    return GeniResponse->Create(GENIRESPONSE_SUCCESS);
}

# Get the status of the sliver associated with the given slice. This
# just passes on to the CM SliverStatus operation.
sub SliverStatus()
{
    my ($argref) = @_;
    my $slice_urn = $argref->{'slice_urn'};
    my $credentials = $argref->{'credentials'};

    my $status_args = {
        'slice_urn' => $slice_urn,
        'credentials' => $credentials,
    };
    return GeniCMV2::SliverStatus($status_args);
}

sub RenewSliver()
{
    return GeniResponse->Create( GENIRESPONSE_UNSUPPORTED );
}

sub Shutdown()
{
    return GeniResponse->Create( GENIRESPONSE_UNSUPPORTED );
}

# _Always_ make sure that this 1 is at the end of the file...
1;
