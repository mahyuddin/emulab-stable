#!/usr/bin/perl -wT
#
# EMULAB-COPYRIGHT
# Copyright (c) 2008 University of Utah and the Flux Group.
# All rights reserved.
#
package GeniCHClient;

#
# The client side of the Emulab to Geni ClearingHouse API. This is where we
# register local users, experiments, etc at the clearinghouse and also how
# we look up things at the clearinghouse.
#
use strict;
use Exporter;
use vars qw(@ISA @EXPORT);

@ISA    = "Exporter";
@EXPORT = qw ( );

# Must come after package declaration!
use lib '@prefix@/lib';
use GeniDB;
use Genixmlrpc;
use GeniResponse;
use User;
use libtestbed;
use English;
use Data::Dumper;

# Configure variables
my $TB		   = "@prefix@";
my $TBOPS          = "@TBOPSEMAIL@";
my $TBAPPROVAL     = "@TBAPPROVALEMAIL@";
my $TBAUDIT   	   = "@TBAUDITEMAIL@";
my $BOSSNODE       = "@BOSSNODE@";
my $OURDOMAIN      = "@OURDOMAIN@";
my $GENICENTRAL    = "myboss.myelab.testbed.emulab.net";
my $GENICENTRALURL = "https://$GENICENTRAL/protogeni/xmlrpc/ch";

#
# Lookup a user at the clearing house.
#
sub LookupUser($$)
{
    my ($uuid, $pref) = @_;

    $$pref = undef;
    
    my $response =
	Genixmlrpc::CallMethodHTTP($GENICENTRALURL, undef,
				   "CH::LookupUser",
				   { "uuid"  => $uuid });
    return -1
	if (!defined($response) || $response->code() != GENIRESPONSE_SUCCESS);
    
    $$pref = $response->value();
    return 0;
}

#
# Lookup a slice (experiment) at the clearing house.
#
sub LookupSlice($$)
{
    my ($uuid, $pref) = @_;

    $$pref = undef;
    
    my $response =
	Genixmlrpc::CallMethodHTTP($GENICENTRALURL, undef,
				   "CH::LookupSlice",
				   { "uuid"  => $uuid });
    return -1
	if (!defined($response) || $response->code() != GENIRESPONSE_SUCCESS);
    
    $$pref = $response->value();
    return 0;
}

#
# Register a local Emulab user at the Geni ClearingHouse (which in the
# prototype is Utah Emulab).
#
sub RegisterUser($$$$$$)
{
    my ($hrn, $uuid, $name, $email, $cert, $sshkey) = @_;

    my $args = { "hrn"    => $hrn,
		 "uuid"   => $uuid,
		 "name"   => $name,
		 "email"  => $email,
		 "cert"   => $cert};
    $args->{"sshkey"} = $sshkey
	if (defined($sshkey));

    my $response =
	Genixmlrpc::CallMethodHTTP($GENICENTRALURL, undef,
				   "CH::RegisterUser", $args);

    return -1
	if (!defined($response) || $response->code() != GENIRESPONSE_SUCCESS);
    
    return 0;
}

#
# Register a local Emulab experiment at the Clearinghouse, as a slice.
#
sub RegisterSlice($$$$)
{
    my ($hrn, $uuid, $creator_uuid, $cert) = @_;

    my $response =
	Genixmlrpc::CallMethodHTTP($GENICENTRALURL, undef,
				   "CH::CreateSliceName",
				   { "hrn"   => $hrn,
				     "uuid"  => $uuid,
				     "creator_uuid" => $creator_uuid,
				     "cert"  => $cert });
    
    return -1
	if (!defined($response) || $response->code() != GENIRESPONSE_SUCCESS);
    
    return 0;
}

#
# Delete a slice registration.
#
sub DeleteSlice($)
{
    my ($uuid) = @_;

    my $response =
	Genixmlrpc::CallMethodHTTP($GENICENTRALURL, undef,
				   "CH::FreeSliceName",
				   { "uuid"  => $uuid });

    return -1
	if (!defined($response) || $response->code() != GENIRESPONSE_SUCCESS);
    
    return 0;
}

#
# Discover resources for a slice (local experiment). This contacts Geni
# Central to get a list of components. I think the interface is supposed
# to be that we send an rspec and it sends back a list of components. But
# lets not worry about that; just get a list of all components we can ask
# for resources from.
#
sub DiscoverResources($$)
{
    my ($slice, $pref) = @_;

    my $response =
	Genixmlrpc::CallMethodHTTP($GENICENTRALURL, undef,
				   "CH::DiscoverResources",
				   { "slice"  => $slice->cert() });

    return -1
	if (!defined($response));

    return -1
	if ($response->code() != GENIRESPONSE_SUCCESS);

    #
    # We get back a list of components right now, which we cache locally.
    #
    my @result = ();
    
    foreach my $ref (@{ $response->value() }) {
	my $uuid = $ref->{'uuid'};
	my $url  = $ref->{'url'};
	my $hrn  = $ref->{'hrn'};
	my $cert = $ref->{'cert'};

	my $component = GeniComponent->Lookup($uuid);
	if (!defined($component)) {
	    $component = GeniComponent->Create($uuid, $hrn, $url, $cert);
	    if (!defined($component)) {
		return GeniResponse->Create(GENIRESPONSE_DBERROR);
	    }
	}
	elsif ($url ne $component->url() ||
	       $hrn ne $component->hrn()) {
	    $component->Update({"url" => $url, "hrn" => $hrn}) == 0 or
		return GeniResponse->Create(GENIRESPONSE_DBERROR);
	}
	push(@result, $component);
    }
    @$pref = @result;
    return 0;
}

#
# Bind and unbind users to/from slices
#
sub BindUser($$)
{
    my ($slice_uuid, $user_uuid) = @_;

    my $args = { "slice_uuid" => $slice_uuid,
		 "user_uuid"  => $user_uuid };

    my $response =
	Genixmlrpc::CallMethodHTTP($GENICENTRALURL, undef,
				   "CH::BindUser", $args);

    return -1
	if (!defined($response) || $response->code() != GENIRESPONSE_SUCCESS);
    
    return 0;
}
sub UnBindUser($$)
{
    my ($slice_uuid, $user_uuid) = @_;

    my $args = { "slice_uuid" => $slice_uuid,
		 "user_uuid"  => $user_uuid };

    my $response =
	Genixmlrpc::CallMethodHTTP($GENICENTRALURL, undef,
				   "CH::UnBindUser", $args);

    return -1
	if (!defined($response) || $response->code() != GENIRESPONSE_SUCCESS);
    
    return 0;
}

