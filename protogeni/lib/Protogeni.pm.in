#!/usr/bin/perl -wT
#
# EMULAB-COPYRIGHT
# Copyright (c) 2005, 2006, 2007, 2008 University of Utah and the Flux Group.
# All rights reserved.
#
package Protogeni;
use Exporter;
@ISA       = "Exporter";
@EXPORT    = qw( );

#
# XXX: Permissions need to be worked on. Some of these interfaces are
# only valid for SAs and others are available to mere users (geni
# users of course).
#
# Must come after package declaration!
use lib '@prefix@/lib';
use GeniResponse;

sub add ($$)
{
    return GeniResponse->Create(0, $_[0] + $_[1], "foo");
}

#############################################################################
# The Slice Authority interface for the Geni Clearinghouse.
#
package Protogeni::SA;
use GeniDB;
use GeniResponse;
use English;
use User;
use emutil;
use GeniUser;

##
# Lookup a GID (UUID) and return the public key for that user.
# A GID is just a UUID that has been bound to some data, such as a public
# key.
#
# @param GID the GID of the user to lookup.
# @return the public key bound to the user GID, or error if no user.
# 
sub Lookup($)
{
    my ($argref) = @_;
    my $uuid = $argref->{'uuid'};

    if (! (defined($uuid) && ($uuid =~ /^[-\w]*$/))) {
	return GeniResponse->MalformedArgsResponse();
    }
    my $user = User->LookupByUUID($uuid);
    if (defined($user)) {
	#
	# A local Emulab user. Return the pubkey for the user.
	#
	my $cert;
	if ($user->SSLCert(1, \$cert) != 0) {
	    return GeniResponse->Create(GENIRESPONSE_ERROR);
	}
	return GeniResponse->Create(0, $cert);
    }
    return GeniResponse->BadArgsResponse("No such user for GID")
	if (!defined($user));

    #
    # We want to return the certificate.
    #
    return GeniResponse->Create(0, 1);
}

#
# Register a new Geni user in the DB. Returns success/failure.
#
sub RegisterUser($)
{
    my ($argref) = @_;
    my $hrn   = $argref->{'hrn'};
    my $uid   = $argref->{'uid'};
    my $uuid  = $argref->{'uuid'};
    my $name  = $argref->{'name'};
    my $email = $argref->{'email'};
    my $cert  = $argref->{'cert'};

    if (! (defined($hrn) && defined($uid) && defined($name) &&
	   defined($email) &&
	   defined($cert) && defined($uuid))) {
	return GeniResponse->MalformedArgsResponse();
    }

    #
    # Use the Emulab checkslot routines.
    #
    if (! ($hrn =~ /^[-\w\.]*$/)) {
	return GeniResponse->Create(GENIRESPONSE_ERROR, undef,
				    "hrn: Invalid characters");
    }
    if (! ($uuid =~ /^[-\w]*$/)) {
	return GeniResponse->Create(GENIRESPONSE_ERROR, undef,
				    "uuid: Invalid characters");
    }
    if (! TBcheck_dbslot($name, "users", "usr_name", TBDB_CHECKDBSLOT_ERROR)) {
	return GeniResponse->Create(GENIRESPONSE_ERROR, undef,
				    "name: ". TBFieldErrorString());
    }
    if (! TBcheck_dbslot($name, "users", "uid", TBDB_CHECKDBSLOT_ERROR)) {
	return GeniResponse->Create(GENIRESPONSE_ERROR, undef,
				    "uid: ". TBFieldErrorString());
    }
    if (! TBcheck_dbslot($email, "users", "usr_email",TBDB_CHECKDBSLOT_ERROR)){
	return GeniResponse->Create(GENIRESPONSE_ERROR, undef,
				    "email: ". TBFieldErrorString());
    }
    if (! TBcheck_dbslot($cert, "default", "text", TBDB_CHECKDBSLOT_ERROR)){
	return GeniResponse->Create(GENIRESPONSE_ERROR, undef,
				    "cert: ". TBFieldErrorString());
    }

    #
    # XXX TODO!
    #
    # Who is the SA? We get this from the SSL environment (certificate).
    #
    my $sa_idx = 1;

    #
    # XXX TODO!
    #
    # Need to verify the UUID is permitted for the SA making the request.
    #

    #
    # XXX
    #
    # What kind of uniquess requirements do we need? No one else with this
    # email address? Of course, we have to allow hrn reuse, but should we
    # require that for a given SA, that hrn is unique, at least to avoid
    # lots of confusion?
    #
    if (GeniUser->CheckExisting($hrn, $email)) {
	return GeniResponse->Create(GENIRESPONSE_ERROR, undef,
				    "$hrn/$email already registered");
    }

    my $newuser = GeniUser->Create($hrn, $uid, $uuid,
				   $name, $email, $cert, $sa_idx);
    if (!defined($newuser)) {
	return GeniResponse->Create(GENIRESPONSE_ERROR, undef,
				    "$hrn/$email could not be registered");
    }

    return GeniResponse->Create(GENIRESPONSE_SUCCESS, undef,
				"$hrn/$email has been registered");
}

#
# Register a new Geni slice in the DB. Returns the UUID (GID).
#
sub RegisterSlice($)
{
    my ($argref) = @_;
    my $hrn   = $argref->{'hrn'};
    my $uuid  = $argref->{'uuid'};
    my $creator_uuid  = $argref->{'creator_uuid'};

    if (! (defined($hrn) && defined($uuid) && defined($creator_uuid))) {
	return Protogeni::MalformedArgsResponse();
    }

    #
    # Use the Emulab checkslot routines.
    #
    if (! ($hrn =~ /^[-\w\.]*$/)) {
	return GeniResponse->Create(GENIRESPONSE_ERROR, undef,
				    "hrn: Invalid characters");
    }
    if (! ($uuid =~ /^[-\w]*$/)) {
	return GeniResponse->Create(GENIRESPONSE_ERROR, undef,
				    "uuid: Invalid characters");
    }

    if (! ($creator_uuid =~ /^[-\w]*$/)) {
	return GeniResponse->Create(GENIRESPONSE_ERROR, undef,
				    "creator_uuid: Invalid characters");
    }

    #
    # XXX TODO!
    #
    # Who is the SA? We get this from the SSL environment (certificate).
    #
    my $sa_idx = 1;

    #
    # XXX TODO!
    #
    # Need to verify the UUID is permitted for the SA making the request.
    #

    #
    # Make sure the geni user exists. It might be a local user though,
    # which is not duplicated in the geni_users table, to avoid consistency
    # problems. Probably change this later though.
    #
    my $user = GeniUser->Lookup($creator_uuid);
    if (!defined($user)) {
	$user = User->LookupByUUID($creator_uuid);

	if (!defined($user)) {
	    return GeniResponse->Create(GENIRESPONSE_ERROR, undef,
					"creator_uuid: No such User");
	}
    }

    #
    # Make sure slice hrn and uuid are unique.
    #
    if (GeniSlice->CheckExisting($hrn, $uuid)) {
	return GeniResponse->Create(GENIRESPONSE_ERROR, undef,
				    "$hrn or $uuid already registered");
    }

    my $newslice = GeniSlice->Create($hrn, $uuid, $creator_uuid, $sa_idx);
    if (!defined($newslice)) {
	return GeniResponse->Create(GENIRESPONSE_ERROR, undef,
				    "$hrn/$uuid could not be registered");
    }

    return GeniResponse->Create(GENIRESPONSE_SUCCESS, undef,
				"$hrn/$uuid has been registered");
}

#
# Brain dead discover resources.
#
sub DiscoverResources($)
{
    my ($argref) = @_;
    my $uuid  = $argref->{'uuid'};

    if (!defined($uuid)) {
	return Protogeni::MalformedArgsResponse();
    }

    if (! ($uuid =~ /^[-\w]*$/)) {
	return GeniResponse->Create(GENIRESPONSE_ERROR, undef,
				    "uuid: Invalid characters");
    }

    #
    # Return simple list of URLs. 
    #
    my @results = ();
    my $query_result = DBQueryWarn("select url from geni_components");
    return GeniResponse->Create(GENIRESPONSE_DBERROR)
	if (!defined($query_result));

    while (my ($url) = $query_result->fetchrow_array()) {
	push(@results, $url);
    }
    return GeniResponse->Create(GENIRESPONSE_SUCCESS, @results);
}

# _Always_ make sure that this 1 is at the end of the file...
1;
