#!/usr/bin/perl -wT
#
# EMULAB-COPYRIGHT
# Copyright (c) 2008 University of Utah and the Flux Group.
# All rights reserved.
#
package GeniComponent;

#
# Some simple ticket stuff.
#
use strict;
use Exporter;
use vars qw(@ISA @EXPORT);

@ISA    = "Exporter";
@EXPORT = qw ( );

# Must come after package declaration!
use lib '@prefix@/lib';
use GeniDB;
use Genixmlrpc;
use GeniResponse;
use GeniTicket;
use GeniCredential;
use libtestbed;
use Experiment;
use libdb qw(TBGetUniqueIndex);
use English;
use overload ('""' => 'Stringify');
use XML::Simple;

# Configure variables
my $TB		   = "@prefix@";
my $TBOPS          = "@TBOPSEMAIL@";
my $TBAPPROVAL     = "@TBAPPROVALEMAIL@";
my $TBAUDIT   	   = "@TBAUDITEMAIL@";
my $BOSSNODE       = "@BOSSNODE@";
my $OURDOMAIN      = "@OURDOMAIN@";
my $SIGNCRED	   = "$TB/sbin/signgenicred";
my $VERIFYCRED	   = "$TB/sbin/verifygenicred";

# Do not allocated nodes.
my $impotent       = 1;

# Cache of instances to avoid regenerating them.
my %components     = ();

#
# Lookup by idx, or uuid.
#
sub Lookup($$)
{
    my ($class, $token) = @_;
    my $query_result;
    my $idx;

    if ($token =~ /^\d+$/) {
	$idx = $token;
    }
    elsif ($token =~ /^\w+\-\w+\-\w+\-\w+\-\w+$/) {
	$query_result =
	    DBQueryWarn("select idx from geni_components ".
			"where uuid='$token'");
	    return undef
		if (! $query_result || !$query_result->numrows);

	    ($idx) = $query_result->fetchrow_array();
    }
    else {
	return undef;
    }
    # Look in cache first
    return $components{"$idx"}
        if (exists($components{"$idx"}));

    $query_result =
	DBQueryWarn("select * from geni_components where idx='$idx'");
    
    return undef
	if (!$query_result || !$query_result->numrows);

    my $self              = {};
    $self->{'COMPONENT'}  = $query_result->fetchrow_hashref();
    bless($self, $class);

    #
    # Grab the certificate, since we will probably want it.
    #
    my $uuid = $self->{'COMPONENT'}->{'uuid'};
    $query_result = DBQueryWarn("select cert from geni_certificates ".
				"where uuid='$uuid'");
    if (!$query_result || !$query_result->numrows) {
	print STDERR "Could not find certificate for component $idx\n";
	return undef;
    }
    my ($cert) = $query_result->fetchrow_array();
    $self->{'COMPONENT'}->{'cert'} = $cert;
    
    # Add to cache. 
    $components{$self->{'COMPONENT'}->{'idx'}} = $self;
    
    return $self;
}

#
# Stringify for output.
#
sub Stringify($)
{
    my ($self) = @_;
    
    my $uuid = $self->uuid();
    my $idx  = $self->idx();

    return "[GeniComponent: $uuid, IDX: $idx]";
}

#
# Create a Geni component in the DB.
#
sub Create($$$$;$$)
{
    my ($class, $uuid, $hrn, $url, $cert) = @_;

    my @insert_data = ();
    my $idx = TBGetUniqueIndex('next_component', 1);

    my $safe_hrn  = DBQuoteSpecial($hrn);
    my $safe_url  = DBQuoteSpecial($url);
    my $safe_uuid = DBQuoteSpecial($uuid);
    my $safe_cert = DBQuoteSpecial($cert);
    
    # Now tack on other stuff we need.
    push(@insert_data, "created=now()");
    push(@insert_data, "idx='$idx'");
    push(@insert_data, "hrn=$safe_hrn");
    push(@insert_data, "url=$safe_url");
    push(@insert_data, "uuid=$safe_uuid");

    # Insert into DB.
    DBQueryWarn("replace into geni_components set " . join(",", @insert_data))
	or return undef;

    # Insert the certificate.
    if (!DBQueryWarn("replace into geni_certificates set ".
		     "  uuid=$safe_uuid, cert=$safe_cert")) {
	DBQueryWarn("delete from geni_components where idx='$idx'");
	return undef;
    }

    return GeniComponent->Lookup($idx);
}
# accessors
sub field($$) { return ((! ref($_[0])) ? -1 : $_[0]->{'COMPONENT'}->{$_[1]}); }
sub idx($)		{ return field($_[0], "idx"); }
sub uuid($)		{ return field($_[0], "uuid"); }
sub url($)		{ return field($_[0], "url"); }
sub hrn($)		{ return field($_[0], "hrn"); }
sub cert($)		{ return field($_[0], "cert"); }

#
# Refresh a class instance by reloading from the DB.
#
sub Refresh($)
{
    my ($self) = @_;

    return -1
	if (! ref($self));

    my $idx  = $self->idx();
    my $uuid = $self->uuid();

    my $query_result =
	DBQueryWarn("select * from geni_components where idx=$idx");

    return -1
	if (!$query_result || !$query_result->numrows);

    $self->{'COMPONENT'}  = $query_result->fetchrow_hashref();

    #
    # Grab the certificate, since we will probably want it.
    #
    $query_result = DBQueryWarn("select cert from geni_certificates ".
				"where uuid='$uuid'");
    if (!$query_result || !$query_result->numrows) {
	print STDERR "Could not find certificate for component $idx\n";
	return undef;
    }
    my ($cert) = $query_result->fetchrow_array();
    $self->{'COMPONENT'}->{'cert'} = $cert;
    
    return 0;
}

#
# Update Fields.
#
sub Update($$)
{
    my ($self, $argref) = @_;

    # Must be a real reference. 
    return -1
	if (! ref($self));

    my $idx = $self->idx();

    my $query = "update geni_components set ".
	join(",", map("$_=" . DBQuoteSpecial($argref->{$_}), keys(%{$argref})));

    $query .= " where idx='$idx'";

    return -1
	if (! DBQueryWarn($query));

    return Refresh($self);
}

#
# Discover Resources on the component. Returns a resource availability
# spec as an XML string (not a structure).
#
sub DiscoverResources($$$$$)
{
    my ($self, $slice, $user, $credential, $pref) = @_;

    # Must be a real reference. 
    return -1
	if (! (ref($self) && ref($slice) && ref($user) && ref($credential)));

    my $response =
	Genixmlrpc::CallMethodHTTP($self->url(),
				   $user,
				   "CM::DiscoverResources",
				   { "slice"       => $slice->cert(),
				     "credential"  => $credential->asString()
				     });
    
    return -1
	if (!defined($response) || $response->code() != GENIRESPONSE_SUCCESS);

    my $rspec = XMLin($response->value(), ForceArray => ["node"]);
    $$pref = $rspec;
    
    return 0;
}

#
# Get a Ticket from a component;
#
sub GetTicket($$$$$)
{
    my ($self, $slice, $rspec, $user, $credential) = @_;
    my $rspec_xml = $rspec;

    # Must be a real reference. 
    return undef
	if (! ref($self));

    # The rspec is passed as XML. If we get a ref, convert it.
    if (ref($rspec_xml)) {
	$rspec_xml = XMLout($rspec_xml, RootName => "rspec");
    }

    my $response = 				       
	Genixmlrpc::CallMethodHTTP($self->url(),
				   $user,
				   "CM::GetTicket",
				   { "slice"        => $slice->cert(),
				     "credential"   => $credential->asString(),
				     "impotent"     => $impotent,
				     "rspec"        => $rspec_xml });
    
    return undef
	if (!defined($response));

    return undef
	if ($response->code() != GENIRESPONSE_SUCCESS);

    #
    # Convert this into a (signed) ticket object.
    #
    return GeniTicket->CreateFromSignedTicket($response->value(), $self, 1);
}

#
# Create a sliver, given a ticket.
#
sub CreateSliver($$$$)
{
    my ($self, $slice, $ticket, $user) = @_;

    # Must be a real reference. 
    return undef
	if (! ref($self));

    my $response =
	Genixmlrpc::CallMethodHTTP($self->url(), $user,
				   "CM::CreateSliver",
				   { "ticket"    => $ticket->asString(),
				     "impotent"  => $impotent });
    
    return undef
	if (!defined($response));

    return undef
	if ($response->code() != GENIRESPONSE_SUCCESS);

    #
    # We get back a signed credential, which has the sliver uuid inside.
    #
    my $credential = GeniCredential->CreateFromSigned($response->value());
    if (!defined($credential)) {
	print STDERR "Could not create local credential object.\n";
	return undef;
    }

    my $sliver = GeniSliver->Create($ticket, $credential);
    if (!defined($sliver)) {
	print STDERR "Could not create local sliver object.\n";
	return undef;
    }
    return $sliver;
}

#
# Destroy a sliver. 
#
sub DestroySliver($$$)
{
    my ($self, $sliver, $user) = @_;

    # Must be a real reference. 
    return -1
	if (! ref($self));

    my $credential = $sliver->GetCredential();
    return -1
	if (!defined($credential));
    
    my $response =
	Genixmlrpc::CallMethodHTTP($self->url(), $user,
				   "CM::DestroySliver",
				   { "sliver"      => $sliver->cert(),
				     "credential"  =>
					 $credential->asString() });
    
    if ($response->code() != GENIRESPONSE_SUCCESS) {
	print STDERR "Could not destroy sliver $sliver\n";
	return -1;
    }
    return 0;
}

# _Always_ make sure that this 1 is at the end of the file...
1;

