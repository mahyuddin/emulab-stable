#!/usr/bin/perl -wT
#
# EMULAB-COPYRIGHT
# Copyright (c) 2008 University of Utah and the Flux Group.
# All rights reserved.
#
package GeniCH;

#
# The server side of the Geni ClearingHouse API. 
#
use strict;
use Exporter;
use vars qw(@ISA @EXPORT);

@ISA    = "Exporter";
@EXPORT = qw ( );

# Must come after package declaration!
use lib '@prefix@/lib';
use GeniDB;
use Genixmlrpc;
use GeniResponse;
use User;
use GeniUser;
use GeniSlice;
use GeniComponent;
use GeniAuthority;
use libtestbed;
use emutil;
use English;
use Data::Dumper;

# Configure variables
my $TB		   = "@prefix@";
my $TBOPS          = "@TBOPSEMAIL@";
my $TBAPPROVAL     = "@TBAPPROVALEMAIL@";
my $TBAUDIT   	   = "@TBAUDITEMAIL@";
my $BOSSNODE       = "@BOSSNODE@";
my $OURDOMAIN      = "@OURDOMAIN@";

#
# Get a credential to use the ClearingHouse. For the moment, the initial
# credential will be provided to callers with the proper certificate, which
# means just SAs/CMs that we know about via the ssl certificate used to
# connect to us.
#
sub GetCredential($)
{
    my ($argref) = @_;
    my $uuid = $argref->{'uuid'};
    my $cred = $argref->{'credential'};
    my $type = $argref->{'type'};

    #
    # The caller has to be known to us, but how are they known to us?
    # Probably need a web interface? 
    #
    my $caller_uuid = $ENV{'GENIUUID'};
    my $caller_authority = GeniAuthority->Lookup($ENV{'GENIUUID'});
    return GeniResponse->Create(GENIRESPONSE_REFUSED, undef, "Who are You?")
	if (!defined($caller_authority));
    
    #
    # No credential, then return a generic credential giving caller permission
    # to do other things.
    #
    if (!defined($cred)) {
	#
	# This credential is for access to this authority.
	#
	my $authority = GeniAuthority->Lookup($ENV{'MYUUID'});
	if (!defined($authority)) {
	    print STDERR "Could not find local authority object\n";
	    return GeniResponse->Create(GENIRESPONSE_ERROR);
	}
	my $credential = GeniCredential->Create($authority, $caller_authority);
	if (!defined($credential)) {
	    print STDERR "Could not create credential for $caller_authority\n";
	    return GeniResponse->Create(GENIRESPONSE_ERROR);
	}
	if ($credential->Sign($GeniCredential::LOCALMA_FLAG)) {
	    print STDERR "Could not sign credential for $caller_authority\n";
	    return GeniResponse->Create(GENIRESPONSE_ERROR);
	}
	return GeniResponse->Create(GENIRESPONSE_SUCCESS,
				    $credential->asString());
    }

    #
    # User provided a credential, and wants a new credential to access
    # the object referenced by the uuid.
    #
    return GeniResponse->Create(GENIRESPONSE_UNSUPPORTED);
}

##
# Lookup a UUID and return a blob of stuff. We allow lookups of both
# users and slices, which is what we allow clients to register.
#
sub Resolve($)
{
    my ($argref) = @_;
    my $cred = $argref->{'credential'};
    my $uuid = $argref->{'uuid'};
    my $type = $argref->{'type'};

    if (! (defined($uuid) && ($uuid =~ /^[-\w]*$/))) {
	return GeniResponse->MalformedArgsResponse();
    }
    if (! (defined($type) && ($type =~ /^(SA|CM|MA|Component|Slice|User)$/i))){
	return GeniResponse->MalformedArgsResponse();
    }
    if (! defined($cred)) {
	return GeniResponse->MalformedArgsResponse();
    }
    my $credential = GeniCredential->CreateFromSigned($cred);
    if (!defined($credential)) {
	return GeniResponse->Create(GENIRESPONSE_ERROR, undef,
				    "Could not create GeniCredential object");
    }

    #
    # Make sure the credential was issued to the caller.
    #
    if ($credential->owner_uuid() ne $ENV{'GENIUUID'}) {
	return GeniResponse->Create(GENIRESPONSE_ERROR, undef,
				    "This is not your credential!");
    }
    #
    # And that the target of the credential is this registry.
    #
    my $authority = GeniAuthority->Lookup($ENV{'MYUUID'});
    if (!defined($authority)) {
	print STDERR "Could not find local authority object\n";
	return GeniResponse->Create(GENIRESPONSE_ERROR);
    }
    if ($credential->target_uuid() ne $authority->uuid()) {
	return GeniResponse->Create(GENIRESPONSE_FORBIDDEN,
				    undef, "This is not your registry!");
    }

    if ($type eq "User") {
	my $user = GeniUser->Lookup($uuid);
	if (!defined($user)) {
	    return GeniResponse->Create(GENIRESPONSE_SEARCHFAILED, undef,
					"No such user $uuid");
	}
	# Grab keys.
	#my @sliverkeys;
	#if ($user->GetKeys(\@sliverkeys) != 0) {
	#    print STDERR "Could not get sliver keys for $user\n";
	#}

	# Return a blob.
	my $blob = { "uid"      => $user->uid(),
		     "hrn"      => $user->hrn(),
		     "uuid"     => $user->uuid(),
		     "email"    => $user->email(),
		     "cert"     => $user->cert(),
		     "name"     => $user->name(),
		     "sa_uuid"  => $user->sa_uuid(),
		 };
	#$blob->{'sliverkeys'} = \@sliverkeys
	#    if (@sliverkeys);
    
	return GeniResponse->Create(GENIRESPONSE_SUCCESS, $blob);
    }
    if ($type eq "Component") {
	my $component = GeniComponent->LookupByResource($uuid);
	
	if (!defined($component)) {
	    return GeniResponse->Create(GENIRESPONSE_SEARCHFAILED, undef,
					"No such resource $uuid");
	}
	my $certificate = GeniCertificate->Lookup($uuid);
	if (!defined($certificate)) {
	    return GeniResponse->Create(GENIRESPONSE_SEARCHFAILED, undef,
					"No certificate for $uuid");
	}

	# Return a blob.
	my $blob = { "gid"      => $certificate->cert(),
		     "cm"	=> $component->cert(),
		     "url"      => $component->url(),
		 };
    
	return GeniResponse->Create(GENIRESPONSE_SUCCESS, $blob);
    }
    if ($type eq "SA" || $type eq "sa") {
	my $authority = GeniAuthority->Lookup($uuid);
	if (!defined($authority)) {
	    return GeniResponse->Create(GENIRESPONSE_SEARCHFAILED, undef,
					"No such authority $uuid");
	}
	# Return a blob.
	my $blob = { "gid"         => $authority->cert(),
		     "url"         => $authority->url(),
		     "type"        => $authority->type(),
		 };
	return GeniResponse->Create(GENIRESPONSE_SUCCESS, $blob);
    }
    if ($type eq "CM") {
	my $component = GeniComponent->Lookup($uuid);
	if (!defined($component)) {
	    return GeniResponse->Create(GENIRESPONSE_SEARCHFAILED, undef,
					"No such component $uuid");
	}
	# Return a blob.
	my $blob = { "gid"         => $component->cert(),
		     "url"         => $component->url(),
		 };
	return GeniResponse->Create(GENIRESPONSE_SUCCESS, $blob);
    }
    if ($type eq "Slice") {
	my $slice = GeniSlice->Lookup($uuid);
	if (!defined($slice)) {
	    return GeniResponse->Create(GENIRESPONSE_SEARCHFAILED, undef,
					"No such slice $uuid");
	}

	# User bindings too.
	#my @userbindings = ();
	#if ($slice->UserBindings(\@userbindings) != 0) {
	#    return GeniResponse->Create(GENIRESPONSE_ERROR, undef,
	#				"Error getting users for slice");
	#}

	# Return a blob.
	my $blob = { "hrn"          => $slice->hrn(),
		     "uuid"         => $slice->uuid(),
		     "creator_uuid" => $slice->creator_uuid(),
		     "cert"         => $slice->cert(),
		     "sa_uuid"      => $slice->sa_uuid(),
	#	     "userbindings" => \@userbindings,
		 };
	return GeniResponse->Create(GENIRESPONSE_SUCCESS, $blob);
    }
    return GeniResponse->Create(GENIRESPONSE_UNSUPPORTED);
}

##
# Register a new object.
#
sub Register($)
{
    my ($argref) = @_;
    my $cred  = $argref->{'credential'};
    my $cert  = $argref->{'cert'};
    my $info  = $argref->{'info'};
    my $type  = $argref->{'type'};

    if (! (defined($type) && ($type =~ /^(SA|MA|Component|Slice|User)$/))) {
	return GeniResponse->MalformedArgsResponse();
    }
    if (! defined($cred)) {
	return GeniResponse->MalformedArgsResponse();
    }
    if (! defined($cert)) {
	return GeniResponse->MalformedArgsResponse();
    }
    if (! ($cert =~ /^[\012\015\040-\176]*$/)) {
	return GeniResponse->Create(GENIRESPONSE_ERROR, undef,
				    "cert: Invalid characters");
    }
    if (! defined($info)) {
	return GeniResponse->MalformedArgsResponse();
    }
    my $credential = GeniCredential->CreateFromSigned($cred);
    if (!defined($credential)) {
	return GeniResponse->Create(GENIRESPONSE_ERROR, undef,
				    "Could not create GeniCredential object");
    }

    #
    # Make sure the credential was issued to the caller.
    #
    if ($credential->owner_uuid() ne $ENV{'GENIUUID'}) {
	return GeniResponse->Create(GENIRESPONSE_ERROR, undef,
				    "This is not your credential!");
    }
    #
    # And that the target of the credential is this registry.
    #
    my $authority = GeniAuthority->Lookup($ENV{'MYUUID'});
    if (!defined($authority)) {
	print STDERR "Could not find local authority object\n";
	return GeniResponse->Create(GENIRESPONSE_ERROR);
    }
    if ($credential->target_uuid() ne $authority->uuid()) {
	return GeniResponse->Create(GENIRESPONSE_FORBIDDEN,
				    undef, "This is not your registry!");
    }

    #
    # Grab the uuid and hrn out of the certificate.
    #
    my $certificate = GeniCertificate->LoadFromString($cert);
    return GeniResponse->Create(GENIRESPONSE_ERROR, undef,
				"Could not parse certificate")
	if (!defined($certificate));

    if (! ($certificate->uuid() =~ /^\w+\-\w+\-\w+\-\w+\-\w+$/)) {
	return GeniResponse->Create(GENIRESPONSE_BADARGS, undef,
				    "Improper format for uuid");
    }
    if (! ($certificate->hrn() =~ /^[\w\.]+$/)) {
	return GeniResponse->Create(GENIRESPONSE_BADARGS, undef,
				    "Improper format for hrn");
    }
    
    if ($type eq "User") {
	my $name  = $info->{'name'};
	my $email = $info->{'email'};
	my $keys  = undef;

	if (! TBcheck_dbslot($name, "users", "usr_name",
			     TBDB_CHECKDBSLOT_ERROR)) {
	    return GeniResponse->Create(GENIRESPONSE_ERROR, undef,
					"name: ". TBFieldErrorString());
	}
	if (! TBcheck_dbslot($email, "users", "usr_email",
			     TBDB_CHECKDBSLOT_ERROR)){
	    return GeniResponse->Create(GENIRESPONSE_ERROR, undef,
					"email: ". TBFieldErrorString());
	}
	if (0 && defined($keys)) {
	    foreach my $keyref (@{ $keys }) {
		my $type = $keyref->{'type'};
		my $key  = $keyref->{'key'};

		if ($type ne 'ssh') {
		    return GeniResponse->Create(GENIRESPONSE_ERROR, undef,
						"key: Invalid key type");
		}
		if (! ($key =~ /^[\012\015\040-\176]*$/)) {
		    return GeniResponse->Create(GENIRESPONSE_ERROR, undef,
						"key: Invalid characters");
		}
	    }
	}
	#
	# Need to verify the UUID is permitted for the SA making the request.
	#
	my $slice_authority = GeniAuthority->Lookup($ENV{'GENIUUID'});
	if (!defined($slice_authority)) {
	    print STDERR "Could not find authority object for caller.\n";
	    return GeniResponse->Create(GENIRESPONSE_ERROR);
	}
	if (! $slice_authority->PrefixMatch($certificate->uuid())) {
	    return GeniResponse->Create(GENIRESPONSE_BADARGS, undef,
					"uuid: Prefix mismatch");
	}

	my $existing = GeniUser->Lookup($certificate->uuid());
	if (defined($existing)) {
	    if (! ($existing->hrn() eq $certificate->hrn())) {
		return GeniResponse->Create(GENIRESPONSE_ERROR, undef,
					    "Not allowed to change hrn");
	    }
	    if (! ($existing->sa_uuid() eq $slice_authority->uuid())) {
		return GeniResponse->Create(GENIRESPONSE_ERROR, undef,
				"Already registered with another SA");
	    }
	    #
	    # Update operation, but only name, email, and keys for now.
	    #
	    if ($existing->Modify($name, $email, $keys) != 0) {
		return GeniResponse->Create(GENIRESPONSE_ERROR, undef,
					    "Could not update user");
	    }
	    return GeniResponse->Create(GENIRESPONSE_SUCCESS);
	}
	#
	# XXX
	#
	# What kind of uniquess requirements do we need? No one else with this
	# email address? Of course, we have to allow hrn reuse, but should we
	# require that for a given SA, that hrn is unique, at least to avoid
	# lots of confusion?
	#
	if (GeniUser->CheckExisting($certificate->hrn(), $email)) {
	    return GeniResponse->Create(GENIRESPONSE_ERROR, undef,
					"hrn/email already registered");
	}
	my $newuser = GeniUser->Create($certificate, $slice_authority,
				       $info, $keys);
	if (!defined($newuser)) {
	    return GeniResponse->Create(GENIRESPONSE_ERROR, undef,
					"Could not be registered");
	}
	return GeniResponse->Create(GENIRESPONSE_SUCCESS, undef,
				    "User has been registered");
    }
    if ($type eq "Slice") {
	my $creator_uuid  = $info->{'creator_uuid'};
	my $userbindings  = $info->{'userbindings'};

	if (! ($creator_uuid =~ /^[-\w]*$/)) {
	    return GeniResponse->Create(GENIRESPONSE_ERROR, undef,
					"creator_uuid: Invalid characters");
	}
	#
	# Make sure the geni user exists. 	
	#
	my $user = GeniUser->Lookup($creator_uuid);
	if (!defined($user)) {
	    return GeniResponse->Create(GENIRESPONSE_ERROR, undef,
					"creator_uuid: No such User");
	}

	#
	# Ditto any users bound to the slice.
	#
	if (0 && defined($userbindings)) {
	    foreach my $binding_uuid (@{ $userbindings }) {
		my $binding_user = GeniUser->Lookup($binding_uuid);
		if (!defined($binding_user)) {
		    return GeniResponse->Create(GENIRESPONSE_ERROR, undef,
						"$binding_user: No such User");
		}
	    }
	}
	
	#
	# Need to verify the UUID is permitted for the SA making the request.
	#
	my $slice_authority = GeniAuthority->Lookup($ENV{'GENIUUID'});
	if (!defined($slice_authority)) {
	    print STDERR "Could not find authority object for caller.\n";
	    return GeniResponse->Create(GENIRESPONSE_ERROR);
	}
	if (! $slice_authority->PrefixMatch($certificate->uuid())) {
	    return GeniResponse->Create(GENIRESPONSE_BADARGS, undef,
					"uuid: Prefix mismatch");
	}

	#
	# Reregistration of existing slice is okay.
	#
	my $existing = GeniSlice->Lookup($certificate->uuid());
	if (defined($existing)) {
	    if (! ($existing->cert() eq $certificate->cert())) {
		return GeniResponse->Create(GENIRESPONSE_ERROR, undef,
					    "Not allowed to change cert");
	    }
	    if (! ($existing->sa_uuid() eq $slice_authority->uuid())) {
		return GeniResponse->Create(GENIRESPONSE_ERROR, undef,
				"Already registered with another SA");
	    }
	    if (0 && defined($userbindings)) {
		$existing->UnBindUsers();
		
		foreach my $binding_uuid (@{ $userbindings }) {
		    my $binding_user = GeniUser->Lookup($binding_uuid);
		    $existing->BindUser($binding_user);
		}
	    }
	    
	    return GeniResponse->Create(GENIRESPONSE_SUCCESS);
	}

	#
	# Make sure slice hrn and uuid are unique.
	#
	if (GeniSlice->CheckExisting($certificate->hrn(),
				     $certificate->uuid())) {
	    return GeniResponse->Create(GENIRESPONSE_ERROR, undef,
					"Slice already registered");
	}

	my $newslice = GeniSlice->Create($certificate, $creator_uuid,
					 $slice_authority);
	if (!defined($newslice)) {
	    return GeniResponse->Create(GENIRESPONSE_ERROR, undef,
					"Could not be registered");
	}

	#
	# Add the bindings now.
	# 
	if (0 && defined($userbindings)) {
	    foreach my $binding_uuid (@{ $userbindings }) {
		my $binding_user = GeniUser->Lookup($binding_uuid);
		$newslice->BindUser($binding_user);
	    }
	}
	
	return GeniResponse->Create(GENIRESPONSE_SUCCESS, undef,
				    "Slice has been registered");
    }
    if ($type eq "Component") {
	my $resource_type  = $info->{'resource_type'};
	my $resource_uuid  = $info->{'resource_uuid'};

	my $component = GeniComponent->Lookup($ENV{'GENIUUID'});
	if (!defined($component)) {
	    print STDERR "Could not find component object for caller.\n";
	    return GeniResponse->Create(GENIRESPONSE_ERROR);
	}

	if (! ($resource_uuid =~ /^[-\w]+$/)) {
	    return GeniResponse->Create(GENIRESPONSE_ERROR, undef,
					"resource_uuid: Invalid characters");
	}
	if (! ($resource_type =~ /^[-\w]+$/)) {
	    return GeniResponse->Create(GENIRESPONSE_ERROR, undef,
					"resource_type: Invalid characters");
	}
	if ($certificate->Store() != 0) {
	    return GeniResponse->Create(GENIRESPONSE_ERROR, undef,
					"Could not store certificate");
	}
	if ($component->NewResource($resource_uuid) != 0) {
	    return GeniResponse->Create(GENIRESPONSE_ERROR, undef,
					"Could not register new resource");
	}
    }

    return GeniResponse->Create(GENIRESPONSE_UNSUPPORTED);
}

##
# Delete an object.
#
sub Remove($)
{
    my ($argref) = @_;
    my $cred  = $argref->{'credential'};
    my $uuid  = $argref->{'uuid'};
    my $type  = $argref->{'type'};

    if (! (defined($type) && ($type =~ /^(SA|MA|Component|Slice|User)$/))) {
	return GeniResponse->MalformedArgsResponse();
    }
    if (! defined($cred)) {
	return GeniResponse->MalformedArgsResponse();
    }
    if (! (defined($uuid) && ($uuid =~ /^\w+\-\w+\-\w+\-\w+\-\w+$/))) {
	return GeniResponse->MalformedArgsResponse();
    }

    my $credential = GeniCredential->CreateFromSigned($cred);
    if (!defined($credential)) {
	return GeniResponse->Create(GENIRESPONSE_ERROR, undef,
				    "Could not create GeniCredential object");
    }

    #
    # Make sure the credential was issued to the caller.
    #
    if ($credential->owner_uuid() ne $ENV{'GENIUUID'}) {
	return GeniResponse->Create(GENIRESPONSE_ERROR, undef,
				    "This is not your credential!");
    }
    #
    # And that the target of the credential is this registry.
    #
    my $authority = GeniAuthority->Lookup($ENV{'MYUUID'});
    if (!defined($authority)) {
	print STDERR "Could not find local authority object\n";
	return GeniResponse->Create(GENIRESPONSE_ERROR);
    }
    if ($credential->target_uuid() ne $authority->uuid()) {
	return GeniResponse->Create(GENIRESPONSE_FORBIDDEN,
				    undef, "This is not your registry!");
    }

    if ($type eq "User") {
	my $user = GeniUser->Lookup($uuid);
	if (!defined($user)) {
	    return GeniResponse->Create(GENIRESPONSE_SEARCHFAILED, undef,
					"No such user $uuid");
	}
	if (!$user->Delete()) {
	    print STDERR "Could not delete $user from ClearingHouse!\n";
	    return GeniResponse->Create(GENIRESPONSE_ERROR, undef,
					"$uuid could not be unregistered");
	}
	return GeniResponse->Create(GENIRESPONSE_SUCCESS, undef,
				    "$uuid has been unregistered");
    }
    if ($type eq "Slice") {
	my $slice = GeniSlice->Lookup($uuid);
	if (!defined($slice)) {
	    return GeniResponse->Create(GENIRESPONSE_SUCCESS, undef,
					"No such slice $uuid");
	}
	if ($slice->Delete()) {
	    print STDERR "Could not delete $slice from ClearingHouse!\n";
	    return GeniResponse->Create(GENIRESPONSE_ERROR, undef,
					"$uuid could not be unregistered");
	}
	return GeniResponse->Create(GENIRESPONSE_SUCCESS, undef,
				    "$uuid has been unregistered");
    }
    return GeniResponse->Create(GENIRESPONSE_UNSUPPORTED);
}

#
# This is just a placeholder; return a list of all components. Eventually
# takes an rspec and we do a resource mapping. 
#
sub ListComponents($)
{
    my ($argref) = @_;
    my $cred  = $argref->{'credential'};

    if (! defined($cred)) {
	return GeniResponse->MalformedArgsResponse();
    }
    my $credential = GeniCredential->CreateFromSigned($cred);
    if (!defined($credential)) {
	return GeniResponse->Create(GENIRESPONSE_ERROR, undef,
				    "Could not create GeniCredential object");
    }

    #
    # Make sure the credential was issued to the caller.
    #
    if ($credential->owner_uuid() ne $ENV{'GENIUUID'}) {
	return GeniResponse->Create(GENIRESPONSE_ERROR, undef,
				    "This is not your credential!");
    }

    #
    # Return simple list of components (hashes).
    #
    my @results = ();
    my $query_result = DBQueryWarn("select uuid from geni_components");
    return GeniResponse->Create(GENIRESPONSE_DBERROR)
	if (!defined($query_result));

    while (my ($component_uuid) = $query_result->fetchrow_array()) {
	my $component = GeniComponent->Lookup($component_uuid);
	return GeniResponse->Create(GENIRESPONSE_DBERROR)
	    if (!defined($component));
	    
	push(@results, { "gid" => $component->cert(),
			 "hrn" => $component->hrn(),
		         "url" => $component->url() });
    }
    return GeniResponse->Create(GENIRESPONSE_SUCCESS, \@results);
}

