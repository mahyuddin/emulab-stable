#!/usr/bin/perl -wT
#
# EMULAB-COPYRIGHT
# Copyright (c) 2008 University of Utah and the Flux Group.
# All rights reserved.
#
package GeniTicket;

#
# Some simple ticket stuff.
#
use strict;
use Exporter;
use vars qw(@ISA @EXPORT);

@ISA    = "Exporter";
@EXPORT = qw ( );

# Must come after package declaration!
use lib '@prefix@/lib';
use GeniDB;
use libtestbed;
use Experiment;
use libdb qw(TBGetUniqueIndex);
use English;
use XML::Simple;
use XML::LibXML;
use Data::Dumper;
use File::Temp qw(tempfile);

# Configure variables
my $TB		   = "@prefix@";
my $TBOPS          = "@TBOPSEMAIL@";
my $TBAPPROVAL     = "@TBAPPROVALEMAIL@";
my $TBAUDIT   	   = "@TBAUDITEMAIL@";
my $BOSSNODE       = "@BOSSNODE@";
my $OURDOMAIN      = "@OURDOMAIN@";
my $SIGNCRED	   = "$TB/sbin/signgenicred";
my $VERIFYCRED	   = "$TB/sbin/verifygenicred";
my $NFREE	   = "$TB/bin/nfree";

#
# Create an unsigned ticket object from the raw rspec. 
#
sub Create($$$$;$$)
{
    my ($class, $slice_uuid, $owner_uuid,
	$rspec, $ticket_string, $component) = @_;

    my $self = {};
    $self->{'rspec'}         = $rspec;
    $self->{'slice_uuid'}    = $slice_uuid;
    $self->{'owner_uuid'}    = $owner_uuid;
    $self->{'ticket_string'} = $ticket_string;
    $self->{'ticket'}        = undef;
    $self->{'idx'}           = undef;	# Only set when in DB.
    $self->{'component'}     = $component;
    bless($self, $class);

    return $self;
}
# accessors
sub field($$)           { return ($_[0]->{$_[1]}); }
sub idx($)		{ return field($_[0], "idx"); }
sub rspec($)		{ return field($_[0], "rspec"); }
sub uuid($)		{ return field($_[0], "slice_uuid"); }
sub slice_uuid($)	{ return field($_[0], "slice_uuid"); }
sub owner_uuid($)	{ return field($_[0], "owner_uuid"); }
sub ticket($)		{ return field($_[0], "ticket"); }
sub asString($)		{ return field($_[0], "ticket_string"); }
sub ticket_string($)	{ return field($_[0], "ticket_string"); }
sub component($)	{ return field($_[0], "component"); }

#
# Create a ticket object from a signed ticket string.
#
sub CreateFromSignedTicket($$)
{
    my ($class, $ticket_string) = @_;

    # First verify the ticket.
    my ($fh, $filename) = tempfile(UNLINK => 0);
    return undef
	if (!defined($fh));
    print $fh $ticket_string;
    close($fh);
    system("$VERIFYCRED $filename");
    if ($?) {
	print STDERR "Ticket in $filename did not verify\n";
	return undef;
    }
    unlink($filename);

    # Use XML::Simple to convert to something we can mess with.
    my $parser = XML::LibXML->new;
    my $doc    = $parser->parse_string($ticket_string);

    # Dig out the rspec.
    my ($rspec_node) = $doc->getElementsByTagName("rspec");
    return undef
	if (!defined($rspec_node));
    my $rspec = XMLin($rspec_node->toString(), ForceArray => 0);

    # Dig out the slice uuid. Locally, I am not sure if we bother to
    # keep slices in the DB (they are in the DB at geni central).
    my ($uuid_node) = $doc->getElementsByTagName("this_uuid");
    return undef
	if (!defined($uuid_node));
    my $slice_uuid = $uuid_node->to_literal();

    if (! ($slice_uuid =~ /^\w+\-\w+\-\w+\-\w+\-\w+$/)) {
	print STDERR "Invalid slice_uuid in ticket\n";
	return undef;
    }

    # Dig out the owner uuid. Locally, I am not sure if we bother to
    # keep users in the DB (they are in the DB at geni central).
    ($uuid_node) = $doc->getElementsByTagName("owner_uuid");
    return undef
	if (!defined($uuid_node));
    my $owner_uuid = $uuid_node->to_literal();

    if (! ($owner_uuid =~ /^\w+\-\w+\-\w+\-\w+\-\w+$/)) {
	print STDERR "Invalid owner_uuid in ticket\n";
	return undef;
    }

    #
    # We save copies of the tickets we hand out; lets find that record
    # in the DB, just to verify.
    #
    my ($serial_node) = $doc->getElementsByTagName("serial");
    return undef
	if (!defined($serial_node));
    my $serial = $serial_node->to_literal();

    if (! ($serial =~ /^\w+$/)) {
	print STDERR "Invalid serial in ticket\n";
	return undef;
    }
    my $query_result =
	DBQueryWarn("select * from geni_tickets where idx='$serial'");
    if (!$query_result || !$query_result->numrows) {
	print STDERR "Could not find the ticket in te DB\n";
	return undef;
    }

    my $self = {};
    $self->{'rspec'}         = $rspec;
    $self->{'slice_uuid'}    = $slice_uuid;
    $self->{'owner_uuid'}    = $owner_uuid;
    $self->{'ticket_string'} = $ticket_string;
    $self->{'xmlref'}        = $doc;
    $self->{'component'}     = undef;
    $self->{'idx'}           = $serial;
    bless($self, $class);

    return $self;
}

#
# Might have to delete this fron the DB, as with an error handing out a ticket.
#
sub Delete($)
{
    my ($self) = @_;

    return -1
	if (! ref($self));

    if (defined($self->idx())) {
	my $idx = $self->idx();
	
	DBQueryWarn("delete from geni_tickets where idx='$idx'")
	    or return -1;
    }
    return 0;
}

#
# Populate the ticket with some stuff, which right now is just the
# number of node we are willing to grant.
#
sub Grant($$)
{
    my ($self, $count) = @_;

    return -1
	if (! ref($self));

    $self->{'count'} = $count;
    return 0;
}

#
# Store the given ticket in the DB. We only do this for signed tickets,
# so we have a record of them. We store them on the server and the client
# side.
#
sub Store($$)
{
    my ($self, $idx) = @_;
    my @insert_data  = ();

    my $slice_uuid = $self->slice_uuid();
    my $owner_uuid = $self->owner_uuid();

    # Now tack on other stuff we need.
    push(@insert_data, "created=now()");
    push(@insert_data, "idx='$idx'");
    push(@insert_data, "slice_uuid='$slice_uuid'");
    push(@insert_data, "owner_uuid='$owner_uuid'");
    
    my $safe_ticket = DBQuoteSpecial($self->ticket_string());
    push(@insert_data, "ticket_string=$safe_ticket");

    # Insert into DB.
    DBQueryWarn("insert into geni_tickets set " . join(",", @insert_data))
	or return -1;

    # If sucessfully stored, set the idx field so we know.
    $self->{'idx'} = $idx;

    return 0;
}

#
# Sign the ticket before returning it. We capture the output, which is
# in XML.
#
sub Sign($)
{
    my ($self) = @_;

    return -1
	if (!ref($self));

    # Every Ticket gets a new unique index, which is used in the xml:id below.
    # Also used for the DB insertion below.
    my $idx = TBGetUniqueIndex('next_ticket', 1);
    
    my $slice_uuid = $self->slice_uuid();
    my $owner_uuid = $self->owner_uuid();
    my $rspec_xml  = XMLout($self->rspec(), "NoAttr" => 1);
    $rspec_xml =~ s/opt\>/rspec\>/g;

    #
    # Create a template xml file to sign.
    #
    my $template =
	"<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?>\n".
	"<credential xml:id=\"ref1\">\n".
	" <type>ticket</type>\n".
	" <serial>$idx</serial>\n".
	" <owner_uuid>$owner_uuid</owner_uuid>\n".
	" <this_uuid>$slice_uuid</this_uuid>\n".
	" <ticket>\n".
	"  <can_delegate>1</can_delegate>\n".
	"  $rspec_xml\n".
	" </ticket>\n".	
        "</credential>\n";

    my ($fh, $filename) = tempfile(UNLINK => 0);
    return -1
	if (!defined($fh));

    print $fh $template;
    close($fh);

    #
    # Fire up the signer and capture the output. This is the signed ticket
    # that is returned. 
    #
    if (! open(SIGNER, "$SIGNCRED $filename |")) {
	print STDERR "Could not sign $filename\n";
	return -1;
    }
    my $ticket = "";
    while (<SIGNER>) {
	$ticket .= $_;
    }
    if (!close(SIGNER)) {
	print STDERR "Could not sign $filename\n";
	return -1;
    }
    $self->{'ticket_string'} = $ticket;

    $self->Store($idx) == 0
	or return -1;

    unlink($filename);
    return 0;
}

#
# Get the experiment for the slice this sliver belongs to.
#
sub GetExperiment($)
{
    my ($self) = @_;

    return undef
	if (! ref($self));

    return Experiment->Lookup($self->slice_uuid());
}

#
# Release a ticket. Need to release the nodes ...
#
sub Release($)
{
    my ($self) = @_;

    return undef
	if (! ref($self));

    my $experiment = Experiment->Lookup($self->slice_uuid());
    my $node_id    = $self->rspec()->{'node_id'};
    my $node       = Node->Lookup($node_id);
    return -1
	if (!defined($node));
    my $reservation = Node->Reservation();
    
    if (defined($reservation) && $reservation->SameExperiment($experiment)) {
	my $pid = $experiment->pid();
	my $eid = $experiment->eid();
	
	system("$NFREE $pid $eid $node_id");
    }
    $self->Delete();
    return 0;
}

# _Always_ make sure that this 1 is at the end of the file...
1;
