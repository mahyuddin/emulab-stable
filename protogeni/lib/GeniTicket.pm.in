#!/usr/bin/perl -wT
#
# EMULAB-COPYRIGHT
# Copyright (c) 2008 University of Utah and the Flux Group.
# All rights reserved.
#
package GeniTicket;

#
# Some simple ticket stuff.
#
use strict;
use Exporter;
use vars qw(@ISA @EXPORT);

@ISA    = "Exporter";
@EXPORT = qw ( );

# Must come after package declaration!
use lib '@prefix@/lib';
use GeniDB;
use libtestbed;
use English;
use XML::Simple;
use XML::LibXML;
use Data::Dumper;
use File::Temp qw(tempfile);

# Configure variables
my $TB		   = "@prefix@";
my $TBOPS          = "@TBOPSEMAIL@";
my $TBAPPROVAL     = "@TBAPPROVALEMAIL@";
my $TBAUDIT   	   = "@TBAUDITEMAIL@";
my $BOSSNODE       = "@BOSSNODE@";
my $OURDOMAIN      = "@OURDOMAIN@";
my $GENICENTRAL    = "https://boss/protogeni/xmlrpc";
my $SIGNCRED	   = "$TB/sbin/signgenicred";

#
# Create an unsigned ticket object from the raw rspec. 
#
# Should we keep track of tickets locally in the DB?
#
sub Create($$$$;$$)
{
    my ($class, $slice_uuid, $owner_uuid,
	$rspec, $ticket_string, $component) = @_;

    my $self = {};
    $self->{'rspec'}         = $rspec;
    $self->{'slice_uuid'}    = $slice_uuid;
    $self->{'owner_uuid'}    = $owner_uuid;
    $self->{'ticket_string'} = $ticket_string;
    $self->{'ticket'}        = undef;
    $self->{'component'}     = $component;
    bless($self, $class);

    return $self;
}
# accessors
sub field($$)           { return ($_[0]->{$_[1]}); }
sub rspec($)		{ return field($_[0], "rspec"); }
sub uuid($)		{ return field($_[0], "slice_uuid"); }
sub slice_uuid($)	{ return field($_[0], "slice_uuid"); }
sub owner_uuid($)	{ return field($_[0], "owner_uuid"); }
sub ticket($)		{ return field($_[0], "ticket"); }
sub asString($)		{ return field($_[0], "ticket_string"); }
sub component($)	{ return field($_[0], "component"); }

#
# Create a ticket object from a signed ticket string.
#
sub CreateFromSignedTicket($$)
{
    my ($class, $ticket_string) = @_;

    # Use XML::Simple to convert to something we can mess with.
    my $parser = XML::LibXML->new;
    my $doc    = $parser->parse_string($ticket_string);

    # Dig out the rspec.
    my ($rspec_node) = $doc->getElementsByTagName("rspec");
    return undef
	if (!defined($rspec_node));
    my $rspec = XMLin($rspec_node->toString(), ForceArray => 0);

    # Dig out the slice uuid. Locally, I am not sure if we bother to
    # keep slices in the DB (they are in the DB at geni central).
    my ($uuid_node) = $doc->getElementsByTagName("this_uuid");
    return undef
	if (!defined($uuid_node));
    my $slice_uuid = $uuid_node->to_literal();

    if (! ($slice_uuid =~ /^\w+\-\w+\-\w+\-\w+\-\w+$/)) {
	print STDERR "Invalid slice_uuid in ticket\n";
	return undef;
    }

    # Dig out the owner uuid. Locally, I am not sure if we bother to
    # keep users in the DB (they are in the DB at geni central).
    ($uuid_node) = $doc->getElementsByTagName("owner_uuid");
    return undef
	if (!defined($uuid_node));
    my $owner_uuid = $uuid_node->to_literal();

    if (! ($owner_uuid =~ /^\w+\-\w+\-\w+\-\w+\-\w+$/)) {
	print STDERR "Invalid owner_uuid in ticket\n";
	return undef;
    }

    my $self = {};
    $self->{'rspec'}         = $rspec;
    $self->{'slice_uuid'}    = $slice_uuid;
    $self->{'owner_uuid'}    = $owner_uuid;
    $self->{'ticket_string'} = $ticket_string;
    $self->{'xmlref'}        = $doc;
    $self->{'component'}     = undef;
    bless($self, $class);

    print Dumper($self);

    return $self;
}

#
# Populate the ticket with some stuff, which right now is just the
# number of node we are willing to grant.
#
sub Grant($$)
{
    my ($self, $count) = @_;

    return 0
	if (! ref($self));

    $self->{'count'} = $count;
    return 0;
}

#
# Sign the ticket before returning it. We capture the output, which is
# in XML.
#
sub Sign($)
{
    my ($self) = @_;

    return -1
	if (!ref($self));
    
    my $slice_uuid = $self->slice_uuid();
    my $owner_uuid = $self->owner_uuid();
    my $requested  = $self->rspec()->{'requested'};
    my $granted    = $self->rspec()->{'granted'};

    #
    # Create a template xml file to sign.
    #
    my $template =
	"<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?>\n".
	"<credential xml:id=\"Ref1\">\n".
	" <type>ticket</type>\n".
	" <owner_uuid>$owner_uuid</owner_uuid>\n".
	" <this_uuid>$slice_uuid</this_uuid>\n".
	" <ticket>\n".
	"  <can_delegate>1</can_delegate>\n".
	"  <rspec>\n".
	"    <requested>$requested</requested>\n".
	"    <granted>$granted</granted>\n".
	"  </rspec>\n".
	" </ticket>\n".	
        "</credential>\n";

    my ($fh, $filename) = tempfile(UNLINK => 0);
    return -1
	if (!defined($fh));

    print $fh $template;
    close($fh);

    #
    # Fire up the signer and capture the output. This is the signed ticket
    # that is returned. 
    #
    if (! open(SIGNER, "$SIGNCRED $filename |")) {
	print STDERR "Could not sign $filename\n";
	return -1;
    }
    my $ticket = "";
    while (<SIGNER>) {
	$ticket .= $_;
    }
    close(SIGNER);
    $self->{'ticket_string'} = $ticket;

    return 0;
}

# _Always_ make sure that this 1 is at the end of the file...
1;
