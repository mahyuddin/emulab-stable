#!/usr/bin/perl -wT
#
# EMULAB-COPYRIGHT
# Copyright (c) 2008 University of Utah and the Flux Group.
# All rights reserved.
#
package GeniCMClient;

#
# The client side of the CM interface.
#

use strict;
use Exporter;
use vars qw(@ISA @EXPORT);

@ISA    = "Exporter";
@EXPORT = qw ( );

# Must come after package declaration!
use lib '@prefix@/lib';
use GeniDB;
use Genixmlrpc;
use GeniResponse;
use GeniTicket;
use GeniCredential;
use GeniSliver;
use User;
use libtestbed;
use English;
use Data::Dumper;

# Configure variables
my $TB		   = "@prefix@";
my $TBOPS          = "@TBOPSEMAIL@";
my $TBAPPROVAL     = "@TBAPPROVALEMAIL@";
my $TBAUDIT   	   = "@TBAUDITEMAIL@";
my $BOSSNODE       = "@BOSSNODE@";
my $OURDOMAIN      = "@OURDOMAIN@";
my $GENICENTRAL    = "https://myboss.little-emulab-bsd61.testbed.emulab.net/protogeni/xmlrpc";

#
# Discover resources for a slice (local experiment). This contacts Geni
# Central to get a list of components. I think the interface is supposed
# to be that we send an rspec and it sends back a list of components. But
# lets not worry about that; just get a list of all components we can ask
# for resources from.
#
sub DiscoverResources($$)
{
    my ($experiment, $pref) = @_;

    my $response =
	Genixmlrpc::CallMethodHTTP($GENICENTRAL, User->LookupByUnixId($UID),
				   "SA::DiscoverResources",
				   { "uuid"  => $experiment->uuid() });

    return -1
	if (!defined($response));

    #print Dumper($response);

    return -1
	if ($response->code() != GENIRESPONSE_SUCCESS);
    $$pref = $response->value();

    return 0;
}

#
# Ask for a ticket. We provide an rspec. Neither of these are defined yet
# so lets be simpleminded; send a count of nodes we want and get back a
# count of nodes that can be allocated. I realize there is a problem of
# those nodes getting allocated before the tickets are redeemed, but not
# going to worry about that either.
#
# $component is just a url for now.
#
sub GetTicket($$$$)
{
    my ($experiment, $component, $rspec, $pref) = @_;

    #
    # XXX 
    #
    my $this_user = User->LookupByUnixId($UID);
    if (! defined($this_user)) {
    	print STDERR "You ($UID) do not exist!\n";
	return -1;
    }

    # Need to construct a credential.
    my $credential = GeniCredential->Create($experiment->uuid(),
					    $this_user->uuid());
    if (!defined($credential)) {
	print STDERR "Could not create a slice credential for $experiment!\n";
	return -1;
    }
    if ($credential->AddCapability("createslice", 0)) {
	print STDERR "Could not add capability to slice credential!\n";
	return -1;
    }
    if ($credential->Sign()) {
	print STDERR "Could not sign slice credential!\n";
	return -1;
    }

    my $response =
	Genixmlrpc::CallMethodHTTP($component, $this_user, "CM::GetTicket",
			{ "slice_uuid"        => $experiment->uuid(),
			  "credential_string" => $credential->asString(),
			  "impotent"          => 1,
			  "rspec"             => $rspec });
    
    return -1
	if (!defined($response));

    return -1
	if ($response->code() != GENIRESPONSE_SUCCESS);

    #
    # Convert this into a (signed) ticket object.
    #
    my $ticket = GeniTicket->Create($experiment->uuid(), $this_user->uuid(),
				    $rspec, $response->value(), $component);
    
    $$pref = $ticket;
    return 0;
}

sub CreateSliver($$$)
{
    my ($experiment, $ticket, $pref) = @_;

    my $response =
	Genixmlrpc::CallMethodHTTP($ticket->component(), "CM::CreateSliver",
				   { "ticket"  => $ticket->asString() });
    
    return -1
	if (!defined($response));

    return -1
	if ($response->code() != GENIRESPONSE_SUCCESS);

    my $sliver = GeniSliver->Create($ticket, $response->value());
    if (!defined($sliver)) {
	print STDERR "Could not create local sliver object\n";
	return undef;
    }
    $$pref = $sliver;
    return 0;
}
		 
sub DestroySliver($$)
{
    my ($experiment, $sliver) = @_;
    my $ticket = $sliver->GetTicket();

    my $response =
	Genixmlrpc::CallMethodHTTP($ticket->component(),
				   "CM::DestroySliver",
				   { "uuid" => $sliver->uuid() });
    
    if ($response->code() != GENIRESPONSE_SUCCESS) {
	print STDERR "Could not destroy sliver $sliver\n";
	return -1;
    }
    $sliver->Delete() == 0
	or return -1;

    return 0;
}
		 
