#!/usr/bin/perl -w
#
# EMULAB-COPYRIGHT
# Copyright (c) 2008 University of Utah and the Flux Group.
# All rights reserved.
#
package GeniEmulab;

#
# Stuff to interface between Emulab core and Geni nodes.
#
use strict;
use Exporter;
use vars qw(@ISA @EXPORT);

@ISA    = "Exporter";
@EXPORT = qw ( );

# Must come after package declaration!
use lib '@prefix@/lib';
use GeniDB;
use Genixmlrpc;
use GeniResponse;
use GeniTicket;
use GeniCredential;
use GeniCertificate;
use GeniSlice;
use GeniSliver;
use GeniUser;
use libtestbed;
use User;
use Node;
use Interface;
use English;
use Data::Dumper;
use Experiment;

# Configure variables
my $TB		   = "@prefix@";
my $TBOPS          = "@TBOPSEMAIL@";
my $TBAPPROVAL     = "@TBAPPROVALEMAIL@";
my $TBAUDIT   	   = "@TBAUDITEMAIL@";
my $BOSSNODE       = "@BOSSNODE@";
my $OURDOMAIN      = "@OURDOMAIN@";

#
# Initialize for using geni resources.
#
sub Initialize($$$)
{
    my ($class, $experiment, $op) = @_;
    my $thisuser = User->ThisUser();

    #
    # The RPC context for this test script is mostly as an SA.
    #
    Genixmlrpc->SetContext(Genixmlrpc->Context("@prefix@/etc/genisa.pem"));

    #
    # except when it has to be as the user.
    #
    my $context = Genixmlrpc->UserContext($thisuser);

    #
    # Create a Geni user from current user doing the operation.
    #
    my $geniuser = GeniUser->CreateFromLocal($thisuser);
    if (!defined($geniuser)) {
	print STDERR
	    "Could not create a geni user from current user $thisuser\n";
	return -1;
    }
    # Register user at the ClearingHouse.
    if ($geniuser->Register() != 0) {
	print STDERR "Could not register $geniuser at the ClearingHouse.\n";
	return -1;
    }

    #
    # Create and register the slice.
    #
    my $slice = GeniSlice->LookupByExperiment($experiment);
    if (defined($slice)) {
	if ($op eq "swapin") {
	    #
	    # Remove from the clearing house.
	    #
	    print STDERR "Removing old slice for $experiment\n";
	    
	    if ($slice->UnRegister()) {
		print STDERR "Could not delete $slice from clearinghouse!\n";
		return -1;
	    }
	    if ($slice->Delete()) {
		print STDERR "Could not delete old $slice for $experiment!\n";
		return -1;
	    }
	    undef($slice);
	}
    }
    if (!defined($slice)) {
	print STDERR "Creating new slice for $experiment\n";
	
	$slice = GeniSlice->CreateFromLocal($experiment, $thisuser);
	if (!defined($slice)) {
	    print STDERR
		"Could not create a local slice record for $experiment\n";
	    return -1;
	}
	if ($slice->Register() != 0) {
	    $slice->Delete();
	    print STDERR
		"Could not register slice for $experiment at ClearingHouse.\n";
	    return -1;
	}
    }
    return 0;
}

#
# Allocate the GENI slivers for an Emulab experiment. The nodes to be created
# are passed in, otherwise lookup the nodes for the experiment.
#
# XXX Need to deal with links between nodes.
#
sub AllocateSlivers($$$)
{
    my ($class, $experiment, $nodelist) = @_;
    my $thisuser = User->ThisUser();

    #
    # The RPC context for this test script is mostly as an SA.
    #
    Genixmlrpc->SetContext(Genixmlrpc->Context("@prefix@/etc/genisa.pem"));

    #
    # except when it has to be as the user.
    #
    my $context = Genixmlrpc->UserContext($thisuser);

    #
    # Create a Geni user from current user doing the operation.
    #
    my $geniuser = GeniUser->CreateFromLocal($thisuser);
    if (!defined($geniuser)) {
	print STDERR
	    "Could not create a geni user from current user $thisuser\n";
	return -1;
    }

    #
    # The slice should already be created and registered by this point.
    #
    my $slice = GeniSlice->LookupByExperiment($experiment);
    if (!defined($slice)) {
	print STDERR "Could not find a local slice record for $experiment\n";
	return -1;
    }

    #
    # Look for a credential. Should already exist, but if not, create one
    # and store it in the DB for later.
    #
    my $credential = GeniCredential->Lookup($slice, $geniuser);
    if (!defined($credential)) {
	$credential = GeniCredential->Create($slice, $geniuser);
	if (!defined($credential)) {
	    print STDERR
		"Could not create a slice credential for $slice/$geniuser!\n";
	    return -1;
	}
	if ($credential->Sign($GeniCredential::LOCALSA_FLAG) != 0) {
	    print STDERR "Could not sign slice credential $credential!\n";
	    return -1;
	}
	if ($credential->Store() != 0) {
	    print STDERR "Could not store slice credential $credential!\n";
	    return -1;
	}
    }

    #
    # Loop through each node and grab a ticket for it. The nodes table
    # stores the uuid of the node as told to us in resource discovery.
    # Use this to create a simple rspec. This will need to get fancier
    # later.
    #
    # XXX We are still not using rspecs anywhere.
    #
    foreach my $node (@{ $nodelist }) {
	my $sliver_idx;
	return -1
	    if ($node->GetGeniSliverInfo(\$sliver_idx) != 0);
	next
	    if ($sliver_idx);

	#
	# The node is a virtnode, but we want a ticket for the physnode.
	#
	my $physnode = Node->Lookup($node->phys_nodeid());
	return -1
	    if (!defined($physnode));
	
	my $node_uuid = $physnode->uuid();

	my $rspec =
	    "<rspec xmlns=\"http://protogeni.net/resources/rspec/0.1\"> " .
	    " <node uuid=\"$node_uuid\" ".
	    "       virtualization_type=\"emulab-vnode\"> " .
	    " </node>" .
	    "</rspec>";
	
	#
	# XXX The component is stored in the geni_resources table. Not sure
	# how that will work out.
	#
	my $component = GeniComponent->LookupByResource($node_uuid);
	if (!defined($component)) {
	    print STDERR "Could not find CM for $node\n";
	    return -1;
	}

        #
        # Get ticket from component.
        #
	print STDERR "Asking for ticket for $node from $component.\n";
	
	my $ticket = $component->GetTicket($slice, $rspec,
					   $context, $credential);
	
	if (!defined($ticket)) {
	    print STDERR "Could not get ticket from CM for $node\n";
	    return -1;
	}

	#
	# Must store the ticket since the sliver will not be created
	# (ticket redeemed) until later.
	#
	if ($ticket->Store() != 0) {
	    $ticket->Delete();
	    print STDERR "Could not store $ticket on $component for $node\n";
	    return -1;

	}
	#
	# Bogus; store the ticket into the sliver index of the node. I
	# need to store it someplace until the ticket is redeemed.
	# Generally though, there might not be a ticket per node,
	# since an rspec can have multiple resources (nodes, links),
	# and I have not figured out what to do for that yet. 
	#
	if ($node->SetGeniSliverInfo($ticket->idx()) != 0) {
	    print STDERR "Could not set sliver (ticket) idx for $node\n";
	    if ($ticket->Delete() != 0) {
		print STDERR "Could not destroy $ticket\n";
	    }
	    return -1;
	}
    }

    return 0;
}

#
# Instantiate the slivers (from tickets)
#
sub InstantiateSlivers($$$)
{
    my ($class, $experiment, $nodelist) = @_;
    my $thisuser = User->ThisUser();

    #
    # The RPC context for this test script is mostly as an SA.
    #
    Genixmlrpc->SetContext(Genixmlrpc->Context("@prefix@/etc/genisa.pem"));

    #
    # except when it has to be as the user.
    #
    my $context = Genixmlrpc->UserContext($thisuser);

    my $slice = GeniSlice->LookupByExperiment($experiment);
    if (!defined($slice)) {
	print STDERR "No slice exists for $experiment. \n";
	return -1;
    }

    #
    # Loop through each node and grab a ticket for it. The nodes table
    # stores the uuid of the node as told to us in resource discovery.
    # Use this to create a simple rspec. This will need to get fancier
    # later.
    #
    # XXX We are still not using rspecs anywhere.
    #
    foreach my $node (@{ $nodelist }) {
	my $sliver_idx;
	return -1
	    if ($node->GetGeniSliverInfo(\$sliver_idx) != 0);
	next
	    if (! $sliver_idx);

	my $sliver     = GeniSliver->Lookup($sliver_idx);
	next
	    if (defined($sliver));

	# See if its still a ticket.
	my $ticket = GeniTicket->Lookup($sliver_idx);
	if (!defined($ticket)) {
	    print STDERR "Could not find ticket for $node in $experiment\n";
	    return -1;
	}
	my $component = $ticket->component();

	#
	# We need to pass in some extra stuff for Emulab federation.
	#
	my $args = {'tmcd_server'  => $BOSSNODE,
		    'tmcd_nodeid'  => $node->node_id() };

        #
        # Create sliver on component using the ticket.
        #
	print STDERR "Redeeming ticket for $node on $component.\n";
	
	$sliver = $component->CreateSliver($slice, $ticket, $context, $args);
	if (!defined($sliver)) {
	    print STDERR "Could not create sliver on $component for $node\n";
	    if ($ticket->Delete() != 0) {
		print STDERR "Could not delete $ticket\n";
	    }
	    if ($node->SetGeniSliverInfo(0) != 0) {
		print STDERR "Could not clear sliver idx for $node\n";
	    }
	    return -1;
	}
	if ($node->SetGeniSliverInfo($sliver->idx()) != 0) {
	    print STDERR "Could not set sliver idx for $node\n";
	    if ($ticket->Delete() != 0) {
		print STDERR "Could not delete $ticket\n";
	    }
	    if ($sliver->Destroy() != 0) {
		print STDERR "Could not destroy $sliver\n";
	    }
	    return -1;
	}
	# No longer need the ticket.
	if ($ticket->Delete() != 0) {
	    print STDERR "Could not delete $ticket\n";
	}
    }
    return 0;
}

#
# Start the slivers.
#
sub StartSlivers($$$)
{
    my ($class, $experiment, $nodelist) = @_;
    my $thisuser = User->ThisUser();

    #
    # The RPC context for this test script is mostly as an SA.
    #
    Genixmlrpc->SetContext(Genixmlrpc->Context("@prefix@/etc/genisa.pem"));

    #
    # except when it has to be as the user.
    #
    my $context = Genixmlrpc->UserContext($thisuser);

    my $slice = GeniSlice->LookupByExperiment($experiment);
    if (!defined($slice)) {
	print STDERR "No slice exists for $experiment. \n";
	return -1;
    }

    foreach my $node (@{ $nodelist }) {
	my $sliver_idx;
	return -1
	    if ($node->GetGeniSliverInfo(\$sliver_idx) != 0);
	next
	    if (! $sliver_idx);

	my $sliver = GeniSliver->Lookup($sliver_idx);
	if (!defined($sliver)) {
	    print STDERR "Could not find sliver for $node in $experiment\n";
	    return -1;
	}
	my $component = $sliver->GetComponent();

        #
        # Start sliver on component using the ticket.
        #
	print STDERR "Starting $sliver on $component.\n";
	
	if ($component->StartSliver($sliver, $context) != 0) {
	    print STDERR "Could not start $sliver on $component for $node\n";
	    return -1;
	}
    }
    return 0;
}

#
# XXX Need to deal with links between nodes.
#
sub DestroySlivers($$$)
{
    my ($class, $experiment, $nodelist) = @_;
    my $thisuser = User->ThisUser();
    my $errors   = 0;

    #
    # The RPC context for this test script is mostly as an SA.
    #
    Genixmlrpc->SetContext(Genixmlrpc->Context("@prefix@/etc/genisa.pem"));

    #
    # except when it has to be as the user.
    #
    my $context = Genixmlrpc->UserContext($thisuser);

    my $slice = GeniSlice->LookupByExperiment($experiment);
    if (!defined($slice)) {
	print STDERR "No local slice record for $experiment\n";
	return -1;
    }

    #
    # Loop through each node and do the sliver thing.
    #
    # XXX We are still not using rspecs anywhere.
    #
    foreach my $node (@{ $nodelist }) {
	my $sliver_idx;
	return -1
	    if ($node->GetGeniSliverInfo(\$sliver_idx) != 0);
	next
	    if (! $sliver_idx);

	my $sliver = GeniSliver->Lookup($sliver_idx);
	if (!defined($sliver)) {
	    # See if its still a ticket.	
	    my $ticket = GeniTicket->Lookup($sliver_idx);
	    if (!defined($ticket)) {
		print STDERR
		    "Could not find ticket for $node in $experiment\n";
		$errors++;
	    }
	    else {
		my $component = $ticket->component();

		#
		# Release the ticket.
		#
		print STDERR "Releasing $ticket for $node on $component.\n";
		
		if ($component->ReleaseTicket($slice, $context, $ticket) != 0){
		    print STDERR "Could not release $ticket on $component\n";
		    $errors++;
		}
		if ($ticket->Delete() != 0) {
		    print STDERR "Could not delete $ticket\n";
		    $errors++;
		}
	    }
	    next;
	}
	print STDERR "Releasing $sliver for $node.\n";
	
	if ($sliver->Destroy() != 0) {
	    print STDERR "Could not destroy $sliver for $node\n";
	    $errors++;
	    next;
	}
	if ($node->SetGeniSliverInfo(0) != 0) {
	    print STDERR "Could not clear sliver idx for $node\n";
	    $errors++;
	    next;
	}
    }

    return $errors;
}


# _Always_ make sure that this 1 is at the end of the file...
1;

