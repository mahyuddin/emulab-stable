#!/usr/bin/perl -w
#
# EMULAB-COPYRIGHT
# Copyright (c) 2008 University of Utah and the Flux Group.
# All rights reserved.
#
package GeniEmulab;

#
# Stuff to interface between Emulab core and Geni nodes.
#
use strict;
use Exporter;
use vars qw(@ISA @EXPORT);

@ISA    = "Exporter";
@EXPORT = qw ( );

# Must come after package declaration!
use lib '@prefix@/lib';
use GeniDB;
use Genixmlrpc;
use GeniResponse;
use GeniTicket;
use GeniCredential;
use GeniCertificate;
use GeniSlice;
use GeniSliver;
use GeniUser;
use libtestbed;
use User;
use Node;
use Interface;
use Lan;
use English;
use Data::Dumper;
use Experiment;

# Configure variables
my $TB		   = "@prefix@";
my $TBOPS          = "@TBOPSEMAIL@";
my $TBAPPROVAL     = "@TBAPPROVALEMAIL@";
my $TBAUDIT   	   = "@TBAUDITEMAIL@";
my $BOSSNODE       = "@BOSSNODE@";
my $OURDOMAIN      = "@OURDOMAIN@";

#
# Initialize for using geni resources.
#
sub Initialize($$$)
{
    my ($class, $experiment, $op) = @_;
    my $thisuser = User->ThisUser();

    #
    # The RPC context for this test script is mostly as an SA.
    #
    Genixmlrpc->SetContext(Genixmlrpc->Context("@prefix@/etc/genisa.pem"));

    #
    # except when it has to be as the user.
    #
    my $context = Genixmlrpc->UserContext($thisuser);

    #
    # Create a Geni user from current user doing the operation.
    #
    my $geniuser = GeniUser->CreateFromLocal($thisuser);
    if (!defined($geniuser)) {
	print STDERR
	    "Could not create a geni user from current user $thisuser\n";
	return -1;
    }
    # Register user at the ClearingHouse.
    if ($geniuser->Register() != 0) {
	print STDERR "Could not register $geniuser at the ClearingHouse.\n";
	return -1;
    }

    #
    # Create and register the slice.
    #
    my $slice = GeniSlice->LookupByExperiment($experiment);
    if (defined($slice)) {
	if ($op eq "swapin") {
	    #
	    # Remove from the clearing house.
	    #
	    print STDERR "Removing old slice for $experiment\n";
	    
	    if ($slice->UnRegister()) {
		print STDERR "Could not delete $slice from clearinghouse!\n";
		return -1;
	    }
	    if ($slice->Delete()) {
		print STDERR "Could not delete old $slice for $experiment!\n";
		return -1;
	    }
	    undef($slice);
	}
    }
    if (!defined($slice)) {
	print STDERR "Creating new slice for $experiment\n";
	
	$slice = GeniSlice->CreateFromLocal($experiment, $thisuser);
	if (!defined($slice)) {
	    print STDERR
		"Could not create a local slice record for $experiment\n";
	    return -1;
	}
	if ($slice->Register() != 0) {
	    $slice->Delete();
	    print STDERR
		"Could not register slice for $experiment at ClearingHouse.\n";
	    return -1;
	}
    }
    return 0;
}

#
# Allocate the GENI slivers for an Emulab experiment. The nodes to be created
# are passed in, otherwise lookup the nodes for the experiment.
#
# XXX Need to deal with links between nodes.
#
sub AllocateSlivers($$$)
{
    my ($class, $experiment, $nodelist) = @_;
    my $thisuser = User->ThisUser();

    #
    # The RPC context for this test script is mostly as an SA.
    #
    Genixmlrpc->SetContext(Genixmlrpc->Context("@prefix@/etc/genisa.pem"));

    #
    # except when it has to be as the user.
    #
    my $context = Genixmlrpc->UserContext($thisuser);

    #
    # Create a Geni user from current user doing the operation.
    #
    my $geniuser = GeniUser->CreateFromLocal($thisuser);
    if (!defined($geniuser)) {
	print STDERR
	    "Could not create a geni user from current user $thisuser\n";
	return -1;
    }

    #
    # The slice should already be created and registered by this point.
    #
    my $slice = GeniSlice->LookupByExperiment($experiment);
    if (!defined($slice)) {
	print STDERR "Could not find a local slice record for $experiment\n";
	return -1;
    }

    #
    # Look for a credential. Should already exist, but if not, create one
    # and store it in the DB for later.
    #
    my $credential = GeniCredential->Lookup($slice, $geniuser);
    if (!defined($credential)) {
	$credential = GeniCredential->Create($slice, $geniuser);
	if (!defined($credential)) {
	    print STDERR
		"Could not create a slice credential for $slice/$geniuser!\n";
	    return -1;
	}
	if ($credential->Sign($GeniCredential::LOCALSA_FLAG) != 0) {
	    print STDERR "Could not sign slice credential $credential!\n";
	    return -1;
	}
	if ($credential->Store() != 0) {
	    print STDERR "Could not store slice credential $credential!\n";
	    return -1;
	}
    }

    #
    # Loop through nodes, combining nodes at the same component into a
    # list for that component.
    #
    # Bookkeeping for the rest of this function.
    my %components      = ();
    my %component_nodes = ();
    my %node_component  = ();
    my %pnode_component  = ();
    
    foreach my $node (@{ $nodelist }) {
	#
	# The node is a virtnode, but we want a ticket for the physnode.
	#
	my $pnode = Node->Lookup($node->phys_nodeid());
	return -1
	    if (!defined($pnode));
	
	my $node_uuid = $pnode->uuid();

	#
	# XXX The component is stored in the geni_resources table. Not sure
	# how that will work out.
	#
	my $component = GeniComponent->LookupByResource($node_uuid);
	if (!defined($component)) {
	    print STDERR "Could not find CM for $node\n";
	    return -1;
	}
	$component_nodes{$component->uuid()} = []
	    if (!exists($component_nodes{$component->uuid()}));
	push(@{ $component_nodes{$component->uuid()} }, $node);
	$node_component{$node->node_id()}   = $component;
	$pnode_component{$pnode->node_id()} = $component;
	$components{$component->uuid()}     = $component;
    }

    #
    # Now find links and lans between nodes, which of course must be at
    # the same components since we talking about real vlans, not tunnels. 
    #
    my %component_lans = ();
    my @lans;

    if (Lan->ExperimentLans($experiment, \@lans) != 0) {
	print STDERR "Could not get lans for $experiment\n";
	return -1;
    }
    foreach my $lan (@lans) {
	next
	    if ($lan->type() ne "geni-vlan");

	my @members;

	if ($lan->MemberList(\@members) != 0) {
	    print STDERR "Could not get members for $lan\n";
	    return -1;
	}

	#
	# Sanity check; all the nodes in the list must reside on the same
	# component.
	#
	my $component;
	foreach my $member (@members) {
	    my $node;
	    my $iface;

	    if ($member->GetNodeIface(\$node, \$iface) != 0) {
		print STDERR "Could not get node/iface for $member\n";
		return -1;
	    }
	    my $tmp = $pnode_component{$node->node_id()};

	    $component = $tmp
		if (!defined($component));

	    if (!$component->SameComponent($tmp)) {
		print STDERR "Component mismatch in members of $lan\n";
		return -1;
	    }
	}
	$component_lans{$component->uuid()} = []
	    if (!exists($component_lans{$component->uuid()}));
	push(@{ $component_lans{$component->uuid()} }, $lan);
	$lan->SetAttribute("geni-component", $component->uuid(), "string");
    }

    #
    # Now build up rspecs for each component. 
    #
    my %component_rspecs = ();

    foreach my $component_uuid (keys(%component_nodes)) {
	my @nodelist  = @{ $component_nodes{$component_uuid} };
	my $component = $components{$component_uuid};
	my $rspec     =
	    "<rspec xmlns=\"http://protogeni.net/resources/rspec/0.1\"> ";
	
	foreach my $node (@nodelist) {
	    #
	    # The node is a virtnode, but we want a ticket for the physnode.
	    #
	    my $physnode = Node->Lookup($node->phys_nodeid());
	    return -1
		if (!defined($physnode));
	    my $node_uuid = $physnode->uuid();
	    my $node_id   = $node->node_id();

	    #
	    # We need to pass in some extra stuff for Emulab federation
	    # (tmcd redirection).
	    #
	    $rspec .= " <node uuid=\"$node_uuid\" ".
		      "       tmcd_server=\"$BOSSNODE\" ".
		      "       tmcd_nodeid=\"$node_id\" ".
		      "       hrn=\"$node_id\" ".
		      "       virtualization_type=\"emulab-vnode\"> " .
		      " </node>";
	}
	if (exists($component_lans{$component_uuid})) {
	    my @lans = @{ $component_lans{$component_uuid} };

	    foreach my $lan (@lans) {
		my $name = $lan->vname();
		my @members;

		if ($lan->MemberList(\@members) != 0) {
		    print STDERR "Could not get members for $lan\n";
		    return -1;
		}
		$rspec .= "<link name=\"$name\" link_name=\"$name\"> ";

		foreach my $member (@members) {
		    my $node;
		    my $iface;

		    if ($member->GetNodeIface(\$node, \$iface) != 0) {
			print STDERR "Could not get node/iface for $member\n";
			return -1;
		    }
		    #
		    # The node is a virtnode, but we want the physnode.
		    #
		    my $physnode = Node->Lookup($node->phys_nodeid());
		    return -1
			if (!defined($physnode));
		    my $pnode_uuid = $physnode->uuid();
		    my $name = $node->node_id() . ":" . $iface;

		    $rspec .= "<LinkEndPoints name=\"$name\" " .
			"            iface_name=\"$iface\" " .
			"            node_uuid=\"$pnode_uuid\" /> ";
		}
		$rspec .= "</link>";
	    }
	}
	$rspec .= "</rspec>";
	print "$rspec\n";
	$component_rspecs{$component_uuid} = $rspec;
    }
    
    #
    # Now submit each rspec to its component.
    #
    my %component_tickets = ();
    
    foreach my $component_uuid (keys(%component_nodes)) {
	my @nodelist  = @{ $component_nodes{$component_uuid} };
	my $component = $components{$component_uuid};
	my $rspec     = $component_rspecs{$component_uuid};

        #
        # Get ticket from component.
        #
	print STDERR "Asking for ticket from $component.\n";
	
	my $ticket = $component->GetTicket($slice, $rspec,
					   $context, $credential);
	
	if (!defined($ticket)) {
	    print STDERR "Could not get ticket from $component\n";
	    return -1;
	}

	#
	# Must store the ticket since the sliver will not be created
	# (ticket redeemed) until later.
	#
	if ($ticket->Store() != 0) {
	    $ticket->Delete();
	    print STDERR "Could not store $ticket for $component\n";
	    return -1;

	}
	#
	# Bogus; store the ticket into the sliver index of the node. I
	# need to store it someplace until the ticket is redeemed.
	# Generally though, there might not be a ticket per node,
	# since an rspec can have multiple resources (nodes, links),
	# and I have not figured out what to do for that yet. 
	#
	foreach my $node (@nodelist) {
	    if ($node->SetGeniSliverInfo($ticket->idx()) != 0) {
		print STDERR "Could not set sliver/ticket idx for $node\n";
		if ($ticket->Delete() != 0) {
		    print STDERR "Could not destroy $ticket\n";
		}
		return -1;
	    }
	}
    }

    return 0;
}

#
# Instantiate the slivers (from tickets)
#
sub InstantiateSlivers($$$)
{
    my ($class, $experiment, $nodelist) = @_;
    my $thisuser = User->ThisUser();

    #
    # The RPC context for this test script is mostly as an SA.
    #
    Genixmlrpc->SetContext(Genixmlrpc->Context("@prefix@/etc/genisa.pem"));

    #
    # except when it has to be as the user.
    #
    my $context = Genixmlrpc->UserContext($thisuser);

    my $slice = GeniSlice->LookupByExperiment($experiment);
    if (!defined($slice)) {
	print STDERR "No slice exists for $experiment. \n";
	return -1;
    }

    my @lans;
    if (Lan->ExperimentLans($experiment, \@lans) != 0) {
	print STDERR "Could not get lans for $experiment\n";
	return -1;
    }

    #
    # Loop through nodes, combining nodes at the same component into a
    # list for that component.
    #
    # Bookkeeping for the rest of this function.
    my %components        = ();
    my %component_nodes   = ();
    my %component_lans    = ();
    my %component_tickets = ();
    my %node_component    = ();
    my %node_slivers      = ();
    my %lan_slivers       = ();
    my %pnodes            = ();

    foreach my $node (@{ $nodelist }) {
	my $ticket_idx;
	return -1
	    if ($node->GetGeniSliverInfo(\$ticket_idx) != 0);
	next
	    if (! $ticket_idx);

	my $physnode = Node->Lookup($node->phys_nodeid());
	if (!defined($physnode)) {
	    print STDERR "Could not get pnode object for $node\n";
	    return -1;
	}
	$pnodes{$node->uuid()} = $physnode;
	
	my $ticket = GeniTicket->Lookup($ticket_idx);
	if (!defined($ticket)) {
	    print STDERR "Could not find ticket for $node in $experiment\n";
	    return -1;
	}
	my $component = $ticket->component();

	$component_nodes{$component->uuid()} = []
	    if (!exists($component_nodes{$component->uuid()}));
	push(@{ $component_nodes{$component->uuid()} }, $node);
	$node_component{$node->node_id()}      = $component;
	$components{$component->uuid()}        = $component;

	# Sanity check.
	if (!exists($component_tickets{$component->uuid()})) {
	    $component_tickets{$component->uuid()} = $ticket;
	}
	elsif (!$ticket->SameTicket($component_tickets{$component->uuid()})) {
	    print STDERR "Ticket mismatch for $component\n";
	    return -1;
	}
    }
    foreach my $lan (@lans) {
	next
	    if ($lan->type() ne "geni-vlan");

	my $component_uuid;
	if ($lan->GetAttribute("geni-component", \$component_uuid) != 0) {
	    print STDERR "Could not find geni-component attribute in $lan\n";
	    return -1;
	}
	$component_lans{$component_uuid} = []
	    if (!exists($component_lans{$component_uuid}));
	push(@{ $component_lans{$component_uuid} }, $lan);
    }

    #
    # For each component, submit the ticket associated with the list of
    # nodes on that component.
    #
    foreach my $component_uuid (keys(%component_tickets)) {
	my @nodelist  = @{ $component_nodes{$component_uuid} };
	my @lanlist   = @{ $component_lans{$component_uuid} };
	my $component = $components{$component_uuid};
	my $ticket    = $component_tickets{$component_uuid};
	my @slivers   = ();

        #
        # Create sliver on component using the ticket.
        #
	print STDERR "Redeeming ticket on $component.\n";
	
	my $sliver =
	    $component->CreateSliver($slice, $ticket, $context);

	# No longer need the ticket.
	if ($ticket->Delete() != 0) {
	    print STDERR "Could not delete $ticket\n";
	}
	if (!defined($sliver)) {
	    print STDERR "Could not create sliver on $component\n";
	    return -1;
	}

	#
	# If the sliver corresponds to multiple nodes, then we want to
	# split it apart so that we have a credential for each node.
	#
	if (@nodelist > 1) {
	    if ($component->SplitSliver($sliver, $context, \@slivers) != 0) {
		print STDERR "Could not split $sliver on $component\n";
		goto bad;
	    }
	    foreach my $node (@nodelist) {
		my $physnode = $pnodes{$node->uuid()};
		my $node_sliver;
		foreach my $s (@slivers) {
		    #
		    # XXX Bogus use of hrn, but I am assuming the only
		    # time this happens is when speaking to another Emulab
		    # which will be doing the same thing.
		    #
		    if ($s->hrn() eq $node->node_id()) {
			$node_sliver = $s;
			last;
		    }
		}
		if (!defined($node_sliver)) {
		    print STDERR "Could not get sliver for $node in $sliver\n";
		    goto bad;
		}
		$node_slivers{$node->uuid()} = $node_sliver;
	    }
	    foreach my $lan (@lanlist) {
		next
		    if ($lan->type() ne "geni-vlan");

		my $lan_sliver;
		foreach my $s (@slivers) {
		    #
		    # XXX Bogus use of hrn, but I am assuming the only
		    # time this happens is when speaking to another Emulab
		    # which will be doing the same thing.
		    #
		    if ($s->hrn() eq $lan->vname()) {
			$lan_sliver = $s;
			last;
		    }
		}
		if (!defined($lan_sliver)) {
		    print STDERR "Could not get sliver for $lan in $sliver\n";
		    goto bad;
		}
		$lan_slivers{$lan->vname()} = $lan_sliver;
	    }
	}
	else {
	    # For loop below.
	    $node_slivers{$nodelist[0]->uuid()} = $sliver;
	}

	foreach my $node (@nodelist) {
	    my $s = $node_slivers{$node->uuid()};
	    
	    if ($node->SetGeniSliverInfo($s->idx()) != 0) {
		print STDERR "Could not set sliver idx for $node\n";
		goto bad;
	    }
	}
	foreach my $lan (@lanlist) {
	    my $s = $lan_slivers{$lan->vname()};
	    
	    if ($lan->SetAttribute("geni-sliver", $s->idx(), "integer") != 0) {
		print STDERR "Could not set sliver idx for $lan\n";
		goto bad;
	    }
	}
	next;
	
      bad:
	foreach my $s (@slivers) {
	    $s->Delete();
	}
	if (defined($sliver) && $sliver->Destroy($context) != 0) {
	    print STDERR "Could not destroy $sliver\n";
	}
	return -1;
    }
    return 0;
}

#
# Start the slivers.
#
sub StartSlivers($$$)
{
    my ($class, $experiment, $nodelist) = @_;
    my $thisuser = User->ThisUser();

    #
    # The RPC context for this test script is mostly as an SA.
    #
    Genixmlrpc->SetContext(Genixmlrpc->Context("@prefix@/etc/genisa.pem"));

    #
    # except when it has to be as the user.
    #
    my $context = Genixmlrpc->UserContext($thisuser);

    my $slice = GeniSlice->LookupByExperiment($experiment);
    if (!defined($slice)) {
	print STDERR "No slice exists for $experiment. \n";
	return -1;
    }

    foreach my $node (@{ $nodelist }) {
	my $sliver_idx;
	return -1
	    if ($node->GetGeniSliverInfo(\$sliver_idx) != 0);
	next
	    if (! $sliver_idx);

	my $sliver = GeniSliver->Lookup($sliver_idx);
	if (!defined($sliver)) {
	    print STDERR "Could not find sliver for $node in $experiment\n";
	    return -1;
	}
	my $component = $sliver->GetComponent();

        #
        # Start sliver on component using the ticket.
        #
	print STDERR "Starting $sliver on $component.\n";
	
	if ($component->StartSliver($sliver, $context) != 0) {
	    print STDERR "Could not start $sliver on $component for $node\n";
	    return -1;
	}
    }
    return 0;
}

#
# XXX Need to deal with links between nodes.
#
sub DestroySlivers($$$)
{
    my ($class, $experiment, $nodelist) = @_;
    my $thisuser = User->ThisUser();
    my $errors   = 0;

    #
    # The RPC context for this test script is mostly as an SA.
    #
    Genixmlrpc->SetContext(Genixmlrpc->Context("@prefix@/etc/genisa.pem"));

    #
    # except when it has to be as the user.
    #
    my $context = Genixmlrpc->UserContext($thisuser);

    my $slice = GeniSlice->LookupByExperiment($experiment);
    if (!defined($slice)) {
	print STDERR "No local slice record for $experiment\n";
	return -1;
    }

    #
    # Loop through each node and do the sliver thing.
    #
    foreach my $node (@{ $nodelist }) {
	my $sliver_idx;
	return -1
	    if ($node->GetGeniSliverInfo(\$sliver_idx) != 0);
	next
	    if (! $sliver_idx);

	my $sliver = GeniSliver->Lookup($sliver_idx);
	if (!defined($sliver)) {
	    # See if its still a ticket.	
	    my $ticket = GeniTicket->Lookup($sliver_idx);
	    if (!defined($ticket)) {
		print STDERR
		    "Could not find ticket for $node in $experiment\n";
		$errors++;
	    }
	    else {
		my $component = $ticket->component();

		#
		# Release the ticket.
		#
		print STDERR "Releasing $ticket for $node on $component.\n";
		
		if ($component->ReleaseTicket($slice, $context, $ticket) != 0){
		    print STDERR "Could not release $ticket on $component\n";
		    $errors++;
		}
		if ($ticket->Delete() != 0) {
		    print STDERR "Could not delete $ticket\n";
		    $errors++;
		}
	    }
	    next;
	}
	print STDERR "Releasing $sliver for $node.\n";
	
	if ($sliver->Destroy($context) != 0) {
	    print STDERR "Could not destroy $sliver for $node\n";
	    $errors++;
	    next;
	}
	if ($node->SetGeniSliverInfo(0) != 0) {
	    print STDERR "Could not clear sliver idx for $node\n";
	    $errors++;
	    next;
	}
    }

    return $errors;
}

#
# Teardown links.
#
sub DestroyLinks($$)
{
    my ($class, $experiment) = @_;
    my $thisuser = User->ThisUser();
    my $errors   = 0;

    #
    # The RPC context for this test script is mostly as an SA.
    #
    Genixmlrpc->SetContext(Genixmlrpc->Context("@prefix@/etc/genisa.pem"));

    #
    # except when it has to be as the user.
    #
    my $context = Genixmlrpc->UserContext($thisuser);

    my $slice = GeniSlice->LookupByExperiment($experiment);
    if (!defined($slice)) {
	print STDERR "No local slice record for $experiment\n";
	return -1;
    }

    #
    # Lookup all geni-vlans and get the sliver idx from the lan attributes
    # table. Then kill them.
    #
    my @lans;
    if (Lan->ExperimentLans($experiment, \@lans) != 0) {
	print STDERR "Could not get lans for $experiment\n";
	return -1;
    }
    return 0
	if (! @lans);

    foreach my $lan (@lans) {
	next
	    if ($lan->type() ne "geni-vlan");

	my $sliver_idx;

	if ($lan->GetAttribute("geni-sliver", \$sliver_idx) != 0) {
	    print STDERR "Could not get sliver idx for $lan\n";
	    $errors++;
	    next;
	}
	if (!defined($sliver_idx) || $sliver_idx == 0) {
	    print STDERR "Sliver idx is not defined for $lan\n";
	    $errors++;
	    next;
	}

	my $sliver = GeniSliver->Lookup($sliver_idx);
	if (!defined($sliver)) {
	    print STDERR "Could not find sliver for $lan in $experiment\n";
	    $errors++;
	    next;
	}
	print STDERR "Releasing $sliver for $lan\n";
	
	if ($sliver->Destroy($context) != 0) {
	    print STDERR "Could not destroy $sliver for $lan\n";
	    $errors++;
	    next;
	}
    }
    return $errors;
}


# _Always_ make sure that this 1 is at the end of the file...
1;

