#!/usr/bin/perl -wT
#
# EMULAB-COPYRIGHT
# Copyright (c) 2008 University of Utah and the Flux Group.
# All rights reserved.
#
package GeniCredential;

#
# Some simple credential stuff.
#
use strict;
use Exporter;
use vars qw(@ISA @EXPORT);

@ISA    = "Exporter";
@EXPORT = qw ( );

# Must come after package declaration!
use lib '@prefix@/lib';
use GeniDB;
use libtestbed;
use Experiment;
use libdb qw(TBGetUniqueIndex);
use English;
use XML::Simple;
use XML::LibXML;
use Data::Dumper;
use File::Temp qw(tempfile);

# Exported variables
use vars qw(@EXPORT_OK $LOCALSA_FLAG $LOCALCM_FLAG);

# Configure variables
my $TB		   = "@prefix@";
my $TBOPS          = "@TBOPSEMAIL@";
my $TBAPPROVAL     = "@TBAPPROVALEMAIL@";
my $TBAUDIT   	   = "@TBAUDITEMAIL@";
my $BOSSNODE       = "@BOSSNODE@";
my $OURDOMAIN      = "@OURDOMAIN@";
my $SIGNCRED	   = "$TB/sbin/signgenicred";
my $VERIFYCRED	   = "$TB/sbin/verifygenicred";
my $NFREE	   = "$TB/bin/nfree";
my $OPENSSL	   = "/usr/bin/openssl";

# Signing flags
$LOCALSA_FLAG	   = 1;
$LOCALCM_FLAG	   = 2;
@EXPORT_OK	   = qw(LOCALSA_FLAG LOCALCM_FLAG);

#
# Create an empty credential object.
#
sub Create($$$$)
{
    my ($class, $this, $owner) = @_;

    return undef
	if (! (ref($this) && ref($owner)));

    my $self = {};
    $self->{'this'}          = $this;
    $self->{'owner'}         = $owner;
    $self->{'this_uuid'}     = $this->uuid();
    $self->{'owner_uuid'}    = $owner->uuid();
    $self->{'this_cert'}     = $this->cert();
    $self->{'owner_cert'}    = $owner->cert();
    $self->{'string'}        = undef;
    $self->{'capabilities'}  = undef;
    $self->{'idx'}	     = undef;	# Only set when stored to DB.
    bless($self, $class);

    return $self;
}
# accessors
sub field($$)           { return ($_[0]->{$_[1]}); }
sub idx($)		{ return field($_[0], "idx"); }
sub this($)		{ return field($_[0], "this"); }
sub owner($)		{ return field($_[0], "owner"); }
sub this_uuid($)	{ return field($_[0], "this_uuid"); }
sub owner_uuid($)	{ return field($_[0], "owner_uuid"); }
sub this_cert($)	{ return field($_[0], "this_cert"); }
sub owner_cert($)	{ return field($_[0], "owner_cert"); }
sub asString($)		{ return field($_[0], "string"); }
sub capabilities($)	{ return field($_[0], "capabilities"); }

#
# Add a capability to the array.
#
sub AddCapability($$$)
{
    my ($self, $name, $delegate) = @_;

    return -1
	if (!ref($self));

    if (!defined($self->capabilities())) {
	$self->{'capabilities'} = {};
    }
    $self->{'capabilities'}->{$name} = {"can_delegate" => $delegate};
    return 0;
}

#
# Create a credential object from a signed credential string.
#
sub CreateFromSigned($$)
{
    my ($class, $string) = @_;

    # First verify the credential
    my ($fh, $filename) = tempfile(UNLINK => 0);
    return undef
	if (!defined($fh));
    print $fh $string;
    close($fh);
    system("$VERIFYCRED $filename");
    if ($?) {
	print STDERR "Credential in $filename did not verify\n";
	return undef;
    }
    unlink($filename);

    # Use XML::Simple to convert to something we can mess with.
    my $parser = XML::LibXML->new;
    my $doc    = $parser->parse_string($string);

    # Dig out the capabilities
    my ($cap_node) = $doc->getElementsByTagName("capabilities");
    return undef
	if (!defined($cap_node));
    my $capabilities = XMLin($cap_node->toString(), ForceArray => 0);

    # Dig out the slice uuid. Locally, I am not sure if we bother to
    # keep slices in the DB (they are in the DB at geni central).
    my ($uuid_node) = $doc->getElementsByTagName("this_uuid");
    return undef
	if (!defined($uuid_node));
    my $this_cert = $uuid_node->to_literal();
    my $this_uuid;
    GeniCredential->CertificateInfo($this_cert, \$this_uuid) == 0
	or return undef;

    if (! ($this_uuid =~ /^\w+\-\w+\-\w+\-\w+\-\w+$/)) {
	print STDERR "Invalid this_uuid in credential\n";
	return undef;
    }

    # Dig out the owner uuid. Locally, I am not sure if we bother to
    # keep users in the DB (they are in the DB at geni central).
    ($uuid_node) = $doc->getElementsByTagName("owner_uuid");
    return undef
	if (!defined($uuid_node));
    my $owner_cert = $uuid_node->to_literal();
    my $owner_uuid;
    GeniCredential->CertificateInfo($owner_cert, \$owner_uuid) == 0
	or return undef;

    if (! ($owner_uuid =~ /^\w+\-\w+\-\w+\-\w+\-\w+$/)) {
	print STDERR "Invalid owner_uuid in credential\n";
	return undef;
    }

    my $self = {};
    $self->{'capabilities'}  = $capabilities;
    $self->{'this_uuid'}     = $this_uuid;
    $self->{'owner_uuid'}    = $owner_uuid;
    $self->{'this_cert'}     = $this_cert;
    $self->{'owner_cert'}    = $owner_cert;
    $self->{'string'}        = $string;
    $self->{'xmlref'}        = $doc;
    $self->{'idx'}	     = undef;	# Only set when stored to DB.
    bless($self, $class);

    return $self;
}

#
# Might have to delete this from the DB.
#
sub Delete($)
{
    my ($self) = @_;

    return -1
	if (! ref($self));

    if (defined($self->idx())) {
	my $idx = $self->idx();
	
	DBQueryWarn("delete from geni_credentials where idx='$idx'")
	    or return -1;
    }
    return 0;
}

#
# Sign the credential.
#
sub Sign($$)
{
    my ($self, $flag) = @_;

    return -1
	if (!ref($self));

    # If no capabilities, then allow all rights, no delegation.
    if (!defined($self->capabilities())) {
	$self->AddCapability("*", 0);
    }
    # This little wrapup is for xmlout.
    my $capabilities = {"capability" => $self->capabilities()};

    # Every one gets a new unique index, which is used in the xml:id below.
    my $idx = TBGetUniqueIndex('next_ticket', 1);
    
    my $this_cert  = $self->this_cert();
    my $owner_cert = $self->owner_cert();
    my $cap_xml    = XMLout($capabilities, "NoAttr" => 1);
    $cap_xml =~ s/opt\>/capabilities\>/g;

    #
    # Create a template xml file to sign.
    #
    my $template =
	"<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?>\n".
	"<credential xml:id=\"ref1\">\n".
	" <type>capability</type>\n".
	" <serial>$idx</serial>\n".
	" <owner_uuid>$owner_cert</owner_uuid>\n".
	" <this_uuid>$this_cert</this_uuid>\n".
	"  $cap_xml\n".
        "</credential>\n";

    my ($fh, $filename) = tempfile(UNLINK => 0);
    return -1
	if (!defined($fh));

    print $fh $template;
    close($fh);

    #
    # Fire up the signer and capture the output. This is the signed credential
    # that is returned. 
    #
    if (! open(SIGNER, "$SIGNCRED $filename |")) {
	print STDERR "Could not start $SIGNCRED on $filename\n";
	return -1;
    }
    my $credential = "";
    while (<SIGNER>) {
	$credential .= $_;
    }
    if (!close(SIGNER)) {
	print STDERR "Could not sign $filename\n";
	return -1;
    }
    $self->{'string'} = $credential;
    unlink($filename);
    return 0;
}

#
# Store the given signed credential in the DB. Client side only for now;
# does the CM need to save all the credentials it hands out?
#
sub Store($)
{
    my ($self) = @_;
    my @insert_data  = ();

    # Do not store again.
    return 0
	if (defined($self->idx()));

    # Every credential store gets a new unique index.
    my $idx = TBGetUniqueIndex('next_ticket', 1);
    
    my $this_uuid  = $self->this_uuid();
    my $owner_uuid = $self->owner_uuid();

    # Now tack on other stuff we need.
    push(@insert_data, "created=now()");
    push(@insert_data, "idx='$idx'");
    push(@insert_data, "this_uuid='$this_uuid'");
    push(@insert_data, "owner_uuid='$owner_uuid'");
    
    my $safe_credential = DBQuoteSpecial($self->asString());
    push(@insert_data, "credential_string=$safe_credential");

    # Insert into DB.
    DBQueryWarn("insert into geni_credentials set " . join(",", @insert_data))
	or return -1;

    # If sucessfully stored, set the idx field so we know.
    $self->{'idx'} = $idx;

    return 0;
}

#
# Create a certificate pair, which gives us a uuid to use for an object.
# We need a file to store the cert/key in.
#
sub CreateCertificate($$$$)
{
    my ($class, $what, $certfile, $pref) = @_;

    system("$MKCERT -o $certfile $what $uuid");
    if ($?) {
	print STDERR "Could not start $MKCERT\n";
	return -1;
    }
    my $cert;
    open(CERT, $certfile) or
	return -1;
    while (<CERT>) {
	if ($_ =~ /^-----BEGIN CERT/) {
	    $cert = "";
	    next;
	}
	last
	    if ($_ =~ /^-----END CERT/);
	next
	    if (!defined($cert));
	$cert .= $_;
    }
    close(CERT);
    $$pref = $cert;
    return 0;
}

#
# Convert a certificate to its uuid.
#
sub CertificateInfo($$$)
{
    my ($class, $string, $pref) = @_;

    # Deleted when scope is left.
    my $tempfile = new File::Temp(UNLINK => 1);
    my $filename = $tempfile->filename;    
    print $tempfile "-----BEGIN CERTIFICATE-----\n";
    print $tempfile "$string";
    print $tempfile "-----END CERTIFICATE-----\n";

    my $dn = `$OPENSSL x509 -in $filename -noout -subject`;
    if ($?) {
	print STDERR "Cailed to convert $filename to uuid!\n";
	return -1;
    }

    if ($dn =~ /CN=([-\w]*)$/) {
	$$pref = $1;
    }
    else {
	return -1;
    }
    return 0;
}

# _Always_ make sure that this 1 is at the end of the file...
1;
