#!/usr/bin/perl -wT
#
# EMULAB-COPYRIGHT
# Copyright (c) 2008 University of Utah and the Flux Group.
# All rights reserved.
#
package GeniCredential;

#
# Some simple credential stuff.
#
use strict;
use Exporter;
use vars qw(@ISA @EXPORT);

@ISA    = "Exporter";
@EXPORT = qw ( );

# Must come after package declaration!
use lib '@prefix@/lib';
use GeniDB;
use GeniCertificate;
use libtestbed;
use Experiment;
use libdb qw(TBGetUniqueIndex);
use English;
use XML::Simple;
use XML::LibXML;
use Data::Dumper;
use File::Temp qw(tempfile);

# Exported variables
use vars qw(@EXPORT_OK $LOCALSA_FLAG $LOCALCM_FLAG);

# Configure variables
my $TB		   = "@prefix@";
my $TBOPS          = "@TBOPSEMAIL@";
my $TBAPPROVAL     = "@TBAPPROVALEMAIL@";
my $TBAUDIT   	   = "@TBAUDITEMAIL@";
my $BOSSNODE       = "@BOSSNODE@";
my $OURDOMAIN      = "@OURDOMAIN@";
my $SIGNCRED	   = "$TB/sbin/signgenicred";
my $VERIFYCRED	   = "$TB/sbin/verifygenicred";
my $NFREE	   = "$TB/bin/nfree";
my $OPENSSL	   = "/usr/bin/openssl";

# Signing flags
$LOCALSA_FLAG	   = 1;
$LOCALCM_FLAG	   = 2;
@EXPORT_OK	   = qw(LOCALSA_FLAG LOCALCM_FLAG);

#
# Look for a signed credential in the DB. At present, we store a credential
# by user/object (uuid/uuid), not worrying about different flavors of creds
# with different permissions. This is basically a cache on the client side of
# credentials in use so that they do not need to be regenerated.
#
sub Lookup($$$)
{
    my ($class, $this, $owner) = @_;

    return undef
	if (! (ref($this) && ref($owner)));

    my $this_uuid  = $this->uuid();
    my $owner_uuid = $owner->uuid();

    my $query_result =
	DBQueryWarn("select * from geni_credentials ".
		    "where owner_uuid='$owner_uuid' and ".
		    "      this_uuid='$this_uuid'");
    return undef
	if (!defined($query_result) || !$query_result->numrows);

    my $credential = GeniCredential->Create($this, $owner);
    return undef
	if (!defined($credential));

    my $row = $query_result->fetchrow_hashref();
    $credential->{'idx'}    = $row->{'idx'};
    $credential->{'string'} = $row->{'credential_string'};
    return $credential;
}

#
# Create an empty credential object.
#
sub Create($$$$)
{
    my ($class, $this, $owner) = @_;

    return undef
	if (! (ref($this) && ref($owner)));

    my $self = {};
    $self->{'this'}          = $this;
    $self->{'owner'}         = $owner;
    $self->{'this_uuid'}     = $this->uuid();
    $self->{'owner_uuid'}    = $owner->uuid();
    $self->{'this_cert'}     = $this->cert();
    $self->{'owner_cert'}    = $owner->cert();
    $self->{'string'}        = undef;
    $self->{'capabilities'}  = undef;
    $self->{'idx'}	     = undef;	# Only set when stored to DB.
    bless($self, $class);

    return $self;
}
# accessors
sub field($$)           { return ($_[0]->{$_[1]}); }
sub idx($)		{ return field($_[0], "idx"); }
sub this($)		{ return field($_[0], "this"); }
sub owner($)		{ return field($_[0], "owner"); }
sub this_uuid($)	{ return field($_[0], "this_uuid"); }
sub owner_uuid($)	{ return field($_[0], "owner_uuid"); }
sub this_cert($)	{ return field($_[0], "this_cert"); }
sub owner_cert($)	{ return field($_[0], "owner_cert"); }
sub asString($)		{ return field($_[0], "string"); }
sub capabilities($)	{ return field($_[0], "capabilities"); }

#
# Add a capability to the array.
#
sub AddCapability($$$)
{
    my ($self, $name, $delegate) = @_;

    return -1
	if (!ref($self));

    if (!defined($self->capabilities())) {
	$self->{'capabilities'} = {};
    }
    $self->{'capabilities'}->{$name} = {"can_delegate" => $delegate};
    return 0;
}

#
# Create a credential object from a signed credential string.
#
sub CreateFromSigned($$;$)
{
    my ($class, $string, $nosig) = @_;

    #
    # This flag is used to avoid verifying the signature since I do not
    # really care if the component gives me a bad ticket; I am not using
    # it locally, just passing it back to the component at some point.
    #
    $nosig = 0
	if (!defined($nosig));

    # First verify the credential
    if (! $nosig) {
	my ($fh, $filename) = tempfile(UNLINK => 0);
	return undef
	    if (!defined($fh));
	print $fh $string;
	close($fh);
	system("$VERIFYCRED $filename");
	if ($?) {
	    print STDERR "Credential in $filename did not verify\n";
	    return undef;
	}
	unlink($filename);
    }

    # Use XML::Simple to convert to something we can mess with.
    my $parser = XML::LibXML->new;
    my $doc    = $parser->parse_string($string);

    # Dig out the capabilities
    my ($cap_node) = $doc->getElementsByTagName("capabilities");
    return undef
	if (!defined($cap_node));
    my $capabilities = XMLin($cap_node->toString(), ForceArray => 0);

    # Dig out the slice uuid. Locally, I am not sure if we bother to
    # keep slices in the DB (they are in the DB at geni central).
    my ($uuid_node) = $doc->getElementsByTagName("this_uuid");
    return undef
	if (!defined($uuid_node));
    my $this_cert = $uuid_node->to_literal();
    my $this_uuid;
    GeniCertificate->CertificateInfo($this_cert, \$this_uuid) == 0
	or return undef;

    if (! ($this_uuid =~ /^\w+\-\w+\-\w+\-\w+\-\w+$/)) {
	print STDERR "Invalid this_uuid in credential\n";
	return undef;
    }

    # Dig out the owner uuid. Locally, I am not sure if we bother to
    # keep users in the DB (they are in the DB at geni central).
    ($uuid_node) = $doc->getElementsByTagName("owner_uuid");
    return undef
	if (!defined($uuid_node));
    my $owner_cert = $uuid_node->to_literal();
    my $owner_uuid;
    GeniCertificate->CertificateInfo($owner_cert, \$owner_uuid) == 0
	or return undef;

    if (! ($owner_uuid =~ /^\w+\-\w+\-\w+\-\w+\-\w+$/)) {
	print STDERR "Invalid owner_uuid in credential\n";
	return undef;
    }

    my $self = {};
    $self->{'capabilities'}  = $capabilities;
    $self->{'this_uuid'}     = $this_uuid;
    $self->{'owner_uuid'}    = $owner_uuid;
    $self->{'this_cert'}     = $this_cert;
    $self->{'owner_cert'}    = $owner_cert;
    $self->{'string'}        = $string;
    $self->{'xmlref'}        = $doc;
    $self->{'idx'}	     = undef;	# Only set when stored to DB.
    bless($self, $class);

    return $self;
}

#
# Might have to delete this from the DB.
#
sub Delete($)
{
    my ($self) = @_;

    return -1
	if (! ref($self));

    if (defined($self->idx())) {
	my $idx = $self->idx();
	
	DBQueryWarn("delete from geni_credentials where idx='$idx'")
	    or return -1;
    }
    return 0;
}

#
# Sign the credential.
#
sub Sign($$)
{
    my ($self, $how) = @_;

    return -1
	if (!ref($self));

    # If no capabilities, then allow all rights, no delegation.
    if (!defined($self->capabilities())) {
	$self->AddCapability("*", 0);
    }
    # This little wrapup is for xmlout.
    my $capabilities = {"capability" => $self->capabilities()};

    # Every one gets a new unique index, which is used in the xml:id below.
    my $idx = TBGetUniqueIndex('next_ticket', 1);
    
    my $this_cert  = $self->this_cert();
    my $owner_cert = $self->owner_cert();
    my $cap_xml    = XMLout($capabilities, "NoAttr" => 1);
    $cap_xml =~ s/opt\>/capabilities\>/g;

    #
    # Create a template xml file to sign.
    #
    my $template =
	"<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?>\n".
	"<credential xml:id=\"ref1\">\n".
	" <type>capability</type>\n".
	" <serial>$idx</serial>\n".
	" <owner_uuid>$owner_cert</owner_uuid>\n".
	" <this_uuid>$this_cert</this_uuid>\n".
	"  $cap_xml\n".
        "</credential>\n";

    my ($fh, $filename) = tempfile(UNLINK => 0);
    return -1
	if (!defined($fh));

    print $fh $template;
    close($fh);

    #
    # Who signs the credential? $how is either a flag (CM or SA) or its
    # a certificate object in the DB. 
    #
    my $certificate;
    if (ref($how)) {
	# This will auto delete too.
	my $certfile = $how->WriteToFile();
	if (!defined($certfile)) {
	    print STDERR "Could not write $certificate to temp file\n";
	    return -1;
	}
	$certificate = "-c $certfile";
    }
    elsif ($how == $LOCALSA_FLAG) {
	$certificate = "-c $TB/etc/genisa.pem";
    }
    elsif ($how == $LOCALCM_FLAG) {
	$certificate = "-c $TB/etc/genicm.pem";
    }
    else {
	print STDERR "Invalid 'how' argument to Sign()\n";
	return -1;
    }

    #
    # Fire up the signer and capture the output. This is the signed credential
    # that is returned. 
    #
    if (! open(SIGNER, "$SIGNCRED $certificate $filename |")) {
	print STDERR "Could not start $SIGNCRED on $filename\n";
	return -1;
    }
    my $credential = "";
    while (<SIGNER>) {
	$credential .= $_;
    }
    if (!close(SIGNER)) {
	print STDERR "Could not sign $filename\n";
	return -1;
    }
    $self->{'string'} = $credential;
    unlink($filename);
    return 0;
}

#
# Store the given signed credential in the DB. Client side only for now;
# does the CM need to save all the credentials it hands out?
#
sub Store($)
{
    my ($self) = @_;
    my @insert_data  = ();

    # Do not store again.
    return 0
	if (defined($self->idx()));

    # Every credential store gets a new unique index.
    my $idx = TBGetUniqueIndex('next_ticket', 1);
    
    my $this_uuid  = $self->this_uuid();
    my $owner_uuid = $self->owner_uuid();

    # Now tack on other stuff we need.
    push(@insert_data, "created=now()");
    push(@insert_data, "idx='$idx'");
    push(@insert_data, "this_uuid='$this_uuid'");
    push(@insert_data, "owner_uuid='$owner_uuid'");
    
    my $safe_credential = DBQuoteSpecial($self->asString());
    push(@insert_data, "credential_string=$safe_credential");

    # Insert into DB.
    DBQueryWarn("insert into geni_credentials set " . join(",", @insert_data))
	or return -1;

    # If sucessfully stored, set the idx field so we know.
    $self->{'idx'} = $idx;

    return 0;
}

# _Always_ make sure that this 1 is at the end of the file...
1;
