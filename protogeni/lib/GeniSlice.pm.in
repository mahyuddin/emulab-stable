#!/usr/bin/perl -wT
#
# EMULAB-COPYRIGHT
# Copyright (c) 2008 University of Utah and the Flux Group.
# All rights reserved.
#
package GeniSlice;

use strict;
use Exporter;
use vars qw(@ISA @EXPORT);

@ISA    = "Exporter";
@EXPORT = qw ( );

# Must come after package declaration!
use lib '@prefix@/lib';
use GeniDB;
use GeniCHClient;
use libtestbed;
# Hate to import all this crap; need a utility library.
use libdb qw(TBGetUniqueIndex);
use Experiment;
use English;
use overload ('""' => 'Stringify');
use vars qw();

# Configure variables
my $TB		   = "@prefix@";
my $TBOPS          = "@TBOPSEMAIL@";
my $TBAPPROVAL     = "@TBAPPROVALEMAIL@";
my $TBAUDIT   	   = "@TBAUDITEMAIL@";
my $BOSSNODE       = "@BOSSNODE@";
my $CONTROL	   = "@USERNODE@";
my $OURDOMAIN      = "@OURDOMAIN@";
my $MKCERT         = "$TB/sbin/mksyscert";

# Cache of instances to avoid regenerating them.
my %slices     = ();
my $debug      = 0;

# Little helper and debug function.
sub mysystem($)
{
    my ($command) = @_;

    print STDERR "Running '$command'\n"
	if ($debug);
    return system($command);
}

#
# Lookup by idx or uuid.
#
sub Lookup($$)
{
    my ($class, $token) = @_;
    my $query_result;
    my $idx;

    if ($token =~ /^\d+$/) {
	$idx = $token;
    }
    elsif ($token =~ /^\w+\-\w+\-\w+\-\w+\-\w+$/) {
	$query_result =
	    DBQueryWarn("select idx from geni_slices ".
			"where uuid='$token'");
	    return undef
		if (! $query_result || !$query_result->numrows);

	    ($idx) = $query_result->fetchrow_array();
    }
    else {
	return undef;
    }
    
    # Look in cache first
    return $slices{"$idx"}
        if (exists($slices{"$idx"}));

    $query_result =
	DBQueryWarn("select * from geni_slices where idx='$idx'");
    return undef
	if (!$query_result || !$query_result->numrows);

    my $self         = {};
    $self->{'SLICE'} = $query_result->fetchrow_hashref();
    bless($self, $class);

    #
    # Grab the certificate, since we will probably want it.
    #
    my $uuid = $self->{'SLICE'}->{'uuid'};
    $query_result = DBQueryWarn("select cert from geni_certificates ".
				"where uuid='$uuid'");
    if (!$query_result || !$query_result->numrows) {
	print STDERR "Could not find certificate for slice $idx\n";
	return undef;
    }
    my ($cert) = $query_result->fetchrow_array();
    $self->{'SLICE'}->{'cert'} = $cert;
    
    # Add to cache. 
    $slices{$self->{'SLICE'}->{'idx'}} = $self;
    
    return $self;
}
# accessors
sub field($$) { return ((! ref($_[0])) ? -1 : $_[0]->{'SLICE'}->{$_[1]}); }
sub idx($)		{ return field($_[0], "idx"); }
sub hrn($)		{ return field($_[0], "hrn"); }
sub uuid($)		{ return field($_[0], "uuid"); }
sub creator_uuid($)	{ return field($_[0], "creator_uuid"); }
sub created($)		{ return field($_[0], "created"); }
sub sa_idx($)		{ return field($_[0], "sa_idx"); }
sub cert($)		{ return field($_[0], "cert"); }

#
# Stringify for output.
#
sub Stringify($)
{
    my ($self) = @_;
    
    my $hrn = $self->hrn();
    my $idx = $self->idx();

    return "[GeniSlice: $hrn, IDX: $idx]";
}

#
# Class method to check for an existing user that has the same
# uid/email. Lets not allow this for now. Return the number of
# users that match or -1 if an error. 
#
sub CheckExisting($$$)
{
    my ($class, $hrn, $uuid) = @_;

    my $safe_hrn  = DBQuoteSpecial($hrn);
    my $safe_uuid = DBQuoteSpecial($uuid);

    my $query_result =
	DBQueryFatal("select idx from geni_slices ".
		     "where hrn=$safe_hrn or uuid=$safe_uuid");
    return -1
	if (!defined($query_result));

    return $query_result->numrows;
}

#
# Class function to create new Geni slice and return the object.
#
sub Create($$$$$$)
{
    my ($class, $hrn, $uuid, $creator_uuid, $cert, $sa_idx) = @_;
    my @insert_data = ();

    # Every slice gets a new unique index.
    my $idx = TBGetUniqueIndex('next_exptidx', 1);

    # Now tack on other stuff we need.
    push(@insert_data, "created=now()");
    push(@insert_data, "idx='$idx'");
    push(@insert_data, "sa_idx='$sa_idx'");

    my $safe_hrn   = DBQuoteSpecial($hrn);
    my $safe_uuid  = DBQuoteSpecial($uuid);
    my $safe_cuuid = DBQuoteSpecial($creator_uuid);
    my $safe_cert  = DBQuoteSpecial($cert);
    push(@insert_data, "hrn=$safe_hrn");
    push(@insert_data, "uuid=$safe_uuid");
    push(@insert_data, "creator_uuid=$safe_cuuid");

    # Insert into DB.
    DBQueryWarn("insert into geni_slices set " . join(",", @insert_data))
	or return undef;

    # Insert the certificate.
    if (!DBQueryWarn("insert into geni_certificates set ".
		     "  uuid=$safe_uuid, cert=$safe_cert")) {
	DBQueryWarn("delete from geni_slices where idx='$idx'");
	return undef;
    }

    return GeniSlice->Lookup($idx);
}

#
# Class function to create new Geni slice from a local experiment.
#
sub CreateFromLocal($$)
{
    my ($class, $experiment, $user) = @_;

    # XXX Form hrn from the uid and domain. This is backwards.
    my $hrn = $OURDOMAIN . "." . $experiment->pid() . "." . $experiment->eid();
    my $uuid = $experiment->uuid();
    my $creator_uuid = $user->uuid();

    # Set the sa_idx to zero to indicate a local slice.
    my $sa_idx = 0;

    #
    # Generate a certificate pair, capturing the certificate to store in
    # the DB so we have ready access to it.
    #
    my $certfile = $experiment->WorkDir() . "/genicert.pem";
    system("$MKCERT -o $certfile slice $uuid");
    if ($?) {
	print STDERR "Could not start $MKCERT\n";
	return undef;
    }
    my $cert;
    open(CERT, $certfile) or
	return undef;
    while (<CERT>) {
	if ($_ =~ /^-----BEGIN CERT/) {
	    $cert = "";
	    next;
	}
	last
	    if ($_ =~ /^-----END CERT/);
	next
	    if (!defined($cert));
	$cert .= $_;
    }
    close(CERT);
    return GeniSlice->Create($hrn, $uuid, $creator_uuid, $cert, $sa_idx);
}

#
# Register a local slice at the clearinghouse;
#
sub Register($)
{
    my ($self) = @_;

    return -1
	if (! ref($self));

    GeniCHClient::RegisterSlice($self->hrn(), $self->uuid(),
				$self->creator_uuid(), $self->cert())
	== 0 or return -1;
    
    return 0;
}

#
# Discover resources for a local slice. We do not worry about the experiment
# yet, since we do not have a resource discovery service. We get back a list
# of components.
#
sub DiscoverResources($$)
{
    my ($self, $pref) = @_;

    return -1
	if (! ref($self));

    GeniCHClient::DiscoverResources($self, $pref) == 0
	or return -1;
    
    return 0;
}

#
# Delete the slice, as for registration errors.
#
sub Delete($)
{
    my ($self) = @_;

    return -1
	if (! ref($self));

    my $idx  = $self->idx();
    my $uuid = $self->uuid();

    DBQueryWarn("delete from geni_certificates where uuid='$uuid'")
	or return -1;
    DBQueryWarn("delete from geni_slices where idx='$idx'")
	or return -1;
    
    return 0;
}

# _Always_ make sure that this 1 is at the end of the file...
1;
