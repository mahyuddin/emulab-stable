#!/usr/bin/perl -wT
#
# EMULAB-COPYRIGHT
# Copyright (c) 2008 University of Utah and the Flux Group.
# All rights reserved.
#
package GeniSlice;

use strict;
use Exporter;
use vars qw(@ISA @EXPORT);

@ISA    = "Exporter";
@EXPORT = qw ( );

# Must come after package declaration!
use lib '@prefix@/lib';
use GeniDB;
use GeniRegistry;
use GeniAuthority;
use GeniCredential;
use GeniComponent;
use GeniCertificate;
use libtestbed;
# Hate to import all this crap; need a utility library.
use libdb qw(TBGetUniqueIndex);
use Experiment;
use English;
use overload ('""' => 'Stringify');
use Data::Dumper;
use vars qw();

# Configure variables
my $TB		   = "@prefix@";
my $TBOPS          = "@TBOPSEMAIL@";
my $TBAPPROVAL     = "@TBAPPROVALEMAIL@";
my $TBAUDIT   	   = "@TBAUDITEMAIL@";
my $BOSSNODE       = "@BOSSNODE@";
my $CONTROL	   = "@USERNODE@";
my $OURDOMAIN      = "@OURDOMAIN@";

# Cache of instances to avoid regenerating them.
my %slices     = ();
my $debug      = 0;

# Little helper and debug function.
sub mysystem($)
{
    my ($command) = @_;

    print STDERR "Running '$command'\n"
	if ($debug);
    return system($command);
}

#
# Lookup by idx or uuid.
#
sub Lookup($$)
{
    my ($class, $token) = @_;
    my $query_result;
    my $idx;

    if ($token =~ /^\d+$/) {
	$idx = $token;
    }
    elsif ($token =~ /^\w+\-\w+\-\w+\-\w+\-\w+$/) {
	$query_result =
	    DBQueryWarn("select idx from geni_slices ".
			"where uuid='$token'");
	    return undef
		if (! $query_result || !$query_result->numrows);

	    ($idx) = $query_result->fetchrow_array();
    }
    elsif ($token =~ /^[-\w\.]*$/) {
	$query_result =
	    DBQueryWarn("select idx from geni_slices ".
			"where hrn='$token'");
	    return undef
		if (! $query_result || !$query_result->numrows);

	    ($idx) = $query_result->fetchrow_array();
    }
    else {
	return undef;
    }
    
    # Look in cache first
    return $slices{"$idx"}
        if (exists($slices{"$idx"}));

    $query_result =
	DBQueryWarn("select * from geni_slices where idx='$idx'");
    return undef
	if (!$query_result || !$query_result->numrows);

    my $self         = {};
    $self->{'SLICE'} = $query_result->fetchrow_hashref();
    bless($self, $class);

    #
    # Grab the certificate, since we will probably want it.
    #
    my $uuid = $self->{'SLICE'}->{'uuid'};
    my $certificate = GeniCertificate->Lookup($uuid);
    if (!defined($certificate)) {
	print STDERR "Could not find certificate for slice $idx ($uuid)\n";
	return undef;
    }
    $self->{'CERT'}     = $certificate;
    $self->{'BINDINGS'} = undef;
    
    # Add to cache. 
    $slices{$self->{'SLICE'}->{'idx'}}    = $self;
    
    return $self;
}
# accessors
sub field($$) { return ((! ref($_[0])) ? -1 : $_[0]->{'SLICE'}->{$_[1]}); }
sub idx($)		{ return field($_[0], "idx"); }
sub hrn($)		{ return field($_[0], "hrn"); }
sub uuid($)		{ return field($_[0], "uuid"); }
sub creator_uuid($)	{ return field($_[0], "creator_uuid"); }
sub created($)		{ return field($_[0], "created"); }
sub sa_uuid($)		{ return field($_[0], "sa_uuid"); }
sub exptidx($)		{ return field($_[0], "exptidx"); }
sub cert($)		{ return $_[0]->{'CERT'}->cert(); }
sub GetCertificate($)   { return $_[0]->{'CERT'}; }

#
# Stringify for output.
#
sub Stringify($)
{
    my ($self) = @_;
    
    my $hrn = $self->hrn();
    my $idx = $self->idx();

    return "[GeniSlice: $hrn, IDX: $idx]";
}

# The slicename is the last token in the hrn.
sub slicename($)
{
    my ($self) = @_;

    my ($slicename) = ($self->hrn() =~ /^.*\.(\w*)$/);
    $slicename = $self->hrn()
	if (!defined($slicename));

    return $slicename;
}

#
# Lookup slice by the experiment it is related to.
#
sub LookupByExperiment($$)
{
    my ($class, $experiment) = @_;

    my $exptidx = $experiment->idx();
    my $query_result =
	DBQueryWarn("select idx from geni_slices ".
		    "where exptidx='$exptidx'");
    return undef
	if (!defined($query_result) || !$query_result->numrows);

    my ($idx) = $query_result->fetchrow_array();
    return GeniSlice->Lookup($idx);
}

#
# Class method to check for an existing user that has the same
# uid/email. Lets not allow this for now. Return the number of
# users that match or -1 if an error. 
#
sub CheckExisting($$$)
{
    my ($class, $hrn, $uuid) = @_;

    my $safe_hrn  = DBQuoteSpecial($hrn);
    my $safe_uuid = DBQuoteSpecial($uuid);

    my $query_result =
	DBQueryFatal("select idx from geni_slices ".
		     "where hrn=$safe_hrn or uuid=$safe_uuid");
    return -1
	if (!defined($query_result));

    return $query_result->numrows;
}

#
# Class function to create new Geni slice and return the object.
#
sub Create($$$$;$)
{
    my ($class, $certificate, $creator_uuid, $authority, $exptidx) = @_;
    my @insert_data = ();

    # Every slice gets a new unique index.
    my $idx = TBGetUniqueIndex('next_exptidx', 1);

    if (!defined($authority)) {
	print STDERR "Need to specify an authority!\n";
	return undef;
    }
    my $sa_uuid = $authority->uuid();

    # Now tack on other stuff we need.
    push(@insert_data, "created=now()");
    push(@insert_data, "idx='$idx'");
    push(@insert_data, "sa_uuid='$sa_uuid'");
    push(@insert_data, "exptidx=$exptidx")
	if (defined($exptidx));
    
    my $safe_hrn   = DBQuoteSpecial($certificate->hrn());
    my $safe_uuid  = DBQuoteSpecial($certificate->uuid());
    my $safe_cuuid = DBQuoteSpecial($creator_uuid);
    push(@insert_data, "hrn=$safe_hrn");
    push(@insert_data, "uuid=$safe_uuid");
    push(@insert_data, "creator_uuid=$safe_cuuid");

    if ($certificate->Store() != 0) {
	print STDERR "Could not store certificate for new slice.\n";
	return undef;
    }

    # Insert into DB.
    return undef
	if (! DBQueryWarn("insert into geni_slices set " .
			  join(",", @insert_data)));

    return GeniSlice->Lookup($idx);
}

#
# Class function to create new Geni slice from a local experiment.
# We want to create the key pair so that we can sign credentials.
#
sub CreateFromLocal($$$)
{
    my ($class, $experiment, $user) = @_;

    #
    # So we know who/what we are acting as.
    #
    my $EMULAB_PEMFILE = "@prefix@/etc/genisa.pem";
    my $certificate = GeniCertificate->LoadFromFile($EMULAB_PEMFILE);
    if (!defined($certificate)) {
	print STDERR "Could not get uuid from $EMULAB_PEMFILE\n";
	return undef;
    }

    #
    # Need our own slice authority record.
    #
    my $authority = GeniAuthority->Lookup($certificate->uuid());
    if (!defined($authority)) {
	print STDERR "Could not find the local authority record\n";
	return undef;
    }
    
    my $hrn = $authority->hrn() . "." . $experiment->idx();
    my $creator_uuid = $user->uuid();

    #
    # Generate a certificate.
    #
    $certificate = GeniCertificate->Create("slice", $hrn, $user->email());
    if (!defined($certificate)) {
	print STDERR "Could not create certificate for slice.\n";
	return undef;
    }
    my $slice = GeniSlice->Create($certificate, $creator_uuid,
				  $authority, $experiment->idx());
    $certificate->Delete()
	if (!defined($slice));

    return $slice;
}

#
# Register a local slice at the clearinghouse;
#
sub Register($)
{
    my ($self) = @_;

    return -1
	if (! ref($self));

    my $clearinghouse = GeniRegistry::ClearingHouse->Create();
    return -1
	if (!defined($clearinghouse));

    return $clearinghouse->RegisterSlice($self->creator_uuid(),
					 $self->cert(), {});
}

#
# Remove a local slice at the clearinghouse;
#
sub UnRegister($)
{
    my ($self) = @_;

    return -1
	if (! ref($self));

    my $clearinghouse = GeniRegistry::ClearingHouse->Create();
    return -1
	if (!defined($clearinghouse));

    return $clearinghouse->RemoveSlice($self->uuid());
}

#
# Discover resources for a local slice. We do not worry about the experiment
# yet, since we do not have a resource discovery service. We get back a list
# of components.
#
sub DiscoverResources($$)
{
    my ($self, $pref) = @_;

    return -1
	if (! ref($self));

    my $clearinghouse = GeniRegistry::ClearingHouse->Create();
    return -1
	if (!defined($clearinghouse));

    my $blob;
    $clearinghouse->DiscoverResources($self, \$blob) == 0
	or return -1;

    #
    # We get back a list of components right now, which we cache locally.
    #
    my @result = ();
    
    foreach my $ref (@{ $blob }) {
	my $certificate = GeniCertificate->LoadFromString($ref->{'gid'});
	return -1
	    if (!defined($certificate));
	my $uuid = $certificate->uuid();

	my $component = GeniComponent->Lookup($uuid);
	if (!defined($component)) {
	    $component = GeniComponent->CreateFromRegistry($uuid);
	    return -1
		if (!defined($component));
	}
	push(@result, $component);
    }
    @$pref = @result;
    return 0;
}

#
# Delete the slice, as for registration errors.
#
sub Delete($)
{
    my ($self) = @_;

    return -1
	if (! ref($self));

    my $idx  = $self->idx();
    my $uuid = $self->uuid();
    my $experiment = $self->GetExperiment();
    $experiment->UnBindNonLocalUsers()
	if (defined($experiment));

    DBQueryWarn("delete from geni_bindings where slice_uuid='$uuid'")
	or return -1;
    DBQueryWarn("delete from geni_certificates where uuid='$uuid'")
	or return -1;
    DBQueryWarn("delete from geni_slices where idx='$idx'")
	or return -1;
    
    return 0;
}

#
# Return the emulab experiment for this slice.
#
sub GetExperiment($)
{
    my ($self) = @_;

    return undef
	if (!ref($self));

    return Experiment->Lookup($self->uuid());
}

#
# Check if the given SA is the actual SA for the slice.
#
sub IsSliceAuthority($$)
{
    my ($self, $authority) = @_;

    return 0
	if (! (ref($self) && ref($authority)));

    return 1
	if ($self->sa_uuid() == $authority->uuid());
    
    return 0;
}

#
# Server side of binding users to slices; insert entries into the bindings
# table.
# 
sub BindUser($$)
{
    my ($self, $target_user) = @_;

    return -1
	if (! (ref($self) && ref($target_user)));

    my $slice_uuid = $self->uuid();
    my $user_uuid  = $target_user->uuid();

    DBQueryWarn("replace into geni_bindings set ".
		" created=now(), slice_uuid='$slice_uuid', ".
		" user_uuid='$user_uuid'")
	or return -1;
    
    return 0;
}

sub UnBindUser($$)
{
    my ($self, $target_user) = @_;

    return -1
	if (! (ref($self) && ref($target_user)));

    my $slice_uuid = $self->uuid();
    my $user_uuid  = $target_user->uuid();

    DBQueryWarn("delete from geni_bindings ".
		"where slice_uuid='$slice_uuid' and user_uuid='$user_uuid'")
	or return -1;
    
    return 0;
}

#
# Unbind all users.
#
sub UnBindUsers($)
{
    my ($self) = @_;

    return -1
	if (! ref($self));

    my $slice_uuid = $self->uuid();

    DBQueryWarn("delete from geni_bindings ".
		"where slice_uuid='$slice_uuid'")
	or return -1;
    
    return 0;
}

#
# Return the user bindings for a slice, as a list of uuids. Do not look
# them up here since this routine is called from the CH.
#
sub UserBindings($$)
{
    my ($self, $pref) = @_;
    
    return -1
	if (! (ref($self) && ref($pref)));

    my $uuid = $self->uuid();

    if (!defined($self->{'BINDINGS'})) {
	my $query_result =
	    DBQueryWarn("select user_uuid from geni_bindings ".
			"where slice_uuid='$uuid'");
	return -1
	    if (!$query_result);

	my @bindings = ();

	while (my ($user_uuid) = $query_result->fetchrow_array()) {
	    push(@bindings, $user_uuid);
	}
	$self->{'BINDINGS'} = \@bindings;
    }
    @$pref = @{ $self->{'BINDINGS'} };
    return 0;
}

# _Always_ make sure that this 1 is at the end of the file...
1;
