#!/usr/bin/perl -wT
#
# GENIPUBLIC-COPYRIGHT
# Copyright (c) 2008-2011 University of Utah and the Flux Group.
# All rights reserved.
#
package GeniUtil;

use strict;
use Exporter;
use vars qw(@ISA @EXPORT);

@ISA    = "Exporter";
@EXPORT = qw(GENI_PURGEFLAG FindHostname);

use English;
use Data::Dumper;
use XML::Simple;
use GeniHRN;

# Configure variables
my $TB		       = "@prefix@";
my $TBOPS              = "@TBOPSEMAIL@";
my $OURDOMAIN          = "@OURDOMAIN@";
my $UUIDGEN	       = "@UUIDGEN@";
my $ELABINELAB         = "@ELABINELAB@";
my $OUTERBOSS_NODENAME = "@OUTERBOSS_NODENAME@";
my $user	       = "geniuser";
my $group              = "GeniSlices";

use vars qw($EXTENSIONS_NS $XSI_NS $EXTENSIONS_PREFIX $EXTENSIONS_SCHEMA_LOCATION $CREDENTIAL_SCHEMA_LOCATION);
#Extensions namespace URI.
$EXTENSIONS_NS = "http://www.protogeni.net/resources/credential/ext/policy/1";
$XSI_NS = "http://www.w3.org/2001/XMLSchema-instance";
$EXTENSIONS_PREFIX = "policyExt";
$EXTENSIONS_SCHEMA_LOCATION = "http://www.protogeni.net/resources/credential/ext/policy/1/policy.xsd"; 
$CREDENTIAL_SCHEMA_LOCATION = "http://www.protogeni.net/resources/credential/credential.xsd";

sub GENI_PURGEFLAG()	{ return 1; }

#
# In the prototype, we accept certificate signed by trusted roots (CA
# certs we have locally cached). Scripts runs as "geniuser" so that
# there is an emulab user context, or many of the scripts we invoke
# will complain and croak.
#
sub FlipToGeniUser(;$)
{
    my ($default_gid) = @_;
    my $glist;
    
    my $unix_uid = getpwnam("$user") or
	die("*** $0:\n".
	    "    No such user $user\n");
    my $unix_gid = getgrnam("$group") or
	die("*** $0:\n".
	    "    No such group $group\n");

    if (defined($default_gid) && $default_gid != $unix_gid) {
	$glist = "$default_gid $default_gid $unix_gid";
    }
    else {
	$default_gid = $unix_gid;
	$glist = "$unix_gid $unix_gid";
    }
    $GID            = $default_gid;
    $EGID           = $glist;
    $EUID = $UID    = $unix_uid;
    $ENV{'USER'}    = $user;
    $ENV{'LOGNAME'} = $user;
    return 0;
}

sub ResetGroups($)
{
    my ($default_gid) = @_;
    
    $EUID = 0;
    return FlipToGeniUser($default_gid);
}

#
# Store up the list of caches to flush
#
my @ourcaches = ();

sub AddCache($)
{
    my ($ref) = @_;

    push(@ourcaches, $ref);
}
sub FlushCaches()
{
    foreach my $ref (@ourcaches) {
	%$ref = ();
    }
}

#
# Get me a UUID (universally unique identifier). Its really nice that there
# is a program that does this! They look like this:
#
#	047edb7b-d346-11db-96cb-001143e453fe
#
sub NewUUID()
{
    my $uuid = `$UUIDGEN`;

    if ($uuid =~ /^(\w{8}\-\w{4}\-\w{4}\-\w{4}\-\w{12})$/) {
	return $1;
    }
    return undef;
}

#
# Look up a node by an identifier of unspecified type (perhaps a URN, an
# (obsolete) UUID, or an old-style HRN.  Ultimately, all IDs should be
# URNs and this mess will go away, but for now we try not to make
# any assumptions, because of backward compatibility constraints.
#
sub LookupNode($)
{
    my ($nodeid) = @_;
    require Node;

    if( GeniHRN::IsValid( $nodeid ) ) {
	# Looks like a URN.
	my ($auth,$t,$id) = GeniHRN::Parse( $nodeid );

	return undef if $auth ne $OURDOMAIN or $t ne "node";

	return Node->Lookup( $id );
    }
 
    #
    # Looks like an old HRN, but we only want the last token for node lookup.
    #
    if ($nodeid =~ /\./) {
	($nodeid) = ($nodeid =~ /\.([-\w]*)$/);

	return Node->Lookup($nodeid);
    }
    
    # Assume it's a UUID, and pass it on as is.
    return Node->Lookup($nodeid);
}

sub FindHostname($)
{
    my ($nodeid) = @_;
    my $prefix = $OURDOMAIN;
    if ($ELABINELAB == 1) {
	$OUTERBOSS_NODENAME =~ /^[^.]+\.(.*)$/;
	$prefix = $1;
    }
    return $nodeid . "." . $prefix;    
}

#
# Run a command, being sure to capture all output. 
#
sub ExecQuiet($)
{
    #
    # Use a pipe read, so that we save away the output
    #
    my ($command) = @_;
    my $output    = "";
    
    open(PIPE,"$command 2>&1 |") or return -1;
    while (<PIPE>) {
	$output .= $_;
    }
    close(PIPE);
    return $output;
}

# _Always_ make sure that this 1 is at the end of the file...
1;
