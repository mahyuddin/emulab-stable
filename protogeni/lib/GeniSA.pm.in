#!/usr/bin/perl -wT
#
# GENIPUBLIC-COPYRIGHT
# Copyright (c) 2008-2010 University of Utah and the Flux Group.
# All rights reserved.
#
package GeniSA;

#
# The server side of the SA interface. The SA is really just a registry,
# in our case mediated by Emulab. 
#
use strict;
use Exporter;
use vars qw(@ISA @EXPORT);

@ISA    = "Exporter";
@EXPORT = qw ( );

# Must come after package declaration!
use lib '@prefix@/lib';
use GeniDB;
use User;
use Genixmlrpc;
use GeniResponse;
use GeniUser;
use GeniSlice;
use GeniCredential;
use GeniCertificate;
use GeniAuthority;
use GeniHRN;
use English;
use XML::Simple;
use Data::Dumper;
use Date::Parse;
use POSIX qw(strftime);
use Time::Local;

# Configure variables
my $TB		   = "@prefix@";
my $OURDOMAIN      = "@OURDOMAIN@";
my $PGENIDOMAIN    = "@PROTOGENI_DOMAIN@";
my $SLICESHUTDOWN  = "$TB/sbin/protogeni/shutdownslice";

my $API_VERSION = 1;

#
# Tell the client what API revision we support.  The correspondence
# between revision numbers and API features is to be specified elsewhere.
# No credentials are required.
#
sub GetVersion()
{
    return GeniResponse->Create( GENIRESPONSE_SUCCESS, $API_VERSION );
}

#
# Get a credential for an object. Ignoring the type for now. If no credential
# provided, then return a generic credential for the registered Emulab user.
# This is the easiest way to get credentials to registered users.
#
sub GetCredential($)
{
    # FIXME once migration to URNs is complete, $uuid should be removed,
    # and $type automatically deduced from the URN.
    my ($argref) = @_;
    my $uuid = $argref->{'uuid'};
    my $urn = $argref->{'urn'};
    my $cred = $argref->{'credential'};
    my $type = $argref->{'type'};
    
    #
    # No credential, then return a generic credential giving user permission
    # to do other things.
    #
    if (!defined($cred)) {
	#
	# Must be an emulab user who is talking to us.
	#
	if (! ($ENV{'GENIUUID'} =~ /^[-\w]*$/)) {
	    return GeniResponse->MalformedArgsResponse();
	}
	
	my $geniuser = GeniUser->Lookup($ENV{'GENIUUID'}, 1);
	if (!defined($geniuser)) {
	    return GeniResponse->Create(GENIRESPONSE_FORBIDDEN,
					undef, "Who are you?");
	}
	#
	# This credential is for access to this SA.
	#
	# FIXME We need to update this to use authority and user URNs,
	# not UUIDs.  But that will require more thought to avoid
	# breaking stuff.
	my $authority = GeniAuthority->Lookup($ENV{'MYUUID'});
	if (!defined($authority)) {
	    print STDERR "Could not find local authority object for $ENV{'MYUUID'}\n";
	    return GeniResponse->Create(GENIRESPONSE_ERROR);
	}
	my $credential =
	    GeniCredential->CreateSigned($authority,
					 $geniuser,
					 $GeniCredential::LOCALSA_FLAG);
	return GeniResponse->Create(GENIRESPONSE_ERROR)
	    if (!defined($credential));

	return GeniResponse->Create(GENIRESPONSE_SUCCESS,
				    $credential->asString());
    }
    # Currently accept either a UUID or a URN, but not both.  Once we
    # have migrated the federation to URNs, UUID support will be removed.
    return GeniResponse->MalformedArgsResponse()
	if( defined( $uuid ) == defined( $urn ) );
    return GeniResponse->MalformedArgsResponse()
	if( defined( $uuid ) && $uuid !~ /^[-\w]*$/ );
    return GeniResponse->MalformedArgsResponse()
	if( defined( $urn ) && !GeniHRN::IsValid( $urn ) );

    my $credential = GeniCredential->CreateFromSigned($cred);
    if (!defined($credential)) {
	return GeniResponse->Create(GENIRESPONSE_ERROR, undef,
				    "Could not create GeniCredential object");
    }

    #
    # Make sure the credential was issued to the caller.
    #
    if ($credential->owner_uuid() ne $ENV{'GENIUUID'}) {
	return GeniResponse->Create(GENIRESPONSE_ERROR, undef,
				    "This is not your credential!");
    }
    #
    # And that the target of the credential is this registry.
    #
    my $authority = GeniAuthority->Lookup($ENV{'MYUUID'});
    if (!defined($authority)) {
	print STDERR "Could not find local authority object\n";
	return GeniResponse->Create(GENIRESPONSE_ERROR);
    }
    if ($credential->target_uuid() ne $authority->uuid()) {
	return GeniResponse->Create(GENIRESPONSE_FORBIDDEN,
				    undef, "This is not your registry!");
    }

    $credential->HasPrivilege( "authority" ) or
	$credential->HasPrivilege( "resolve" ) or
	return GeniResponse->Create( GENIRESPONSE_FORBIDDEN, undef,
				     "Insufficient privilege" );

    my $this_user = GeniUser->Lookup($credential->owner_uuid(), 1);
    if (!defined($this_user)) {
	return GeniResponse->Create(GENIRESPONSE_FORBIDDEN,
				    undef, "Who are you?");
    }
    
    #
    # User provided a credential, and wants a new credential to access
    # the object referenced by the URN.
    #
    if ($type eq "Slice") {
	my $slice = GeniSlice->Lookup( defined( $urn ) ? $urn : $uuid );

	return GeniResponse->Create(GENIRESPONSE_SEARCHFAILED, undef,
				    "No such Slice")
	    if (!defined($slice));
	if ($slice->Lock() != 0) {
	    return GeniResponse->BusyResponse("slice");
	}
	if ($slice->creator_uuid() ne $this_user->uuid() &&
	    !$slice->IsBound($this_user)) {
	    $slice->UnLock();
	    return GeniResponse->Create(GENIRESPONSE_FORBIDDEN, undef,
					"Not your slice!");
	}
	#
	# Return a credential for the slice.
	#
	my $slice_credential =
	    GeniCredential->CreateSigned($slice,
					 $this_user,
					 $GeniCredential::LOCALSA_FLAG);
	if (!defined($slice_credential)) {
	    $slice->UnLock();
	    return GeniResponse->Create(GENIRESPONSE_ERROR);
	}
	$slice->UnLock();
	return GeniResponse->Create(GENIRESPONSE_SUCCESS,
				    $slice_credential->asString());
    }
    
    return GeniResponse->Create(GENIRESPONSE_UNSUPPORTED);
}

#
# Resolve a uuid or HRN to a record.
#
sub Resolve($)
{
    my ($argref) = @_;
    my $uuid = $argref->{'uuid'};
    my $hrn  = $argref->{'hrn'};
    my $cred = $argref->{'credential'};
    my $type = $argref->{'type'};

    # Allow lookup by uuid or hrn.
    if (! (defined($uuid) || defined($hrn))) {
	return GeniResponse->MalformedArgsResponse();
    }
    if (defined($uuid) && !($uuid =~ /^[-\w]*$/)) {
	return GeniResponse->MalformedArgsResponse();
    }
    if (defined($hrn) && !($hrn =~ /^[-\w\.]*$/) &&
	!GeniHRN::IsValid( $hrn ) ) {
	return GeniResponse->MalformedArgsResponse();
    }
    if (! (defined($type) && ($type =~ /^(SA|MA|Component|Slice|User)$/i))) {
	return GeniResponse->MalformedArgsResponse();
    }
    $type = lc($type);
    if (! defined($cred)) {
	return GeniResponse->MalformedArgsResponse();
    }
    
    my $credential = GeniCredential->CreateFromSigned($cred);
    if (!defined($credential)) {
	return GeniResponse->Create(GENIRESPONSE_ERROR, undef,
				    "Could not create GeniCredential object");
    }

    #
    # Make sure the credential was issued to the caller.
    #
    if ($credential->owner_uuid() ne $ENV{'GENIUUID'}) {
	return GeniResponse->Create(GENIRESPONSE_ERROR, undef,
				    "This is not your credential!");
    }
    #
    # And that the target of the credential is this registry.
    #
    my $authority = GeniAuthority->Lookup($ENV{'MYUUID'});
    if (!defined($authority)) {
	print STDERR "Could not find local authority object\n";
	return GeniResponse->Create(GENIRESPONSE_ERROR);
    }
    if ($credential->target_uuid() ne $authority->uuid()) {
	return GeniResponse->Create(GENIRESPONSE_FORBIDDEN,
				    undef, "This is not your registry!");
    }

    $credential->HasPrivilege( "authority" ) or
	$credential->HasPrivilege( "resolve" ) or
	return GeniResponse->Create( GENIRESPONSE_FORBIDDEN, undef,
				     "Insufficient privilege" );

    #
    # We need to enforce Emulab permissions here, since the credential
    # allows anyone with a credential for this registry to lookup anyone
    # else. Good feature of the Geni API.
    #
    my $this_user = GeniUser->Lookup($credential->owner_uuid(), 1);
    if (!defined($this_user)) {
	return GeniResponse->Create(GENIRESPONSE_FORBIDDEN,
				    undef, "Who are you?");
    }
    
    if ($type eq "user") {
	my $geniuser;
	
	if (defined($uuid)) {
	    $geniuser = GeniUser->Lookup($uuid, 1);
	}
	elsif( GeniHRN::IsValid( $hrn ) ) {
	    $geniuser = GeniUser->Lookup($hrn, 1);
	} else {
	    #
	    # Deprecated (pre-URN) HRN.
	    # XXX Form hrn from the uid and domain. This is backwards.
	    #
	    if (! ($hrn =~ /\./)) {
		$hrn = "${PGENIDOMAIN}.${hrn}";
	    }
	    $geniuser = GeniUser->Lookup($hrn, 1);
	}
	if (!defined($geniuser)) {
	    return GeniResponse->Create(GENIRESPONSE_SEARCHFAILED,
					undef, "No one here by that name");
	}

	my @slices = GeniSlice->LookupByCreator( $geniuser );
	my @sliceURNs = map( GeniHRN::Generate( $OURDOMAIN, "slice",
						$_->slicename() ), @slices );

	# Return a blob.
	my $blob = { "uid"      => $geniuser->uid(),
		     "hrn"      => $geniuser->hrn(),
		     "uuid"     => $geniuser->uuid(),
		     "email"    => $geniuser->email(),
		     "gid"      => $geniuser->cert(),
		     "name"     => $geniuser->name(),
		     "slices"   => \@sliceURNs
		    };
	
	return GeniResponse->Create(GENIRESPONSE_SUCCESS, $blob);
    }
    if ($type eq "slice") {
	my $slice;
	
	if (defined($uuid)) {
	    $slice = GeniSlice->Lookup($uuid);
	}
	elsif( GeniHRN::IsValid( $hrn ) ) {
	    $slice = GeniSlice->Lookup($hrn);
	} else {
	    #
	    # Deprecated (pre-URN) HRN.
	    # XXX Form hrn from the uid and domain. This is backwards.
	    #
	    if (! ($hrn =~ /\./)) {
		$hrn = "${PGENIDOMAIN}.${hrn}";
	    }
	    $slice = GeniSlice->Lookup($hrn);
	}
	if (!defined($slice)) {
	    return GeniResponse->Create(GENIRESPONSE_SEARCHFAILED, undef,
					"No such slice registered here");
	}
	if ($slice->Lock() != 0) {
	    return GeniResponse->BusyResponse("slice");
	}
	# Return a blob.
	my $blob = { "hrn"          => $slice->hrn(),
		     "uuid"         => $slice->uuid(),
		     "creator_uuid" => $slice->creator_uuid(),
		     "gid"          => $slice->cert(),
		     "urn"          => GeniHRN::Generate( $OURDOMAIN,
							  "slice",
							  $slice->slicename() )
		 };
	$slice->UnLock();
	return GeniResponse->Create(GENIRESPONSE_SUCCESS, $blob);
    }
    
    return GeniResponse->Create(GENIRESPONSE_UNSUPPORTED);
}

#
# Register a new Geni object. Currently, just slices. Also, the
# certificate and uuid are generated here, not by the caller. The Geni
# API says that the caller provides that, but I see that as being
# silly and more work then the user needs to deal with. 
#
sub Register($)
{
    # FIXME once migration to URNs is complete, $type should be removed
    # (it's deduced automatically from the URN).
    my ($argref) = @_;
    my $cred  = $argref->{'credential'};
    my $type  = $argref->{'type'};
    my $hrn   = $argref->{'hrn'};

    if (! defined($hrn)) {
	return GeniResponse->MalformedArgsResponse();
    }

    return GeniResponse->Create(GENIRESPONSE_ERROR, undef,
				"Invalid URN")
	if( !GeniHRN::IsValid( $hrn ) && $hrn !~ /^[-\w\.]*$/);

    if( GeniHRN::IsValid( $hrn ) ) {
	my ($auth,$t,$id) = GeniHRN::Parse( $hrn );

	return GeniResponse->Create( GENIRESPONSE_ERROR, undef,
				     "Authority mismatch" )
	    if( $auth ne $OURDOMAIN );
	
	$type = $t;

	$hrn = $id;
    }

    my $credential = GeniCredential->CreateFromSigned($cred);
    if (!defined($credential)) {
	return GeniResponse->Create(GENIRESPONSE_ERROR, undef,
				    "Could not create GeniCredential object");
    }

    #
    # Make sure the credential was issued to the caller.
    #
    if ($credential->owner_uuid() ne $ENV{'GENIUUID'}) {
	return GeniResponse->Create(GENIRESPONSE_ERROR, undef,
				    "This is not your credential!");
    }
    #
    # And that the target of the credential is this registry.
    #
    my $authority = GeniAuthority->Lookup($ENV{'MYUUID'});
    if (!defined($authority)) {
	print STDERR "Could not find local authority object\n";
	return GeniResponse->Create(GENIRESPONSE_ERROR);
    }
    if ($credential->target_uuid() ne $authority->uuid()) {
	return GeniResponse->Create(GENIRESPONSE_FORBIDDEN,
				    undef, "This is not your registry!");
    }

    $credential->HasPrivilege( "authority" ) or
	$credential->HasPrivilege( "refresh" ) or
	return GeniResponse->Create( GENIRESPONSE_FORBIDDEN, undef,
				     "Insufficient privilege" );

    #
    # We need to enforce Emulab permissions here, since the credential
    # allows anyone with a credential for this registry to lookup anyone
    # else. Good feature of the Geni API.
    #
    my $this_user = GeniUser->Lookup($credential->owner_uuid(), 1);
    if (!defined($this_user)) {
	return GeniResponse->Create(GENIRESPONSE_FORBIDDEN,
				    undef, "Who are you?");
    }
    
    if ( lc( $type ) eq "slice") {
	my $userbindings = $argref->{'userbindings'};
	my $expires = $argref->{'expiration'};
	
	if (! ($hrn =~ /^[-\w]+$/)) {
	    return GeniResponse->Create(GENIRESPONSE_ERROR, undef,
					"hrn: Single token only please");
	}

	#
	# Make sure the user creating the slice is registered at the
	# clearinghouse. Ditto for anyone bound to the slice.
	#
	if ($this_user->Register() != 0) {
	    print STDERR "Could not register $this_user at clearinghouse\n";
	    return GeniResponse->Create(GENIRESPONSE_ERROR);
	}
	if (0 && defined($userbindings)) {
	    foreach my $binding_uuid (@{ $userbindings }) {
		my $binding_user = GeniUser->Lookup($binding_uuid, 1);
		if (!defined($binding_user)) {
		    print STDERR "No user $binding_uuid to bind to slice\n";
		    return GeniResponse->Create(GENIRESPONSE_ERROR);
		}
		if ($binding_user->Register() != 0) {
		    print STDERR
			"Could not register $binding_user at clearinghouse\n";
		    return GeniResponse->Create(GENIRESPONSE_ERROR);
		}
	    }
	}

	#
	# Figure out new expiration time; this is the time at which we can
	# idleswap the slice out. 
	#
	if (defined($expires)) {
	    my $message;
		
	    if (! ($expires =~ /^[-\w:.\/]+/)) {
		$message = "Illegal valid_until in rspec";
		goto bad;
	    }
	    # Convert to a localtime.
	    my $when = timegm(strptime($expires));
	    if (!defined($when)) {
		$message = "Could not parse valid_until";
		goto bad;
	    }
	    #
	    # Do we need a policy limit?
	    #
	    my $diff = $when - time();

	    if ($diff < (60 * 5) || $diff > (3600 * 24 * 90)) {
		$message = "valid_until out of range";
		goto bad;
	    }
	  bad:
	    if (defined($message)) {
		return GeniResponse->Create(GENIRESPONSE_ERROR, undef, $message);
	    }
	    $expires = $when;
	}
	
	my $urn = GeniHRN::Generate( "@OURDOMAIN@", "slice", $hrn );
	#
	# When using this interface, the HRN does not correspond to an
	# existing experiment in a project. It is just a token to call
	# the slice (appended to our DOMAIN).
	#
	# XXX Form hrn from the uid and domain. This is backwards.
	#
	my $hrn = "${PGENIDOMAIN}.${hrn}";

	#
	# Generate a certificate (and uuid) for this new slice.
	#
	my $certificate = GeniCertificate->Create("slice", $urn, $hrn,
						  $this_user->email());
	if (!defined($certificate)) {
	    print STDERR "Could not create new certificate for slice\n";
	    return GeniResponse->Create(GENIRESPONSE_ERROR);
	}
	my $uuid = $certificate->uuid();
	
	#
	# Make sure slice hrn and uuid are unique. Locking?
	#
	if (GeniSlice->CheckExisting($hrn, $uuid)) {
	    $certificate->Delete();
	    return GeniResponse->Create(GENIRESPONSE_ERROR, undef,
					"$hrn or $uuid already registered");
	}
	# Slice is created as locked.
	my $slice = GeniSlice->Create($certificate,
				      $credential->owner_uuid(),
				      $authority, undef, 1);
	if (!defined($slice)) {
	    $certificate->Delete();
	    print STDERR "Could not create new slice object\n";
	    return GeniResponse->Create(GENIRESPONSE_ERROR);
	}
	
	if (defined($expires) && $slice->SetExpiration($expires) != 0) {
	    print STDERR "Could not set slice expiration to $expires\n";
	    $slice->Delete();
	    return GeniResponse->Create(GENIRESPONSE_ERROR);
	}

	#
	# Return a credential for the slice.
	#
	my $slice_credential =
	    GeniCredential->CreateSigned($slice,
					 $this_user,
					 $GeniCredential::LOCALSA_FLAG);
	if (!defined($slice_credential)) {
	    $slice->Delete();
	    return GeniResponse->Create(GENIRESPONSE_ERROR);
	}

	#
	# Register new slice at the clearinghouse.
	#
	if ($slice->Register() != 0) {
	    $slice_credential->Delete();
	    $slice->Delete();
	    print STDERR "Could not register new slice at the clearinghouse\n";
	    return GeniResponse->Create(GENIRESPONSE_ERROR, undef,
			"Could not register new slice at clearinghouse");
	}
	$slice->UnLock();
	return GeniResponse->Create(GENIRESPONSE_SUCCESS,
				    $slice_credential->asString());
    }

    return GeniResponse->Create(GENIRESPONSE_UNSUPPORTED);
}

#
# Remove record.
#
sub Remove($)
{
    # FIXME once migration to URNs is complete, $type should be removed
    # (it's deduced automatically from the URN).  $uuid should die, too.
    my ($argref) = @_;
    my $uuid = $argref->{'uuid'};
    my $hrn  = $argref->{'hrn'};
    my $cred = $argref->{'credential'};
    my $type = lc( $argref->{'type'} );

    if( defined( $hrn ) && GeniHRN::IsValid( $hrn ) ) {
	# this is pretty ugly, but since this section will have to be
	# cleaned up eventually to remove support for deprecated HRNs,
	# it will do for now.
	my ($auth,$t,$id) = GeniHRN::Parse( $hrn );

	return GeniResponse->Create( GENIRESPONSE_ERROR, undef,
				     "Authority mismatch" )
	    if( $auth ne $OURDOMAIN );

	$type = lc( $t );
	
	$hrn = $id;
    }

    if (! (defined($uuid) || defined($hrn))) {
	return GeniResponse->MalformedArgsResponse();
    }
    if (defined($uuid) && !($uuid =~ /^[-\w]*$/)) {
	return GeniResponse->MalformedArgsResponse();
    }
    if (defined($hrn) && !($hrn =~ /^[-\w\.]*$/)) {
	return GeniResponse->MalformedArgsResponse();
    }
    if (! (defined($type) && ($type =~ /^(sa|ma|component|slice|user)$/))) {
	return GeniResponse->MalformedArgsResponse();
    }
    if (! defined($cred)) {
	return GeniResponse->MalformedArgsResponse();
    }
    
    my $credential = GeniCredential->CreateFromSigned($cred);
    if (!defined($credential)) {
	return GeniResponse->Create(GENIRESPONSE_ERROR, undef,
				    "Could not create GeniCredential object");
    }

    #
    # Make sure the credential was issued to the caller.
    #
    if ($credential->owner_uuid() ne $ENV{'GENIUUID'}) {
	return GeniResponse->Create(GENIRESPONSE_ERROR, undef,
				    "This is not your credential!");
    }
    #
    # And that the target of the credential is this registry.
    #
    my $authority = GeniAuthority->Lookup($ENV{'MYUUID'});
    if (!defined($authority)) {
	print STDERR "Could not find local authority object\n";
	return GeniResponse->Create(GENIRESPONSE_ERROR);
    }
    if ($credential->target_uuid() ne $authority->uuid()) {
	return GeniResponse->Create(GENIRESPONSE_FORBIDDEN,
				    undef, "This is not your registry!");
    }

    $credential->HasPrivilege( "authority" ) or
	$credential->HasPrivilege( "refresh" ) or
	return GeniResponse->Create( GENIRESPONSE_FORBIDDEN, undef,
				     "Insufficient privilege" );

    #
    # We need to enforce Emulab permissions here, since the credential
    # allows anyone with a credential for this registry to lookup anyone
    # else. Good feature of the Geni API.
    #
    my $this_user = GeniUser->Lookup($credential->owner_uuid(), 1);
    if (!defined($this_user)) {
	return GeniResponse->Create(GENIRESPONSE_FORBIDDEN,
				    undef, "Who are you?");
    }
    
    if ($type eq "slice") {
	my $slice;
	
	if (defined($uuid)) {
	    $slice = GeniSlice->Lookup($uuid);
	}
	else {
	    #
	    # XXX Form hrn from the uid and domain. This is backwards.
	    #
	    if (! ($hrn =~ /\./)) {
		$hrn = "${PGENIDOMAIN}.${hrn}";
	    }
	    $slice = GeniSlice->Lookup($hrn);
	}
	if (!defined($slice)) {
	    return GeniResponse->Create(GENIRESPONSE_SEARCHFAILED, undef,
					"No such slice");
	}
	if ($slice->Lock() != 0) {
	    return GeniResponse->BusyResponse("slice");
	}
	#
	# Not allowed to delete a cooked mode slice via this interface.
	#
	if ($slice->exptidx()) {
	    $slice->UnLock();
	    return GeniResponse->Create(GENIRESPONSE_REFUSED, undef,
					"Cooked mode Slice");
	}
	
	#
	# Not allowed to delete a slice that has not expired since
	# that would make it impossible to control any existing
	# slivers.
	#
	if (! $slice->IsExpired()) {
	    $slice->UnLock();
	    return GeniResponse->Create(GENIRESPONSE_REFUSED, undef,
					"Slice has not expired");
	}
	# Needs to move.
	GeniRegistry::ClientSliver->SliceDelete($slice);
	
	#
	# Remove from the clearing house.
	#
	if ($slice->UnRegister()) {
	    print STDERR "Could not delete $slice from clearinghouse!\n";
	    $slice->UnLock();
	    return GeniResponse->Create(GENIRESPONSE_ERROR, undef,
					(defined($uuid)?$uuid:$hrn)
					. " could not be unregistered");
	}
	if ($slice->Delete()) {
	    print STDERR "Could not delete $slice from SA!\n";
	    return GeniResponse->Create(GENIRESPONSE_ERROR, undef,
					(defined($uuid)?$uuid:$hrn)
					. " could not be unregistered");
	}
	return GeniResponse->Create(GENIRESPONSE_SUCCESS);
    }
    
    return GeniResponse->Create(GENIRESPONSE_UNSUPPORTED);
}

#
# Return ssh keys.
#
sub GetKeys($)
{
    my ($argref) = @_;
    my $cred  = $argref->{'credential'};

    if (! defined($cred)) {
	return GeniResponse->MalformedArgsResponse();
    }
    my $credential = GeniCredential->CreateFromSigned($cred);
    if (!defined($credential)) {
	return GeniResponse->Create(GENIRESPONSE_ERROR, undef,
				    "Could not create GeniCredential object");
    }

    #
    # Make sure the credential was issued to the caller.
    #
    if ($credential->owner_uuid() ne $ENV{'GENIUUID'}) {
	return GeniResponse->Create(GENIRESPONSE_ERROR, undef,
				    "This is not your credential!");
    }
    #
    # And that the target of the credential is this registry.
    #
    my $authority = GeniAuthority->Lookup($ENV{'MYUUID'});
    if (!defined($authority)) {
	print STDERR "Could not find local authority object\n";
	return GeniResponse->Create(GENIRESPONSE_ERROR);
    }
    if ($credential->target_uuid() ne $authority->uuid()) {
	return GeniResponse->Create(GENIRESPONSE_FORBIDDEN,
				    undef, "This is not your registry!");
    }

    $credential->HasPrivilege( "authority" ) or
	$credential->HasPrivilege( "resolve" ) or
	return GeniResponse->Create( GENIRESPONSE_FORBIDDEN, undef,
				     "Insufficient privilege" );

    my $this_user = GeniUser->Lookup($credential->owner_uuid(), 1);
    if (!defined($this_user)) {
	return GeniResponse->Create(GENIRESPONSE_FORBIDDEN,
				    undef, "Who are you?");
    }
    my @keys;
    if ($this_user->GetKeyBundle(\@keys) != 0) {
	print STDERR "Could not get keys for $this_user\n";
	return GeniResponse->Create(GENIRESPONSE_ERROR);	
    }
    return GeniResponse->Create(GENIRESPONSE_SUCCESS, \@keys);
}

#
# Bind a user to a slice. The slice creator does this so that the target
# user can request his own credential to manipulate the slice. This is in
# leu of delegation.
#
sub BindToSlice($)
{
    my ($argref) = @_;
    my $cred  = $argref->{'credential'};
    my $uuid  = $argref->{'uuid'};

    if (!defined($uuid) || !defined($cred)) {
	return GeniResponse->MalformedArgsResponse();
    }
    if (!($uuid =~ /^[-\w]*$/)) {
	return GeniResponse->MalformedArgsResponse();
    }
    my $credential = GeniCredential->CreateFromSigned($cred);
    if (!defined($credential)) {
	return GeniResponse->Create(GENIRESPONSE_ERROR, undef,
				    "Could not create GeniCredential object");
    }

    #
    # Make sure the credential was issued to the caller.
    #
    if ($credential->owner_uuid() ne $ENV{'GENIUUID'}) {
	return GeniResponse->Create(GENIRESPONSE_ERROR, undef,
				    "This is not your credential!");
    }
    my $this_user = GeniUser->Lookup($credential->owner_uuid(), 1);
    if (!defined($this_user)) {
	return GeniResponse->Create(GENIRESPONSE_FORBIDDEN,
				    undef, "Who are you?");
    }
    my $slice = GeniSlice->Lookup($credential->target_uuid());
    if (!defined($slice)) {
	return GeniResponse->Create(GENIRESPONSE_ERROR, undef,
				    "Unknown slice for this credential");
    }
    
    $credential->HasPrivilege( "pi" ) or
	$credential->HasPrivilege( "bind" ) or
	return GeniResponse->Create( GENIRESPONSE_FORBIDDEN, undef,
				     "Insufficient privilege" );

    #
    # Locate the target user; must exist locally.
    #
    my $target_user = GeniUser->Lookup($uuid, 1);
    if (!defined($target_user)) {
	return GeniResponse->Create(GENIRESPONSE_SEARCHFAILED,
				    undef, "No such user here");
    }
    if ($slice->Lock() != 0) {
	return GeniResponse->BusyResponse("slice");
    }
    if ($slice->BindUser($target_user) != 0) {
	print STDERR "Could not bind $target_user to $slice\n";
	$slice->UnLock();
	return GeniResponse->Create(GENIRESPONSE_ERROR);
    }
    $slice->UnLock();
    return GeniResponse->Create(GENIRESPONSE_SUCCESS);
}

#
# Emergency shutdown a slice. This cannot be undone via this interface.
# An Emulab admin will have to do that.
#
sub Shutdown($)
{
    my ($argref) = @_;
    my $cred  = $argref->{'credential'};

    if (!defined($cred)) {
	return GeniResponse->MalformedArgsResponse();
    }
    my $credential = GeniCredential->CreateFromSigned($cred);
    if (!defined($credential)) {
	return GeniResponse->Create(GENIRESPONSE_ERROR, undef,
				    "Could not create GeniCredential object");
    }

    #
    # Make sure the credential was issued to the caller.
    #
    if ($credential->owner_uuid() ne $ENV{'GENIUUID'}) {
	return GeniResponse->Create(GENIRESPONSE_ERROR, undef,
				    "This is not your credential!");
    }
    my $slice_uuid = $credential->target_uuid();
    my $slice = GeniSlice->Lookup($slice_uuid);
    if (!defined($slice)) {
	return GeniResponse->Create(GENIRESPONSE_ERROR, undef,
				    "Unknown slice for this credential");
    }
    $credential->HasPrivilege( "pi" ) or
	$credential->HasPrivilege( "control" ) or
	return GeniResponse->Create( GENIRESPONSE_FORBIDDEN, undef,
				     "Insufficient privilege" );
    system("$SLICESHUTDOWN $slice_uuid");
    if ($?) {
	print STDERR "Could not shutdown $slice!\n";
	return GeniResponse->Create(GENIRESPONSE_ERROR, undef,
				    "Error shutting down slice");
    }
    return GeniResponse->Create(GENIRESPONSE_SUCCESS);
}

#
# Extend a slice expiration time.
#
sub RenewSlice($)
{
    my ($argref) = @_;
    my $credstr = $argref->{'credential'};
    my $expires = $argref->{'expiration'};
    my $message = "Error renewing slice";

    if (! (defined($credstr) && defined($expires))) {
	return GeniResponse->Create(GENIRESPONSE_BADARGS);
    }
    my $credential = GeniCredential->CreateFromSigned($credstr);
    if (!defined($credential)) {
	return GeniResponse->Create(GENIRESPONSE_ERROR, undef,
				    "Could not create GeniCredential object");
    }

    #
    # Make sure the credential was issued to the caller.
    #
    if ($credential->owner_uuid() ne $ENV{'GENIUUID'}) {
	return GeniResponse->Create(GENIRESPONSE_ERROR, undef,
				    "This is not your credential!");
    }
    my $slice = GeniSlice->Lookup($credential->target_uuid());
    if (!defined($slice)) {
	return GeniResponse->Create(GENIRESPONSE_ERROR, undef,
				    "Unknown slice for this credential");
    }
    #
    # Not allowed to renew a cooked mode slice via this interface.
    #
    if ($slice->exptidx()) {
	return GeniResponse->Create(GENIRESPONSE_REFUSED, undef,
				    "Cooked mode Slice");
    }
    
    $credential->HasPrivilege( "pi" ) or
	$credential->HasPrivilege( "bind" ) or
	return GeniResponse->Create( GENIRESPONSE_FORBIDDEN, undef,
				     "Insufficient privilege" );

    #
    # Figure out new expiration time; this is the time at which we can
    # idleswap the slice out. 
    #
    if (! ($expires =~ /^[-\w:.\/]+/)) {
	$message = "Illegal characters in expiration";
	goto bad;
    }
    # Convert to a localtime.
    my $when = timegm(strptime($expires));
    if (!defined($when)) {
	$message = "Could not parse expiration";
	goto bad;
    }
    #
    # Do we need a policy limit?
    #
    my $diff = $when - time();

    if ($diff < (60 * 5) || $diff > (3600 * 24 * 90)) {
	$message = "expiration out of range";
	goto bad;
    }
    if ($when < time()) {
	$message = "Expiration is in the past";
	goto bad;
    }
    if ($slice->Lock() != 0) {
	return GeniResponse->BusyResponse("slice");
    }
    if ($slice->SetExpiration($when) != 0) {
	$message = "Could not set expiration time";
	$slice->UnLock();
	goto bad;
    }
    $slice->UnLock();
    return GeniResponse->Create(GENIRESPONSE_SUCCESS);

  bad:
    return GeniResponse->Create(GENIRESPONSE_ERROR, undef, $message);
}

#
# Register a sliver.
#
sub RegisterSliver($)
{
    my ($argref) = @_;
    my $credstr  = $argref->{'credential'};
    my $slice_urn= $argref->{'slice_urn'};
    my $blob     = $argref->{'info'};

    if (! (defined($blob) && defined($slice_urn) && defined($credstr))) {
	return GeniResponse->MalformedArgsResponse("Missing Arguments");
    }
    if (!GeniHRN::IsValid($slice_urn)) {
	return GeniResponse->MalformedArgsResponse("Bad URN");
    }
    my $credential = GeniCredential->CreateFromSigned($credstr);
    if (!defined($credential)) {
	return GeniResponse->Create(GENIRESPONSE_ERROR, undef,
				    "Could not create GeniCredential object");
    }

    #
    # Make sure the credential was issued to the caller.
    #
    if ($credential->owner_uuid() ne $ENV{'GENIUUID'}) {
	return GeniResponse->Create(GENIRESPONSE_ERROR, undef,
				    "This is not your credential!");
    }
    #
    # And that the target of the credential is this registry.
    #
    my $authority = GeniAuthority->Lookup($ENV{'MYUUID'});
    if (!defined($authority)) {
	print STDERR "Could not find local authority object\n";
	return GeniResponse->Create(GENIRESPONSE_ERROR);
    }
    if ($credential->target_uuid() ne $authority->uuid()) {
	return GeniResponse->Create(GENIRESPONSE_FORBIDDEN,
				    undef, "This is not your registry!");
    }

    $credential->HasPrivilege( "authority" ) or
	return GeniResponse->Create( GENIRESPONSE_FORBIDDEN, undef,
				     "Insufficient privilege" );

    my $slice = GeniSlice->Lookup($slice_urn);
    if (!defined($slice)) {
	return GeniResponse->Create(GENIRESPONSE_SEARCHFAILED, undef,
				    "No such slice here");
    }
    # The user is embedded in the blob.
    if (!exists($blob->{'creator_urn'})) {
	return GeniResponse->MalformedArgsResponse("Please tell me creator");
    }
    my $user = GeniUser->Lookup($blob->{'creator_urn'}, 1);
    if (!defined($user)) {
	return GeniResponse->Create(GENIRESPONSE_SEARCHFAILED, undef,
				    "No such user here");
    }
    if (!exists($blob->{'urn'})) {
	return GeniResponse->MalformedArgsResponse("Please tell me the urn");
    }
    my $manager_urn = $credential->owner_cert()->urn();
    if (!defined($manager_urn)) {
	print STDERR "No URN in $credential\n";
	return GeniResponse->Create(GENIRESPONSE_ERROR);
    }
    if ($slice->Lock() != 0) {
	return GeniResponse->BusyResponse("slice");
    }
    #
    # See if one already exists; overwrite it.
    #
    my $clientsliver =
	GeniRegistry::ClientSliver->LookupByAuthority($slice, $manager_urn);
    $clientsliver->Delete()
	if (defined($clientsliver));
    
    $clientsliver =
	GeniRegistry::ClientSliver->Create($slice, $manager_urn, $user, $blob);
    if (!defined($clientsliver)) {
	print STDERR "Could not register sliver for $slice_urn\n";
	print STDERR Dumper($blob);
	$slice->UnLock();
	return GeniResponse->Create(GENIRESPONSE_ERROR);
    }
    $slice->UnLock();
    return GeniResponse->Create(GENIRESPONSE_SUCCESS);
}

#
# UnRegister a sliver.
#
sub UnRegisterSliver($)
{
    my ($argref) = @_;
    my $credstr  = $argref->{'credential'};
    my $slice_urn= $argref->{'slice_urn'};

    if (! (defined($slice_urn) && defined($credstr))) {
	return GeniResponse->MalformedArgsResponse("Missing Arguments");
    }
    if (!GeniHRN::IsValid($slice_urn)) {
	return GeniResponse->MalformedArgsResponse("Bad URN");
    }
    my $credential = GeniCredential->CreateFromSigned($credstr);
    if (!defined($credential)) {
	return GeniResponse->Create(GENIRESPONSE_ERROR, undef,
				    "Could not create GeniCredential object");
    }

    #
    # Make sure the credential was issued to the caller.
    #
    if ($credential->owner_uuid() ne $ENV{'GENIUUID'}) {
	return GeniResponse->Create(GENIRESPONSE_ERROR, undef,
				    "This is not your credential!");
    }
    #
    # And that the target of the credential is this registry.
    #
    my $authority = GeniAuthority->Lookup($ENV{'MYUUID'});
    if (!defined($authority)) {
	print STDERR "Could not find local authority object\n";
	return GeniResponse->Create(GENIRESPONSE_ERROR);
    }
    if ($credential->target_uuid() ne $authority->uuid()) {
	return GeniResponse->Create(GENIRESPONSE_FORBIDDEN,
				    undef, "This is not your registry!");
    }

    $credential->HasPrivilege( "authority" ) or
	return GeniResponse->Create( GENIRESPONSE_FORBIDDEN, undef,
				     "Insufficient privilege" );

    my $slice = GeniSlice->Lookup($slice_urn);
    if (!defined($slice)) {
	return GeniResponse->Create(GENIRESPONSE_SEARCHFAILED, undef,
				    "No such slice here");
    }

    my $manager_urn = $credential->owner_cert()->urn();
    if (!defined($manager_urn)) {
	print STDERR "No URN in $credential\n";
	return GeniResponse->Create(GENIRESPONSE_ERROR);
    }
    if ($slice->Lock() != 0) {
	return GeniResponse->BusyResponse("slice");
    }
    #
    # See if one already exists; overwrite it.
    #
    my $clientsliver =
	GeniRegistry::ClientSliver->LookupByAuthority($slice, $manager_urn);

    $clientsliver->Delete()
	if (defined($clientsliver));
    
    $slice->UnLock();
    return GeniResponse->Create(GENIRESPONSE_SUCCESS);
}

# _Always_ make sure that this 1 is at the end of the file...
1;
