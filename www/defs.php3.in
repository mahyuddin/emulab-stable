<?php
#
# Standard definitions! 
#
$TBDIR          = "@prefix@/";
$OURDOMAIN      = "@OURDOMAIN@";
$BOSSNODE       = "@BOSSNODE@";
$USERNODE       = "@USERNODE@";
$TBADMINGROUP   = "@TBADMINGROUP@";
$WWWHOST	= "@WWWHOST@";
$WWW		= "@WWW@";
$TBAUTHDOMAIN	= "@TBAUTHDOMAIN@";
$TBBASE		= "@TBBASE@";
$TBDOCBASE	= "@TBDOCBASE@";
$TBWWW		= "@TBWWW@";
$THISHOMEBASE	= "@THISHOMEBASE@";

$TBMAILADDR_OPS		= "@TBOPSEMAIL_NOSLASH@";
$TBMAILADDR_WWW		= "@TBWWWEMAIL_NOSLASH@";
$TBMAILADDR_APPROVAL	= "@TBAPPROVALEMAIL_NOSLASH@";
$TBMAILADDR_LOGS	= "@TBLOGSEMAIL_NOSLASH@";
$TBMAILADDR_AUDIT	= "@TBAUDITEMAIL_NOSLASH@";

# Can override this in the defs file. 
$TBAUTHTIMEOUT  = "@TBAUTHTIMEOUT@";
$TBMAINSITE     = "@TBMAINSITE@";
$TBSECURECOOKIES= "@TBSECURECOOKIES@";
$TBCOOKIESUFFIX = "@TBCOOKIESUFFIX@";

$TBWWW_DIR	= "$TBDIR"."www/";
$TBBIN_DIR	= "$TBDIR"."bin/";
$TBETC_DIR	= "$TBDIR"."etc/";
$TBLIBEXEC_DIR	= "$TBDIR"."libexec/";
$TBSUEXEC_PATH  = "$TBLIBEXEC_DIR/suexec";
$TBCHKPASS_PATH = "$TBLIBEXEC_DIR/checkpass";
$TBCSLOGINS     = "$TBETC_DIR/cslogins";

#
# Hardcoded check against $WWWHOST, to prevent anyone from accidentally setting
# $TBMAINSITE when it should not be
#
if ($WWWHOST != "www.emulab.net") {
    $TBMAINSITE = 0;
}

$TBPROJ_DIR     = "/proj";
$TBUSER_DIR	= "/users";
$TBGROUP_DIR	= "/groups";
$TBNSSUBDIR     = "nsdir";

$TBAUTHCOOKIE   = "HashCookie" . $TBCOOKIESUFFIX;
$TBNAMECOOKIE   = "MyUidCookie" . $TBCOOKIESUFFIX;
$TBLOGINCOOKIE  = "LoginCookie" . $TBCOOKIESUFFIX;

$HTTPTAG        = "http://";

$TBMAIL_OPS		= "Testbed Ops <$TBMAILADDR_OPS>";
$TBMAIL_WWW		= "Testbed WWW <$TBMAILADDR_WWW>";
$TBMAIL_APPROVAL	= "Testbed Approval <$TBMAILADDR_APPROVAL>";
$TBMAIL_LOGS		= "Testbed Logs <$TBMAILADDR_LOGS>";
$TBMAIL_AUDIT		= "Testbed Audit <$TBMAILADDR_AUDIT>";

#
# This just spits out an email address in a page, so it does not need
# to be configured per development tree. It could be though ...
# 
$TBMAILADDR     = "<a href=\"mailto:$TBMAILADDR_OPS\">
                      Testbed Operations ($TBMAILADDR_OPS)</a>";

# So subscripts always know ...
putenv("HTTP_SCRIPT=1");

#
# Database constants and the like.
#
include("dbdefs.php3");

#
# Control how error messages are returned to the user. If the session is
# not actually "interactive" then do not send any output to the browser.
# Just save it up and let the page deal with it. 
#
$session_interactive  = 1;
$session_errorhandler = 0;

#
# Wrap up the mail function so we can prepend a tag to the subject
# line that indicates what testbed. Useful when multiple testbed
# email to the same list.
#
# 
function TBMAIL($to, $subject, $message, $headers = 0)
{
    global $THISHOMEBASE;
    global $SCRIPT_NAME;

    $subject = strtoupper($THISHOMEBASE) . ": $subject";

    $tag = "X-NetBed: " . basename($SCRIPT_NAME);
    
    if ($headers) {
	$headers = "$headers\n" . $tag;
    }
    else {
	$headers = $tag;
    }
    return mail($to, $subject, $message, $headers);
}

#
# Internal errors should be reported back to the user simply. The actual 
# error information should be emailed to the list for action. The script
# should then terminate if required to do so.
#
function TBERROR ($message, $death, $xmp = 0) {
    global $TBMAIL_WWW, $TBMAIL_OPS, $TBMAILADDR, $TBMAILADDR_OPS;
    global $session_interactive, $session_errorhandler;
    $script = urldecode($_SERVER['REQUEST_URI']);

    TBMAIL($TBMAIL_OPS,
         "WEB ERROR REPORT",
         "\n".
	 "In $script\n\n".
         "$message\n\n".
         "Thanks,\n".
         "Testbed WWW\n",
         "From: $TBMAIL_OPS\n".
         "Errors-To: $TBMAIL_WWW");

    if ($death) {
	if ($session_interactive)
	    PAGEERROR("Could not continue. Please contact $TBMAILADDR");
	elseif ($session_errorhandler) {
	    $session_errorhandler("Could not continue. ".
				  "Please contact $TBMAILADDR_OPS", $death);
	}
	exit(1);
    }
    return 0;
}

#
# General user errors should print something warm and fuzzy
#
function USERERROR($message, $death) {
    global $TBMAILADDR;
    global $session_interactive, $session_errorhandler;

    if (! $session_interactive) {
	if ($session_errorhandler)
	    $session_errorhandler($message, $death);
	else
	    echo "$message";

	if ($death)
	    exit(1);
	return;
    }

    $msg = "<font size=+1><br>
            $message
      	    </font>
            <br><br><br>
            <font size=-1>
            Please contact $TBMAILADDR if you feel this message is an error.
            </font>\n";

    if ($death) {
	PAGEERROR($msg);
    }
    else
        echo "$msg\n";
}

#
# A form error.
#
function FORMERROR($field) {
    USERERROR("Missing field; ".
              "Please go back and fill out the \"$field\" field!", 1);
}

#
# A page argument error. 
# 
function PAGEARGERROR($msg = 0) {
    $default = "Invalid page arguments: " . $_SERVER['REQUEST_URI'];

    if ($msg) {
	$default = "$default<br><br>$msg";
    }
    USERERROR($default, 1);
}

#
# SUEXEC stuff.
#
# Save this stuff so we can generate better error messages and such.
# 
$suexec_cmdandargs = "";
$suexec_retval     = 0;
$suexec_output     = "";
$suexec_output_array;

#
# Actions for suexec. 
#
define("SUEXEC_ACTION_CONTINUE",	0);
define("SUEXEC_ACTION_DIE",		1);
define("SUEXEC_ACTION_USERERROR",	2);
define("SUEXEC_ACTION_IGNORE",		3);
define("SUEXEC_ACTION_DUPDIE",		4);

#
# An suexec error.
#
function SUEXECERROR($action)
{
    global $suexec_cmdandargs, $suexec_retval;
    global $suexec_output, $suexec_output_array;

    $foo  = "Shell Program Error. Exit status: $suexec_retval\n";
    $foo .= "  '$suexec_cmdandargs'\n";
    $foo .= "\n";
    $foo .= $suexec_output;

    switch ($action) {
    case SUEXEC_ACTION_CONTINUE:
	TBERROR($foo, 0, 1);
        break;
    case SUEXEC_ACTION_DIE:
	TBERROR($foo, 1, 1);
        break;
    case SUEXEC_ACTION_USERERROR:
	USERERROR("<XMP>$foo</XMP>", 1);
        break;
    case SUEXEC_ACTION_IGNORE:
	break;
    case SUEXEC_ACTION_DUPDIE:
	TBERROR($foo, 0, 1);
	USERERROR("<XMP>$foo</XMP>", 1);
        break;
    default:
	TBERROR($foo, 1, 1);
    }
}

#
# Run a program as a user.
#
function SUEXEC($uid, $gid, $cmdandargs, $action) {
    global $TBSUEXEC_PATH;
    global $suexec_cmdandargs, $suexec_retval;
    global $suexec_output, $suexec_output_array;

    ignore_user_abort(1);

    $suexec_cmdandargs   = "$uid $gid $cmdandargs";
    $suexec_output_array = array();
    $suexec_output       = "";
    $suexec_retval       = 0;
    
    exec("$TBSUEXEC_PATH $suexec_cmdandargs",
	 $suexec_output_array, $suexec_retval);

    # Yikes! Something is not doing integer conversion properly!
    if ($suexec_retval == 255) {
	$suexec_retval = -1;
    }

    if (count($suexec_output_array)) {
	for ($i = 0; $i < count($suexec_output_array); $i++) {
	    $suexec_output .= "$suexec_output_array[$i]\n";
	}
    }

    #
    # The output is still available of course, via $suexec_output.
    # 
    if ($suexec_retval == 0 || $action == SUEXEC_ACTION_IGNORE) {
	return $suexec_retval;
    }
    SUEXECERROR($action);
    # Must return the shell value!
    return $suexec_retval;
}

#
# Invoke the XMLRPC backend. We invoke the xmlrpc server, writing the request
# to its stdin. We then wait for the reply to came back on its stdout. We
# decode that reply, and return an error status and output to the caller.
# Note that we run the backend as the uid/gid, much like we do for plain
# scripts. This might change in the future. 
#
function XMLRPC($uid, $gid, $method, $arghash)
{
    global $TBSUEXEC_PATH;

    $xmlcode = xmlrpc_encode_request($method, array(0.1, $arghash));

    $descriptorspec = array(0 => array("pipe", "r"),
			    1 => array("pipe", "w"));

    $process = proc_open("$TBSUEXEC_PATH $uid $gid webxmlrpc",
			 $descriptorspec, $pipes);

    if (! is_resource($process)) {
	TBERROR("Could not invoke XMLRPC backend!\n".
		"$uid $gid $method\n".
		print_r($arghash, true), 1);
    }
    # $pipes now looks like this:
    # 0 => writeable handle connected to child stdin
    # 1 => readable handle connected to child stdout

    #
    # Write the request to the process, and then close the pipe so that
    # the other side sees the EOF. The sshxmlrpc protocol looks sorta
    # like a POST request, so we have to do that.
    #
    fwrite($pipes[0], "content-length: " . strlen($xmlcode) . "\r\n");
    fwrite($pipes[0], "\r\n");
    fwrite($pipes[0], "$xmlcode");
    fflush($pipes[0]);
    fclose($pipes[0]);

    #
    # Now read back the results into a string. We then convert the string
    # back into a PHP datatype. This datatype is defined outside this code
    # though. 
    #
    # Skip the headers, but we need the content-length.
    #
    $content_length = 0;
    while (!feof($pipes[1]) && ($foo = trim(fgets($pipes[1], 4096)))) {
        if (preg_match("/^content-length: (\d*)/", $foo, $matches)) {
	    $content_length = $matches[1];
	}
    }

    $output = "";
    while(!feof($pipes[1])) {
	$output .= fgets($pipes[1], 1024);
    }
    fclose($pipes[1]);

    # It is important that you close any pipes before calling
    # proc_close in order to avoid a deadlock.
    $return_value = proc_close($process);

    if (!$return_value && $content_length) {
	$decoded = xmlrpc_decode_request(substr($output, 0, $content_length),
					 $meth);
    }

    # On command error or on a "Fault" reply, send email and terminate the
    # script; something went really wrong. 
    if ($return_value || !$content_length ||
	(count($decoded) == 2 &&
	 array_key_exists("faultCode", $decoded) &&
	 array_key_exists("faultString", $decoded)) ||
	!(array_key_exists("code", $decoded) &&
	  array_key_exists("value", $decoded) &&
	  array_key_exists("output", $decoded))) {
	TBERROR("XMLRPC backend failure!\n".
		"$uid $gid $method returned $return_value\n".
		"Arg Hash:\n" .
		print_r($arghash, true) . "\n\n" .
		"XML:\n" .
		"$xmlcode\n\n" .
		"Output:\n" .
		"$output\n", 1);
    }
    return $decoded;
}

function ADDPUBKEY($uid, $cmdandargs) {
    global $TBSUEXEC_PATH;

    #
    # Complication. User might not have an actual account if setting or
    # changing his own pubkeys. webonly, unapproved, and unverified users
    # can still muck with their personal info. So, just invoke as user
    # nobody. We will get audit email in case we need to track what has
    # happened. 
    #
    if (! HASREALACCOUNT($uid)) {
	$uid = "nobody";
    }
    return SUEXEC($uid, "nobody", $cmdandargs, 0);
}

#
# Verify a URL.
#
function CHECKURL($url, &$error) {
    global $HTTPTAG;

    if (strlen($url)) {
	if (strstr($url, " ")) {
	    $error = "URL is malformed; spaces are not allowed!";
	    return 0;
	}
	
	if (strcmp($HTTPTAG, substr($url, 0, strlen($HTTPTAG)))) {
	    $error = "URL is malformed; must begin with $HTTPTAG!";
	    return 0;
	}

	$fp = @fopen($url, "r");
	if (! $fp) {
	    # Check to see if it was a redirect, in which case its OK
	    for ($i = 0; $i < count($http_response_header); $i++) {
		if (!strcmp("Location:", substr($http_response_header[$i],0,9))) {
		    $is_redirect = 1;
		}
	    }
	    if (!$is_redirect) {
		$error = "URL is not valid; Cannot be accessed!";
		return 0;
	    }
	} else {
	    fclose($fp);
	}
    }
    return 1;
}

#
# Check a password.
#
function CHECKPASSWORD($uid, $password, $name, $email, &$error)
{
    global $TBCHKPASS_PATH;
    
    $mypipe =
	popen(escapeshellcmd("$TBCHKPASS_PATH $password $uid '$name:$email'"),
	      "w+");
    
    if ($mypipe) { 
        $retval=fgets($mypipe, 1024);
        if (strcmp($retval,"ok\n") != 0) {
	    $error = "$retval";
	    return 0;
	}
	return 1;
    }
    TBERROR("Checkpass Failure! Returned '$mypipe'.\n\n".
	    "$TBCHKPASS_PATH $password $uid '$name:$email'", 1);
}

function LASTNODELOGIN($node)
{
}

#
# A function to print the contents of an array (recursively).
# Mostly useful for debugging.
#
function ARRAY_PRINT($arr) {
  if (!is_array($arr)) { echo "non-array '$arr'\n"; }
  foreach ($arr as $i => $val) {
    echo("'$i' - '$val'\n");
    if (is_array($val)) {
      echo "Sub-array $i:\n";
      array_print($val);
      echo "End Sub-array $i.\n";
    }
  }
}

#
# Beware empty spaces (cookies)!
# 
require("tbauth.php3");

#
# Okay, this is what checks the login and spits out the menu.
#
require("menu.php3");
?>
