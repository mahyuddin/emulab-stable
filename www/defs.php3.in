<?php
#
# Standard definitions! 
#
$TBDIR          = "@prefix@/";
$WWWDEFS        = "@WWWDEFS@";

# Overridden by the defs file!
$TBMAINSITE     = 0;

#
# Include configure selected definitions.
#
include("$WWWDEFS"."-defs.php3");

$TBWWW_DIR	= "$TBDIR"."www/";
$TBBIN_DIR	= "$TBDIR"."bin/";
$TBETC_DIR	= "$TBDIR"."etc/";
$TBLIBEXEC_DIR	= "$TBDIR"."libexec/";
$TBSUEXEC_PATH  = "$TBLIBEXEC_DIR/suexec";
$TBCHKPASS_PATH = "$TBLIBEXEC_DIR/checkpass";
$TBCSLOGINS     = "$TBETC_DIR/cslogins";

$TBPROJ_DIR     = "/proj";
$TBUSER_DIR	= "/users";
$TBNSSUBDIR     = "nsdir";

$TBAUTHCOOKIE   = "HashCookie" . $TBCOOKIESUFFIX;
$TBNAMECOOKIE   = "MyUidCookie" . $TBCOOKIESUFFIX;
$TBAUTHTIMEOUT  = 21600;

$HTTPTAG        = "http://";

#
# This just spits out an email address in a page, so it does not need
# to be configured per development tree. It could be though ...
# 
$TBMAILADDR     = "<a href=\"mailto:$TBMAILADDR_OPS\">
                      Testbed Operations ($TBMAILADDR_OPS)</a>";

#
# Database constants and the like.
#
include("dbdefs.php3");

#
# Generate the KEY from a name
#
function GENKEY ($name) {
    return crypt("TB_"."$name"."_USR", strlen($name) + 13);
}

#
# Wrap up the mail function so we can prepend a tag to the subject
# line that indicates what testbed. Useful when multiple testbed
# email to the same list.
#
# 
function TBMAIL($to, $subject, $message, $headers = 0)
{
    global $THISHOMEBASE;

    $subject = strtoupper($THISHOMEBASE) . ": $subject";

    if ($headers)
	    return mail($to, $subject, $message, $headers);
    else
	    return mail($to, $subject, $message);
}

#
# Internal errors should be reported back to the user simply. The actual 
# error information should be emailed to the list for action. The script
# should then terminate if required to do so.
#
function TBERROR ($message, $death, $xmp = 0) {
    global $TBMAIL_WWW, $TBMAIL_OPS, $TBMAILADDR;

    TBMAIL($TBMAIL_OPS,
         "WEB ERROR REPORT",
         "\n".
         "$message\n\n".
         "Thanks,\n".
         "Testbed WWW\n",
         "From: $TBMAIL_OPS\n".
         "Errors-To: $TBMAIL_WWW");

    # Allow sendmail to run.
    sleep(1);
    
    if ($death) {
	if ($xmp)
	    $message = "<XMP>$message</XMP>\n";
	
            $msg = "<font size=+1><br>
                    $message
	            <br>	
        	    </font>
                    <p><p>
		    Could not continue. Please contact $TBMAILADDR\n";

	    PAGEERROR($msg);
    }
    return 0;
}

#
# General user errors should print something warm and fuzzy
#
function USERERROR($message, $death) {
    global $TBMAILADDR;

    $msg = "<font size=+1><br>
            $message
            <br>	
      	    </font>
            <p><p>
            Please contact $TBMAILADDR if you feel this message is an error.";

    if ($death) {
	PAGEERROR($msg);
    }
    else
        echo "$msg\n";
}

#
# A form error.
#
function FORMERROR($field) {
    USERERROR("Missing field; ".
              "Please go back and fill out the \"$field\" field!", 1);
}

#
# Is this user an admin type?
#
function ISADMIN($uid) {
    global $TBDBNAME;

    $query_result = mysql_db_query($TBDBNAME,
	"SELECT admin FROM users WHERE uid='$uid'");

    if (! $query_result) {
        $err = mysql_error();
        TBERROR("Database Error getting admin status for $uid: $err\n", 1);
    }

    $row = mysql_fetch_row($query_result);
    $admin  = $row[0];

    return $admin;
}

#
# Run a program as a user.
#
function SUEXEC($uid, $gid, $cmdandargs, $die) {
    global $TBSUEXEC_PATH;

    ignore_user_abort(1);

    $output = array();
    $retval = 0;
    $result = exec("$TBSUEXEC_PATH $uid $gid $cmdandargs",
		   $output, $retval);

    if ($retval) {
	$foo = "";
        for ($i = 0; $i < count($output); $i++) {
	      $foo = "$foo $output[$i]";
	}
	
	TBERROR("SUEXEC failure: '$cmdandargs'\n".
		"Error output:\n\n".
                "$foo", $die, 1);
    }
    return $retval;
}

#
# Verify a URL.
#
function VERIFYURL($url) {
    global $HTTPTAG;

    if (strlen($url)) {
	if (strstr($url, " ")) {
	    USERERROR("URL ($url) is malformed; spaces are not allowed. ".
		      "Please go back and fix it up.", 1);
	}
	
	if (strcmp($HTTPTAG, substr($url, 0, strlen($HTTPTAG)))) {
	    USERERROR("URL ($url) must begin with $HTTPTAG. ".
		      "Please go back and fix it up.", 1);
	}
	$fp = fopen($url, "r");
	if (! $fp) {
	    USERERROR("URL ($url) is not valid (cannot be accessed). ".
		      "Please go back and fix it up.", 1);
	}
	fclose($fp);
    }
    return 0;
}

#
# Verify a URL.
#
function CHECKURL($url, &$error) {
    global $HTTPTAG;

    if (strlen($url)) {
	if (strstr($url, " ")) {
	    $error = "URL is malformed; spaces are not allowed!";
	    return 0;
	}
	
	if (strcmp($HTTPTAG, substr($url, 0, strlen($HTTPTAG)))) {
	    $error = "URL is malformed; must begin with $HTTPTAG!";
	    return 0;
	}
	
	$fp = @fopen($url, "r");
	if (! $fp) {
	    $error = "URL is not valid; Cannot be accessed!";
	    return 0;
	}
	fclose($fp);
    }
    return 1;
}

#
# Check a password.
#
function CHECKPASSWORD($uid, $password, $name, $email, &$error)
{
    global $TBCHKPASS_PATH;
    
    $mypipe =
	popen(escapeshellcmd("$TBCHKPASS_PATH $password $uid '$name:$email'"),
	      "w+");
    
    if ($mypipe) { 
        $retval=fgets($mypipe, 1024);
        if (strcmp($retval,"ok\n") != 0) {
	    $error = "$retval";
	    return 0;
	}
	return 1;
    }
    TBERROR("Checkpass Failure! Returned '$mypipe'.\n\n".
	    "$TBCHKPASS_PATH $password $uid '$name:$email'", 1);
}

#
# Get the last USERS node login for a user (or all users). If this fails,
# the let testbed ops know, but its not a fatal problem.
#
function LASTUSERSLOGIN($uid) {
    global $TBLIBEXEC_DIR;
    
    $output = array();
    $retval = 0;

    #
    # Either a specific UID or a list of all UIDs.
    #
    $uidarg = "";
    if ($uid) {
	$uidarg = "-u $uid";
    }

    $cmdandargs = "$TBLIBEXEC_DIR/lastlogin $uidarg";

    $result = exec($cmdandargs, $output, $retval);

    if ($retval) {
      if (0) {
	$foo = "";
        for ($i = 0; $i < count($output); $i++) {
	      $foo = "$foo $output[$i]";
	}
	
	TBERROR("LASTUSERSLOGIN: ".
		"Cmd was \"$cmdandargs\". \n".
		"Error output:\n\n $foo\n", 0);
      }
        return 0;
    }
    $hashtable = array();

    #
    # In single user mode, return a hash of date, time, node.
    # 
    if ($uid) {
	if (! $output[0])
	    return 0;
	
	$parts = explode(" ", $output[0]);

	$hashtable["date"] = $parts[0];
	$hashtable["time"] = $parts[1];
	$hashtable["node_id"] = $parts[2];
	return $hashtable;
    }
    
    #
    # In all user mode, return a hash of hashes, indexed by uid.
    #
    for ($i = 0; $i < count($output); $i++) {
	$utable = array();
	$parts  = explode(" ", $output[$i]);

	$utable["date"] = $parts[1];
	$utable["time"] = $parts[2];
	$utable["node_id"] = $parts[3];	

	$hashtable["$parts[0]"] = $utable;
    }
    return $hashtable;
}

function LASTNODELOGIN($node)
{
}

#
# Beware empty spaces (cookies)!
# 
require("tbauth.php3");

#
# Okay, this is what checks the login and spits out the menu.
#
require("menu.php3");
?>
