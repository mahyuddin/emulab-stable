<?php
#
# Standard definitions! 
#
$TBDIR          = "@prefix@/";
$OURDOMAIN      = "@OURDOMAIN@";
$BOSSNODE       = "@BOSSNODE@";
$TBADMINGROUP   = "@TBADMINGROUP@";
$WWWHOST	= "@WWWHOST@";
$WWW		= "@WWW@";
$TBAUTHDOMAIN	= "@TBAUTHDOMAIN@";
$TBBASE		= "@TBBASE@";
$TBDOCBASE	= "@TBDOCBASE@";
$TBWWW		= "@TBWWW@";
$THISHOMEBASE	= "@THISHOMEBASE@";

$TBMAILADDR_OPS		= "@TBOPSEMAIL_NOSLASH@";
$TBMAILADDR_WWW		= "@TBWWWEMAIL_NOSLASH@";
$TBMAILADDR_APPROVAL	= "@TBAPPROVALEMAIL_NOSLASH@";
$TBMAILADDR_LOGS	= "@TBLOGSEMAIL_NOSLASH@";
$TBMAILADDR_AUDIT	= "@TBAUDITEMAIL_NOSLASH@";

# Can override this in the defs file. 
$TBAUTHTIMEOUT  = "@TBAUTHTIMEOUT@";
$TBMAINSITE     = "@TBMAINSITE@";
$TBSECURECOOKIES= "@TBSECURECOOKIES@";
$TBCOOKIESUFFIX = "@TBCOOKIESUFFIX@";

$TBWWW_DIR	= "$TBDIR"."www/";
$TBBIN_DIR	= "$TBDIR"."bin/";
$TBETC_DIR	= "$TBDIR"."etc/";
$TBLIBEXEC_DIR	= "$TBDIR"."libexec/";
$TBSUEXEC_PATH  = "$TBLIBEXEC_DIR/suexec";
$TBCHKPASS_PATH = "$TBLIBEXEC_DIR/checkpass";
$TBCSLOGINS     = "$TBETC_DIR/cslogins";

#
# Hardcoded check against $WWWHOST, to prevent anyone from accidentally setting
# $TBMAINSITE when it should not be
#
if ($WWWHOST != "www.emulab.net") {
    $TBMAINSITE = 0;
}

$TBPROJ_DIR     = "/proj";
$TBUSER_DIR	= "/users";
$TBGROUP_DIR	= "/groups";
$TBNSSUBDIR     = "nsdir";

$TBAUTHCOOKIE   = "HashCookie" . $TBCOOKIESUFFIX;
$TBNAMECOOKIE   = "MyUidCookie" . $TBCOOKIESUFFIX;

$HTTPTAG        = "http://";

$TBMAIL_OPS		= "Testbed Ops <$TBMAILADDR_OPS>";
$TBMAIL_WWW		= "Testbed WWW <$TBMAILADDR_WWW>";
$TBMAIL_APPROVAL	= "Testbed Approval <$TBMAILADDR_APPROVAL>";
$TBMAIL_LOGS		= "Testbed Logs <$TBMAILADDR_LOGS>";
$TBMAIL_AUDIT		= "Testbed Audit <$TBMAILADDR_AUDIT>";

#
# This just spits out an email address in a page, so it does not need
# to be configured per development tree. It could be though ...
# 
$TBMAILADDR     = "<a href=\"mailto:$TBMAILADDR_OPS\">
                      Testbed Operations ($TBMAILADDR_OPS)</a>";

# So subscripts always know ...
putenv("HTTP_SCRIPT=1");

#
# Database constants and the like.
#
include("dbdefs.php3");

#
# Wrap up the mail function so we can prepend a tag to the subject
# line that indicates what testbed. Useful when multiple testbed
# email to the same list.
#
# 
function TBMAIL($to, $subject, $message, $headers = 0)
{
    global $THISHOMEBASE;
    global $SCRIPT_NAME;

    $subject = strtoupper($THISHOMEBASE) . ": $subject";

    $tag = "X-NetBed: " . basename($SCRIPT_NAME);
    
    if ($headers) {
	$headers = "$headers\n" . $tag;
    }
    else {
	$headers = $tag;
    }
    return mail($to, $subject, $message, $headers);
}

#
# Internal errors should be reported back to the user simply. The actual 
# error information should be emailed to the list for action. The script
# should then terminate if required to do so.
#
function TBERROR ($message, $death, $xmp = 0) {
    global $TBMAIL_WWW, $TBMAIL_OPS, $TBMAILADDR;

    TBMAIL($TBMAIL_OPS,
         "WEB ERROR REPORT",
         "\n".
         "$message\n\n".
         "Thanks,\n".
         "Testbed WWW\n",
         "From: $TBMAIL_OPS\n".
         "Errors-To: $TBMAIL_WWW");

    if ($death) {
	if ($xmp)
	    $message = "<XMP>$message</XMP>\n";
	
            $msg = "<font size=+1><br>
                    $message
	            <br>	
        	    </font>
                    <p><p><p>
		    Could not continue. Please contact $TBMAILADDR\n";

	    PAGEERROR($msg);
    }
    return 0;
}

#
# General user errors should print something warm and fuzzy
#
function USERERROR($message, $death) {
    global $TBMAILADDR;

    $msg = "<font size=+1><br>
            $message
      	    </font>
            <br><br><br>
            <font size=-1>
            Please contact $TBMAILADDR if you feel this message is an error.
            </font>\n";

    if ($death) {
	PAGEERROR($msg);
    }
    else
        echo "$msg\n";
}

#
# A form error.
#
function FORMERROR($field) {
    USERERROR("Missing field; ".
              "Please go back and fill out the \"$field\" field!", 1);
}

#
# SUEXEC stuff.
#
# Save this stuff so we can generate better error messages and such.
# 
$suexec_cmdandargs = "";
$suexec_retval     = 0;
$suexec_output;

#
# Actions for suexec. 
#
define("SUEXEC_ACTION_CONTINUE",	0);
define("SUEXEC_ACTION_DIE",		1);
define("SUEXEC_ACTION_USERERROR",	2);
define("SUEXEC_ACTION_IGNORE",		3);

#
# An suexec error.
#
function SUEXECERROR($action)
{
    global $suexec_cmdandargs, $suexec_retval, $suexec_output;

    $foo  = "Shell Program Error. Exit status: $suexec_retval\n";
    $foo .= "  '$suexec_cmdandargs'\n";
	    
    if (count($suexec_output)) {
	$foo .= "\n";
	    
	for ($i = 0; $i < count($suexec_output); $i++) {
	    $foo .= "$suexec_output[$i]\n";
	}
    }
    switch ($action) {
    case SUEXEC_ACTION_CONTINUE:
	TBERROR($foo, 1, 0);
        break;
    case SUEXEC_ACTION_DIE:
	TBERROR($foo, 1, 1);
        break;
    case SUEXEC_ACTION_USERERROR:
	USERERROR("<XMP>$foo</XMP>", 1);
        break;
    case SUEXEC_ACTION_IGNORE:
	break;
    default:
	TBERROR($foo, 1, 1);
    }
}

#
# Run a program as a user.
#
function SUEXEC($uid, $gid, $cmdandargs, $action) {
    global $TBSUEXEC_PATH;
    global $suexec_cmdandargs, $suexec_retval, $suexec_output;

    ignore_user_abort(1);

    $suexec_cmdandargs = "$uid $gid $cmdandargs";
    $suexec_output     = array();
    $suexec_retval     = 0;
    
    exec("$TBSUEXEC_PATH $suexec_cmdandargs", $suexec_output, $suexec_retval);

    #
    # The output is still available of course, via $suexec_output.
    # 
    if ($suexec_retval == 0 || $action == SUEXEC_ACTION_IGNORE) {
	return $suexec_retval;
    }
    SUEXECERROR($action);
}

function ADDPUBKEY($uid, $cmdandargs) {
    global $TBSUEXEC_PATH;

    #
    # Complication. User might not have an actual account if setting or
    # changing his own pubkeys. webonly, unapproved, and unverified users
    # can still muck with their personal info. So, just invoke as user
    # nobody. We will get audit email in case we need to track what has
    # happened. 
    #
    if (! HASREALACCOUNT($uid)) {
	$uid = "nobody";
    }
    return SUEXEC($uid, "nobody", $cmdandargs, 0);
}

#
# Verify a URL.
#
function CHECKURL($url, &$error) {
    global $HTTPTAG;

    if (strlen($url)) {
	if (strstr($url, " ")) {
	    $error = "URL is malformed; spaces are not allowed!";
	    return 0;
	}
	
	if (strcmp($HTTPTAG, substr($url, 0, strlen($HTTPTAG)))) {
	    $error = "URL is malformed; must begin with $HTTPTAG!";
	    return 0;
	}

	$fp = @fopen($url, "r");
	if (! $fp) {
	    # Check to see if it was a redirect, in which case its OK
	    for ($i = 0; $i < count($http_response_header); $i++) {
		if (!strcmp("Location:", substr($http_response_header[$i],0,9))) {
		    $is_redirect = 1;
		}
	    }
	    if (!$is_redirect) {
		$error = "URL is not valid; Cannot be accessed!";
		return 0;
	    }
	} else {
	    fclose($fp);
	}
    }
    return 1;
}

#
# Check a password.
#
function CHECKPASSWORD($uid, $password, $name, $email, &$error)
{
    global $TBCHKPASS_PATH;
    
    $mypipe =
	popen(escapeshellcmd("$TBCHKPASS_PATH $password $uid '$name:$email'"),
	      "w+");
    
    if ($mypipe) { 
        $retval=fgets($mypipe, 1024);
        if (strcmp($retval,"ok\n") != 0) {
	    $error = "$retval";
	    return 0;
	}
	return 1;
    }
    TBERROR("Checkpass Failure! Returned '$mypipe'.\n\n".
	    "$TBCHKPASS_PATH $password $uid '$name:$email'", 1);
}

function LASTNODELOGIN($node)
{
}

#
# Beware empty spaces (cookies)!
# 
require("tbauth.php3");

#
# Okay, this is what checks the login and spits out the menu.
#
require("menu.php3");
?>
