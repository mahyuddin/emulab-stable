<!--
   EMULAB-COPYRIGHT
   Copyright (c) 2000-2003 University of Utah and the Flux Group.
   All rights reserved.
  -->
<center>
<h2>Jails</h2>
</center>

A long long long time ago I started working on better Jail support.
What follows is the story of my incredible journey (of woe).

<br>
<br>

Initially, we started out with some small changes to jail. Mike made
these changes around October of 2002.

<ul>
<li> Optionally allow access to raw sockets. The jail is allowed to
     both read and write, but is restricted from accessing the
     firewall, dummynet, route, and RSVP interfaces. We also ensure
     that the packet header reflects the IP address of the jail.  This
     option is enabled globally with a MIB entry, and then on a
     per-jail basis via a command line option to the jail command.
     TODO: Allow header to reflect any of the IPs to which the jail
     has access to.

<li> Optionally allow access to BPF devices. The jail is only allowed to
     read packets. The interface is not put into promiscuous mode, so
     the jail is not able to see all of the packets on the wire, but
     only those addressed to the node. However, if the interface is
     already in promiscuous mode (say, cause someone outside the jail
     is using tcpdump), then the jail will also be able to any packet
     that goes by. This option is enabled globally with a MIB entry,
     and then on a per-jail basis via a command line option to the
     jail command.  TODO: Allow header to reflect any of the IPs to
     which the jail has access to. TODO: Limit packets to those
     addressed to the IPs or interfaces (tunnels) that the jail is
     allowed to access.
     
<li> Restrict the port range to which a jail can bind to. This allows
     multiple jails on the same node to safely share the port space
     without stepping on each other. Since the ultimate goal to allow
     different experiments to coexist in jails on the same node, the
     port space has to be allocated globally, with the same port space
     assigned to all jails across an experiment, so as not to conflict
     with any other experiments. This assignment is done when the
     experiment is swapped in so that swapped experiments are not
     holding ranges (16 bits of port space does not go very far).

<li> Allow a jailed process to optionally bind to IPs other than the
     jail IP (the ip that is specified to the jail command). The
     default implementation of jail allows processes inside of a jail
     to bind to just the one IP. If a process specifies INADDR_ANY,
     the kernel silently changes it to the jail IP. If however there
     are other interfaces on the node, or if tunnels are being used to
     construct an overlay for the experiment, it is necessary to allow
     processes inside the jail to bind to those interfaces. When the
     jail is created, a list of aux IPs can be specified on the
     command line, which tells the kernel to allow processes inside
     the jail to bind to any of those IPs (including the jail IP).
     When the bind happens, the kernel checks the jails list of IPs;
     this applies to sockets bound for outgoing traffic, as well as
     incoming traffic. 
     
<li> Disallow FS unmounts inside a jail unless the mount was created
     in the jail. This was more of a bug fix that a feature addition.
</ul>

The other part of this first phase was creating a jailed environment
on the node that looked as much like the standard Emulab environment
as possible.  The goal was to make a jail look so close that user did
not mind (he was certainly going to notice!). Also note that the
intent was to use jails both locally and remotely, where there are
going to be different security considerations (hence the need for
per-jail permissions bits as mentioned above). Setting up the jail is
broken into two parts; the stuff that needs to be done outside the
jail (creating the jail filesystem, setting up interfaces, tunnels,
routes, mounting user/proj filesystems) cause the jail does not have
enough permission, and the stuff that can be done inside the jail
(creating accounts, installing software, starting programs and traffic
generators).

<br>
<br>

<h3>Setting up the jail, phase one:</h3>

To set up the outer environment it is necessary to:

<ul>
<li> Create the tunnels if the experiment requested tunnels. This applies
     only to widearea nodes, not to local nodes. At the same time,
     routes are setup if the user requested them (static and manual
     only; we do not run gated on widearea nodes!). At present, the
     routing setup is done via the vtun config file, which specifies
     external commands to run as each tap interface is configured and
     torn down. 

<li> Ask tmcd for the set of jail options that apply. Different users
     and/or experiments might get differing levels of permission to
     access the extended jail features mentioned above. 

<li> Create a base filesystem for the jail, and then apply some
     customizations to it. In addition to customizations based on the
     permissions that tmcd said to use, there are the usual things
     like setting the hostname of the jail, giving it a proper rc.conf
     and resolv.conf, etc. More on this below.

<li> Mounting filesystems. Locally, we mount the /user and /proj
     filesystems into the jail so that the users get the standard
     directories.

<li> Start the tmcd proxy. More on this below.
</ul>

Setting up the filesystem for the jail is a long arduous process:
<ul>
<li> Create a zero-filled vnode file (currently set to 64MB) and find
     a free vn device to configure. The root of the filesystem is
     mounted under /var/emulab/jails/<jailname>/root.

<li> Copy in /root and /etc into the new jail filesystem so that each
     jail gets to munge their own copy of it.

<li> NFS mount read-only /bin, /sbin, and /usr into the jailed
     filesystem. This gives each jail shared access to the bulk of the
     filesystem so that we do not have to duplicate. If the user
     wishes to install their own software, they will need to do it
     into /opt. This is perhaps not ideal.
  
<li> Mount a proc filesystem inside the jail. This gives the jail a
     private view of it process world.

<li> Populate the jails /dev filesystem. The jail is not allowed to
     run the mknod system call, so device entries must be created for
     it. 

<li> Create a pristine /var filesystem. Create stub entries for
     several files in /etc including the passsword and group file.
     Create a resolv.conf file that points to the outer host.

<li> Create an sshd config file and make sure X11 forwarding is off.
     Also arrange for sshd to be started up (inside the jail) on its
     per-jail assigned port (which is within the port range for the
     jail).

<li> NFS mount (via a call in the tmcd library) all of the proj and
     user directories for the experiment. Again, since the jail cannot
     do NFS mounts inside, this is down outside. Clean out various
     files for security (pem files, cvsup auth file, etc).

</ul>

The other complication in setting up the jailed environment involves
access to TMCD. Widearea testbed nodes are not allowed to contact tmcd
without an ssl certificate, but we do not want to hand out per-jail
certificates that could be easily copied. My approach was to not allow
a jail to contact tmcd directly, but to instead go through a proxy
running outside the jail. This has the added benefit of ensuring that
the jail is not able to spoof another jail in another experiment.
The implementation of this was to add a <em>proxy</em> mode to the
tmcc client. Outside the jail, a tmcc proxy is started that creates a
unix domain socket, whose path is inside the jail filesystem. In other
words, the socket is named such that a tmcc client running inside the
jail sees it too. The tmcc client inside the jail connects to the tmcc
proxy running outside the jail via the unix domain socket, which
relays the request to tmcd (sanitizing the request string), and then
relays the answer back to the tmcc inside the jail. The proxy ensures
that there is no spoofing of the jail id. There are many other
alternatives for accomplishing this, but this was fairly easy to do.

<br>
<br>

<h3>Setting up the jail, phase two:</h3>

Once the jail system call has been issued, it is up to the inner
environment to finish getting it set up. Inside the jail, the first
program to run is a little perl script (injail.pl) that is intended to
act like "init" in that it starts the initial shell and then waits
until it receives a signal to terminate. The easiest way to ensure
that all processes inside the jail are terminated is for injail.pl to
send a TERM to the entire process group, and then a KILL to pick up
any stragglers. This is because kill all of the processes from outside
the jail is difficult (hard to see inside the jail), and because the
jail will not actually terminate until all the processes inside are
really dead. 

<br>
<br>
The initial shell mentioned above is /etc/rc, which proceeds to do all
of the same boot time configuration that normally happens when a node
boots. The difference of course is that the jail has a heavily
constrained /etc/rc.conf that starts up just a few essential services
such as syslogd, cron, and sshd (on the specific port assigned sshd
for the jail; see above). The last part of configuration run is the
standard testbed setup, although again in a somewhat restricted
manner.  Currently the following testbed mechanisms are supported
<em>within</em> the jailed environment:

<ul>
<li> 
</ul>

<br>
<br>

In March of 2003 Mike and Leigh added another option to jails:

<ul>
<li> Optionally allow jails to bind to INADDRY_ANY. The default
     implementation of jail is to map INADDRY_ANY to the jail's main
     IP address (that which is specified to the jail command).
     However, if the jail is allowed to access other IPs (see above),
     then INADDRY_ANY actually means a subset of all the interfaces on
     the node that the jail is allowed to us (which might also be
     tunnels). There are two situations in which this matters:

     <ul>
     <li> A process is connecting to another address, and has
     specified its local address as INADDR_ANY (which is typical).
     Instead of binding the local address of packets to the jail IP,
     the local address is set to the actual address of the interface
     that the packet is routed out of. If there are IP aliases on the
     interface, the list of aliases is searched for a match against
     one of the allowed prison IPs. If there is a match, the local
     address is set to that IP. Otherwise the address is set to the
     main address of the interface (this is not correct; it should be
     an error). This is to support multiplexing links using IP
     aliases. If we were to use IP tunnels or some other form of
     virtual interface, there would be no need to search the list of
     aliases. 

     <li> A process is binding a local socket for an incoming
     connection. In this case, any of the prison IPs can be the local
     target of the connection, but it is not until the connection is
     actually made that the address can be checked. This is done in
     the pcb lookup routine. For each pcb, if the port matches and the
     local address is INADDR_ANY, and the pcb was created within a
     jail, then the list of the prison IPs is searched, looking for a
     match. If no match is found, the pcb is skipped.
</ul>

