<center>
<h1>Emulab Tutorial - A More Advanced Example</h1>
</center>

<p>
Here is a slightly more complex example demonstrating the use of RED
queues, traffic generation, and the event system. Where possible, we
adhere to the syntax and operational model of
<a href="http://www.isi.edu/nsnam/ns/">ns-2</a>, as described in the
<a href="http://www.isi.edu/nsnam/ns/doc/index.html">NS manual</a>.

<ul>
<li> RED/GRED Queues: In addition to normal DropTail links, Emulab
     supports the specification of the RED and GRED (Gentle RED) links
     in your NS file. RED/GRED queuing is handled via the
     insertion of a traffic shaping delay node, in much the same way
     that bandwidth, delay, and packet loss is handled. For a better
     understanding of how we support traffic shaping, see the
     <tt>ipfw</tt> and <tt>dummynet</tt> man pages on
     <tt>users.emulab.net</tt>. It is important to note that Emulab
     supports a smaller set of tunable parameters then NS does; please
     read the aforementioned manual pages!

<li> Traffic Generation: Emulab supports Constant Bit Rate (CBR)
     traffic generation, in conjunction with either Agent/UDP or
     Agent/TCP agents. We currently use the
     <a href="http://www.postel.org/tg">TG Tool Set</a> to generate
     traffic (usermode programs running on FreeBSD 4.3 endpoints).

<li> Traffic Generation using <a href="http://www.isi.edu/nsnam/ns/doc/node477.html">
     NS Emulation (NSE)</a>: Emulab supports TCP traffic generation
     using NS's Agent/TCP/FullTcp which is a BSD Reno derivative and
     its subclasses namely Newreno, Tahoe and Sack. Currently two
     application classes are supported: Application/FTP and 
     Application/Telnet. The former drives the FullTcp agent to send
     bulk-data according to connection dynamics. The latter uses the
     NS's <a href="http://citeseer.nj.nec.com/danzig91tcplib.html"> 
     tcplib</a> telnet distribution for telnet-like data. For
     configuration parameters and commands allowed on the objects,
     refer to NS documentation <a href="http://www.isi.edu/nsnam/ns/doc/node351.html">
     here.</a>


<li> Event System: Emulab supports limited use of the NS "at"
     syntax, allowing you to define a static set of events in your NS
     file, to be delivered to agents running on your nodes.
</ul>

<p>
What follows is a <a href="advanced.ns">sample NS file</a> that
demonstrates the above features, with annotations where appropriate.
First we define the 2 nodes in the topology:
	<code><pre>
	set nodeA [$ns node]
	set nodeB [$ns node]			</code></pre>
</p>

<p>
Next define a duplex link between nodes nodeA and nodeB. Instead of a
standard DropTail link, it is declared to be a Random Early Detection
(RED) link. While this is obviously contrived, it allows us to ignore
<a href="tutorial.php3#Routing">routing</a> issues within this
example.
	<code><pre>
	set link0 [$ns duplex-link $nodeA $nodeB 100Mb 0ms RED]</code></pre>
</p>

<p>
Each link is has an NS "Queue" object associated with it, which you
can modify to suit your needs. (<em>currently, there is a single queue
object per duplex link; you can cannot set the parameters
asymmetrically). The following parameters can be changed, and are
defined in the NS manual (see Section 7.3):
	<code><pre>
	set queue0 [[$ns link $nodeA $nodeB] queue]
	$queue0 set gentle_ 0
	$queue0 set queue-in-bytes_ 0
	$queue0 set limit_ 75
	$queue0 set maxthresh_ 20
	$queue0 set thresh_ 7
	$queue0 set linterm_ 11
	$queue0 set q_weight_ 0.004</code></pre>
</p>

<p>
A UDP agent is created and attached to nodeA, then a CBR traffic
generator application is created, and attached to the UDP agent:
	<code><pre>
	set udp0 [new Agent/UDP]
	$ns attach-agent $nodeA $udp0

	set cbr0 [new Application/Traffic/CBR]
	$cbr0 set packetSize_ 500
	$cbr0 set interval_ 0.005
	$cbr0 attach-agent $udp0</code></pre>
</p>

<p>
A TCP agent is created and also attached to nodeA, then a second CBR
traffic generator application is created, and attached to the TCP
agent:
	<code><pre>
	set tcp0 [new Agent/TCP]
	$ns attach-agent $nodeA $tcp0

	set cbr1 [new Application/Traffic/CBR]
	$cbr1 set packetSize_ 500
	$cbr1 set interval_ 0.005
	$cbr1 attach-agent $tcp0</code></pre>
</p>

<p>
You must define traffic sinks for each of the traffic generators
created above. The sinks are attached to nodeB:
	<code><pre>
	set null0 [new Agent/Null]
	$ns attach-agent $nodeB $null0

	set null1 [new Agent/TCPSINK]
	$ns attach-agent $nodeB $null1</code></pre>
</p>

<p>
Then you must connect the traffic generators on nodeA to the traffic sinks
on nodeB:
	<code><pre>
	$ns connect $udp0 $null0  
	$ns connect $tcp0 $null1</code></pre>
</p>

<p>
Here is a good example for NSE FullTcp traffic generation. The
following code snippet attaches an FTP agent that drives a Reno
FullTcp on NodeA:
	<code><pre>
	set tcpfull0 [new Agent/TCP/FullTcp]
	$ns attach-agent $nodeA $tcpfull0

	set ftp0 [new Application/FTP]
	$ftp0 attach-agent $tcpfull0</code></pre>
      
</p>

<p>
You must then define the sink FullTcp endpoint and call the method
"listen" making this agent wait for an incoming connection:
	<code><pre>
	set tcpfull1 [new Agent/TCP/FullTcp/Sack]
	$tcpfull1 listen
	$ns attach-agent $nodeB $tcpfull1</code></pre>

</p>

<p>
Like all other source-sink traffic generators, you need to connect
them:
        <code><pre>
	$ns connect $tcpfull0 $tcpfull1</code></pre>

</p>

<p>
Lastly, a set of events to control your applications and link
characteristics: 
	<code><pre>
	$ns at 60.0  "$cbr0  start"
	$ns at 70.0  "$link0 bandwidth 10Mb duplex"
	$ns at 80.0  "$link0 delay 10ms"
	$ns at 90.0  "$link0 plr 0.05"
	$ns at 100.0 "$link0 down"
	$ns at 110.0 "$link0 up"
	$ns at 115.0 "$cbr0  stop"

	$ns at 120.0 "$ftp0 start"
	$ns at 140.0 "$tcpfull0 set segsize_ 256; $tcpfull0 set	segsperack_ 2"
	$ns at 145.0 "$tcpfull1 set nodelay_ true"
	$ns at 150.0 "$ftp0 stop"
	
	$ns at 120.0 "$cbr1  start"
	$ns at 130.0 "$cbr1  set packetSize_ 512"
	$ns at 130.0 "$cbr1  set interval_ 0.01"
	$ns at 140.0 "$link0 down"
	$ns at 150.0 "$cbr1  stop"

</code></pre>
</p>

<p>
When you receive email containing the experiment setup information (as
described in <a href="tutorial.php3#Beginning">Beginning an
Experiment</a>), you will notice an additional section that lists all
of the events that will be delivered during your experiment:
	<code><pre>
Event List:
Time         Node         Agent      Type       Event      Arguments
------------ ------------ ---------- ---------- ---------- ------------ 
60.000       nodeA        cbr0       TRAFGEN    START      PACKETSIZE=500
                                                           RATE=100000
                                                           INTERVAL=0.005
70.000       tbsdelay0    link0      LINK       MODIFY     BANDWIDTH=10000
80.000       tbsdelay0    link0      LINK       MODIFY     DELAY=10ms
90.000       tbsdelay0    link0      LINK       MODIFY     PLR=0.05
100.000      tbsdelay0    link0      LINK       DOWN       
110.000      tbsdelay0    link0      LINK       UP         
115.000      nodeA        cbr0       TRAFGEN    STOP       
120.000      nodeA        cbr1       TRAFGEN    START      PACKETSIZE=500
                                                           RATE=100000
                                                           INTERVAL=0.005
120.000      nodeA        ftp0       NSETRAFGEN MODIFY     $ftp0 start
130.000      nodeA        cbr1       TRAFGEN    MODIFY     PACKETSIZE=512
130.000      nodeA        cbr1       TRAFGEN    MODIFY     INTERVAL=0.01
140.000      tbsdelay0    link0      LINK       DOWN       
140.000      nodeA        tcpfull0   NSETRAFGEN MODIFY     $tcpfull0 set segsize_ 256
140.000      nodeA        tcpfull0   NSETRAFGEN MODIFY     $tcpfull0 set segsperack_ 2
145.000      nodeB        tcpfull1   NSETRAFGEN MODIFY     $tcpfull1 set nodelay_ true
150.000      tbsdelay0    link0      LINK       UP         
150.000      nodeA        ftp0       NSETRAFGEN MODIFY     $ftp0 stop
160.000      nodeA        cbr1       TRAFGEN    STOP		</code></pre>

<p>
The above list represents the set of events for your experiments, and
are stored in the Emulab Database. When your experiment is swapped in,
an <em>event scheduler</em> is started that will process the list, and
send them at the time offset specified. In order to make sure that all
of the nodes are actually rebooted and ready, time does not start
ticking until all of the nodes have reported to the event system that
they are ready. At present, events are restricted to system level
agents (Emulab traffic generators and delay nodes), but in the future
we expect to provide an API that will allow experimentors to write
their own event agents.
</p>

<p>
<h3>
Dynamic Scheduling of Events
</h3>

<p>
NS scripts give you the ability to schedule events dynamically; an NS
script is just a TCL program and the argument to the "at" command is
any valid TCL expression. This gives you great flexibility in a
simulated world, but alas, this cannot be supported in a practical
manner in the real world. Instead, we provide a way for you to inject
events into the system dynamically, but leave it up to you to script
those events in whatever manner you are most comfortable with, be it a
PERL script, or a shell script, or even another TCL script!  Dynamic
event injection is accomplished via the <em>Testbed Event Client</em>
(tevc), which is installed on your experimental nodes and on
<tt>users.emulab.net</tt>. The command line syntax for <tt>tevc</tt>
is:
	<code><pre>
	tevc -e pid/eid time objname event [args ...]</code></pre>

where the <tt>time</tt> parameter is one of:

<blockquote>
<ul>
<li> now
<li> +seconds (floating point or integer)
<li> [[[[yy]mm]dd]HH]MMss
</ul>
</blockquote>

For example, you could issue this sequence of events. 
	<code><pre>
	tevc -e testbed/myexp now cbr0 set interval_=0.2
	tevc -e testbed/myexp +10 cbr0 start
	tevc -e testbed/myexp +15 link0 down
	tevc -e testbed/myexp +17 link0 up
	tevc -e testbed/myexp +20 cbr0 stop</code></pre>

Some points worth mentioning:

<ul>
<li> There is no "global" clock; Emulab nodes are kept in sync with
     NTP, which does a very good job of keeping all of the clocks
     within 1ms of each other.

<li> The times "now" and "+seconds" are relative to the time at which
     each event is submitted, not to each other or the start of the
     experiment. 

<li> The set of events you can send is currently limited to control of
     traffic generators and delay nodes. We expect to add more agents
     in the future.

<li> Sending dynamic events that intermix with statically scheduled events
     can result in unpredictable behavior if you are not careful.

<li> Currently, the event list is replayed each time the experiment is
     swapped in. This is almost certainly not the behaviour people
     expect; we plan to change that very soon.

<li> <tt>tevc</tt> does not provide any feedback; if you specify an
     object (say, cbr78 or link45) that is not a valid object in your
     experiment, the event is silently thrown away. Further, if you
     specify an operation or parameter that is not approprate (say,
     "link0 start" instead of "link0 up"), the event is silently
     dropped. We expect to add error feedback in the future.
</ul>

<p>
<h3>
Supported Events
</h3>

This is a (mostly) comprehensive list of events that you can specify,
either in your NS file or as a dynamic event on the command line. In
the listings below, the use of "link0", "cbr0", etc. are included to
clarify the syntax; the actual object names will depend on your NS
file. Also note that when sending events from the command line with
<tt>tevc</tt>, you should not include the dollar ($) sign. For
example:

<blockquote>
<table border=0>
<tr>
 <td> NS File:</td>
 <td><code></pre>$ns at 3.0 "$link0 down"</pre></code></td>
</tr>
<tr>
 <td> tevc:</td>
 <td><code></pre>tevc -e pid/eid +3.0 link0 down</pre></code>
 </td>
</tr>
</table>
</blockquote>
 
<ul>
<li> Links:
     <ul>
     <code><pre>
     <li> $link0 up
     <li> $link0 down
     <li> $link0 bandwidth 10Mb duplex
     <li> $link0 delay 10ms
     <li> $link0 plr 0.1</code></pre>
     </ul>

<li> Queues: Queues are special. In your NS file you modify the actual
     queue, while on the command line you use the link that queue is
     part of.
     <ul>
     <code><pre>
     <li> $queue0 set queue-in-bytes_ 0
     <li> $queue0 set limit_ 75
     <li> $queue0 set maxthresh_ 20
     <li> $queue0 set thresh_ 7
     <li> $queue0 set linterm_ 11
     <li> $queue0 set q_weight_ 0.004</code></pre>
     </ul>

<li> CBR
     <ul>
     <code><pre>
     <li> $cbr0 start
     <li> $cbr0 set packetSize_ 512
     <li> $cbr0 set interval_ 0.01
     <li> $cbr0 set rate_ 10Mbs
     <li> $cbr0 stop </code></pre>
     </ul>

<li> FullTcp, FTP and Telnet: Refer NS documentation <a
     href="http://www.isi.edu/nsnam/ns/doc/ns_doc.pdf">here</a>.

</ul>

