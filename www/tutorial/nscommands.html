<center>
<h1>Emulab - Testbed NS Command Extensions</h1>
</center>


<h2>Contents</h2>
<ul>
  <li><a href="#INTRO">Introduction</a>
  <li><a href="#TCL">TCL, NS, and node names</a>
  <li><a href="#ORDER">Ordering issues</a>
  <li><a href="#HARD">Hardware Commands</a>
  <li><a href="#IP">IP Address Commands</a>
  <li><a href="#ROUTE">IP Routing Commands</a>
  <li><a href="#OS">OS Commands</a>
  <li><a href="#LOSS">Link Characteristic Commands</a>
  <li><a href="#VTYPE">Virtual Type Commands</a>
  <li><a href="#MISC">Misc. Commands</a>
</ul>

<hr>

<a name="INTRO"></a><h3>Introduction</h3>

<p>In order to use the testbed specific commands you must include the
following line near the top of your NS file (before any testbed
commands are used):

<pre>
source tb_compat.tcl
</pre>

<p>If you wish to use your file under NS you can use download this <a
href=http://www.emulab.net/tutorial/tb_compat.tcl>tb_compat.tcl</a>.
Place it in the same directory as your NS file.  When run in this way
under NS the testbed commands will have no effect, but NS will be able
to parse your file.

<hr>

<a name="TCL"></a><h3>TCL, NS, and node names</h3>

In your file you will be creating nodes with something like:

<pre>
set node1 [$ns node]
</pre>

What is really going on is that the simulator, represented by
<code>$ns</code> is creating a new node, involving a bunch of internal
data changes, and returning a reference to it which is stored in the
variable <code>node1</code>.  In almost all cases, when you need to
refer to a node you will do it as <code>$node1</code>, the
<code>$</code> indicating that you want the value the variable
<code>node1</code>, i.e. the reference to the node.  Thus you will be
issuing commands like:

<pre>
$ns duplex-link $node1 $node2 100Mb 150ms DropTail
tb-set-ip $node1 192.0.0.2
</pre>

<p>(Note the <code>$</code>'s)

<p>You will notice that when your experiment is setup the node names
and such will be <code>node1</code>.  This happens because the parser
detects what variable you are using to store the node reference and
uses that as the node name.  In the case that you do something like:

<pre>
set node1 [$ns node2]
set A $node1
</pre>

<p>The node will still be called <code>node1</code> as that was the first
variable to contain the reference.

<p>If you are dealing with many nodes you may store them in array,
perhaps like this:

<pre>
for {set i 0} {$i < 4} {incr i} {
   set nodes($i) [$ns node]
}
</pre>

<p>In this case the names of the node will be <code>nodes-0</code>,
<code>nodes-1</code>, <code>nodes-2</code>, <code>nodes-3</code>. (In
other words, the <code>(</code> character is replaced with
<code>-</code>, and <code>)</code> is removed.)  This slightly
different syntax comes is to avoid any problems that <code>()</code>
may cause later in the process. For example, the <code>()</code>
characters cannot appear in DNS entries.

<p>As a final note, everything said above for nodes applies equally to
lans.  I.e.:

<pre>
set lan0 [$ns make-lan "$node0 $node1" 100Mb .1ms]
tb-set-lan-loss $lan0 .02
</pre>

<p>(Again, note the <code>$</code>'s)

<p>Links can also be named just like nodes and lans.  The names can
then be used to set loss rates or IP addresses.  This technique is the
only way to set such attributes when their are multiple links between
two nodes.

<pre>
set link1 [$ns duplex-link $node0 $node1 100Mb .1ms DropTail]
tb-set-link-loss $link1 0.05
tb-set-ip-link $node0 $link1 192.0.0.128
</pre>

<hr>

<a name="ORDER"></a><h3>Ordering Issues</h3>

<p>tb- commands have the same status as all other Tcl and NS commands.
Thus the order matters not only relative to each other but also
relative other commands.  One common example of this is that IP
commands must be issued after the links or lans are created.

<hr>

<a name="HARD"></a><h3>Hardware Commands</h3>

<h4>tb-set-hardware</h4>

<pre>
tb-set-hardware <i>node</i> <i>type</i> [<i>args</i>].

tb-set-hardware $node3 pc
tb-set-hardware $node4 shark
</pre>

<dl>
  <dt><i>node</i> - The name of the node.
  <dt><i>type</i> - The type of the node.
</dl>

<p>Notes:

<ul>
  <li>Currently only <code>pc</code>, <code>pc600</code>, 
     <code>pc850</code>, and <code>shark</code> are
     supported types.  <code>pc</code> is the default type.
  <li>No current types have any additional arguments.
</ul>

<hr>

<a name="IP"></a><h3>IP Address Commands</h3>

<p>Each node will be assigned an IP address for each interface that is
in use.  The following commands will allow you to explicitly set those
IP addresses.  IP addresses will be automatically generated for all
nodes that you do not explicitly set IP addresses.

<p>In the common case the IP addresses on either side of a link must
be in the same subnet.  Likewise, all IP addresses on a LAN should be
in the same subnet. Generally the same subnet should not be used for
more than one link or LAN in a given experiment, nor should one node
have multiple interfaces in the same subnet. Automatically generated
IP addresses will conform to these requirements.  If part of a link or
lan is explicitly specified with the commands below then the remainder
will be automatically generated under the same subnet.

<p>IP address assignment is deterministic and tries to fill lower IP's
first, starting at 2.  Except in the partial specification case (see
above), all automatic IP addresses are in the network
<code>192.168</code>.

<h4>tb-set-ip</h4>

<pre>
tb-set-ip <i>node</i> <i>ip</i>

tb-set-ip $node1 142.3.4.5
</pre>

<dl>
  <dt><i>node</i> - The node to assign the IP address to.
  <dt><i>ip</i> - The IP address.
</dl>

<p>Notes:

<ul>
  <li>This command should only be used for nodes that have a single
      link.  For nodes with multiple links the next commands should be
      used.  Mixing <code>tb-set-ip</code> and any other IP command on
      the same node will result in an error.
</ul>


<h4>tb-set-ip-link</h4>

<pre>
tb-set-ip-link <i>node</i> <i>link</i> <i>ip</i>

tb-set-ip-link $node0 $link0 142.3.4.6
</pre>

<dl>
  <dt><i>node</i> - The node to set the IP for.
  <dt><i>link</i> - The link to set the IP for.
  <dt><i>ip</i> - The IP address.
</dl>

<p>Notes:
<ul>
  <li>One way to think of the arguments is a link with the node
      specifying which side of the link to set the IP for.
  <li>This command can not be mixed with <code>tb-set-ip</code> on the
      same node.
</ul>


<h4>tb-set-ip-lan</h4>

<pre>
tb-set-ip-lan <i>node</i> <i>lan</i> <i>ip</i>

tb-set-ip-lan $node1 $lan0 142.3.4.6
</pre>

<dl>
  <dt><i>node</i> - The node to set the IP for.
  <dt><i>lan</i> - The lan the IP is on.
  <dt><i>ip</i> - The IP address.
</dl>

<p>Notes:
<ul>
  <li>One way to think of the arguments is a node with the LAN
      specifying which port to set the IP address for.
  <li>This command can not be mixed with <code>tb-set-ip</code> on the
same node.
</ul>


<h4>tb-set-ip-interface</h4>

<pre>
tb-set-ip-interface <i>node</i> <i>dst</i> <i>ip</i>

tb-set-ip-interface $node2 $node1 142.3.4.6
</pre>

<dl>
  <dt><i>node</i> - The node to set the IP for.
  <dt><i>dst</i> - The destination of the link to set the IP for.
  <dt><i>IP</i> - The IP address.
</dl>

<p>Notes:
<ul>
  <li>This command can not be mixed on the same node with
      <code>tb-set-ip</code>.  (See above)
  <li>In the case of multiple links between the same pair of nodes
      there is no way to distinguish which link to the set the IP
      for.  This should be fixed soon.
  <li>This command is converted internally to either tb-set-ip-link or
      tb-set-ip-lan.  It is possible that error messages will report
      either of those commands instead of tb-set-ip-interface.
</ul>


<hr>

<a name="ROUTE"></a><h3>IP Routing Commands</h3>

We currently provide a simple mechanism for setting up default IP routes
between nodes in an experiment.

<h4>tb-set-ip-routing</h4>

<pre>
tb-set-ip-routing <i>protocol</i>.

tb-set-ip-routing none
tb-set-ip-routing ospf
</pre>

<dl>
  <dt><i>protocol</i> - The routing protocol to use.
</dl>

<p>Notes:

<ul>
  <li><code>none</code> is the default protocol;
      i.e., no default routing is setup.
  <li><code>ospf</code> is implemented by running <tt>gated</tt>
      on all nodes in the experiment.
</ul>

<hr>

<a name="OS"></a><h3>OS Commands</h3>

<h4>tb-set-node-os</h4>

<pre>
tb-set-node-os <i>node</i> <i>os</i>

tb-set-node-os $node1 FBSD-STD
tb-set-node-os $node1 MY_OS
</pre>

<dl>
  <dt><i>node</i> - The node to set the OS for.
  <dt><i>os</i> - The id of the OS for that node.
</dl>

<p>Notes:

<ul>
  <li>The OSID can either by one of the standard OS's we provide or
      a custom OSID, created via the web interface.
  <li>If no OS is specified for a node a default OS is chosen based on
      the nodes type.  This is currently RHL-STD for PCs.
  <li>The currently available standard OS types are: FBSD-STD,
      RHL-STD, NBSD14-STD (should not be used on PC nodes), and
      NETBOOT-STD (oskit netboot kernel for loading other
      operating systems over the network).
</ul>


<h4>tb-set-node-rpms</h4>

<pre>
tb-set-node-rpms <i>node</i> <i>rpms...</i>

tb-set-node-rpms $node0 rpm1 rpm2 rpm3
</pre>

<p>Notes:

<ul>
  <li>This command sets which rpms are to be installed on the node.
  <li>This command sets which rpms are to be installed on the node
  when it first boots after being assigned to an experiment. 
  <li>See the <a href="tutorial/tutorial.php3#RPMS">tutorial</a> for more
  information.
</ul>


<h4>tb-set-node-startup</h4>

<pre>
tb-set-node-startup <i>node</i> <i>startupcmd</i>

tb-set-node-startup $node0 {mystart.sh -a}
</pre>

<p>Notes:
<ul>
  <li>Specify a script or program to be run when the node is booted.
  <li>See the <a href="tutorial/tutorial.php3#Startupcmd">tutorial</a> for more
  information.
</ul>


<h4>tb-set-node-cmdline</h4>

<pre>
tb-set-node-cmdline <i>node</i> <i>cmdline</i>

tb-set-node-cmdline $node0 {???}
</pre>

<p>Notes:
<ul>
  <li>Set the command line, to be passed to the <i>kernel</i> when it
  is booted.
  <li>Currently, this is supported on OSKit kernels only. 
</ul>


<h4>tb-set-node-tarfiles</h4>

<pre>
tb-set-node-tarfiles <i>node</i> <i>dir</i> <i>tarfile</i>

tb-set-node-tarfiles $node0 /bin mybinmods.tar /sbin mysbinmods.tar
</pre>

<p>Notes:
<ul>
  <li>This installs tarfiles in specified directories when the node
  first boots after being assigned to an experiment. 
  <li>Each tar file is installed just one. Tarfiles that have been
  loaded, are not reloaded after subsequent reboots.
</ul>
	
<hr>

<a name="LOSS"></a><h3>Link Loss Commands</h3>

<p>This is the NS syntax for creating a link:

<pre>
$ns duplex-link $node1 $node2 100Mb 150ms DropTail
</pre>

<p>Note that it does not allow for specifying link loss rates.  Emulab
does, however, support link loss.  The following commands can be used
to specify link loss rates.

<h4>tb-set-link-loss</h4>

<pre>
tb-set-link-loss <i>src</i> <i>dst</i> <i>loss</i>
tb-set-link-loss <i>link</i> <i>loss</i>

tb-set-link-loss $node1 $node2 0.05
tb-set-link-loss $link1 0.02
</pre>

<dl>
  <dt><i>src</i>, <i>dst</i> - Two nodes to describe the link.
  <dt><i>link</i> - The link to set the rate for.
  <dt><i>loss</i> - The loss rate (between 0 and 1).
</dl>

<p>Notes:
<ul>
  <li>There are two syntax's available.  The first specifies a link by
      a source/destination pair.  The second explicitly specifies the
      link.
  <li>The source/destination pair is incapable of describing an
      individual link in the case of multiple links between two
      nodes.  Use the second syntax for this case.
</ul>


<h4>tb-set-lan-loss</h4>

<pre>
tb-set-lan-loss <i>lan</i> <i>loss</i>

tb-set-lan-loss $lan1 0.3
</pre>

<dl>
  <dt><i>lan</i> - The lan to set the loss rate for.
  <dt><i>loss</i> - The loss rate (between 0 and 1).
</dl>

<p>Notes:
<ul>
  <li>This command sets the loss rate for the entire LAN.
</ul>

<h4>tb-set-node-lan-delay</h4>

<pre>
tb-set-node-lan-delay <i>node</i> <i>lan</i> <i>delay</i>

tb-set-node-lan-delay $lan0 $node0 40ms
</pre>

<dl>
  <dt><i>node</i> - The node we are modifying the delay for.
  <dt><i>lan</i> - Which LAN the node is in that we are affecting.
  <dt><i>delay</i> - The new node to switch delay (see below).
</dl>

<p>Notes:
<ul>
  <li>This command changes the delay between the node and the
      switch of the LAN.  This is only half of the trip a packet must
      take.  The packet will also traverse the switch to the
      destination node, possibly incurring additional latency from any
      delay parameters there.
  <li>If this command is not used to overwrite the delay, then the
      delay for a given node to switch link is taken as one half of
      the delay passed to <code>make-lan</code>.  Thus in a LAN where
      no <code>tb-set-node-delay</code> calls are made the node to
      node latency will be the latency passed to
      <code>make-lan</code>.
  <li>The behavior of this command is not defined when used with nodes
      that are in the same LAN multiple times.
  <li>Delays of less than 3ms (per trip) are too small to be
      accurately modeled at this time, and will be silently ignored.
</ul>

<h4>tb-set-node-lan-bandwidth</h4>

<pre>
tb-set-node-lan-bandwidth <i>node</i> <i>lan</i> <i>bandwidth</i>

tb-set-node-lan-bandwidth $lan0 $node0 20Mb
</pre>

<dl>
  <dt><i>node</i> - The node we are modifying the bandwidth for.
  <dt><i>lan</i> - Which LAN the node is in that we are affecting.
  <dt><i>bandwidth</i> - The new node to switch bandwidth (see below).
</dl>

<p>Notes:
<ul>
  <li>This command changes the bandwidth between the node and the
      switch of the LAN.  This is only half of the trip a packet must
      take.  The packet will also traverse the switch to the
      destination node which may have a lower bandwidth.
  <li>If this command is not used to overwrite the bandwidth, then the
      bandwidth for a given node to switch link is taken directly from
      the bandwidth passed to <code>make-lan</code>.
  <li>The behavior of this command is not defined when used with nodes
      that are in the same LAN multiple times.
</ul>

<h4>tb-set-node-lan-loss</h4>

<pre>
tb-set-node-lan-loss <i>node</i> <i>lan</i> <i>loss</i>

tb-set-node-lan-loss $lan0 $node0 0.05
</pre>

<dl>
  <dt><i>node</i> - The node we are modifying the loss for.
  <dt><i>lan</i> - Which LAN the node is in that we are affecting.
  <dt><i>loss</i> - The new node to switch loss (see below).
</dl>

<p>Notes:
<ul>
  <li>This command changes the loss probability between the node and the
      switch of the LAN.  This is only half of the trip a packet must
      take.  The packet will also traverse the switch to the
      destination node which may also have a loss chance.  Thus for
      packet going to switch with loss chance <var>A</var> and then
      going on the destination with loss chance <var>B</var> the node
      to node loss chance is
      <code>(1-(1-<var>A</var>)(1-<var>B</var>))</code>.
  <li>If this command is not used to overwrite the loss, then the
      loss for a given node to switch link is taken from the loss rate
      passed to the <code>make-lan</code> command.  If a loss rate of
      <var>L</var> is passed to <code>make-lan</code> then the node to
      switch loss rate for each node is set to
      <code>(1-sqrt(1-<var>L</var>))</code>.  Thus as each packet will
      have two such chances to be lost the node to loss rate comes out
      as the desired <var>L</var>.
  <li>The behavior of this command is not defined when used with nodes
      that are in the same LAN multiple times.
</ul>

<h4>tb-set-node-lan-params</h4>

<pre>
tb-set-node-lan-params <i>node</i> <i>lan</i> <i>delay</i> <i>bandwidth</i> <i>loss</i>

tb-set-node-lan-params $node0 $lan0 40ms 20Mb 0.05
</pre>

<dl>
  <dt><i>node</i> - The node we are modifying the loss for.
  <dt><i>lan</i> - Which LAN the node is in that we are affecting.
  <dt><i>delay</i> - The new node to switch delay.
  <dt><i>bandwidth</i> - The new node to switch bandwidth.
  <dt><i>loss</i> - The new node to switch loss.
</dl>

<p>Notes:
<ul>
  <li>This command is exactly equivalent to calling each of the above
      three commands appropriately.  See above for more information.
  </li>
</ul>

<h4>tb-set-link-simplex-params</h4>

<pre>
tb-set-link-simplex-params <i>link</i> <i>src</i> <i>delay</i> <i>bw</i> <i>loss</i>

tb-set-link-simplex-params $link1 $srcnode 100ms 50Mb 0.2
</pre>

<dl>
  <dt><i>link</i> - The link we are modifying.
  <dt><i>src</i> - The source, defining which direction we are
      modifying.
  <dt><i>delay</i> - The source to destination delay.
  <dt><i>bw</i> - The source to destination bandwidth.
  <dt><i>loss</i> - The source to destination loss.
</dl>

<p>Notes:

<ul>
  <li>This commands modifies the delay characteristics of a link in a
      single direction.  The other direction is unchanged.
  <li>This command only applies to links.  Use
      <code>tb-set-lan-simplex-params</code> below for LANs.
</ul>

<h4>tb-set-lan-simplex-params</h4>

<pre>
tb-set-lan-simplex-params <i>lan</i> <i>node</i> <i>todelay</i> <i>tobw</i> <i>toloss</i> <i>fromdelay</i> <i>frombw</i> <i>fromloss</i>

tb-set-lan-simplex-params $lan1 $node1 100ms 10Mb 0.1 5ms 100Mb 0
</pre>

<dl>
  <dt><i>lan</i> - The lan we are modifying.
  <dt><i>node</i> - The member of the lan we are modifying.
  <dt><i>todelay</i> - Node to lan delay.
  <dt><i>tobw</i> - Node to lan bandwidth.
  <dt><i>toloss</i> - Node to lan loss.
  <dt><i>fromdelay</i> - Lan to node delay.
  <dt><i>frombw</i> - Lan to node bandwidth.
  <dt><i>fromloss</i> - Lan to node loss.
</dl>

<p>Notes:
<ul>
<li>This command is exactly like <code>tb-set-node-lan-params</code>
    except that it allows the characteristics in each direction to be
    chosen separately.  See all the notes for
    <code>tb-set-node-lan-params</code>.
</ul>

<hr>

<a name="VTYPE"></a><h3>Virtual Type Commands</h3>

<p>Virtual Types are a method of defining fuzzy types.  I.e. types
that can be fulfilled by multiple different physical types.  The
advantage of virtual types (vtypes) is that all nodes of the same
vtype will usually be the same physical type of node.  In this way,
vtypes allows logical grouping of nodes.

<p>As an example, imagine we have network with internal routers
connecting leaf nodes.  We want the routers to all have the same
hardware, and the leaf nods to all have the same hardware, but the
specifics of this hardware do not matter.  We have the following
fragment in our NS file:

<pre>
...
tb-make-soft-vtype router {pc600 pc850}
tb-make-soft-vtype leaf {pc600 pc850}

tb-set-hardware $router1 router
tb-set-hardware $router2 router
tb-set-hardware $leaf1 leaf
tb-set-hardware $leaf2 leaf
</pre>

<p>Here we have set up two soft (see below) vtypes, router and leaf.
Our router nodes are then specified to be of type router, and the leaf
nods of type leaf.  When the experiment is swapped in the testbed will
attempt to make router1 and router2 be of the same type, and
similarly, leaf1 and leaf2 of the same type.  However, the
routers/leafs may be pc600s or they may be pc850s, whichever is easier
to fit in to the available resources.

<p>As a basic use, vtypes can be used to request nodes that are all
the same type, but can be of any available type:

<pre>
...
tb-make-soft-vtype N {pc600 pc850}

tb-set-hardware $node1 N
tb-set-hardware $node2 N
...
</pre>

<p>Vtypes come in two varieties, hard and soft.  With soft vtypes, the
testbed will try to make all nodes of that vtype the same physical
type, but may do otherwise if resources are tight.  Hard vtypes behave
just like soft vtypes except that the testbed will give higher
priority to vtype consistency and swapping in will fail if the vtypes
can not be satisfied.  So, if you use soft vtypes you are more likely
to swap in but there is a chance your node of a specific vtype will
not all be the same.  If you use hard vtypes all nods of a given vtype
will be the same, but swapping in may fail.

<p>Finally, you can have weighted soft vtypes.  Here you assign a
weight from 0 to 1 exclusive to your vtype.  The testbed will give
higher priority to consistency in the higher weighted vtypes.  The
primary use of this in to rank multiple vtypes by importance of
consistency.  Soft vtypes have a weight of 0.5 by default.

<p>As a final note, when specifying the types of a vtype, use the most
specific type possible.  For example: tb-make-soft-vtype router {pc
pc600}, is not very useful, as pc600 is a sub type of pc.  You may
very well end up with two routers as type pc with different hardware,
as pc covers multiple types of hardware.

<h4>tb-make-soft-vtype</h4>

<pre>
tb-make-soft-vtype <i>vtype</i> {<i>types</i>}
tb-make-hard-vtype <i>vtype</i> {<i>types</i>}
tb-make-weighted-vtype <i>vtype</i> <i>weight</i> {<i>types</i>}

tb-make-soft-vtype router {pc600 pc850}
tb-make-hard-vtype leaf {pc600 pc850}
tb-make-weighted-vtype A 0.1 {pc600 pc850}
</pre>

<dl>
  <dt><i>vtype</i> - The name of the vtype to create.
  <dt><i>types</i> - One or more physical types.
  <dt><i>weight</i> - The weight of the vtype, 0 < <i>weight</i> < 1.
</dl>

<p>Notes:
<ul>
  <li>These commands create vtypes.  See notes above for description
      of vtypes and the difference between soft and hard.
  <li><code>tb-make-soft-vtype</code> creates vtypes with weight 0.5.
  <li>vtype commands must appear before <code>tb-set-hardware</code>
      commands that use them.
  <li>Do not used <code>tb-fix-node</code> with nodes that have a vtype.
</ul>

<a name="MISC"></a><h3>Misc. Commands</h3>

<h4>tb-fix-node</h4>

<pre>
tb-fix-node <i>vnode</i> <i>pnode</i>

tb-fix-node $node0 pc42
</pre>

<dl>
  <dt><i>vnode</i> - The node we are fixing.
  <dt><i>pnode</i> - The physical node we want used.
</dl>

<p>Notes:
<ul>
  <li>This command forces the virtual node to be mapped to the
      specified physical node.  Swap in will fail if this can not be
      done.
  <li>Do not use this command on nodes that are a virtual type.
</ul>
