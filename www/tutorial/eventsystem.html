<!--
   EMULAB-COPYRIGHT
   Copyright (c) 2005, 2006 University of Utah and the Flux Group.
   All rights reserved.
  -->
<center>
<h1>Emulab Event System Reference</h1>
</center>

<h2>Contents</h2>
<ul>
  <li><a href="#INTRO">Introduction</a>
  <li><a href="#SIMULATOR">NS "Simulator" Agent</a>
  <li><a href="#SEQUENCE">Sequence</a>
  <li><a href="#TIMELINE">Timeline</a>
  <li><a href="#PROGRAM">Program Agent</a>
  <li><a href="#GROUP">Event Group</a>
  <li><a href="#NODE">Node Agent</a>
  <li><a href="#CONSOLE">Console</a>
  <li><a href="#TRAFGEN">Traffic Generator</a>
</ul>

<hr>

<a name="INTRO"></a><h3>Introduction</h3>

<p>
The Emulab event system provides a means for automating your experiments.  The
event system consists of several types of "agents" that implement some sort of
functionality, such as running programs or generating traffic, and a scheduler
that triggers the events at the appropriate time.  When your experiment is
swapped in, any agents specified in your NS file are automatically setup on the
experimental nodes and the ops node.  A short time after the experiment becomes
<i>active</i>, "event time" begins to flow.  As event time progresses, any
events scheduled in the NS file for a particular time offset are sent to the
appropriate agents.  Alternatively, events can be sent at runtime using the
<b>tevc</b> command from ops or an experimental node.  For a detailed
walkthrough of using the event system, see the <a
href="docwrapper.php3?docname=advanced.html">advanced example</a>.

<p>
Recently, we have added some experimental extensions to make the event system
even more capable.  Note that many of these features are subject to change and
are only available when using the latest versions of the FBSD410-STD and
RHL90-STD disk images.  The NS file below gives an example of using these
extensions to automate the process of creating disk images.  First, it
downloads a network traffic analyzer, <a
href="http://www.ex-parrot.com/~pdw/iftop/">iftop</a>, then proceeds to build
and install the software.  Next, the source directory is removed and a snapshot
is taken of the node's disk.  Finally, after the snapshot completes and the
node has finished rebooting, the experiment is swapped out.

<blockquote style='border-style:solid; border-color:#bbbbbb; border-width: thin'>
<code><pre>
 set opt(VERSION) 0.16

 set ns [new Simulator]
 source tb_compat.tcl

 set node [$ns node]
 tb-set-node-tarfiles $node \
     /tmp http://www.ex-parrot.com/~pdw/iftop/download/iftop-$opt(VERSION).tar.gz

 set builder [$node program-agent -dir "/tmp/iftop-$opt(VERSION)"]
 set cleaner [$node program-agent]

 set build [$ns event-sequence {
     $builder run -command "./configure"
     $builder run -command "gmake"
     $builder run -command "sudo gmake install"
 }]

 set clean [$ns event-sequence {
     $cleaner run -command "sudo rm -rf /tmp/iftop-$opt(VERSION)"
 }]

 set doit [$ns event-sequence {
     $build run
     $clean run
     $node snapshot-to RHL90-CUSTOMIZED
     $ns swapout
 }]

 $ns at 0.0 "$doit start"
 $ns run
</pre></code>
</blockquote>
<center>
<font size="-2">An example NS file that automates the process of installing
software on a node and taking a snapshot of the disk image.</font>
</center>

<p>
We also have a small package containing a more complicated experiment that runs
BitTorrent on a bunch of nodes, collects their output, and generates a simple
report on how they performed.

<blockquote>
<a href="http://www.emulab.net/downloads/btexp-0.1.tar.gz">BitTorrent
experiment package</a>
</blockquote>

<p>
The rest of this document is intended as a reference manual for the available
set of agents and the events they can handle.

<hr>

<a name="SIMULATOR"></a><h3>NS "Simulator" Agent</h3>

Constructor: <code>new Simulator</code>

<p>
The simulator agent provides control over your Emulab experiment as a whole.

<p>
The simulator agent listens for the following events:

<ul>
<li><b>swapout</b> - Swap out the experiment.

<li><b>terminate</b> - Terminate the experiment.  <i>Warning</i>: This event
will completely destroy every trace of the experiment and there is no
confirmation.

<li><b>report</b> <i>[-digester script]</i> - Automatically generate and send a
"report" e-mail to the user.  Typically, this event should be sent at the end
of an experimental "trial", when all of the data has been produced and it is
time to gather, analyze, and archive the data.  Gathering and archiving the
data is handled by the <a
href="docwrapper.php3?docname=loghole.html">loghole</a> utility, which copies
log files on the nodes to the experiment's log directory.  Simple analysis can
be done by specifying a "digester" script that processes the log files.  Once
all of the data processing has been finished, an e-mail will be sent to the
user containing the following:
  <ul>
  <li>The contents of any <b>message</b> events sent to the simulator agent.
  <li>The output from the digester script.
  <li>The captured NS file <a
      href="docwrapper.php3?docname=nscommands.html#PARAMETERS">parameters</a>
  <li>Any <b>log</b> messages sent to the simulator, along with log messages
  automatically generated by the simulator.
  <li>For any programs that exited with an error, a description of the command
  that failed and the tails of their standard error and output files.
  </ul>

<li><b>message</b> <i>string</i> - Append a string to the head of the e-mail
sent by the <b>report</b> event.
<li><b>log</b> <i>string</i> - Append a log message to the tail of the e-mail
sent by the <b>report</b> event.
</ul>

<p>
<h4>NS Examples:</h4>

<blockquote style='border-style:solid; border-color:#bbbbbb; border-width: thin'>
<code><pre>
 set ns [new Simulator]

 ...

 set doit [$ns event-sequence {
    $ns message "Testing one way, then the other..."
    $thisway run
    $thatway run
    $ns report
 }]
</pre></code>
</blockquote>
<center>
<font size="-2">Example 1: Adds some text to the report e-mail, runs an
application twice, and then sends a report to the user.</font>
</center>


<a name="SEQUENCE"></a><h3>Event Sequence</h3>

Constructor: <code>$ns event-sequence [<i>body</i>]</code>

<ul>
  <li><i>body</i> - The list of events to be sent.  If none is specified,
  events can be added using the sequence's <code>append</code> method.
</ul>

<p>
An event sequence agent is an ordered list of events, each of which is sent
when the previous event in the list has reported its completion.  For example,
in a sequence consisting of a pair of events that run programs, the first event
will be sent immediately and the second will be sent when the run of the first
program completes.  While running two programs in a row may be trivial using
conventional means, this capability works across machines and can interact with
other operations like reloading disks and rebooting machines.

<p>
The semantics of when an event "completes" depend on the type of agent and
event.  Many events complete instantaneously, such as those used to set a
property, so the next event in the sequence is sent immediately.  Other events
that take a variable amount of time to complete, such as running a program.
Some agents provide two types of events to support non-blocking and blocking
operation, usually called <b>start</b> and <b>run</b>.  Whereas the
<b>start</b> event completes instantly, the <b>run</b> blocks the sequence
until the agent is finished.

<p>
Event sequences listen for the following events:

<ul>
<li><b>start, run</b> - Begins the execution of the sequence.  When the
<b>run</b> event is used inside another sequence, this sequence will complete
when the last event completes.
</ul>

<p>
<h4>NS Examples:</h4>

<blockquote style='border-style:solid; border-color:#bbbbbb; border-width: thin'>
<code><pre>
 set doit [$ns event-sequence {
     $prog0 run -command "setup.sh"
     $node0 reboot
     $prog0 run -command "test.sh"
 }]
</pre></code>
</blockquote>
<center>
<font size="-2">Example 1: A sequence that performs some setup on a node,
reboots it, and then starts the test.</font>
</center>

<blockquote style='border-style:solid; border-color:#bbbbbb; border-width: thin'>
<code><pre>
 set doit [$ns event-sequence {
     $serverprog start; # Start the server,
     $clientprogs run;  # run the clients to completion, then
     $serverprog stop;  # stop the server.
 }]
</pre></code>
</blockquote>
<center>
<font size="-2">Example 2: A sequence that asynchronously starts a server, runs
some clients, and finally, stops the server.</font>
</center>

<blockquote style='border-style:solid; border-color:#bbbbbb; border-width: thin'>
<code><pre>
 set testseq [$ns event-sequence]

 foreach test $tests {
     $testseq append "$prog0 -run \"$test\""
 }
</pre></code>
</blockquote>
<center>
<font size="-2">Example 3: A sequence that is constructed incrementally instead
of being fully specified in the constructor.</font>
</center>


<a name="TIMELINE"></a><h3>Event Timeline</h3>

Constructor: <code>$ns event-timeline</code>

<p>
An event timeline agent sends other events at a relative offset to the overall
start time of the timeline.  In other words, a timeline is a first class
version of the existing "$ns at" syntax.

<p>
Event timelines listen for the following events:

<ul>
<li><b>start, run</b> - Starts the timeline.  When <b>run</b> is used in a <a
href="#SEQUENCE">sequence</a>, the timeline completes when it sends the last
event.
</ul>

<p>
<h4>NS Examples:</h4>

<blockquote style='border-style:solid; border-color:#bbbbbb; border-width: thin'>
<code><pre>
 set tl [$ns event-timeline]

 $tl at 0s "$prog0 start"
 $tl at 15s "$prog0 stop"

 set seq [$ns event-sequence {
     $tl run
     $ns swapout
 }]
</pre></code>
</blockquote>
<center>
<font size="-2">Example 1: A timeline that runs a program for 15
seconds and then swaps out the experiment.</font>
</center>


<a name="PROGRAM"></a><h3>Program Agent</h3>

Constructor: <code>$node program-agent [-command <i>cmdline</i>]
[-dir <i>dir</i>] [-timeout <i>seconds</i>] [-tag <i>string</i>]
&nbsp;&nbsp;[-expected-exit-code <i>code</i>]
</code>

<ul>
<li>-command "<i>cmdline</i>" - Specifies the command-line to run.  Defaults to
the last command that was run or the command specified in the NS file.
See <a href="#PROGRAM-CMDLINE">below</a>for additional notes on command lines.

<li>-dir <i>directory</i> - Specifies the directory to run the command within.
Defaults to the last directory that was specified, the directory in the NS
file, or "/tmp".

<li>-timeout <i>seconds</i> - Specifies the timeout, in seconds, for the
command or zero for no timeout.  If the command does not complete before the
timeout, it will be stopped forcefully.  Defaults to the last timeout used for
this agent or no timeout.

<li>-tag <i>string</i> - Specifies the symbolic tag to be attached to this
invocation of the agent and its output log file names.  By default, invocations
are identified by a unique number, so this option allows the user to attach a
more meaningful identifier.

<li>-expected-exit-code <i>number</i> - The expected exit code for the command,
this value is compared against the actual exit code to determine whether or not
the command completed successfully.  Unsuccessful commands run by a sequence
will cause the sequence to stop executing and also fail.  Defaults to the last
value used or zero.
</ul>

<p>
Program agents listen for the following events:

<ul>
<li><b>start, run</b> <i>[options]</i> - Starts the program by running the
command-line in the specified directory and capturing its standard output and
error.  The agent will then switch into "management" mode and only accept
<b>stop</b> and <b>kill</b> events until the command terminates.  The event
accepts the same options as the constructor, so you can change the command to
be run on the fly.

<p>
The output from the command is stored in the "/local/logs" directory on the
node.  Each invocation of the agent is stored in a separate file tagged with a
unique id, in addition, the stdout and stderr data are stored separately in
".out" and ".err" files.  To make it easier to locate the last invocation of
the agent, soft links are created with file names that lack the unique id
(e.g. "prog0.out" -> "prog0.out.5").  If a "tag" is specified, a soft link will
also be created that refers to the actual file (e.g. "prog0.baseline.out" ->
"prog0.out.5").

<p>
The command will be executed with the following environment variables set:

<table>
<tr><th>Variable</th><th>Description</th></tr>

<tr>
<td>PATH</td>
<td>The default path for binaries is set to the standard path (e.g. /usr/bin,
/bin, /usr/sbin, /sbin), the binary directories in /usr/local, and the
directory containing Emulab specific binaries.</td>
</tr>

<tr>
<td>EXPDIR</td>
<td>The experiment's directory in NFS space (e.g. /proj/foo/exp/bar).</td>
</tr>

<tr>
<td>LOGDIR</td>
<td>The preferred directory for log files on the local machine.</td>
</tr>

<tr>
<td>USER</td>
<td>The name of the user that swapped in this experiment.</td>
</tr>

<tr>
<td>HOME</td>
<td>The path to the user's home directory.</td>
</tr>

<tr>
<td>GROUP</td>
<td>The name of the unix group for the user that swapped in this experiment.
</td>
</tr>

<tr>
<td>PID</td>
<td>The project ID for the experiment this agent is running within.</td>

<tr>
<td>EID</td>
<td>The experiment ID for the experiment this agent is running within.</td>
</tr>

<tr>
<td>NODE</td>
<td>The name of the node this program agent is running on.  Note that this is
the short name and <i>not</i> the fully qualified host name that would refer to
the control interface.</td>
</tr>

<tr>
<td>NODEIP</td>
<td>The IP address of the experiment network interface that the node name maps
to.  For nodes with no experimental interfaces, this variable will not be
set.</td>
</tr>

<tr>
<td>set opt(<b><i>VAR</i></b>) <i>values</i></td>

<td>Any entries in the "opt" array of the NS file will automatically be added
to the environment.  For example, to set a variable named "DURATION" with a
value of "100", you would add "set opt(DURATION) 100" to the top of your NS
file.  See <a
href="docwrapper.php3?docname=nscommands.html#PARAMETERS">captured
parameters</a>.</td>

</tr>
</table>
<br>

<li><b>stop</b> - Stops the program, if it is currently running, by sending a
SIGTERM to the process group.

<li><b>kill</b> <i>signal</i> - Signals the program with the given signal name.
For example, to send a SIGHUP to the process you would use "sighup", or for
<b>tevc</b>, "SIGNAL=SIGHUP".

<li><b>set</b> - Set the properties of the program agent, accepts the same
arguments as the <b>start</b> event.

</ul>

<br>

<a name="PROGRAM-CMDLINE"></a>
<h4>Notes on Command Lines</h4>
In general, if you have complicated or multiple commands to execute,
it is best to put them in a script and specify the script name in -command.
But if you insist, here are some things to be aware of.
<p>
The command line is executed with "csh -c."  Yes, that is the Berkeley
C-shell and not the Bourne shell or bash.  Sorry, it is an historical thing.
So be aware of differences in redirection and expansion syntax (e.g.,
">&" and "{}").  When in doubt, put your command in a script and set
the command line to "sh -c myscript.sh".
<p>
Quoting is fragile and happens at a couple of levels:
<ol>
<li>Quoting for TCL.  Putting curly braces ({...}) or double quotes ("...")
around the entire command line will quote the string to TCL (i.e., the NS
script parser language).  Double quotes allows for TCL variable expansion,
curly braces allow no expansion.  Thus, these quotes will be stripped off
before the command line is given to csh.  Use this mechanism if your command
line has white space (i.e., arguments to the command), otherwise the Emulab
NS parser will flag an error.

<li>Quoting for csh.  Recall that the program agent runs a shell to interpret
your commands, so you may need additional quoting to get special characters
past it.  For example, if one of your command arguments has an embedded space,
you will need to quote it with single or double quotes.  Backslash quoting
also works.
</ol>
<p>
A sick example might look like this:
<code><pre>
  ... -command {echo arg{1,2} "arg3 has spaces" arg4\ has\ \'\ \'\ too}
</pre></code>
where the <code>echo</code> command would have four arguments:
<code><pre>
  arg1
  arg2
  arg3 has spaces
  arg4 has ' ' too
</pre></code>
<p>
To summarize: put your commands in a script.
<br>
<h4>Other Notes:</h4>
<ol>
<li> Many of the features described here are only available on recent
FBSD{410,54,61}-STD, RHL90-STD, and FC4-STD disk images.

<li> This page currently only covers the agent at a high-level, you
can find some more detail in the <i>program-agent(8)</i> man page on ops or an
experimental node.
</ol>

<p>
<h4>NS Examples:</h4>

<blockquote style='border-style:solid; border-color:#bbbbbb; border-width: thin'>
<code><pre>
 set prog0 [$node0 program-agent]
 set prog1 [$node0 program-agent -command "/usr/bin/env"]
 set prog2 [$node0 program-agent -command "inf_loop_bug" -timeout 10]
 set prog3 [$node0 program-agent -command "ls" -dir "/foo/bar"]
</pre></code>
</blockquote>
<center>
<font size="-2">Example 1: Creates four program agents with different default
properties.</font>
</center>



<a name="GROUP"></a><h3>Event Group</h3>

Constructor: <code>$ns event-group [<i>list-of-agents</i>]</code>

<ul>
  <li><i>list-of-agents</i> - A TCL list of the agents to be in the group.
</ul>

<p>
The event group agent is used to broadcast events to a group of agents of the
same type.  For example, if you wanted to start a program on a large number of
nodes at the same time, you can create a group consisting of those
program-agents and send a single <b>start</b> event to the group.  An event
group can also act as a simple synchronization method when used inside an <a
href="#SEQUENCE">event-sequence</a>.  In this case, the next event in the
sequence won't be sent until all of the agents in the group have signalled
completion.

<p>
<h4>NS Examples:</h4>

<blockquote style='border-style:solid; border-color:#bbbbbb; border-width: thin'>
<code><pre>
 set group [$ns event-group]
 for {set i 0} {$i < 4} {incr i} {
     set nodes($i) [$ns node]
     set progs($i) [$nodes(i) program-agent]
     $group add $progs($i)
 }

 set doit [$ns event-sequence {
     $group run -command "setup.sh"
     $group run -command "client.sh"
 }]
</pre></code>
</blockquote>
<center>
<font size="-2">Example 1: Runs the "setup.sh" script on a group of nodes and
when they have all completed, runs the "client.sh" script.</font>
</center>

<blockquote style='border-style:solid; border-color:#bbbbbb; border-width: thin'>
<code><pre>
 set group [$ns event-group [list $rnode $lnode]]

 set doit [$ns event-sequence {
     $group reboot
     $ns log "Reboot finished"
 }]
</pre></code>
</blockquote>
<center>
<font size="-2">Example 2: Reboots a pair of nodes and logs a message with the
simulator.</font>
</center>


<a name="NODE"></a><h3>Node Agent</h3>

Constructor: <code>$ns node</pre>

<p>
In addition to allocating an actual machine, the "$ns node" constructor will
create a node agent so the node can be controlled from the event system.

<p>
Node agents listen for the following events:

<ul>
<li><b>reboot</b> - Reboot the node.  When used in a <a
href="#SEQUENCE">sequence</a>, this event will complete when the node has
finished booting and is considered "up".

<li><b>snapshot-to</b> <i>imagename</i> - Snapshot the node's disk into the
given <a href="docwrapper.php3?docname=tutorial.html#CustomOS">disk image</a>.
Before the snapshot is taken, the node's logs will be sync'd back to ops using
the <a href="docwrapper.php3?docname=loghole.html">loghole</a> utility and the
"/local/logs" directory will be cleaned out.  When used in a <a
href="#SEQUENCE">sequence</a>, this event will complete when the snapshot has
been taken and the node has finished booting and is considered "up".

<li><b>reload</b> <i>[-image imagename]</i> - Reload the node's disk with the
default image or the given image.  When used in a <a
href="#SEQUENCE">sequence</a>, this event will complete when the node has
finished booting and is considered "up".

<li><b>setdest</b> <i>x y speed [-orientation degrees]</i> - (<a
href="mobilewireless.php3">mobile</a> nodes only)  This event will set the next
physical destination for the node.  When used in a <a
href="#SEQUENCE">sequence</a>, this event will complete when the node has
reached its destination.  If another <b>setdest</b> event is sent to a node
before it has reached its current destination, the new destination will
overwrite the old one.
</ul>


<a name="CONSOLE"></a><h3>Console Agent</h3>

Constructor: <code>$node console</code>

<p>
Console agents operate on the serial consoles attached to some Emulab nodes.
Currently, they only support capturing a slice of the output received on the
serial line.

<p>
Console agents listen for the following events:

<ul>
<li><b>start</b> - Start recording the serial console output from a node.
<li><b>stop</b> <i>id</i> - Stop recording the serial console output from a
node and save it to a file named "<i>agentname</i>-<i>id</i>.log" in the
experiment's log directory.
</ul>


<a name="TRAFGEN"></a><h3>Traffic Generator</h3>

Traffic generation agents output network traffic at a constant bit rate over a
link.  Consult the <a href="docwrapper.php3?docname=advanced.html">advanced
example</a> for more information and examples of their use.

<p>
Traffic generators listen for the following events:

<ul>
<li><b>start</b> - Start sending traffic.
<li><b>stop</b> - Stop sending traffic.
<li><b>set</b> - Change characteristics of the traffic.
</ul>
