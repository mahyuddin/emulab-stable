#!/usr/bin/perl -w

#
# EMULAB-COPYRIGHT
# Copyright (c) 2003 University of Utah and the Flux Group.
# All rights reserved.
#

#
# newnode - a script for moving nodes from the new_ tables into production.
#

use lib '@prefix@/lib';

use libdb;
use English;

use strict;

my $TB = "@prefix@";

my $switchmac = "$TB/sbin/switchmac";
my $os_load = "$TB/bin/os_load";
my $os_select = "$TB/bin/os_select";
my $newnode_reboot = "$TB/sbin/newnode_reboot";
my $named_setup = "$TB/sbin/named_setup";
my $nalloc = "$TB/bin/nalloc";
my $nfree = "$TB/bin/nfree";
my $dhcpd_makeconf = "$TB/sbin/dhcpd_makeconf";
my $exports_setup = "$TB/sbin/exports_setup";

my $dhcpd_conf = "/usr/local/etc/dhcpd.conf";
my $dhcpd_template = "/usr/local/etc/dhcpd.conf.template";
my $dhcpd_rc = "/usr/local/etc/rc.d/2.dhcpd.sh";

my $sudo = "/usr/local/bin/sudo -S";

#
# Initial event system state to put the nodes into
#
my $INITIAL_STATE = TBDB_NODESTATE_SHUTDOWN;
my $INITIAL_OPMODE = TBDB_NODEOPMODE_RELOAD;

#
# MFS to boot the nodes into initially
#
my $INITIAL_MFS = "PXEFBSD";

#
# Number of vnodes to create for each physical node
#
my $NUM_VNODES = 50;

# Turn off line buffering on output
$| = 1;

if (!TBAdmin()) {
    die "Sorry, only testbed administrators can run this script!\n";
}

#
# We seem to have to do this so that ssh gets proper root permissions to read
# the key file. Argh.
#
$UID = $EUID = 0;

if (@ARGV < 1) {
    die "Usage: $0 <node_id> ...\n";
}

#
# The user has to be able to run sudo, so they can restart dhcpd.
#
if (system "$sudo /bin/pwd < /dev/null") {
    die "You must be able to sudo to root to use this script\n";
}

#
# Make sure that the dhcpd template file exists, and that the real version
# is writable
#
if (!-e $dhcpd_template) {
    die "In order to use this script, $dhcpd_template must exist!\n";
}
if (!-w $dhcpd_conf) {
    die "In order to use this script, you must be able to write $dhcpd_conf\n";
}

#
# For vnodes - figure out the jail IP base
#
my $IPBASE;
if (TBDB_JAILIPBASE =~ /^(\d+).(\d+).(\d+).(\d+)/) {
    $IPBASE = "$1.$2";
} else {
    die "Problem with JAILIPBASE\n"
}

my @node_ids = @ARGV;

#
# Now, loop through the nodes given, and add each one
#
my (@succeeded_nodes, @succeeded_IPs);
NODE: foreach my $node_id (@node_ids) {
    my $query_result;

    #
    # Check to make sure said node does not already exist!
    #
    $query_result = DBQueryFatal("SELECT node_id FROM nodes WHERE " .
	"node_id='$node_id'");
    if ($query_result->num_rows()) {
	warn "Node $node_id failed: a node with that name already exists!\n";
	next NODE;
    }

    #
    # Grab information about the node from the new_nodes table
    #
    $query_result = DBQueryFatal("SELECT new_node_id, type, IP, temporary_IP " .
	"FROM new_nodes WHERE node_id='$node_id'");
    if (!$query_result->num_rows()) {
	warn "Node $node_id failed: No pending node with that name exists!\n";
	next NODE;
    }
    my ($new_node_id, $type, $IP, $tempIP) = $query_result->fetchrow();

    #
    # Make sure that the new node is of a valid type, and grab a few other
    # things to fill in as initial values
    #
    $query_result = DBQueryFatal("SELECT control_iface FROM node_types " .
	"WHERE type='$type'");
    if (!$query_result->num_rows()) {
	warn "Node $node_id failed: Type $type does not exist!\n";
	next NODE;
    }
    my ($control_iface) = $query_result->fetchrow();

    #
    # Grab the node's MACs from the new_interfaces table
    #
    $query_result = DBQueryFatal("SELECT card, MAC, interface_type, " .
	"switch_id, switch_card, switch_port " .
	"FROM new_interfaces WHERE new_node_id='$new_node_id'");
    if (!$query_result->num_rows()) {
	warn "Node $node_id failed: Must have at least one interface!\n";
	next NODE;
    }

    my %interfaces;
    while (my ($card, $MAC, $iface_type, $switch_id, $switch_card,
	    $switch_port) = $query_result->fetchrow()) {
	#
	# Get some more information about this interface type
	#
	my $iface_query = DBQueryFatal("SELECT max_speed, full_duplex " .
	    "FROM interface_types WHERE type='$iface_type'");
	if (!$iface_query->num_rows()) {
	    warn "Node $node_id failed: Interface $card is of unknown type " .
	    	"$iface_type";
	    next NODE;
	}

	my ($max_speed, $full_duplex) = $iface_query->fetchrow();

	#
	# Stash it away...
	#
	$interfaces{$card} = [$MAC, $iface_type, $max_speed, $full_duplex,
		$switch_id, $switch_card, $switch_port];

    }

    #
    # Make up a priority (just used for sorting)
    #
    $node_id =~ /^(.*\D)(\d+)$/;
    my ($prefix,$nodenum) = ($1, $2);
    my $priority;
    if (defined $nodenum) {
	$priority = $nodenum;
    } else {
	$priority = 1;
    }

    #
    # Okay, time to actually add the node!
    #
    
    DBQueryFatal("INSERT INTO nodes SET node_id='$node_id', type='$type', " .
	"phys_nodeid='$node_id', role='testnode', priority=$priority, " .
    	"eventstate='$INITIAL_STATE', op_mode='$INITIAL_OPMODE'");

    #
    # Add some vnodes
    #
    if (defined $nodenum) {
	my $vtype = $type;
	if (!($vtype =~ s/pc/pcvm/)) {
	    $vtype = "$vtype-vm";
	}
	for (my $i = 1; $i <= $NUM_VNODES; $i++) {
	    my $vpriority = 10000000 + ($nodenum * 1000) + $i;
	    my $nodename = $node_id;
	    if (!($nodename =~ s/pc/pcvm/)) {
		$nodename = "$nodename-vm";
	    }
	    $nodename .= "-$i";
	    my $jailip = "${IPBASE}.${nodenum}.${i}";

	    DBQueryFatal("INSERT INTO nodes SET node_id='$nodename', " .
		"type='$vtype', phys_nodeid='$node_id', role='virtnode', " .
		"priority='$vpriority', op_mode='PCVM', " .
		"eventstate='SHUTDOWN', " .
		"def_boot_osid='emulab-ops-FBSD-JAIL', " .
		"update_accounts=1, jailflag=1, jailip='$jailip'");
	}
    }

    while (my ($card, $aref) = each %interfaces) {
	my ($MAC, $iface_type, $speed, $duplex, $switch_id, $switch_card,
	    $switch_port) = @$aref;
	my $iface = "eth$card";
	my $iface_IP = "";
	my $wire_type = "Node";
	my $iface_role = TBDB_IFACEROLE_EXPERIMENT();
	if ($iface eq $control_iface) {
	    $iface_IP = $IP;
	    $wire_type = "Control";
	    $iface_role = TBDB_IFACEROLE_CONTROL();
	}
	DBQueryFatal("INSERT INTO interfaces SET node_id='$node_id', " .
	    "card=$card, port=1, mac='$MAC', IP='$iface_IP', " .
	    "interface_type='$iface_type', iface='$iface', " .
	    "current_speed='$speed', duplex=$duplex, role='$iface_role'");

	if (!$switch_id) {
	    print "No switch found for ${node_id}:$iface - skipping\n";
	    next;
	}
	DBQueryFatal("INSERT INTO wires SET type='$wire_type', " .
	    "node_id1='$node_id', card1=$card, port1=1, " .
	    "node_id2='$switch_id', card2='$switch_card', " .
	    "port2='$switch_port'");
    }

    #
    # Put it into hwdown for now - I would put them in reloading, but I'm
    # afriad the reload_daemon might do the wrong thing to them
    #
    system "$nalloc emulab-ops hwdown $node_id";

    #
    # Remove the node from the new_ tables
    #
    DBQueryFatal("DELETE FROM new_nodes WHERE new_node_id=$new_node_id");
    DBQueryFatal("DELETE FROM new_interfaces WHERE new_node_id=$new_node_id");

    print "$node_id succesfully added!\n";

    push @succeeded_nodes, $node_id;
    push @succeeded_IPs, $tempIP;
}

#
# No point in restarting dhcpd, etc. if there are no nodes that succeeded
#
if (!@succeeded_nodes) {
    die "No nodes succeeded, exiting early\n";
}

#
# Re-generate dhcpd.conf
#
print "Re-generating dhcpd.conf\n";
open(CONF,"$dhcpd_makeconf $dhcpd_template|") or die "Unable to fork: $!\n";
my @conf = <CONF>;
close CONF or die "Error reading from dhcpd_makeconf: $!\n";

open(CONF,">$dhcpd_conf") or die "Unable to open $dhcpd_conf for writing\n";
print CONF @conf;
close CONF;

print "Restarting dhcpd: $sudo $dhcpd_rc stop\n";
my $sudo_rv = system "$sudo $dhcpd_rc stop";
if ($sudo_rv) {
    die "Error stopping dhcpd - return value was $sudo_rv\n";
}
sleep 2;
print "Restarting dhcpd: $sudo $dhcpd_rc start\n";
$sudo_rv = system "$sudo $dhcpd_rc start";
if ($sudo_rv) {
    die "Error starting dhcpd - return value was $sudo_rv\n";
}

print "Setting up nameserver\n";
my $named_rv = system "$named_setup";
if ($named_rv) {
    die "Error running named_setup - return value was $named_rv\n";
}

#
# Before we boot nodes into the MFS, we have to make sure they can mount
# NFS filesystems
#
print "Running exports_setup\n";
my $exports_rv = system "$exports_setup";
if ($exports_rv) {
    warn "WARNING - exports_setup returned $exports_rv";
}

#
# Tell the nodes to boot into the FreeBSD MFS, so that we have them in a state
# which we can control - this also puts them into a state that the event system
# likes better
#
print "Instructing nodes to boot into the FreeBSD MFS\n";
my $select_rv = system "$os_select -m $INITIAL_MFS " .
    join(" ",@succeeded_nodes);
if ($select_rv) {
    warn "WARNING - failed to select FreeBSD MFS for nodes";
}

#
# Start rebooting nodes
#
print "Rebooting nodes...\n";
foreach my $IP (@succeeded_IPs) {
    print "Rebooting $IP\n";
    system "$newnode_reboot $IP\n";
}

print "\n\n";
print "Finished - when you are satisifed that the nodes are working\n";
print "correctly, use nfree on boss to free them from the emulab-ops/hwdown\n";
print "experiment.\n";

#
# TODO -
#    disable interfaces
#    console setup
#
