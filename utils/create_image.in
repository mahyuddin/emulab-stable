#!/usr/bin/perl -wT
use English;
use Getopt::Std;

#
# Create a disk image.
#
# XXX: Device file should come from DB.
#      Start/count slice computation is not generalized at all.
#
sub usage()
{
    print STDOUT
	"Usage: create_image [-p <pid>] <image descriptor> <node>\n" .
	"Use -p to specify the project ID of the image descriptor.\n" .
	"  Defaults to system project.\n";
    exit(-1);
}
my  $optlist = "p:";

#
# Configure variables
#
my $TB		= "@prefix@";
my $TBOPS       = "@TBOPSEMAIL@";
my $TBLOGS      = "@TBLOGSEMAIL@";
my $BOSSNODE	= "@BOSSNODE@";
my $PROJROOT	= "/proj";
my $TFTPDIR     = "/tftpboot";

#
# Testbed Support libraries
#
use lib "@prefix@/lib";
use libdb;
use libtestbed;

#
# Turn off line buffering on output
#
$| = 1;

#
# Untaint the path
# 
$ENV{'PATH'} = "/bin:/sbin:/usr/bin:";
delete @ENV{'IFS', 'CDPATH', 'ENV', 'BASH_ENV'};

my $freebsd     = "$BOSSNODE:$TFTPDIR/pxeboot.freebsd";
my $nodereboot	= "$TB/bin/node_reboot";
my $createimage = "/usr/local/bin/create-image";
my $device      = "/dev/rad0";
my $mereuser    = 0;
my %imageid_row = ();
my $debug       = 0;
my $imageid;
my $imagepid    = TB_OPSPID;
my $logname;
my @row;
my $dbuid;

#
# Parse command arguments. Once we return from getopts, all that should be
# left are the required arguments.
#
%options = ();
if (! getopts($optlist, \%options)) {
    usage();
}
if (@ARGV != 2) {
    usage();
}

my $imagename  = $ARGV[0];
my $node       = $ARGV[1];

#
# Untaint the arguments.
#
if ($node =~ /^([-\w]+)$/) {
    $node = $1;
}
else {
    die("*** Bad data in $node\n");
}

if ($imagename =~ /^([-\w\.\+]+)$/) {
    $imagename = $1;
}
else {
    die("*** Bad data in $imagename.\n");
}
    
if (defined($options{"p"})) {
    $imagepid = $options{"p"};
	
    if ($imagepid =~ /^([-\w\.\+]+)$/) {
	$imagepid = $1;
    }
    else {
	die("*** Bad data in $imagepid.\n");
    }
}

#
# Verify user and get his DB uid.
#
if (! UNIX2DBUID($UID, \$dbuid)) {
    die("*** You do not exist in the Emulab Database.\n");
}

#
# Verify Permission.
#
if ($UID && !TBAdmin($UID)) {
    $mereuser = 1;

    if (! TBNodeAccessCheck($UID, TB_NODEACCESS_LOADIMAGE, $node)) {
	die("*** You do not have permission to create an image from $node\n");
    }
}

#
# Get email info for user.
#
my $user_name;
my $user_email;
if (! UserDBInfo($dbuid, \$user_name, \$user_email)) {
    die("*** Cannot determine user name and email address");
}

#
# We need the project id for test below. The target directory for the
# output file has to be the node project directory, since that is the
# directory that is going to be NFS mounted by default.
#
my $pid;
my $eid;
if (! NodeidToExp($node, \$pid, \$eid)) {
    die("*** Could not map $node to its pid/eid");
}

#
# Grab the imageid description from the DB. We do a permission check, but
# mostly to avoid hard to track errors that would result if the user picked
# the wrong one (which is likely to happen no matter what I do).
#
$db_result =
    DBQueryFatal("select * from images where ".
		 "pid='$imagepid' and imagename='$imagename'");
    
if ($db_result->numrows < 1) {
    die("*** No such image descriptor $imagename in project $imagepid!");
}
%imageid_row = $db_result->fetchhash();
$imageid = $imageid_row{'imageid'};

if ($mereuser &&
    ! TBImageIDAccessCheck($UID, $imageid, TB_IMAGEID_ACCESS)) {
    die("*** You do not have permission to use imageid $imageid!\n");
}

#
# Make sure that the filename is a /proj/$pid filename and a directory that
# exists and is writeable for the user. We test this by creating the file.
# Its going to get wiped anyway.
#
my $filename = $imageid_row{'path'};

# Untaint. Very silly.
if ($filename =~ /^([-\w\.\/]+)$/) {
    $filename = $1;
}
else {
    die("Bad filename: $filename");
}

if (! ($filename =~ /^$PROJROOT\/$pid\/.*/)) {
    die("File $filename for must reside someplace in $PROJROOT/$pid\n");
}
open(FILE, "> $filename") or
    die("Could not create $filename: $!");
close(FILE) or
    die("Could not truncate $filename: $!");

#
# Okay, we want to build up a command line that will run the script on
# on the client node. We use the imageid description to determine what
# slice (or perhaps the entire disk) is going to be zipped up. We do not
# allow arbitrary combos of course. 
#
my $startslice = $imageid_row{'loadpart'};
my $loadlength = $imageid_row{'loadlength'};
my $command    = "$createimage ";

if ($startslice || $loadlength == 1) {
    $command = "$command -s $startslice $device $filename";
}
else {
    $command = "$command $device $filename";
}

#
# Go to the background since this is going to take a while.
# 
if (!$debug) {
    $logname = `mktemp /tmp/create-image-$pid-$eid.XXXXXX`;

    if ($logname =~ /^([-\@\w.\/]+)$/) {
	$logname = $1;
    }
    else {
	die("Bad data in logfile name: $logname");
    }
    if (TBBackGround($logname)) {
	#
	# Parent exits normally
	#
	print STDOUT
	    "Your image from $node is being created\n".
	    "You will be notified via email when the image has been\n".
	    "completed, and you can load the image on another node.\n";
	exit(0);
    }
}

#
# We want to save off the old pxeboot/startupcmd and replace them with
# the special freebsd boot, and the command we created above. Then we
# reboot the node, and wait for it to come back alive. We also clear the
# startcommand status, and and use that to wait for the zipper to finish.
# I think we need a better mechanism for determining when a node is booted
# since we are basically stuck waiting for this, without knowing if the node
# even came up okay.
#
$query_result =
    DBQueryWarn("select pxe_boot_path,startupcmd from nodes ".
                "where node_id='$node'");

if (!$query_result ||
    $query_result->numrows < 1) {
    fatal("DB error getting node info for $node");
}
@row = $query_result->fetchrow_array();
my $saved_pxebootpath = $row[0];
my $saved_startupcmd  = $row[1];

my $result   = 0;
my $maxwait  = (60 * 20); # 20 minutes in seconds.
my $sleepwait= 10;	  # seconds.
my $maxloops = ($maxwait / $sleepwait);
my $tries    = 2;

while ($tries) {
    if (! DBQueryWarn("update nodes set pxe_boot_path='$freebsd', ".
		      "startupcmd='$command', startstatus='none' ".
		      "where node_id='$node'")) {
	fatal("DB error updating node info for $node");
    }

    #
    # Reboot node. If this fails must reset. Note race with update above.
    # I think this is harmless; node will either be rebooted for no reason
    # (load finished between these two ops) or the load will be redone a
    # second time.
    #
    if (system("$nodereboot", "$node")) {
	cleanup();
	fatal("Failed to reboot $node!");
    }

    #
    # Now we wait for the status to flip. We don't want to wait too long of
    # course. 
    #
    my $count = $maxloops;
    
    while ($count) {
	$query_result =
	    DBQueryWarn("select startstatus from nodes where node_id='$node'");

	if (!$query_result ||
	    $query_result->numrows < 1) {
	    cleanup();
	    fatal("DB error getting startstatus for $node");
	}
 
	@row = $query_result->fetchrow_array();
	$result = $row[0];

	if ("$result" ne "none") {
	    last;
	}
	if ($count && (($count % (60 / $sleepwait)) == 0)) {
	    print "Still waiting ...\n";
	}

	sleep($sleepwait);
	$count--;
    }
    if ("$result" ne "none") {
	last;
    }
    $tries--;
}
cleanup();

#
# Need to reboot the node so that it comes out of the pxebooted kernel and
# returns to its normal self. Its okay if this fails, although it should not.
#
if (system("$nodereboot", "$node")) {
    print "*** Failed to reboot $node after zipper completed!\n";
}

#
# If we timed out or if the result code was bad.
#
if (! $tries) {
    fatal("FAILED: Timed out generating image ... \n");
}
if ($result) {
    fatal("FAILED: Returned error code $result generating image ... \n");
}

SENDMAIL("$user_name <$user_email>",
	 "TESTBED: Image Creation on $node Completed: $pid/$imagename",
	 "Image creation on $node has completed. As you requested, the\n".
	 "image has been written to $filename.\n".
	 "You may now os_load this image on other nodes in your experiment.\n",
	 "$user_name <$user_email>",
	 "Bcc: $TBLOGS",
	 ($logname));

if (defined($logname)) {
    unlink("$logname");
}
exit 0;

sub cleanup ()
{
    DBQueryWarn("update nodes set pxe_boot_path='$saved_pxebootpath', ".
		"startupcmd='$saved_startupcmd' where node_id='$node'");
}

sub fatal($)
{
    my($mesg) = $_[0];

    print "$mesg\n";
    
    #
    # Send a message to the testbed list. 
    #
    SENDMAIL("$user_name <$user_email>",
	     "TESTBED: Image Creation Failure on $node: $pid/$imagename",
	     $mesg,
	     "$user_name <$user_email>",
	     "Cc: $TBOPS",
	     ($logname));
    
    
    if (defined($logname)) {
	unlink("$logname");
    }
    exit(-1);
}

