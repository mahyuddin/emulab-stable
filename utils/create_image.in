#!/usr/bin/perl -wT

#
# EMULAB-COPYRIGHT
# Copyright (c) 2000-2003 University of Utah and the Flux Group.
# All rights reserved.
#

use English;
use Getopt::Std;

#
# Create a disk image.
#
# XXX: Device file should come from DB.
#      Start/count slice computation is not generalized at all.
#
sub usage()
{
    print STDOUT
	"Usage: create_image [-p <pid>] <image descriptor> <node>\n" .
	"Use -p to specify the project ID of the image descriptor.\n" .
	"  Defaults to system project.\n";
    exit(-1);
}
my  $optlist = "p:";

#
# Configure variables
#
my $TB		= "@prefix@";
my $TBOPS       = "@TBOPSEMAIL@";
my $TBLOGS      = "@TBLOGSEMAIL@";
my $BOSSNODE	= "@BOSSNODE@";
my $PROJROOT	= "/proj";
my $TFTPDIR     = "/tftpboot";

#
# Testbed Support libraries
#
use lib "@prefix@/lib";
use libdb;
use libtestbed;

#
# Turn off line buffering on output
#
$| = 1;

#
# Untaint the path
# 
$ENV{'PATH'} = "/bin:/sbin:/usr/bin:";
delete @ENV{'IFS', 'CDPATH', 'ENV', 'BASH_ENV'};

my $nodereboot	= "$TB/bin/node_reboot";
my $createimage = "/usr/local/bin/create-image";
my $osselect    = "$TB/bin/os_select";
my $devtype	= "ad";
my $devnum	= 0;
my $mereuser    = 0;
my %imageid_row = ();
my $debug       = 0;
my $imageid;
my $imagepid    = TB_OPSPID;
my $logname;
my @row;
my $dbuid;
my $needcleanup = 0;

#
# Parse command arguments. Once we return from getopts, all that should be
# left are the required arguments.
#
%options = ();
if (! getopts($optlist, \%options)) {
    usage();
}
if (@ARGV != 2) {
    usage();
}

my $imagename  = $ARGV[0];
my $node       = $ARGV[1];

#
# Untaint the arguments.
#
if ($node =~ /^([-\w]+)$/) {
    $node = $1;
}
else {
    fatal("*** Bad data in $node\n");
}

if ($imagename =~ /^([-\w\.\+]+)$/) {
    $imagename = $1;
}
else {
    fatal("*** Bad data in $imagename.\n");
}
    
if (defined($options{"p"})) {
    $imagepid = $options{"p"};
	
    if ($imagepid =~ /^([-\w\.]+)$/) {
	$imagepid = $1;
    }
    else {
	fatal("*** Bad data in $imagepid.\n");
    }
}

#
# Verify user and get his DB uid.
#
if (! UNIX2DBUID($UID, \$dbuid)) {
    fatal("*** You do not exist in the Emulab Database.\n");
}

#
# Verify Permission.
#
if ($UID && !TBAdmin($UID)) {
    $mereuser = 1;

    if (! TBNodeAccessCheck($UID, TB_NODEACCESS_LOADIMAGE, $node)) {
	fatal("*** You do not have permission to create an image from $node\n");
    }
}

#
# Get email info for user.
#
my $user_name;
my $user_email;
if (! UserDBInfo($dbuid, \$user_name, \$user_email)) {
    fatal("*** Cannot determine user name and email address");
}

#
# We need the project id for test below. The target directory for the
# output file has to be the node project directory, since that is the
# directory that is going to be NFS mounted by default.
#
my $pid;
my $eid;
if (! NodeidToExp($node, \$pid, \$eid)) {
    fatal("*** Could not map $node to its pid/eid");
}

#
# Grab the imageid description from the DB. We do a permission check, but
# mostly to avoid hard to track errors that would result if the user picked
# the wrong one (which is likely to happen no matter what I do).
#
$db_result =
    DBQueryFatal("select * from images where ".
		 "pid='$imagepid' and imagename='$imagename'");
    
if ($db_result->numrows < 1) {
    fatal("*** No such image descriptor $imagename in project $imagepid!");
}
%imageid_row = $db_result->fetchhash();
$imageid = $imageid_row{'imageid'};

if ($mereuser &&
    ! TBImageIDAccessCheck($UID, $imageid, TB_IMAGEID_ACCESS)) {
    fatal("*** You do not have permission to use imageid $imageid!\n");
}

#
# Make sure that the filename is a /proj/$pid filename and a directory that
# exists and is writeable for the user. We test this by creating the file.
# Its going to get wiped anyway.
#
my $filename = $imageid_row{'path'};

# Untaint. Very silly.
if ($filename =~ /^([-\w\.\/\+]+)$/) {
    $filename = $1;
}
else {
    fatal("Bad filename: $filename");
}

if (! ($filename =~ /^$PROJROOT\/$pid\/.*/)) {
    fatal("File $filename for must reside someplace in $PROJROOT/$pid\n");
}
open(FILE, "> $filename") or
    fatal("Could not create $filename: $!");
close(FILE) or
    fatal("Could not truncate $filename: $!");

#
# Get the disktype for this node
#
$db_result =
    DBQueryFatal("select disktype from nodes ".
		 "left join node_types on nodes.type=node_types.type ".
		 "where node_id='$node'");
if ($db_result->numrows == 1) {
    ($devtype) = $db_result->fetchrow_array;
}
my $device = "/dev/${devtype}${devnum}";

#
# Record when this image was updated, so that we can figure out which
# revision of the testbed image it was based off.
#
DBQueryFatal("update images set updated=now() where ".
		 "pid='$imagepid' and imagename='$imagename'");

#
# Okay, we want to build up a command line that will run the script on
# on the client node. We use the imageid description to determine what
# slice (or perhaps the entire disk) is going to be zipped up. We do not
# allow arbitrary combos of course. 
#
my $startslice = $imageid_row{'loadpart'};
my $loadlength = $imageid_row{'loadlength'};
my $command    = "$createimage ";

if ($startslice || $loadlength == 1) {
    $command = "$command -s $startslice $device $filename";
}
else {
    $command = "$command $device $filename";
}

#
# Go to the background since this is going to take a while.
# 
if (!$debug) {
    $logname = `mktemp /tmp/create-image-$pid-$eid.XXXXXX`;

    if ($logname =~ /^([-\@\w.\/]+)$/) {
	$logname = $1;
    }
    else {
	fatal("Bad data in logfile name: $logname");
    }
    if (TBBackGround($logname)) {
	#
	# Parent exits normally
	#
	print STDOUT
	    "Your image from $node is being created\n".
	    "You will be notified via email when the image has been\n".
	    "completed, and you can load the image on another node.\n";
	exit(0);
    }
}

#
# We want to save off the old pxeboot/startupcmd and replace them with
# the special freebsd boot, and the command we created above. Then we
# reboot the node, and wait for it to come back alive. We also clear the
# startcommand status, and and use that to wait for the zipper to finish.
# I think we need a better mechanism for determining when a node is booted
# since we are basically stuck waiting for this, without knowing if the node
# even came up okay.
#
$query_result =
    DBQueryWarn("select pxe_boot_path,startupcmd from nodes ".
                "where node_id='$node'");

if (!$query_result ||
    $query_result->numrows < 1) {
    fatal("DB error getting node info for $node");
}
@row = $query_result->fetchrow_array();
my $saved_pxebootpath = $row[0];
my $saved_startupcmd  = $row[1];

my $result   = 0;
my $maxwait  = (60 * 5); # 5 minutes - in seconds.
my $sleepwait= 10;	  # seconds (must be a multiple of the above)
my $maxloops = ($maxwait / $sleepwait);
my $tries    = 2;
my $maximagesize = (4 * 1024**3); # 4 GB maximum
my $cursize  = 0;
my $repfreq  = 2; # wait report frequency.
my $maxslack = (3 * 60) / $sleepwait; # NFS cache slop factor

#
# From here on out, we should take care to clean up the DB, and
# reboot the source node.
#
$needcleanup = 1;

while ($tries) {
    system("$osselect -m PXEFBSD $node") and
	fatal("*** Failed to change OS on $node!\n");

    if (! DBQueryWarn("update nodes set ".
		      "startupcmd='$command', startstatus='none' ".
		      "where node_id='$node'")) {
	fatal("DB error updating node info for $node");
    }

    #
    # Reboot node. If this fails must reset. Note race with update above.
    # I think this is harmless; node will either be rebooted for no reason
    # (load finished between these two ops) or the load will be redone a
    # second time.
    #
    if (system("$nodereboot", "$node")) {
	fatal("Failed to reboot $node!");
    }

    #
    # Now we wait for the status to flip. We don't want to wait too long of
    # course. 
    #
    my $count = $maxloops;
    my $prevsize = 0;
    my $starttime = time();
    my $curtdiff = 0;
    my $prevtdiff = 0;
    my $slack = $maxslack-1;
 
    while ($count) {

	sleep($sleepwait);

	$query_result =
	    DBQueryWarn("select startstatus from nodes where node_id='$node'");

	if (!$query_result ||
	    $query_result->numrows < 1) {
	    fatal("DB error getting startstatus for $node");
	}
 
	@row = $query_result->fetchrow_array();
	$result = $row[0];

	if ("$result" ne "none") {
	    last;
	}

        #
        # See if imagezip on the node is making progress.  If not, we need to
        # decrement our timeout counter.  If so, be sure to reset the counter.
        #
        # Also, check to see if the (somewhat arbitrary) maximum filesize has 
        # been exceeded.
        #
        $cursize = (stat($filename))[7];
        if ($cursize > $maximagesize) {
            last;
        }
        if ($cursize == $prevsize) {
            if ($slack) {$slack--;}  # NFS cache slop timer
            else {
                if ($count*$sleepwait % 60 == 0) {
                    print "Timeout in ". 
                          int($count*$sleepwait/60) .
                          " minutes.\n";
                }
                $count--;
            }
        }
        else {
            $slack = $maxslack-1;
            if ($count != $maxloops) {
                print "Timeout aborted - image size increased.\n";
                $count = $maxloops;
            }
        }
        $prevsize = $cursize;

        $curtdiff = int((time() - $starttime)/60);
        if ( ($curtdiff != $prevtdiff) && ($curtdiff % $repfreq == 0) ) {
            print "Still waiting ... its been ". $curtdiff ." minutes.".
                " Current image size: $cursize bytes.\n";
        }
        $prevtdiff = $curtdiff;
    }
    if ("$result" ne "none") {
	last;
    }
    $tries--;
}

if (! cleanup()) {
    fatal("Problem encountered while cleaning up!\n");
}

#
# If we timed out, if the result code was bad, or if the image size
# grew too large.
#
if (! $tries) {
    fatal("FAILED: Timed out generating image ... \n");
}
if ($result) {
    fatal("FAILED: Returned error code $result generating image ... \n");
}
if ($cursize > $maximagesize) {
    fatal("FAILED: Maximum image size ($maximagesize bytes) exceeded ... \n");
}

print "Image creation succeeded.  Final size: $cursize bytes. \n";

SENDMAIL("$user_name <$user_email>",
	 "Image Creation on $node Completed: $pid/$imagename",
	 "Image creation on $node has completed. As you requested, the\n".
	 "image has been written to $filename.\n".
	 "You may now os_load this image on other nodes in your experiment.\n",
	 "$user_name <$user_email>",
	 "Bcc: $TBLOGS",
	 ($logname));

if (defined($logname)) {
    unlink("$logname");
}
exit 0;

sub cleanup ()
{
    my $retval = 1;

    $needcleanup = 0;

    #
    # Reset node (DB) state
    #

    if (system("$osselect -m $saved_pxebootpath $node")) {
	print("*** Failed to reset PXE boot path to $saved_pxebootpath!\n");
        $retval = 0;
    }

    if (!DBQueryWarn("update nodes set startupcmd='$saved_startupcmd' ".
                      "where node_id='$node'")) {
        print("*** Failed to reset node statup command!\n");
        $retval = 0;
    }

    #
    # Leave the node alone if we couldn't reset its DB state.
    #
    if ($retval && system("$nodereboot", "$node")) {
        print("*** Failed to reboot node on cleanup!\n");
    }

    return $retval;
}

sub fatal($)
{
    my($mesg) = $_[0];

    print "$mesg\n";

    if ($needcleanup && !cleanup()) {
        print "Encountered problems cleaning up!\n";
    }
    
    #
    # Send a message to the testbed list. 
    #
    SENDMAIL("$user_name <$user_email>",
	     "Image Creation Failure on $node: $pid/$imagename",
	     $mesg,
	     "$user_name <$user_email>",
	     "Cc: $TBOPS",
	     ($logname));
    
    
    if (defined($logname)) {
	unlink("$logname");
    }
    exit(-1);
}

