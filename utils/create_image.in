#!/usr/bin/perl -wT

#
# EMULAB-COPYRIGHT
# Copyright (c) 2000-2004 University of Utah and the Flux Group.
# All rights reserved.
#

use English;
use Getopt::Std;
use POSIX qw(setsid);
use File::Basename;

#
# Create a disk image.
#
# XXX: Device file should come from DB.
#      Start/count slice computation is not generalized at all.
#
sub usage()
{
    print(STDERR
	  "Usage: create_image [-w] [-p <pid>] <imageid> <node>\n" .
	  "switches and arguments:\n".
	  "-w        - wait for non-batchmode experiment terminate\n".
	  "-p <pid>  - project ID of the imageid; defaults to system project\n".
	  "<imageid> - imageid to use\n".
	  "<node>    - nodeid to create the image from\n");
    exit(-1);
}
my $optlist  = "p:w";
my $waitmode = 0;

#
# Configure variables
#
my $TB		= "@prefix@";
my $TBOPS       = "@TBOPSEMAIL@";
my $TBLOGS      = "@TBLOGSEMAIL@";
my $BOSSNODE	= "@BOSSNODE@";
my $TFTPDIR     = "/tftpboot";

#
# Testbed Support libraries
#
use lib "@prefix@/lib";
use libdb;
use libtestbed;

#
# Turn off line buffering on output
#
$| = 1;

#
# Untaint the path
# 
$ENV{'PATH'} = "/bin:/sbin:/usr/bin:";
delete @ENV{'IFS', 'CDPATH', 'ENV', 'BASH_ENV'};

my $nodereboot	= "$TB/bin/node_reboot";
my $createimage = "/usr/local/bin/create-image";
my $friskiller  = "$TB/sbin/frisbeelauncher";
my $osselect    = "$TB/bin/os_select";
my $devtype	= "ad";
my $devnum	= 0;
my $mereuser    = 0;
my %imageid_row = ();
my $debug       = 0;
my $imageid;
my $imagepid    = TB_OPSPID;
my $ADMINOSID   = TB_OSID_FREEBSD_MFS;
my $logname;
my @row;
my $dbuid;
my $needcleanup = 0;

#
# Parse command arguments. Once we return from getopts, all that should be
# left are the required arguments.
#
%options = ();
if (! getopts($optlist, \%options)) {
    usage();
}
if (defined($options{"w"})) {
    $waitmode = 1;
}
if (@ARGV != 2) {
    usage();
}

my $imagename  = $ARGV[0];
my $node       = $ARGV[1];

#
# Untaint the arguments.
#
if ($node =~ /^([-\w]+)$/) {
    $node = $1;
}
else {
    die("*** $0:\n".
	"    Bad data in $node\n");
}

if ($imagename =~ /^([-\w\.\+]+)$/) {
    $imagename = $1;
}
else {
    die("*** $0:\n".
	"    Bad data in $imagename.\n");
}
    
if (defined($options{"p"})) {
    $imagepid = $options{"p"};
	
    if ($imagepid =~ /^([-\w\.]+)$/) {
	$imagepid = $1;
    }
    else {
	die("*** $0:\n".
	    "    Bad data in $imagepid.\n");
    }
}

#
# Verify user and get his DB uid.
#
if (! UNIX2DBUID($UID, \$dbuid)) {
    die("*** $0:\n".
	"    You do not exist in the Emulab Database.\n");
}

#
# Valid Node ID?
#
if (! TBValidNodeName($node)) {
    die("*** $0:\n".
	"    Invalid node name $node!\n");
}

#
# Verify Permission.
#
if ($UID && !TBAdmin($UID)) {
    $mereuser = 1;

    if (! TBNodeAccessCheck($UID, TB_NODEACCESS_LOADIMAGE, $node)) {
	die("*** $0:\n".
	    "    You do not have permission to create an image from $node\n");
    }
}

#
# Get email info for user.
#
my $user_name;
my $user_email;
if (! UserDBInfo($dbuid, \$user_name, \$user_email)) {
    die("*** $0:\n".
	"    Cannot determine user name and email address!\n");
}

#
# We need the project id for test below. The target directory for the
# output file has to be the node project directory, since that is the
# directory that is going to be NFS mounted by default.
#
my $pid;
my $eid;
if (! NodeidToExp($node, \$pid, \$eid)) {
    die("*** $0:\n".
	"    Could not map $node to its project and experiment ID!\n");
}

#
# Grab the imageid description from the DB. We do a permission check, but
# mostly to avoid hard to track errors that would result if the user picked
# the wrong one (which is likely to happen no matter what I do).
#
$db_result =
    DBQueryFatal("select * from images where ".
		 "pid='$imagepid' and imagename='$imagename'");
    
if ($db_result->numrows < 1) {
    die("*** $0:\n".
	"    No such image descriptor $imagename in project $imagepid!\n");
}
%imageid_row = $db_result->fetchhash();
$imageid = $imageid_row{'imageid'};

if ($mereuser &&
    ! TBImageIDAccessCheck($UID, $imageid, TB_IMAGEID_ACCESS)) {
    die("*** $0:\n".
	"    You do not have permission to use imageid $imageid!\n");
}

#
# Make sure that the directory exists and is writeable for the user.
# We test this by creating the file. Its going to get wiped anyway.
#
my $filename = $imageid_row{'path'};
my $isglobal = $imageid_row{'global'};

#
# Throw an error if the image is global; we cannot write images into
# /usr/testbed/images. In fact, lets check the filename just in case.
#
if ($isglobal) {
    die("*** $0:\n".
	"    Not able to autocreate images that are marked global!\n");
}

# Untaint. Very silly.
if ($filename =~ /^([-\w\.\/\+]+)$/) {
    $filename = $1;
}
else {
    die("*** $0:\n".
	"    Bad filename: $filename!\n");
}

#
# Make sure real path is someplace that makes sense; remember that the
# image is created on the nodes, and it NFS mounts directories on ops.
# Writing the image to anyplace else is just going to break things.
#
# Use realpath to resolve any symlinks.
#
my $translated = `realpath $filename`;
if ($translated =~ /^([-\w\.\/]+)$/) {
    $filename = $1;
}
else {
    die("*** $0:\n".
	"    Bad data returned by realpath: $translated\n");
}

#
# The file must reside in /proj, /groups, or /users. Since this script
# runs as the caller, regular file permission checks ensure its a file
# the user is allowed to use. 
#
if (! ($filename =~ /^\/proj/) &&
    ! ($filename =~ /^\/groups/) &&
    ! ($filename =~ /^\/users/)) {
    die("*** $0:\n".
	"    $filename does not resolve to an allowed directory!\n");
}

#
# Be sure to kill off running frisbee. If a node is trying to load that
# image, well tough. 
#
system("$friskiller -k $imageid");
if ($?) {
    die("*** $0:\n".
	"    Could not kill running frisbee for $imageid!\n");
}

open(FILE, "> $filename") or
    die("*** $0:\n".
	"    Could not create $filename: $!\n");
close(FILE) or
    die("*** $0:\n".
	"    Could not truncate $filename: $!\n");

#
# Get the disktype for this node
#
$db_result =
    DBQueryFatal("select disktype from nodes ".
		 "left join node_types on nodes.type=node_types.type ".
		 "where node_id='$node'");
if ($db_result->numrows == 1) {
    ($devtype) = $db_result->fetchrow_array;
}
my $device = "/dev/${devtype}${devnum}";

#
# Record when this image was updated, so that we can figure out which
# revision of the testbed image it was based off.
#
DBQueryFatal("update images set updated=now() where ".
	     "pid='$imagepid' and imagename='$imagename'");

#
# Okay, we want to build up a command line that will run the script on
# on the client node. We use the imageid description to determine what
# slice (or perhaps the entire disk) is going to be zipped up. We do not
# allow arbitrary combos of course. 
#
my $startslice = $imageid_row{'loadpart'};
my $loadlength = $imageid_row{'loadlength'};
my $command    = "$createimage ";

if ($startslice || $loadlength == 1) {
    $command = "$command -s $startslice $device $filename";
}
else {
    $command = "$command $device $filename";
}

#
# Go to the background since this is going to take a while.
# 
if (!$debug) {
    $logname = TBMakeLogname("create-image-$pid-$eid");

    if (my $childpid = TBBackGround($logname)) {
	#
	# Parent exits normally, except if in waitmode. 
	#
	if (!$waitmode) {
	    print("Your image from $node is being created\n".
		  "You will be notified via email when the image has been\n".
		  "completed, and you can load the image on another node.\n");
	    exit(0);
	}
	print("Waiting for image creation to complete\n");
	print("You may type ^C at anytime; you will be notified via email;\n".
	      "later; you will not actually interrupt image creation.\n");
	
	# Give child a chance to run.
	select(undef, undef, undef, 0.25);
	
	#
	# Reset signal handlers. User can now kill this process, without
	# stopping the child.
	#
	$SIG{TERM} = 'DEFAULT';
	$SIG{INT}  = 'DEFAULT';
	$SIG{QUIT} = 'DEFAULT';

	#
	# Wait until child exits or until user gets bored and types ^C.
	#
	waitpid($childpid, 0);
	
	print("Done. Exited with status: $?\n");
	exit($? >> 8);
    }
}

#
# When in waitmode, must put ourselves in another process group so that
# an interrupt to the parent will not have any effect on the backend.
#
if ($waitmode) {
    POSIX::setsid();
}

#
# We want to save off the old startupcmd and replace with the command
# we created above. Then we reboot the node, and wait for it to come
# back alive. We also clear the startcommand status, and and use that
# to wait for the zipper to finish.  I think we need a better
# mechanism for determining when a node is booted since we are
# basically stuck waiting for this, without knowing if the node even
# came up okay.
#
$query_result =
    DBQueryWarn("select startupcmd from nodes ".
                "where node_id='$node'");

if (!$query_result ||
    $query_result->numrows < 1) {
    fatal("DB error getting node info for $node");
}
@row = $query_result->fetchrow_array();
my $saved_startupcmd  = $row[0];

my $result   = 0;
my $maxwait  = (60 * 5); # 5 minutes - in seconds.
my $sleepwait= 10;	  # seconds (must be a multiple of the above)
my $maxloops = ($maxwait / $sleepwait);
my $tries    = 2;
my $maximagesize = (4 * 1024**3); # 4 GB maximum
my $cursize  = 0;
my $repfreq  = 2; # wait report frequency.
my $maxslack = (3 * 60) / $sleepwait; # NFS cache slop factor

#
# From here on out, we should take care to clean up the DB, and
# reboot the source node.
#
$needcleanup = 1;

while ($tries) {
    system("$osselect -t $ADMINOSID $node") and
	fatal("*** Failed to set temp boot to $ADMINOSID for $node!");

    if (! DBQueryWarn("update nodes set ".
		      "startupcmd='$command', startstatus='none' ".
		      "where node_id='$node'")) {
	fatal("DB error updating node info for $node");
    }

    #
    # Reboot node. If this fails must reset. Note race with update above.
    # I think this is harmless; node will either be rebooted for no reason
    # (load finished between these two ops) or the load will be redone a
    # second time.
    #
    if (system("$nodereboot", "$node")) {
	fatal("Failed to reboot $node!");
    }

    #
    # Now we wait for the status to flip. We don't want to wait too long of
    # course. 
    #
    my $count = $maxloops;
    my $prevsize = 0;
    my $starttime = time();
    my $curtdiff = 0;
    my $prevtdiff = 0;
    my $slack = $maxslack-1;
 
    while ($count) {

	sleep($sleepwait);

	$query_result =
	    DBQueryWarn("select startstatus from nodes where node_id='$node'");

	if (!$query_result ||
	    $query_result->numrows < 1) {
	    fatal("DB error getting startstatus for $node");
	}
 
	@row = $query_result->fetchrow_array();
	$result = $row[0];

	if ("$result" ne "none") {
	    last;
	}

        #
        # See if imagezip on the node is making progress.  If not, we need to
        # decrement our timeout counter.  If so, be sure to reset the counter.
        #
        # Also, check to see if the (somewhat arbitrary) maximum filesize has 
        # been exceeded.
        #
        $cursize = (stat($filename))[7];
        if ($cursize > $maximagesize) {
            last;
        }
        if ($cursize == $prevsize) {
            if ($slack) {$slack--;}  # NFS cache slop timer
            else {
                if ($count*$sleepwait % 60 == 0) {
                    print "Timeout in ". 
                          int($count*$sleepwait/60) .
                          " minutes.\n";
                }
                $count--;
            }
        }
        else {
            $slack = $maxslack-1;
            if ($count != $maxloops) {
                print "Timeout aborted - image size increased.\n";
                $count = $maxloops;
            }
        }
        $prevsize = $cursize;

        $curtdiff = int((time() - $starttime)/60);
        if ( ($curtdiff != $prevtdiff) && ($curtdiff % $repfreq == 0) ) {
            print "Still waiting ... its been ". $curtdiff ." minutes.".
                " Current image size: $cursize bytes.\n";
        }
        $prevtdiff = $curtdiff;
    }
    if ("$result" ne "none") {
	last;
    }
    $tries--;
}

if (! cleanup()) {
    fatal("Problem encountered while cleaning up!\n");
}

#
# If we timed out, if the result code was bad, or if the image size
# grew too large.
#
if (! $tries) {
    fatal("FAILED: Timed out generating image ... \n");
}
if ($result) {
    fatal("FAILED: Returned error code $result generating image ... \n");
}
if ($cursize > $maximagesize) {
    fatal("FAILED: Maximum image size ($maximagesize bytes) exceeded ... \n");
}

print "Image creation succeeded.\n";
#      "Final size: " . (stat($filename))[7] . " bytes.\n";

SENDMAIL("$user_name <$user_email>",
	 "Image Creation on $node Completed: $pid/$imagename",
	 "Image creation on $node has completed. As you requested, the\n".
	 "image has been written to $filename.\n".
	 "You may now os_load this image on other nodes in your experiment.\n",
	 "$user_name <$user_email>",
	 "Bcc: $TBLOGS",
	 ($logname));

if (defined($logname)) {
    unlink("$logname");
}
exit 0;

sub cleanup ()
{
    my $retval = 1;

    $needcleanup = 0;

    #
    # Reset node (DB) state
    #

    if (system("$osselect -c -t $node")) {
	print("*** Failed to clear temp boot for $node!\n");
        $retval = 0;
    }

    if (!DBQueryWarn("update nodes set startupcmd='$saved_startupcmd' ".
                      "where node_id='$node'")) {
        print("*** Failed to reset node statup command!\n");
        $retval = 0;
    }

    #
    # Leave the node alone if we couldn't reset its DB state.
    #
    if ($retval && system("$nodereboot", "$node")) {
        print("*** Failed to reboot node on cleanup!\n");
    }

    return $retval;
}

sub fatal($)
{
    my($mesg) = $_[0];

    print "$mesg\n";

    if ($needcleanup && !cleanup()) {
        print "Encountered problems cleaning up!\n";
    }
    
    #
    # Send a message to the testbed list. 
    #
    SENDMAIL("$user_name <$user_email>",
	     "Image Creation Failure on $node: $pid/$imagename",
	     $mesg,
	     "$user_name <$user_email>",
	     "Cc: $TBOPS",
	     ($logname));
    
    
    if (defined($logname)) {
	unlink("$logname");
    }
    exit(-1);
}

