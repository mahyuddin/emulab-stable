#!/usr/bin/perl -wT
#
# EMULAB-COPYRIGHT
# Copyright (c) 2000-2007 University of Utah and the Flux Group.
# All rights reserved.
#
use English;
use Getopt::Std;
use POSIX qw(setsid);
use File::Basename;

#
# Tuneables:
#
# $maxwait	max wall clock time to allow, progress or not
#		Empirically we have observed about 1.8MB/sec on a pc850,
#		so 40 minutes should be sufficient for a 4GB image.
# $idlewait	max time to wait between periods of progress
# $checkwait	time between progress checks (must be int div of $idlewait)
# $reportwait	time between progress reports (must be multiple of $checkwait)
#
# $maximagesize	max size in bytes of an image
#
my $maxwait      = (40 * 60);
my $idlewait     = ( 8 * 60);
my $reportwait   = ( 2 * 60);
my $checkwait    = 15;
my $maximagesize = (6 * 1024**3); # 6GB

#
# Create a disk image.
#
# XXX: Device file should come from DB.
#      Start/count slice computation is not generalized at all.
#
sub usage()
{
    print(STDERR
	  "Usage: create_image [-w] [-p <pid>] <imagename> <node>\n" .
	  "switches and arguments:\n".
	  "-w          - wait for image to be fully created\n".
	  "-p <pid>    - project ID of the image; defaults to system project\n".
	  "<imagename> - imagename to use\n".
	  "<node>      - nodeid to create the image from\n");
    exit(-1);
}
my $optlist  = "p:w";
my $waitmode = 0;

#
# Configure variables
#
my $TB		= "@prefix@";
my $TBOPS       = "@TBOPSEMAIL@";
my $TBLOGS      = "@TBLOGSEMAIL@";
my $BOSSNODE	= "@BOSSNODE@";
my $CONTROL     = "@USERNODE@";
my $TFTPDIR     = "/tftpboot";

#
# Testbed Support libraries
#
use lib "@prefix@/lib";
use libdb;
use libtestbed;
use libadminmfs;
use Experiment;
use Node;
use User;
use Image;

#
# Turn off line buffering on output
#
$| = 1;

#
# Untaint the path
# 
$ENV{'PATH'} = "/bin:/sbin:/usr/bin:";
delete @ENV{'IFS', 'CDPATH', 'ENV', 'BASH_ENV'};

sub cleanup();
sub fatal($);

my $nodereboot	= "$TB/bin/node_reboot";
my $createimage = "/usr/local/bin/create-image";
my $friskiller  = "$TB/sbin/frisbeelauncher";
my $osselect    = "$TB/bin/os_select";
my $checkquota  = "$TB/sbin/checkquota";
my $imagehash	= "$TB/bin/imagehash";
my $def_devtype	= "ad";
my $def_devnum	= 0;
my $devtype;
my $devnum;
my $mereuser    = 0;
my $debug       = 0;
my $imagepid    = TB_OPSPID;
my $logname;
my $needcleanup = 0;

#
# Parse command arguments. Once we return from getopts, all that should be
# left are the required arguments.
#
my %options = ();
if (! getopts($optlist, \%options)) {
    usage();
}
if (defined($options{"w"})) {
    $waitmode = 1;
}
if (@ARGV != 2) {
    usage();
}

my $imagename  = $ARGV[0];
my $node_id    = $ARGV[1];

#
# Untaint the arguments.
#
if ($node_id =~ /^([-\w]+)$/) {
    $node_id = $1;
}
else {
    die("*** $0:\n".
	"    Bad data in $node_id\n");
}

if ($imagename =~ /^([-\w\.\+]+)$/) {
    $imagename = $1;
}
else {
    die("*** $0:\n".
	"    Bad data in $imagename.\n");
}
    
if (defined($options{"p"})) {
    $imagepid = $options{"p"};
	
    if ($imagepid =~ /^([-\w\.]+)$/) {
	$imagepid = $1;
    }
    else {
	die("*** $0:\n".
	    "    Bad data in $imagepid.\n");
    }
}

#
# Verify user and get his DB uid and other info for later.
#
my $this_user = User->ThisUser();
if (! defined($this_user)) {
    tbdie("You ($UID) do not exist!");
}
my $user_uid   = $this_user->uid();
my $user_name  = $this_user->name();
my $user_email = $this_user->email();

# Check node and permission
my $node = Node->Lookup($node_id);
if (!defined($node)) {
    die("*** $0:\n".
	"    Invalid node name $node_id!\n");
}
if ($UID && ! $this_user->IsAdmin()) {
    $mereuser = 1;

    if (! $node->AccessCheck($this_user, TB_NODEACCESS_LOADIMAGE)) {
	die("*** $0:\n".
	    "    You do not have permission to create an image from $node\n");
    }
}

#
# Before doing anything else, check for overquota ... lets not waste
# our time. Make sure user sees the error by exiting with 1.
#
if (system("$checkquota $user_uid") != 0) {
    die("*** $0:\n".
	"    You are over your disk quota on $CONTROL; ".
	"please login there and cleanup!\n");
}

#
# We need the project id for test below. The target directory for the
# output file has to be the node project directory, since that is the
# directory that is going to be NFS mounted by default.
#
my $experiment = $node->Reservation();
if (!defined($experiment)) {
    die("*** $0:\n".
	"    Could not map $node to its experiment object!\n");
}
my $pid = $experiment->pid();
my $eid = $experiment->eid();

#
# Grab the imageid description from the DB. We do a permission check, but
# mostly to avoid hard to track errors that would result if the user picked
# the wrong one (which is likely to happen no matter what I do).
#
my $image = Image->Lookup($imagepid, $imagename);
if (!defined($image)) {
    die("*** $0:\n".
	"    No such image descriptor $imagename in project $imagepid!\n");
}
my $imageid = $image->imageid();

if ($mereuser &&
    ! $image->AccessCheck($this_user, TB_IMAGEID_ACCESS)) {
    die("*** $0:\n".
	"    You do not have permission to use imageid $imageid!\n");
}

#
# Make sure that the directory exists and is writeable for the user.
# We test this by creating the file. Its going to get wiped anyway.
#
my $filename = $image->path();
my $isglobal = $image->global();

#
# Redirect pathname for global images.
#
if ($isglobal && ($filename =~ /^\/usr\/testbed/)) {
    $filename = PROJROOT() . "/$pid/images/" . basename($filename);
    print "*** WARNING: Writing global descriptor to $filename instead!\n";
}

# Untaint. Very silly.
if ($filename =~ /^([-\w\.\/\+]+)$/) {
    $filename = $1;
}
else {
    die("*** $0:\n".
	"    Bad filename: $filename!\n");
}

#
# Make sure real path is someplace that makes sense; remember that the
# image is created on the nodes, and it NFS mounts directories on ops.
# Writing the image to anyplace else is just going to break things.
#
# Use realpath to resolve any symlinks.
#
my $translated = `realpath $filename`;
if ($translated =~ /^([-\w\.\/]+)$/) {
    $filename = $1;
}
else {
    die("*** $0:\n".
	"    Bad data returned by realpath: $translated\n");
}

#
# The file must reside in an allowed directory. Since this script
# runs as the caller, regular file permission checks ensure its a file
# the user is allowed to use. 
#
if (! TBValidUserDir($filename, 0)) {
    die("*** $0:\n".
	"    $filename does not resolve to an allowed directory!\n");
}

#
# Be sure to kill off running frisbee. If a node is trying to load that
# image, well tough. 
#
system("$friskiller -k $imageid");
if ($?) {
    die("*** $0:\n".
	"    Could not kill running frisbee for $imageid!\n");
}

if (-e $filename) {
    unlink($filename) or
	die("*** $0:\n".
	    "    Could not delete $filename: $!\n");
}

open(FILE, "> $filename") or
    die("*** $0:\n".
	"    Could not create $filename: $!\n");
close(FILE) or
    die("*** $0:\n".
	"    Could not truncate $filename: $!\n");

#
# Get the disktype for this node
#
$node->disktype(\$devtype);
$node->bootdisk_unit(\$devnum);

$devtype = $def_devtype
    if (!defined($devtype));
$devnum = $def_devnum
    if (!defined($devnum));
my $device = "/dev/${devtype}${devnum}";

#
# Record when this image was updated, so that we can figure out which
# revision of the testbed image it was based off.
#
$node->MarkUpdateTime() == 0 or
    die("*** $0:\n".
	"    Could not mark the update time in $image\n");
    
#
# Okay, we want to build up a command line that will run the script on
# on the client node. We use the imageid description to determine what
# slice (or perhaps the entire disk) is going to be zipped up. We do not
# allow arbitrary combos of course. 
#
my $startslice = $image->loadpart();
my $loadlength = $image->loadlength();
my $command    = "$createimage ";

if ($startslice || $loadlength == 1) {
    $command = "$command -s $startslice $device $filename";
}
else {
    $command = "$command $device $filename";
}

#
# Go to the background since this is going to take a while.
# 
if (!$debug) {
    $logname = TBMakeLogname("create-image-$pid-$eid");

    $experiment->SetLogFile($logname);
    $experiment->OpenLogFile();

    if (my $childpid = TBBackGround($logname)) {
	#
	# Parent exits normally, except if in waitmode. 
	#
	if (!$waitmode) {
	    print("Your image from $node_id is being created\n".
		  "You will be notified via email when the image has been\n".
		  "completed, and you can load the image on another node.\n");
	    exit(0);
	}
	print("Waiting for image creation to complete\n");
	print("You may type ^C at anytime; you will be notified via email;\n".
	      "later; you will not actually interrupt image creation.\n");
	
	# Give child a chance to run.
	select(undef, undef, undef, 0.25);
	
	#
	# Reset signal handlers. User can now kill this process, without
	# stopping the child.
	#
	$SIG{TERM} = 'DEFAULT';
	$SIG{INT}  = 'DEFAULT';
	$SIG{QUIT} = 'DEFAULT';

	#
	# Wait until child exits or until user gets bored and types ^C.
	#
	waitpid($childpid, 0);
	
	print("Done. Exited with status: $?\n");
	exit($? >> 8);
    }
}

#
# When in waitmode, must put ourselves in another process group so that
# an interrupt to the parent will not have any effect on the backend.
#
if ($waitmode) {
    POSIX::setsid();
}

#
# From here on out, we should take care to clean up the DB, and
# reboot the source node.
#
$needcleanup = 1;

# Clear the bootlog; see below.
$node->ClearBootLog();

#
# Reboot into admin mode and run the command.
#
my $me           = $0;
my %args         = ();
$args{'name'}    = $me;
$args{'command'} = $command;
$args{'timeout'} = $maxwait + $checkwait;
$args{'prepare'} = 1;

$args{'pfunc'}     = \&check_progress;
$args{'pinterval'} = $checkwait;

# check_progress state
my $runticks	 = 0;
my $maxticks	 = int($maxwait / $checkwait);
my $reportticks  = int($reportwait / $checkwait);
my $idleticks    = 0;
my $maxidleticks = int($idlewait / $checkwait);
my $lastsize     = 0;
my $result;

my $retry = 1;
while ($retry) {
    $retry = 0;
    if (TBAdminMfsRunCmd(\%args, undef, $node_id)) {
	$result = "setupfailed"
	    if (!defined($result));
    }
}

if (! cleanup()) {
    fatal("Problem encountered while cleaning up!\n");
}

#
# If we timed out, if the result code was bad, or if the image size
# grew too large.
#
if ($result eq "setupfailed") {
    fatal("FAILED: Node setup failed ... \n");
}
if ($result eq "timeout") {
    fatal("FAILED: Timed out generating image ... \n");
}
if ($result eq "toobig") {
    fatal("FAILED: Maximum image size ($maximagesize bytes) exceeded ... \n");
}
if ($result != 0) {
    fatal("FAILED: Returned error code $result generating image ... \n");
}

#
# Everything worked, create the hash signature file.
#
my $sigdir;
($sigdir = $filename) =~ s/^(.*)\/[^\/]+$/$1\/sigs/;
mkdir($sigdir, 0770)
    if (! -d "$sigdir");

my $sigfilename;
($sigfilename = $filename) =~ s/^(.*)(\/[^\/]+$)/$1\/sigs$2.sig/;
my $swmsg = "";
if (! -x $imagehash ||
    system("$imagehash -c -o $sigfilename $filename") != 0) {
    warn("Could not create swapout signature file\n");
    $swmsg = "WARNING: could not create swapout signature file $sigfilename\n".
	     "       You will not be able to save disk state for this image\n";
} else {
    print("Swapout signature file created\n");
}

print "Image creation succeeded.\n";
print "Image written to $filename.\n";
#      "Final size: " . (stat($filename))[7] . " bytes.\n";

# Append bootlog (which has prepare output)
my $bootlog;
if ($node->GetBootLog(\$bootlog) == 0) {
    print "\n\n";
    print "------------------ Prepare Output ----------------\n";
    print "$bootlog\n";
}

SENDMAIL("$user_name <$user_email>",
	 "Image Creation on $node_id Completed: $pid/$imagename",
	 "Image creation on $node_id has completed. As you requested, the\n".
	 "image has been written to $filename.\n".
	 "You may now os_load this image on other nodes in your experiment.\n".
	 "$swmsg",
	 "$user_name <$user_email>",
	 "Bcc: $TBLOGS",
	 defined($logname) ? ($logname) : ());

if (defined($logname)) {
    # Close up the log file so the webpage stops.
    $experiment->CloseLogFile();
    unlink("$logname");
}
exit 0;

sub cleanup ()
{
    $needcleanup = 0;

    #
    # Turn admin mode back off and reboot back to the old OS
    #
    my %args          = ();
    $args{'name'}     = $me;
    $args{'on'}       = 0;
    $args{'clearall'} = 0;
    if (TBAdminMfsSelect(\%args, undef, $node_id)) {
	print("*** $me:\n".
	      "    Could not turn admin mode off for $node_id!\n");
	return 0;
    }

    %args           = ();
    $args{'name'}   = $me;
    $args{'on'}     = 0;
    $args{'reboot'} = 1;
    $args{'wait'}   = 0;
    if (TBAdminMfsBoot(\%args, undef, $node_id)) {
	print("*** $me:\n".
	      "    Failed to reboot $node_id on cleanup!\n");
	return 0;
    }

    return 1;
}

sub fatal($)
{
    my($mesg) = $_[0];

    print "$mesg\n";

    if ($needcleanup && !cleanup()) {
        print "Encountered problems cleaning up!\n";
    }
    
    #
    # Send a message to the testbed list. 
    #
    SENDMAIL("$user_name <$user_email>",
	     "Image Creation Failure on $node_id: $pid/$imagename",
	     $mesg,
	     "$user_name <$user_email>",
	     "Cc: $TBOPS",
	     defined($logname) ? ($logname) : ());
    
    if (defined($logname)) {
        # Close up the log file so the webpage stops.
	$experiment->CloseLogFile();
	unlink("$logname");
    }
    exit(-1);
}

#
# Check progress of image creation by periodically checking the image size.
#
# Called every $checkwait seconds.
# Reports progress every $reportwait seconds.
# Gives up after $idlewait seconds without a size change.
#
sub check_progress($$)
{
    my (undef, $statusp) = @_;

    #
    # Command has finished for better or worse, record status and finish.
    #
    if ($statusp->{$node_id} ne "none") {
	$result = $statusp->{$node_id};
	return 0;
    }

    #
    # Has run too long
    #
    $runticks++;
    if ($runticks >= $maxticks) {
	$result = "timeout";
	return 0;
    }

    #
    # See if imagezip on the node is making progress.  If not, we need to
    # check the idle timer and timeout if we have taken too long.
    #
    # Also, check to see if the (somewhat arbitrary) maximum filesize has 
    # been exceeded.
    #
    my $cursize = (stat($filename))[7];
    if ($cursize > $maximagesize) {
	$result = "toobig";
	return 0;
    }
    if ($cursize == $lastsize) {
	$idleticks++;
	if ($idleticks >= $maxidleticks) {
	    $result = "timeout";
	    return 0;
	}
    } else {
	$idleticks = 0;
    }
    $lastsize = $cursize;
    
    if (($runticks % $reportticks) == 0) {
	my $curtdiff = int($runticks * $checkwait / 60);
	print "Still waiting ... its been ". $curtdiff ." minutes.".
	    " Current image size: $cursize bytes.\n";
    }

    return 1;
}
