#!/usr/bin/perl -w

#
# EMULAB-COPYRIGHT
# Copyright (c) 2000-2002, 2004, 2005 University of Utah and the Flux Group.
# All rights reserved.
#

use English;

#
# An ssh frontend to determine if the node is local or remote, and to
# add in special options.
#
# NOTE THE DIFFERENT SYNTAX!
# 

sub usage()
{
    print STDOUT
	"Usage: sshtb [ssh args] -host <hostname> [command and args ...]\n";
    exit(-1);
}

#
# Configure variables
#
my $TB		= "@prefix@";
my $SSH	        = "@SSH@";
my $SSH_ARGS	= '@SSH_ARGS@';
my $UNIFIED     = "@UNIFIED_BOSS_AND_OPS@";
my $BOSSNODE    = "@BOSSNODE@";
my $USERNODE    = "@USERNODE@";
my $FSNODE      = "@FSNODE@";

# Locals
my $debug	= 0;
my @args;
my $hostname;

#
# Testbed Support libraries
#
use lib "@prefix@/lib";
use libdb;
use libtestbed;

#
# Turn off line buffering on output
#
$| = 1;

# un-taint path
$ENV{'PATH'} = "/bin:/usr/bin:/usr/local/bin:$TB/libexec:$TB/sbin:$TB/bin";
delete @ENV{'IFS', 'CDPATH', 'ENV', 'BASH_ENV'};

#
# We run through the args looking for -host. We save everything else.
#
if (@ARGV < 2) {
    usage();
}

# Find everything before the -host.
while (@ARGV) {
    my $arg = shift(@ARGV);
    if ($arg eq "-host") {
	$hostname = shift(@ARGV);
	last;
    }
    push(@args, $arg);
}

if (!defined($hostname)) {
    usage();
}

#
# Different stuff for remote nodes.
#
my @cmdargs;

if ($UNIFIED && ($hostname eq $BOSSNODE || $hostname eq $USERNODE ||
		 $hostname eq $FSNODE)) {
    @cmdargs = "@ARGV";
}
else {
    my $user;

    if (TBValidNodeName($hostname)) {
	my ($jailed, $plab, $physhost);
	if (TBIsNodeVirtual($hostname, \$jailed, \$plab)) {
	    if ($plab) {
		TBPlabNodeUsername($hostname, \$user);
	    }
	    TBPhysNodeID($hostname, \$physhost);
	    $hostname = $physhost;
	}
	elsif (TBIsNodeRemote($hostname)) {
	    $user = "emulabman";
	}
    }

    #
    # Yuck, the point is to turn the above string into a proper list for
    # exec so that we do not get a shell to interpret the arguments cause
    # there are quotes embedded. I am sure there is a regex that will do this
    # for me, but hell if I know what it is.
    #
    my @sshargs = ();
    my $tmp;
    foreach my $f (split('\s+', $SSH_ARGS)) {
	if (defined($tmp)) {
	    if ($f =~ /(.*)\"$/) {
		$tmp = "$tmp $1";
		push(@sshargs, $tmp);
		undef($tmp);
	    }
	    else {
		$tmp = "$tmp $1";
	    }
	    next;
	}
	elsif ($f =~ /^\"(.*)$/) {
	    $tmp = $1;
	    next;
	}
	push(@sshargs, $f);
    }

    @cmdargs = ($SSH, @sshargs, @args,
		(defined($user) ? ("-l", "$user") : ()),
		$hostname, @ARGV);
}

if ($debug) {
    print "@cmdargs\n";
}
# Close our connection the DB to avoid holding open connections.
TBDBDisconnect();

exec(@cmdargs);
