#!/usr/bin/perl -w
#
# EMULAB-COPYRIGHT
# Copyright (c) 2000-2012 University of Utah and the Flux Group.
# All rights reserved.
#
use English;
use strict;
use Getopt::Std;
use Data::Dumper;
use File::Temp qw(tempfile);
use CGI;

#
# Clone an image (descriptor) from a node and then snapshot
# that node into the descriptor. Creates the descriptor if
# if it does not exist. The idea is to use all of the info
# from the current image descriptor that is loaded on the node
# to quickly create a new descriptor by inheriting all of the
# attributes of the original.
#
# We also want to support taking a snapshot of a previously
# created clone. To make everything work properly, require
# that the imagename exist in the experiment project, which
# ensures that we are operating on a clone, not an image in
# some other project or a system image.
#
sub usage()
{
    print("Usage: clone_image [-d] [-e] [-n | -s] <imagename> <node_id>\n".
	  "Options:\n".
	  "       -d     Turn on debug mode\n".
	  "       -e     Create a whole disk image\n".
	  "       -s     Create descriptor but do not snapshot\n".
	  "       -n     Impotent mode\n");
    exit(-1);
}
my $optlist     = "dens";
my $debug       = 0;
my $wholedisk   = 0;
my $impotent    = 0;
my $nosnapshot  = 0;

#
# Configure variables
#
my $TB           = "@prefix@";
my $PROJROOT     = "@PROJROOT_DIR@";
my $CREATEIMAGE  = "$TB/bin/create_image";
my $NEWIMAGEEZ   = "$TB/bin/newimageid_ez";

#
# Untaint the path
#
$ENV{'PATH'} = "$TB/bin:$TB/sbin:/bin:/usr/bin:/usr/bin:/usr/sbin";
delete @ENV{'IFS', 'CDPATH', 'ENV', 'BASH_ENV'};

#
# Turn off line buffering on output
#
$| = 1;

#
# Load the Testbed support stuff.
#
use lib "@prefix@/lib";
use EmulabConstants;
use emutil;
use User;
use Project;
use Image;
use OSinfo;
use Node;

# Protos
sub fatal($);

#
# Parse command arguments. Once we return from getopts, all that should be
# left are the required arguments.
#
my %options = ();
if (! getopts($optlist, \%options)) {
    usage();
}
if (defined($options{"d"})) {
    $debug = 1;
}
if (defined($options{"e"})) {
    $wholedisk = 1;
}
if (defined($options{"n"})) {
    $impotent = 1;
}
if (defined($options{"s"})) {
    $nosnapshot = 1;
}
usage()
    if (@ARGV != 2);

my $imagename = shift(@ARGV);
my $node_id   = shift(@ARGV);

#
# Map invoking user to object. 
#
my $this_user = User->ThisUser();
if (! defined($this_user)) {
    fatal("You ($UID) do not exist!");
}

#
# The node must of course be allocated and the user must have
# permission to clone it. 
#
my $node = Node->Lookup($node_id);
if (!defined($node)) {
    fatal("No such node");
}
if (!$node->AccessCheck($this_user, TB_NODEACCESS_LOADIMAGE())) {
    fatal("Not enough permission");
}
my $experiment = $node->Reservation();
if (!defined($experiment)) {
    fatal("Node is not reserved");
}
my $pid     = $experiment->pid();
my $group   = $experiment->GetGroup();
my $project = $experiment->GetProject();
if (! (defined($project) && defined($group))) {
    fatal("Could not get project/group for $experiment");
}
my $image = Image->Lookup($project->pid(), $imagename);

#
# The simple case is that the descriptor already exists. So it is just
# a simple snapshot to the image file. 
#
if (defined($image)) {
    #
    # Only EZ images via this interface.
    #
    if (!$image->ezid()) {
	fatal("Cannot clone a non-ez image");
    }
    
    #
    # The access check above determines if the caller has permission
    # to overwrite the image file. 
    # Not that this matters, cause create_image is going to make the
    # same checks.
    #
    # But we do not allow emulab-ops images to ever be overwritten.
    # Might remove this later. Just being careful since this is going
    # to be used from the ProtoGENI RPC interface.
    #
    if ($image->pid eq TBOPSPID()) {
	fatal("Not allowed to snapshot a system image");
    }
    if ($impotent) {
	print "Not doing anything in impotent mode\n";
	exit(0);
    }
    if ($nosnapshot) {
	print "Not taking a snapshot, as directed\n";
	exit(0);
    }

    my $output = emutil::ExecQuiet("$CREATEIMAGE -p $pid $imagename $node_id");
    if ($?) {
	print STDERR $output;
	fatal("Failed to create image");
    }
    print "Image is being created. This can take 15-30 minutes.\n";
    exit(0);
}

#
# Need to look up the base image; the image that is currently running
# on the node and being cloned.
#
my ($base_osinfo, $base_image) = $node->RunningOsImage();
if (! (defined($base_osinfo) && defined($base_image))) {
    fatal("Could not determine osid/imageid for $node_id");
}
print "$node_id is running $base_osinfo,$base_image\n"
    if ($debug);

#
# Create the image descriptor. We use the backend script to do the
# heavy lifting, but we have to cons up an XML file based on the image
# descriptor that is being cloned.
#
# These are the fields we have to come up with, plus a number
# of mtype_* entries.
#
my %xmlfields =
    ("imagename"	=> $imagename,
     "pid"		=> $project->pid(),
     "gid"		=> $experiment->gid(),
     "description"	=> $base_image->description(),
     "loadpart"		=> $base_image->loadpart(),
     "OS"		=> $base_osinfo->OS(),
     "version"		=> $base_osinfo->version(),
     "path"		=> "$PROJROOT/$pid/images/${imagename}.ndz",
     "node_id"		=> $node_id,
     "osfeatures",	=> $base_osinfo->osfeatures(),
     "op_mode",		=> $base_osinfo->op_mode(),
     "wholedisk",	=> $wholedisk,
     "mbr_version",	=> $base_image->mbr_version(),
);

#
# Grab the existing type list and generate new mtype_* variables.
#
my @typelist = $base_image->TypeList($base_osinfo);
if (! @typelist) {
    fatal("$base_image does not run on any types");
}
foreach my $type (@typelist) {
    my $type_id = $type->type();
    
    $xmlfields{"mtype_${type_id}"} = 1;
}

#
# Create the XML file to pass to newimageid_ez.
#
my ($fh, $filename) = tempfile(UNLINK => 1);
fatal("Could not create temporary file")
    if (!defined($fh));

print $fh "<image>\n";
foreach my $key (keys(%xmlfields)) {
    my $value = $xmlfields{$key};

    print $fh "<attribute name=\"$key\">";
    print $fh "<value>" . CGI::escapeHTML($value) . "</value>";
    print $fh "</attribute>\n";
}
print $fh "</image>\n";
close($fh);

my $output = emutil::ExecQuiet("$NEWIMAGEEZ -v -a $filename");
if ($?) {
    print STDERR $output;
    fatal("Failed to verify image descriptor from $filename");
}
if ($impotent) {
    print "Not doing anything in impotent mode\n";
    system("cat $filename");
    exit(0);
}
$output = emutil::ExecQuiet("$NEWIMAGEEZ -a $filename");
if ($?) {
    print STDERR $output;
    my $foo = `cat $filename`;
    print STDERR $foo;
    fatal("Failed to create image descriptor");
}

$image = Image->Lookup($project->pid(), $imagename);
if (!defined($image)) {
    fatal("Cannot lookup newly created image for $imagename");
}
my $osinfo = OSinfo->Lookup($image->imageid());
if (!defined($osinfo)) {
    fatal("Cannot lookup newly created osinfo for $image");
}
if ($debug) {
    print "Created $osinfo\n";
    print "Created $image\n";
}
if ($nosnapshot) {
    print "Not taking a snapshot, as directed\n";
    exit(0);
}
$output = emutil::ExecQuiet("$CREATEIMAGE -p $pid $imagename $node_id");
if ($?) {
    print STDERR $output;
    fatal("Failed to create image");
}
print "Image is being created. This can take 15-30 minutes.\n";
exit(0);

sub fatal($)
{
    my ($mesg) = @_;

    die("*** $0:\n".
	"    $mesg\n");
}
