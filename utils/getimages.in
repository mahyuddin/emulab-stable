#!/usr/bin/perl -w
#
# EMULAB-COPYRIGHT
# Copyright (c) 2003-2012 University of Utah and the Flux Group.
# All rights reserved.
#
use strict;
use English;
use Getopt::Std;
use XML::Simple;
use Date::Parse;
use Time::Local;
use Data::Dumper;
use File::Temp qw(tempfile);

#
# Checkin at the master (Utah) to see if we should download and install
# any new images
#
sub usage()
{
    print STDERR "Usage: getimages [-d] [-n]\n";
    print STDERR "  -h     This message\n";
    print STDERR "  -n     Impotent mode; just check and report.\n";
    exit(-1);
}
my $optlist  = "hndt:";
my $debug    = 1;
my $impotent = 0;
my $testfile;

# Protos
sub fatal($);

#
# Configure variables
#
my $TB		 = "@prefix@";
my $METAURL      = "http://www.emulab.net/genirack-imageinfo.xml";
my $FETCH	 = "/usr/bin/fetch";
my $metadata	 = "/tmp/imageinfo-$$.xml";
my $NEWIMAGE_EZ  = "$TB/bin/newimageid_ez";

#
# Testbed Support libraries
#
use lib "@prefix@/lib";
use emdb;
use Image;
use OSinfo;
use libaudit;
use EmulabConstants;

#
# Turn off line buffering on output
#
$| = 1;

#
# Untaint the path
# 
$ENV{'PATH'} = "/bin:/sbin:/usr/bin:";

# Record output in case of error.
LogStart(0, undef, LIBAUDIT_LOGTBOPS());

#
# Parse command arguments. Once we return from getopts, all that should be
# left are the required arguments.
#
my %options = ();
if (! getopts($optlist, \%options)) {
    usage();
}
if (defined($options{'h'})) {
    usage();
}
if (defined($options{'n'})) {
    $impotent = 1;
}
if (defined($options{'d'})) {
    $debug = 1;
}
if (defined($options{'t'})) {
    $testfile = $options{'t'};
}
usage()
    if (@ARGV);

# Only root.
if ($UID && !$impotent) {
    die("*** $0:\n".
	"    Must run this as root!\n");
}

#
# Fetch the metadata, which tells what to do.
#
if (!defined($testfile)) {
    print "Fetching metadata from the server\n"
	if ($debug);
    system("$FETCH -o $metadata $METAURL") == 0
	or fatal("Could not fetch $METAURL");
}
else {
    $metadata = $testfile;
}

#
# Must wrap the parser in eval since it exits on error.
#
my $xmlparse = eval { XMLin($metadata,
			    VarAttr => 'name',
			    ForceArray => ['image'],
			    ContentKey => '-content',
			    SuppressEmpty => undef); };
fatal($@)
    if ($@);

#
#
#
foreach my $imageid (keys(%{ $xmlparse->{'image'} })) {
    my $attributes = $xmlparse->{'image'}->{$imageid}->{'attribute'};

    if ($debug) {
	print STDERR Data::Dumper->Dump([$attributes], [$imageid]);
    }

    my $metaurl  = $attributes->{'metaurl'};
    my $imageurl = $attributes->{'imageurl'};
    my $newhash  = $attributes->{'hash'};

    #
    # If we have an entry in the DB, we use the hash value to 
    # to determine if we need to download a new version.
    #
    # XXX What if the local site has its own more recent version?
    #
    # Lookup will sanity check the imageid string.
    #
    my $image = Image->Lookup(TBOPSPID(), $imageid);
    if (defined($image)) {
	print "Local descriptor found: $image\n"
	    if ($debug);

	if (defined($image->hash()) && $newhash eq $image->hash()) {
	    print "Image has not changed, skipping ...\n"
		if ($debug);
	    next;
	}
    }
    print "$imageid has changed or does not exist, downloading ...\n";

    my ($fh, $metafilename) = tempfile(UNLINK => !$debug);
    fatal("Could not create temporary file")
	if (!defined($fh));
    close($fh);

    #
    # Grab the metadata file
    #
    print "Fetching $metaurl\n";
    system("$FETCH  -o $metafilename $metaurl") == 0
	or fatal("Could not fetch $metaurl");

    #
    # Load up the descriptor if we do not have it.
    #
    if (!defined($image)) {
	system("$NEWIMAGE_EZ -a $metafilename") == 0
	    or fatal("Could not create descriptor for $imageid");
    }
    $image = Image->Lookup(TBOPSPID(), $imageid);
    if (!defined($image)) {
	fatal("Could not lookup newly created descriptor for $imageid");
    }

    my $imagefilename = "$TB/images/${imageid}.ndz";
    my $tmpfilename   = "${imagefilename}.new";
    unlink($tmpfilename)
	if (-e $tmpfilename);
    print "Fetching $imageurl\n";
    system("$FETCH  -o $tmpfilename $imageurl") == 0
	or fatal("Could not fetch $imageurl");

    #
    # Do an integrity check.
    #
    print "Doing an integrity check ...\n";
    my $filehash = `/sbin/sha1 -q $tmpfilename`;
    if ($?) {
	fatal("Could not generate sha1 of $tmpfilename");
    }
    chomp($filehash);
    if ($filehash ne $newhash) {
	fatal("Integrity check failure. $newhash ne $filehash");
    }

    if ($impotent) {
	print "Impotent mode is on; not installing the new image.\n";
	next;
    }

    #
    # So move it into place.
    #
    print "Moving new image into place\n";
    rename("${imagefilename}", "${imagefilename}.old")
	if (-e "${imagefilename}");
    rename("$tmpfilename", "${imagefilename}") or
	fatal("Could not rename $tmpfilename: $!");

    #
    # Now update the descriptor to reflect new hash.
    #
    $image->SetHash($newhash) == 0
	or fatal("Could not update hash for $image");

    # Good measure.
    $image->MarkUpdateTime();
}

exit(0);

sub fatal($)
{
    my ($mesg) = $_[0];

    unlink($metadata)
	if (-e $metadata);
    die("*** $0:\n".
	"    $mesg\n");
}


