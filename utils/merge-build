#!/usr/bin/perl 

#
# See http://users.emulab.net/trac/emulab/wiki/MergeBuild
#

use Cwd;
use File::Temp qw(mktemp);

use warnings;
use strict;

sub cd ($) {
    print "cd $_[0]\n";
    chdir $_[0] or die "Unable to cd to $_[0]\n";
}

sub sysq (@) {
    system @_;
    die "ERROR: @_ failed\n" unless $? == 0;
}

sub sys (@) {
    print join(' ', @_), "\n";
    sysq @_;
}

sub sysp (@) {
    my $cmd = join(' ', @_, '|');
    open F, $cmd or die $!;
    local $/ = undef;
    my $output = <F>;
    close F;
    die "ERROR: $cmd faild\n" unless $? == 0;
    return $output;
}

sub sys_filter ($&) {
    my $cmd = "$_[0] |";
    my $filter = $_[1];
    print "$cmd\n";
    open F, $cmd or die $!;
    while (<F>) {
	print if $filter->();
    }
    die "ERROR: $cmd faild\n" unless $? == 0;
}

sub usage() {
    print "usage: merge-build prep|reset|sync\n";
    exit(1);
}

#
# Read config file
#
open F, ".merge-build" or die "Unable to open .merge-build\n";
my $source_tree;
my $merge_tree;
my @branches;
my $branches_str;
my $merge_branch = "merge";
while (<F>) {
    s/#.+//;
    next unless /\S/;
    my ($key, $value) = /^\s*(\S+)\s+(.+?)\s*$/ or die "Bad Line\n";
    if ($key eq 'source-tree') {
	$source_tree = $value;
    } elsif ($key eq 'merge-tree') {
	$merge_tree = $value;
    } elsif ($key eq 'branches') {
	@branches = split /\s+/, $value;
    } elsif ($key eq 'merge-branch') {
	$merge_branch = $value;
    } else {
	die "Unknown key in .merge-build: $key\n";
    }
}
sub missing_key($) {die "Missing key in .merge-build: $_[0]\n";}
missing_key('source-tree') unless defined $source_tree;
missing_key('merge-tree') unless defined $merge_tree;
missing_key('branches') unless @branches;
my $branch_str = join ' ', map {"origin/$_"} @branches;

#
# Figure out where we are
#
sub same_file($$) {
    my ($dev0,$ino0) = stat $_[0];
    my ($dev1,$ino1) = stat $_[1];
    return defined $dev0 && defined $dev1 && $dev0 == $dev1 && $ino0 == $ino1;
}
sub where_am_i() {
    my $cwd = cwd();
    if (same_file($cwd,"$cwd/$source_tree/$merge_tree")) {
	return 'merge';
    } elsif (same_file($cwd,"$cwd/$merge_tree/$source_tree")) {
	return 'source';
    } else {
	die "I don't know where I am! Check that source-tree and merge-tree are correct.\n";
    }
}
sub cd_source() {
    cd $source_tree if where_am_i() eq 'merge';
    die unless where_am_i() eq 'source';
}
sub cd_merge() {
    cd $merge_tree if where_am_i() eq 'source';
    die unless where_am_i() eq 'merge';
}

#
#
#

sub save_uncommited() {
    cd_source();
    print "Saving Uncommited Changes\n";
    sysq "git update-index -q --refresh";
    local $ENV{GIT_INDEX_FILE} = mktemp ".git/index.XXXXXX";
    sysq "cp -p .git/index $ENV{GIT_INDEX_FILE}";
    sysq "git add -A";
    sysq "git reset -q .merge-build";
    my $tree_id = sysp "git write-tree";
    chomp $tree_id;
    my $stash_id = sysp "echo Build stash | git commit-tree $tree_id -p HEAD";
    chomp $stash_id;
    unlink($ENV{GIT_INDEX_FILE});
    return $stash_id;
}

sub merge_base(@) {
    cd_merge();
    my $res = shift @_;
    while (@_) {
	my $other = shift @_;
	$res = sysp "git merge-base $res $other";
	chomp $res;
    }
    return $res;
}

#
# Finally, do the work
#
my $op = shift @ARGV || '';
if ($op eq 'prep') {
    die "Merge tree must not exist\n" if -e $merge_tree;
    sys "git clone -sn . $merge_tree";
    cd_merge();
    my $base = merge_base split / /, $branch_str;
    sys "git checkout -b $merge_branch $base";
    sys "ln -s $source_tree/.merge-build";
} elsif ($op eq 'reset') {
    cd_merge();
    my $base = merge_base $merge_branch, split / /, $branch_str;
    sys "git reset -q --hard $base";
} elsif ($op eq 'sync') {
    cd_source();
    my $stash_id = save_uncommited();
    cd_merge();
    sys "git fetch -q origin";
    sys "git reset -q --hard";
    sys "git merge -q $branch_str";
    sys "git merge-recursive -- HEAD $stash_id";
    sys "touch .merged";
} else {
    usage();
}


