This file describes the implementation of (and a little bit of the rationale
for) out FreeBSD-based "virtual node" support.

The summary is that we use a highly customized FreeBSD kernel supporting
beefed-up jails, virtual disks, virtual ethernet interfaces, and multiple
routing tables to implement reasonably isolated virtual nodes for network-
centric activity.  We do not yet provide complete resource isolation, in
particular to limit CPU or memory consumption.

A. Rationale

Why jails?

One way to achieve multiplexing of activity on physical nodes is simply to
start up multiple copies of an experimenter's desired applications.  For
example, if they want 10 "nodes" running a background traffic generator,
we just start up 10 copies on a single physical node.  There are a number
of problems with this approach.  One is that it will likely require
customization of the application, possibly even changing the code itself,
to allow it to co-exist with other instances of itself.  For example,
the application might have a hardwired path in the filesystem for
configuration or logging information or require a specific port number.
The first step in virtualizing an application's environment is thus to
give it its own name space.

BSD jails (jail(2)) serve to restrict a process and all its descendents to
a unique slice of the filesystem namespace using chroot.  This not only gives
each jail a custom, virtual root filesystem (/, /var, etc.) but also insulates
them from the filesystem activities of others (and visa-versa).  Jails also
provide a mechanism for virtualizing and restricting access to the network.
When a jail is created, it is given a virtual hostname and a set of IP
addresses that it can bind to.  These IP addresses are associated with
network interfaces outside of the jail context and cannot be changed from
within a jail.  Hence, jails are implicitly limited to a set of interfaces
they may use.  Further, jails allow processes within them to run as root,
albeit a watered-down variant.  With root inside a jail, applications can
add/change/remove whatever files they want (except for device special files),
bind to privileged ports, and kill any other jailed processes.

Why virtual disks?

One potential problem with the filesystem virtualization provided by jails,
is constraining disk usage.  Even though each jail has its own subset of
the filesystem name space, that space is likely to be part of a larger
filesystem.  Jails themselves do nothing to limit now much disk space can
be used within the hosting filesystem.  Disk quotas aren't useful since,
within the jail's name space, files are not restricted to a single uid
or even subset of uids, they can be owned by anyone.

The BSD vnode disk driver (vn(4)) allows us to create a regular file with
a fixed size and expose it via a disk interface.  These fixed-size virtual
disks are used to contain a root filesystem for each jail which is mounted
at the root of each jail's name space.  Since the virtual disks are contained
in regular files, they are also easy and efficient to move or clone.

Why virtual ethernet interfaces?

An important part of BSD jails is the ability to restrict them to specific
IP addresses.  While the jail mechanism does provide some degree of network
virtualization as described above, it falls short of what is needed in our
environment.  In particular, though jails have their own distinct IP
addresses, those IP addresses are associated directly with physical
interfaces which are shared among all jails.  Thus, interface-centric
operations such as tcpdump or ipfw/dummynet either are not correctly
isolated or require special handling in many different places.

Further, with jails, when packets leave a physical host they lose the
identity of the virtual node (jail) that was the most-recent hop of the
packet.  This identity is essential for handling the "revisitation"
problem, where multiple nodes in a topology can be located on the same
physical node.  The loss occurs because packets from the jails are
multiplexed on to physical interfaces.  The IP header of a packet does
contains a virtual node IP address, but it is that of the originator of
the IP packet, not that of the most-recent hop router.  The MAC address
in the wire packet will be for the physical node, not the virtual node
that sent it (since there is no virtual MAC).  Preserving the necessary
information in the ethernet packet would require help from the switching
fabric, either by supporting VLANs or by supporting arbitrary numbers of
fake MAC addresses per switch port (where the fake addresses would be
derived from the virtual IP addresses).

We solve all of these problems in one fell swoop, with a virtual ethernet
device.  The BSD virtual ethernet (veth) driver, which we wrote, is a goofy
hybrid of a virtual device, an encapsulating device and a bridging device.
It allows us to create lots and lots of ethernet interfaces (virtualization),
multiplex them on physical interfaces or tie them together in a loopback
fashion (bridging) and have them communicate transparently through our
switch fabric (encapsulation).

Virtualization gives us per-jail interfaces above the physical interface to
which we can apply jail-specific ipfw/dummynet rules or on which the jail
processes can operate.  Bridging allows the correct routing of packets at
the link level so that virtual interfaces only receive the packets that
they should.  Two attributes of a virtual ethernet device define the
bridged topology.  The "parent interface" attribute associates a virtual
device with a physical device allowing for multiplexing/demultiplexing
of virtual devices on physical devices.  A 16-bit tag, essentially identical
to that of the 802.1q VLAN standard, identifies a broadcast domain for a
set of veths, all veths with the same tag will see each other's traffic.
Finally, encapsulation preserves the virtual link information
necessary to implement revisitation (the tag) when crossing physical links,
without making any assumptions about the switching fabric.


Why virtual routing tables?

While virtual ethernet devices are sufficient to enable construction of
virtual ethernet topologies, they are not sufficient to support arbitrary
IP topologies.  This is due to shared IP infrastructure, in particular,
the routing table.  Since the routing table is indexed by destination
and returns a next-hop address, it is only possible to have one entry
per destination.  But with a physical node hosting multiple jails
representing different virtual nodes at different points in the topology,
we need to be able to support multiple routes to (next hops for) a single
destination.

The obvious solution is to virtualize the IP routing table.  To do so,
we started with the FreeBSD work done by Scandariato and Risso which
implements multiple IP routing tables to support multiple VPN end points
on a physical node.  Routing tables are identified by a small integer
routing table id (rtabid).  Rtabids are the glue that bind together
jails, virtual interfaces and routing tables.  Our extended jails each
have a unique rtabid and thus every jail has its own routing table.
Virtual ethernet interfaces are likewise associated with an rtabid when
they are created, forming a unique set of virtual interfaces per jail.
Incoming packets for the same destination can thus be differentiated
by the rtabid of the receiving interface and can be routed differently
based on the content of the associated routing table.


B. Implementation

All virtual nodes on a physical node will belong to the same experiment.
This eases the immediate burden of providing isolation somewhat and also
allows us to evade tricky issues of who has what access to the hosting
physical node.  So a physical node, mapped to an experiment, boots up and
eventually runs the bootvnodes script.  That script contacts Testbed Central
and discovers that it has vnodes to setup.  It performs a couple of global
"one time" actions: it creates a filesystem on the 4th DOS partition for
jail disk space and ensures that sufficient virtual disk (vn) devices exist
for all vnodes.  It then runs vnodesetup for every vnode.

The vnodesetup script is used to start ("boot"), stop ("halt") and restart
("reboot") vnodes.  It is also used to setup vnodes on widearea nodes, but
we consider only local cluster nodes here.  Vnodesetup forks and runs another
script, mkjail.pl, in the child.  The parent hangs around and cleans up if the
jail dies.  It also serves as a focal point for killing the jail, catching
signals and forcibly terminating the jail.  It is the parent vnodesetup
process that handles informing stated of state transitions in the jail.

In mkjail.pl we finally get down to it.  This script builds up the filesystem
hierarchy used by the jail, sets up its interfaces (including the virtual
control net interface, routes and dummynet delay pipes), and then starts
the jail.  Note that the filesystem and interfaces are setup outside the
jail and passed as parameters into the jail.

The filesystem consists of a per-jail vnode-disk and loopback (null) mounts
of various physical node filesystems.  The whole shebang is located in
/var/emulab/jails/<vnodename>.  root.vnode is the regular file which serves
as the root disk.  It is attached to a vn device that is then mounted at
/var/emulab/jails/<vnodename>/root.  The mkjail.pl script populates the disk
by copying in some directories from the physical node and customizing the
content.  This loading of the disk only happens on the first boot up of the
virtual node.  Subsequent boots simply mount the vn disk.  To save space in
the per-jail disk, the binary directories /sbin and /bin are remounted
read-only with a loopback mount as is /usr.  The shared /share, /proj,
/users and /local directories are also loopback mounted read-write from
the physical node.  From the perspective of the physical node, there will
be at least 8 mounts for every jail: /dev/vn?c (the root), /bin, /sbin,
/usr, /proc, /share, /proj/<pid>, and /local/<pid>, plus one in /users
for every user in the project (and maybe a /group/<gid> too!).

The network setup starts with configuration of the virtual control net
interface.  This consists of a 172.16/12 address alias assigned to the
real control net interface.  There will be one such alias per virtual
node.  These aliases allow us to further isolate jails from each other
as each jail now has a unique address on which to run services.  We no
longer have to assign port ranges within the primary control net address
and run daemons on weird port numbers.  We can also use DNS to map
symbolic names to the virtual nodes.  Note that these address are
"unroutable" and thus are not exposed outside emulab.net.  Accessing
services on the nodes from outside requires a proxy on ops.emulab.net,
such as an ssh tunnel.

For experimental interfaces, mkjail.pl creates an rc file to setup the virtual
interfaces and routes, and runs them.  A virtual interface's parameters are
assigned as follows.  We assign veth virtual MACs based on the interfaces IP
address, in the form: 00:00:IP#0:IP#1:IP#2:IP#3, ensuring uniqueness.
We assign veth tags using the subnet part of the interface's IP address.
Since we use 10.n.n.h space, where n.n is the subnet, we use the second and
third octets.  A veth's physical interface is determined by assign.  We may
use multiple physical interfaces between nodes or we may use no physical
interfaces at all.  The routing table ID is unique per virtual node on a
physical node, so we simply use a per-physical node counter to assign these
when the vnodes are booted.  All veths for a virtual node get the same
counter value.  There is nothing magical in route setup, just an extra
argument to the route command to ensure the routes get added to the correct
table.  Likewise for delay setup, ipfw rules are simply applied to veths
rather than physical interfaces.  Setting up routes and dummynet outside
the jail is largely historical, both could be done from inside.

Finally, the jail startup is done.  Our augmented jail implementation
takes some new parameters in addition to a "primary" IP address, the root
directory of the jail, and the program to run.  The important additional
parameter is a list of IP addresses.  These addresses, along with the primary,
implicitly define which interfaces are accessible to the jail: those to which
the IP addresses are assigned.  This is analogous to the root directory
specification which determines which mounted filesystems are accessible:
those at or below the level of the root directory.  The program run by the
jail, /etc/injail, is effectively the /sbin/init of the virtual node.
Its primary jobs are to fire off /etc/rc to bring up the virtual node and
then sit around and wait for a signal to shutdown the jail.  The startup
scripts run by /etc/rc in the jail are scaled back versions of what would
run on a real node.  This scaling back reflects the fact that the node has
already been partially initialized and also that it usually will not run as
many services as a real node.  A typical jail syslogd, cron and sshd, as
well as the Emulab watchdog and optional agents like trafgen or delay_agent.
From the perspective of the physical node, each jail has at least 8 processes
running: vnodesetup, mkjail.pl and proxy-tmcc outside the jail as well as
injail, syslogd, cron, sshd, and the Emulab watchdog inside the jail.
Empirically, it appears that each jail requires 12-16MB of physical memory
for its base processes.

C. Assorted Details

C1. FreeBSD Jails [ lifted from Leigh's jail.html... ]

Jails provide filesystem and network namespace isolation and some degree of
superuser privilege restriction.  Following is a list of the features we added,
and bugs we fixed in FreeBSD jails.  All of the new features are optional,
controlled by sysctl MIBs and per-jail flags.  This new jail implementation
is backward compatible with the original implementation, meaning all new
features are disabled by default.

1. Allow a jailed process to bind to multiple IP addresses.

    The default implementation of jail allows processes inside of a jail
    to bind to just one IP, the IP that was specified to the jail command.
    In that implementation, if a process specifies INADDR_ANY,
    the kernel silently changes it to the jail IP. If however there
    are other interfaces on the node, or if tunnels are being used to
    construct an overlay for the experiment, it is necessary to allow
    processes inside the jail to bind to those interfaces. In our
    modified implementation, when the
    jail is created, a list of auxiliary IPs can be specified on the
    command line, telling the kernel to allow processes inside
    the jail to bind to any of those IPs (including the jail IP).
    When the bind happens, the kernel checks the jails list of IPs;
    this applies to sockets bound for outgoing traffic, as well as
    incoming traffic.  Further, the set of accessible IPs determine
    the list of interfaces that a jail can see so that, for example,
    ifconfig inside a jail will only list the interfaces and IPs
    available to the jail.
     
2. Allow jails to bind to INADDR_ANY.

    The default behavior (and original implementation) of jail maps
    INADDR_ANY to the jail's main IP address.  However, when a jail
    is allowed to access other IPs, then INADDR_ANY actually means a
    subset of all the interfaces on the node that the jail is allowed
    to use (which might also be tunnels). There are two situations in
    which this matters:

        A process is connecting to another address, and has
	specified its local address as INADDR_ANY (which is typical).
	Instead of binding the local address of packets to the jail IP,
	the local address is set to the actual address of the interface
	that the packet is routed out of. If there are IP aliases on the
	interface, the list of aliases is searched for a match against
	one of the allowed prison IPs. If there is a match, the local
	address is set to that IP. Otherwise the address is set to the
	main address of the interface (this is not correct; it should be
	an error). This is to support multiplexing links using IP
	aliases. If we were to use IP tunnels or some other form of
	virtual interface, there would be no need to search the list of
	aliases. 

        A process is binding a local socket for an incoming
	connection. In this case, any of the prison IPs can be the local
	target of the connection, but it is not until the connection is
	actually made that the address can be checked. This is done in
	the pcb lookup routine. For each pcb, if the port matches and the
	local address is INADDR_ANY, and the pcb was created within a
	jail, then the list of the prison IPs is searched, looking for a
	match. If no match is found, the pcb is skipped.  This behavior
	improves compatibility with existing server applications which
	typically specify INADDR_ANY.  If the kernel were to continue
	binding INADDR_ANY sockets to the main IP address of the jail,
	such applications would only be able to receive packets on the
	primary jail interface.

3. Allow access to raw sockets.

    The jail is allowed to both read and write, but is restricted from
    accessing the firewall, dummynet, route, and RSVP interfaces. We also
    ensure that the packet header reflects a source IP address appropriate
    for the jail: INADDR_ANY is mapped to an appropriate address for
    the outgoing interface and fixed addresses that are not part of
    the jail set are rejected.  This feature allows ping, traceroute
    and gated to work in jails.

4. Allow read-only access to BPF devices.

    The interface is not put into promiscuous mode, so the jail is not
    able to see all of the packets on the wire, but only those addressed
    to the node. However, if the interface is already in promiscuous mode
    (say, because someone outside the jail is using tcpdump), then the jail
    will also be able to see any packet that goes by. Even when not in
    promiscuous mode, a jail will see all packets destined for the interface
    whether targeted to a valid jail IP address or not.  This could be fixed,
    and the promiscuous-mode problem avoided, by augmenting the filter given
    when the bpf device is setup.  Allowing BPF access enables use
    of tcpdump and other packet trace tools within jails.
     
5. Restrict the port range to which a jail can bind.

    This allows multiple jails on the same node to safely share the port
    space without stepping on each other in environments where jails cannot
    be assigned their own IP addresses.  Since the ultimate goal is to allow
    different experiments to coexist in jails on the same node, the
    port space has to be allocated globally, with the same port space
    assigned to all jails across an experiment, so as not to conflict
    with any other experiments. This assignment is done when the
    experiment is swapped in so that swapped experiments are not
    holding ranges (16 bits of port space does not go very far).

6. Disallow FS unmounts inside a jail unless the mount was done in the jail.

    This is a bug fix that prevents a jail from unmounting a filesystem
    and exposing the underlying mount point to which it likely shouldn't
    have access.

7. Added per-jail flags to control various existing and new jail features.

    These are in addition to sysctls which control the global availability
    of a given feature.  Existing features thus controlled are: access to
    SYSV IPC facilities, access to routing sockets and ability to turn on
    and off filesystem quotas.  New features controlled are: access to raw
    sockets, access to read-only BPF and the ability to use INADDR_ANY.
    Additionally, there is a new global sysctl to allow jails to be
    configured with multiple IP addresses.

C2. Virtual ethernet devices.

Virtual ethernet devices (veths) are configured with a few parameters:
a virtual MAC (VMAC) address, a broadcast domain tag, an associated physical
(parent) ethernet interface, and a routing table ID.  The VMAC obviously
identifies the interface and needs to be unique within a broadcast domain,
*not* unique per physical node.  Thus, you could have the same VMAC on
multiple veths on the same physical node (though we don't do that) and you
may have to have distinct VMACs within a set of physical nodes, it depends
on the topology.  The broadcast domain tag is basically a VLAN tag, it allows
us to use the same physical wire for multiple LANs.  Unlike VLANs where you
can have up to 4096, we currently use a 16-bit value allowing up to 64k LANs.
Again, a tag's uniqueness has nothing to do with physical node boundaries,
veths on different physical nodes may need to have the same tag while veths
on the same node may have different values.  The parent interface parameter
determines which interface the veths send and receive encapsulated packets
to and from.  All veths with the same parent interface and broadcast domain
tag, can talk to each other.  If such veths are on the same physical node,
they talk via a loopback with no encapsulation and without packets going
out on the physical interface.  Specifying a null parent can be used for a
strictly loopback connection.  The routing table ID is used with incoming
packets to determine which table to use for lookups when forwarding.
The route table ID effectively identifies a virtual node: all interfaces
associated with a virtual node have the same ID, every virtual node has
its own unique ID.  The route table ID is a local-node only value, different
physical nodes can use the same ID for different purposes.

C3. More about the startup pieces.

vnodesetup hangs around so that you can signal it and easily
 reboot the vnode.  I guess the idea is that it is also jail/vserver
 independent as opposed to...

mkjail.pl is jail specific and hangs around so that it can clean up
 jail specific things when the jail exits.

injail is the jail's init process.  This is the single point of
 contact for killing the jail.
