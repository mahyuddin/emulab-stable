--- grub-0.97/stage2/builtins.c.orig	2005-02-15 14:58:23.000000000 -0700
+++ grub-0.97/stage2/builtins.c	2008-10-17 13:31:46.000000000 -0600
@@ -49,6 +49,15 @@
 # include <md5.h>
 #endif
 
+#ifdef SUPPORT_EMULAB
+# include "testbed_boot.h"
+/* FIXME this may be too low; use 0xff? */
+#define MAX_BIOS_DRIVE	0x90
+
+/* FIXME this should be good enough */
+#define DEVNAME_SIZE 32
+#endif /* SUPPORT_EMULAB */
+
 /* The type of kernel loaded.  */
 kernel_t kernel_type;
 /* The boot device.  */
@@ -103,6 +112,23 @@
   grub_timeout = -1;
 }
 
+#ifdef SUPPORT_EMULAB
+#define CRCPOLY 0xedb88320UL
+unsigned long crc32(unsigned long crc, unsigned char const *p, int len);
+
+unsigned long crc32(unsigned long crc, unsigned char const *p, int len)
+{
+	int i;
+	while (len--) {
+		crc ^= *p++;
+		for (i = 0; i < 8; i++) {
+			crc = (crc >> 1) ^ ((crc & 1) ? CRCPOLY : 0);
+		}
+	}
+	return crc;
+}
+#endif /* SUPPORT_EMULAB */
+
 /* Check a password for correctness.  Returns 0 if password was
    correct, and a value != 0 for error, similarly to strcmp. */
 int
@@ -3612,6 +3638,188 @@
   {"delete",		0,		0x7f,	0,	0x53}
 };
 
+#ifdef SUPPORT_EMULAB
+static int
+gettbboot(int drive, tbboot_t *tbhdr)
+{
+	unsigned long oldcrc, newcrc;
+
+	if (!rawread(drive, TBBOOT_SECTOR, 0, sizeof(tbboot_t),
+	             (void *)tbhdr)) {
+		return 1;
+	}
+
+	if (tbhdr->magic1 != TBBOOT_MAGIC1 ||
+	    tbhdr->magic2 != TBBOOT_MAGIC2) {
+
+		return 1;
+	}
+
+	printf("BIOS drive 0x%x\n", drive);
+	printf("  version:	 %d\n",  tbhdr->version);
+	printf("  bootdisk:	 %x\n",  tbhdr->bootdisk);
+	printf("  bootfromdisk:	 %d\n",  tbhdr->bootfromdisk);
+	printf("  bootfromcdrom: %d\n",  tbhdr->bootfromcdrom);
+	printf("  checksum:	 %x\n", tbhdr->checksum);
+
+	oldcrc = tbhdr->checksum;
+	tbhdr->checksum = 0;
+	newcrc = crc32(~0, (void *) tbhdr, sizeof(tbboot_t));
+	newcrc ^= 0xffffffffUL;
+
+	if (newcrc != oldcrc) {
+		printf("gettbboot: bad checksum number on 0x%x: %x %x", drive, oldcrc, newcrc);
+		return 1;
+	}
+
+	if (tbhdr->version != TBBOOT_VERSION) {
+		printf("gettbboot: version mismatch on device '0x%x': %d vs %d",
+		drive, tbhdr->version, TBBOOT_VERSION);
+#if 0
+			delay(2000000);
+#endif
+		return 1;
+	}
+
+	return 0;
+}
+
+static int
+tbboot_func(char *arg, int flags)
+{
+	int biosdev, slice;
+	char buffer[512];
+	tbboot_t *tbhdr = (tbboot_t *)buffer;
+	int config_biosdev;
+	struct geometry geometry;
+	char diskdev[DEVNAME_SIZE];
+	unsigned long newcrc;
+
+	memset(buffer, 0, sizeof(buffer));
+
+	errnum = 0;
+	if (*arg) {
+		if (!set_device(arg))
+			return 1;
+
+		if (current_drive < 0x80) {
+			grub_printf("invalid device for testbed boot\n");
+			errnum = ERR_BOOT_FAILURE;
+			return 1;
+		}
+
+		biosdev = current_drive;
+
+		if (gettbboot(biosdev, tbhdr) != 0) {
+			grub_printf("no biosdev found for testbed boot");
+			errnum = ERR_BOOT_FAILURE;
+			return 1;
+		}
+	}
+	else {
+		for (biosdev = 0x80; biosdev < MAX_BIOS_DRIVE; biosdev++) {
+			if (gettbboot(biosdev, tbhdr) == 0)
+				break;
+		}
+
+		if (biosdev == MAX_BIOS_DRIVE) {
+			errnum = ERR_BOOT_FAILURE;
+			grub_printf("no biosdev found for testbed boot");
+		}
+	}
+
+	if (errnum) {
+		grub_printf("Falling back to MFS...\n");
+		errnum = ERR_BOOT_FAILURE;
+		return 1;
+	}
+
+	/* Save the device number where we found our config sector. */
+	config_biosdev = biosdev;
+
+	/* If bootdisk == 0xfe, boot from the specified partition
+	 * on the boot device.
+	 * If bootdisk == 0xff, boot from the device on which our
+	 * magic sector was found
+	 * Else, boot from the specifed device.
+	 */
+	if (tbhdr->bootdisk < 0xfe) {
+		biosdev = tbhdr->bootdisk;
+		if (get_diskinfo(biosdev, &geometry) != 0) {
+			grub_printf("no such bios device 0x%x for testbed boot\n",
+			            biosdev);
+			tbhdr->bootfromcdrom = 1;
+		}
+	}
+	else if (tbhdr->bootdisk == 0xfe) {
+		printf("requested booting from boot device (0x%x)\n",
+		       saved_drive);
+		if (saved_drive < 0x80) {
+			grub_printf("invalid device '0x%x' for testbed boot\n",
+			            saved_drive);
+			tbhdr->bootfromcdrom = 1;
+		}
+	}
+	else {
+		slice = tbhdr->bootfromdisk;
+		if (slice == 255) {
+			slice = 0;
+			sprintf(diskdev, "(hd%d)", biosdev - 0x80);
+		} else {
+			sprintf(diskdev, "(hd%d,%d)", biosdev - 0x80, slice);
+		}
+	}
+
+	/*
+	 * Check boot direction. Its an error for them to be equal,
+	 * so boot to the cdrom and leave things as they are. 
+	 */
+	if (tbhdr->bootfromcdrom ||
+	    tbhdr->bootfromcdrom == tbhdr->bootfromdisk) {
+		if (tbhdr->bootfromcdrom == tbhdr->bootfromdisk)
+			grub_printf("Oops, bootfromdisk==bootfromcdrom==%d. "
+			       "Falling back to MFS ...\n",
+			       tbhdr->bootfromdisk);
+		else
+			grub_printf("Falling back to MFS ...\n");
+			
+		errnum = ERR_BOOT_FAILURE;
+		return 1;
+	}
+
+	/*
+	 * Only choice is bootfromdisk=$slice. Clear it and go.
+	 */
+	tbhdr->bootfromdisk = 0;
+	tbhdr->bootfromcdrom = 1;
+	newcrc = crc32(~0, (void *) tbhdr, sizeof(*tbhdr));
+	newcrc ^= 0xffffffffUL;
+	tbhdr->checksum = newcrc;
+
+	grub_printf("Writing out new boot header ...\n");
+	if (rawwrite(config_biosdev, TBBOOT_SECTOR, (void *)tbhdr) == 0) {
+		return 1;
+	}
+
+	if (real_root_func(diskdev, 0) != 0) {
+		return 1;
+	}
+
+	/* Activate the chosen slice */
+	if (slice != 0  && !make_saved_active())
+		return 1;
+
+	grub_printf("Booting from %s...\n", diskdev);
+
+	if (chainloader_func("+1", 0) != 0) {
+		return 1;
+	}
+
+	/* Shouldn't ever get here */
+	return 1;
+}
+#endif /* SUPPORT_EMULAB */
+
 static int
 setkey_func (char *arg, int flags)
 {
@@ -3757,6 +3965,17 @@
   return 0;
 }
 
+#ifdef SUPPORT_EMULAB
+static struct builtin builtin_tbboot =
+{
+  "testbed_boot",
+  tbboot_func,
+  BUILTIN_CMDLINE | BUILTIN_MENU | BUILTIN_HELP_LIST,
+  "testbed_boot",
+  "testbed booting magic",
+};
+#endif /* SUPPORT_EMULAB */
+
 static struct builtin builtin_setkey =
 {
   "setkey",
@@ -4864,6 +5083,9 @@
 #endif /* SUPPORT_SERIAL */
   &builtin_setkey,
   &builtin_setup,
+#if defined(SUPPORT_EMULAB)
+  &builtin_tbboot,
+#endif /* SUPPORT_EMULAB */
 #if defined(SUPPORT_SERIAL) || defined(SUPPORT_HERCULES)
   &builtin_terminal,
 #endif /* SUPPORT_SERIAL || SUPPORT_HERCULES */
