--- grub-0.97/stage2/builtins.c.orig	2005-02-15 16:58:23.000000000 -0500
+++ grub-0.97/stage2/builtins.c	2008-10-28 15:07:43.000000000 -0400
@@ -49,6 +49,15 @@
 # include <md5.h>
 #endif
 
+#ifdef SUPPORT_EMULAB
+# include "testbed_boot.h"
+/* FIXME this may be too low; use 0xff? */
+#define MAX_BIOS_DRIVE	0x90
+
+/* FIXME this should be good enough */
+#define DEVNAME_SIZE 32
+#endif /* SUPPORT_EMULAB */
+
 /* The type of kernel loaded.  */
 kernel_t kernel_type;
 /* The boot device.  */
@@ -103,6 +112,23 @@
   grub_timeout = -1;
 }
 
+#ifdef SUPPORT_EMULAB
+#define CRCPOLY 0xedb88320UL
+unsigned long crc32(unsigned long crc, unsigned char const *p, int len);
+
+unsigned long crc32(unsigned long crc, unsigned char const *p, int len)
+{
+	int i;
+	while (len--) {
+		crc ^= *p++;
+		for (i = 0; i < 8; i++) {
+			crc = (crc >> 1) ^ ((crc & 1) ? CRCPOLY : 0);
+		}
+	}
+	return crc;
+}
+#endif /* SUPPORT_EMULAB */
+
 /* Check a password for correctness.  Returns 0 if password was
    correct, and a value != 0 for error, similarly to strcmp. */
 int
@@ -3171,6 +3197,188 @@
   return 0;
 }
 
+#ifdef SUPPORT_EMULAB
+static int
+gettbboot(int drive, tbboot_t *tbhdr)
+{
+	unsigned long oldcrc, newcrc;
+
+	if (!rawread(drive, TBBOOT_SECTOR, 0, sizeof(tbboot_t),
+	             (void *)tbhdr)) {
+		return 1;
+	}
+
+	if (tbhdr->magic1 != TBBOOT_MAGIC1 ||
+	    tbhdr->magic2 != TBBOOT_MAGIC2) {
+
+		return 1;
+	}
+
+	printf("BIOS drive 0x%x\n", drive);
+	printf("  version:	 %d\n",  tbhdr->version);
+	printf("  bootdisk:	 %x\n",  tbhdr->bootdisk);
+	printf("  bootfromdisk:	 %d\n",  tbhdr->bootfromdisk);
+	printf("  bootfromcdrom: %d\n",  tbhdr->bootfromcdrom);
+	printf("  checksum:	 %x\n", tbhdr->checksum);
+
+	oldcrc = tbhdr->checksum;
+	tbhdr->checksum = 0;
+	newcrc = crc32(~0, (void *) tbhdr, sizeof(tbboot_t));
+	newcrc ^= 0xffffffffUL;
+
+	if (newcrc != oldcrc) {
+		printf("gettbboot: bad checksum number on 0x%x: %x %x", drive, oldcrc, newcrc);
+		return 1;
+	}
+
+	if (tbhdr->version != TBBOOT_VERSION) {
+		printf("gettbboot: version mismatch on device '0x%x': %d vs %d",
+		drive, tbhdr->version, TBBOOT_VERSION);
+#if 0
+			delay(2000000);
+#endif
+		return 1;
+	}
+
+	return 0;
+}
+
+static int
+tbboot_func(char *arg, int flags)
+{
+	int biosdev, slice = 0;
+	char buffer[512];
+	tbboot_t *tbhdr = (tbboot_t *)buffer;
+	int config_biosdev;
+	struct geometry geometry;
+	char diskdev[DEVNAME_SIZE];
+	unsigned long newcrc;
+
+	memset(buffer, 0, sizeof(buffer));
+
+	errnum = 0;
+	if (*arg) {
+		if (!set_device(arg))
+			return 1;
+
+		if (current_drive < 0x80) {
+			grub_printf("invalid device for testbed boot\n");
+			errnum = ERR_BOOT_FAILURE;
+			return 1;
+		}
+
+		biosdev = current_drive;
+
+		if (gettbboot(biosdev, tbhdr) != 0) {
+			grub_printf("no biosdev found for testbed boot");
+			errnum = ERR_BOOT_FAILURE;
+			return 1;
+		}
+	}
+	else {
+		for (biosdev = 0x80; biosdev < MAX_BIOS_DRIVE; biosdev++) {
+			if (gettbboot(biosdev, tbhdr) == 0)
+				break;
+		}
+
+		if (biosdev == MAX_BIOS_DRIVE) {
+			errnum = ERR_BOOT_FAILURE;
+			grub_printf("no biosdev found for testbed boot\n");
+		}
+	}
+
+	if (errnum) {
+		grub_printf("Falling back to MFS...\n");
+		errnum = ERR_BOOT_FAILURE;
+		return 1;
+	}
+
+	/* Save the device number where we found our config sector. */
+	config_biosdev = biosdev;
+
+	/* If bootdisk == 0xfe, boot from the specified partition
+	 * on the boot device.
+	 * If bootdisk == 0xff, boot from the device on which our
+	 * magic sector was found
+	 * Else, boot from the specifed device.
+	 */
+	if (tbhdr->bootdisk < 0xfe) {
+		biosdev = tbhdr->bootdisk;
+		if (get_diskinfo(biosdev, &geometry) != 0) {
+			grub_printf("no such bios device 0x%x for testbed boot\n",
+			            biosdev);
+			tbhdr->bootfromcdrom = 1;
+		}
+	}
+	else if (tbhdr->bootdisk == 0xfe) {
+		printf("requested booting from boot device (0x%x)\n",
+		       saved_drive);
+		if (saved_drive < 0x80) {
+			grub_printf("invalid device '0x%x' for testbed boot\n",
+			            saved_drive);
+			tbhdr->bootfromcdrom = 1;
+		}
+	}
+	else {
+		slice = tbhdr->bootfromdisk;
+		if (slice == 255) {
+			slice = 0;
+			sprintf(diskdev, "(hd%d)", biosdev - 0x80);
+		} else {
+			sprintf(diskdev, "(hd%d,%d)", biosdev - 0x80, slice - 1);
+		}
+	}
+
+	/*
+	 * Check boot direction. Its an error for them to be equal,
+	 * so boot to the cdrom and leave things as they are. 
+	 */
+	if (tbhdr->bootfromcdrom ||
+	    tbhdr->bootfromcdrom == tbhdr->bootfromdisk) {
+		if (tbhdr->bootfromcdrom == tbhdr->bootfromdisk)
+			grub_printf("Oops, bootfromdisk==bootfromcdrom==%d. "
+			       "Falling back to MFS ...\n",
+			       tbhdr->bootfromdisk);
+		else
+			grub_printf("Falling back to MFS ...\n");
+			
+		errnum = ERR_BOOT_FAILURE;
+		return 1;
+	}
+
+	/*
+	 * Only choice is bootfromdisk=$slice. Clear it and go.
+	 */
+	tbhdr->bootfromdisk = 0;
+	tbhdr->bootfromcdrom = 1;
+	newcrc = crc32(~0, (void *) tbhdr, sizeof(*tbhdr));
+	newcrc ^= 0xffffffffUL;
+	tbhdr->checksum = newcrc;
+
+	grub_printf("Writing out new boot header ...\n");
+	if (rawwrite(config_biosdev, TBBOOT_SECTOR, (void *)tbhdr) == 0) {
+		return 1;
+	}
+
+	if (real_root_func(diskdev, 0) != 0) {
+		return 1;
+	}
+
+	/* Activate the chosen slice */
+	if (slice != 0  && !make_saved_active())
+		return 1;
+
+	grub_printf("Booting from %s...\n", diskdev);
+
+	if (chainloader_func("+1", 0) != 0) {
+		return 1;
+	}
+
+	/* Shouldn't ever get here */
+	return 1;
+}
+#endif /* SUPPORT_EMULAB */
+
 static int
 root_func (char *arg, int flags)
 {
@@ -4359,6 +4567,19 @@
   return 0;
 }
 
+#ifdef SUPPORT_EMULAB
+static struct builtin builtin_tbboot =
+{
+  "testbed_boot",
+  tbboot_func,
+  BUILTIN_CMDLINE | BUILTIN_MENU | BUILTIN_HELP_LIST,
+  "testbed_boot [BOOT_DEVICE]",
+  "Use the Emulab magic disk sector to determine whether a certain disk"
+  " and partition should be booted, or if the Linux MFS should be booted."
+  " BOOT_DEVICE must be a hard disk device (i.e. hd0)."
+};
+#endif /* SUPPORT_EMULAB */
+
 static struct builtin builtin_terminfo =
 {
   "terminfo",
@@ -4870,6 +5091,9 @@
 #ifdef SUPPORT_SERIAL
   &builtin_terminfo,
 #endif /* SUPPORT_SERIAL */
+#ifdef SUPPORT_EMULAB
+  &builtin_tbboot,
+#endif /* SUPPORT_EMULAB */
   &builtin_testload,
   &builtin_testvbe,
 #ifdef SUPPORT_NETBOOT
--- /dev/null	2008-09-15 14:59:17.502817549 -0400
+++ grub-0.97/stage2/testbed_boot.h	2008-10-24 18:18:47.447983762 -0400
@@ -0,0 +1,121 @@
+/*
+ * EMULAB-COPYRIGHT
+ * Copyright (c) 2000-2002 University of Utah and the Flux Group.
+ * All rights reserved.
+ */
+
+/*
+ * This structure is placed in the boot block. The loader reads the
+ * structure to determine whether it should boot from CDROM or switch
+ * to the disk.
+ *
+ * The basic idea is this:
+ *
+ * 1. The node always boots from the CD-ROM (first in boot chain).
+ * 2. The loader looks for this magic structure:
+ *     2a: If not present continues to load from the CD-ROM (step 4).
+ *     2b: If present check the contents of the structure. If directed to
+ *         boot from the disk goto step 3. If not, continues to load from
+ *         the CDROM (step 4).
+ * 3. Boot from the disk. Switch the boot device to the disk so that the
+ *    kernel is loaded from the disk. Also reset the flag (written to disk)
+ *    to indicate that next reboot should happen from the CDROM. Also set
+ *    another flag, cleared by the kernel, that indicates the kernel booted
+ *    okay. This avoids reboot loops in the case of a scrogged disk.
+ * 4. Boot from the CD-ROM. The user level code on the CD-ROM will take care
+ *    of the rest, writing the proper flags to the structure on the disk.
+ *    Normally, this means checking in with Emulab, and then setting the flag
+ *    to cause it to boot from the disk.
+ *
+ * This entire structure has to be less than a sector.
+ */
+#define SECSIZE			512
+#define TBBOOT_MAXIFACELEN	12
+#define TBBOOT_MAXHOSTLEN	32
+#define TBBOOT_MAXDOMAINLEN	64
+#define TBBOOT_MAXKEYLEN	64
+#define TBBOOT_MAXDISKDEVLEN	32
+
+struct in_addr
+{
+	unsigned long s_addr;
+};
+
+typedef struct tbboot_header
+{
+	unsigned long		magic1;
+	short			version;
+
+	/*
+	 * BIOS device number to boot from, with two magic values:
+	 * - 0xfe means the boot device (CD or USB dongle)
+	 * - 0xff means the disk on which this sector is found
+	 */
+	unsigned char			bootdisk;
+
+	/*
+	 * Set bootfromdisk to 1 to force loader to boot from disk.
+	 */
+	char			bootfromdisk;
+
+	/*
+	 * Set bootfromcdrom to 0 when booting from the disk. The kernel
+	 * will set this to 1. If the cdrom boots with bootfromdisk 0
+	 * and bootfromcdrom 0, something went wrong and the kernel did not
+	 * boot properly. Avoids a loop.
+	 */
+	char			bootfromcdrom;
+
+	/*
+	 * Flag to indicate the image is valid. Clear this when writing
+	 * a new image, and set it when done.
+	 */
+	char			validimage;
+
+	/*
+	 * Flag to indicate the system config block is valid (has info).
+	 */
+	char			validconfig;
+
+	/*
+	 * crc32 from the zlib library.
+	 */ 
+	unsigned long		checksum;
+
+	/* Paranoia */
+	unsigned long		magic2;
+
+	/*
+	 * The emulab key. 
+	 */
+	char			emulabkey[TBBOOT_MAXKEYLEN];
+
+	/*
+	 * System configuration.
+	 */
+	struct {
+		char		interface[TBBOOT_MAXIFACELEN];
+		char		hostname[TBBOOT_MAXHOSTLEN];
+		char		domain[TBBOOT_MAXDOMAINLEN];
+		struct in_addr	IP;
+		struct in_addr	netmask;
+		struct in_addr	nameserver;
+		struct in_addr	gateway;
+	} sysconfig;
+} tbboot_t;
+
+/* Magic value identifying the header.  */
+#define TBBOOT_MAGIC1		0x9badbeef
+#define TBBOOT_MAGIC2		0x69ceafd8
+
+/* Current Version */
+#define TBBOOT_VERSION		101
+
+/*
+ * Offset from start of the disk. Hardwired to sector 60 which should be
+ * clear on our images.
+ */
+#define TBBOOT_SECTOR		60
+#define TBBOOT_OFFSET		(TBBOOT_SECTOR * SECSIZE)
+
+
